*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS FOR USE BY TOKEN.SPT
*      ---------------------------------------------------------
*
*      THIS FILE OF CONDITIONAL SYMBOLS WILL OVERRIDE THE CONDITIONAL
*      DEFINITIONS CONTAINED IN THE SPITBOL MINIMAL FILE.   IN ADDITION,
*      LINES BEGINNING WITH ">" ARE TREATED AS SPITBOL STATEMENTS AND
*      IMMEDIATELY EXECUTED.
*
*      FOR 16-BIT 8088 SPITBOL, WITH 32-BIT INTEGER ACCUMULATOR.
*
*      NOTE THAT THE 8088 IMPLEMENTATION _MUST_ DEFINE .CEPP AND
*      .CRPP.  BECAUSE THE MINIMAL CODE RUNS IN ANOTHER SEGMENT,
*      IT IS POSSIBLE AND PROBABLE THAT THERE WILL BE CODE
*      ADDRESSES GREATER THAN MXLEN.  THIS WILL CAUSE PROBLEMS
*      FOR THE GARBAGE COLLECTOR. USING THE ODD/EVEN TESTS AVOIDS
*      THESE ADDRESS COMPARISONS.
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL NOT
*                            DEFINED, A FULL COMMENT LINE INDICATES
*                            SYMBOL INITIALLY NOT DEFINED.
*
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CENG                 DEFINE TO INCLUDE ENGINE FEATURES
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CSED                 DEFINE TO USE SEDIMENT IN GARBAGE COLLECTOR
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*
*
* Fix CFP values that are initialized for 32-bit systems by TOKEN.SPT:
{{TTL{27,S P I T B O L -- COPYRIGHT NOTICE{{{{95
*
*      COPYRIGHT (C) BY ROBERT B. K. DEWAR, 1983
*
*      THIS SOFTWARE IS THE PROPERTY OF
*           PROFESSOR ROBERT B. K. DEWAR
*           COURANT INSTITUTE OF MATHEMATICAL SCIENCES
*           251 MERCER STREET
*           NEW YORK,  NY 10012
*           U.S.A.
*      TEL NO -  (212) 460 7497
*
{{EJC{{{{{107
{{TTL{27,S P I T B O L -- NOTES TO IMPLEMENTORS{{{{108
*
*      M A C R O   S P I T B O L     V E R S I O N   3 . 7
*      ---------------------------------------------------
*
*      DATE OF RELEASE  -  10 DECEMBER 1991
*
*
*      THIS PROGRAM IS MAINTAINED BY
*           MARK EMMER
*           CATSPAW, INC.
*           P.O. BOX 1123
*           SALIDA, COLORADO 81021
*           U.S.A
*      TEL NO -  (719) 539-3884
*      E-MAIL - MARKE@SNOBOL4.COM
*
*      WHO WILL BE GLAD TO RECEIVE REPORTS OF FAULTS FOUND
*      BY USERS OR IMPLEMENTORS.
*
*      PERMISSION TO USE SPITBOL MAY BE NEGOTIATED WITH
*      PROFESSOR ROBERT B. K. DEWAR.
*      SITES WHICH HAVE OBTAINED SUCH PERMISSION MAY NOT PASS
*      ON COPIES OF THE SPITBOL SYSTEM OR PARTS OF IT EXCEPT
*      BY AGREEMENT WITH DEWAR.
*
*      VERSIONS 2.6 THROUGH 3.4 WERE MAINTAINED BY
*           DR. A. P. MCCANN
*           DEPARTMENT OF COMPUTER STUDIES
*           UNIVERSITY OF LEEDS
*           LEEDS LS2 9JT
*           ENGLAND.
*
*      FROM 1979 THROUGH EARLY 1983 A NUMBER OF FIXES AND
*      ENHANCEMENTS WERE MADE BY STEVE DUFF AND ROBERT GOLDBERG.
*
*      TO ASSIST IMPLEMENTORS A REVISION HISTORY BASED ON
*      VERSION 2.7 IS BEING MAINTAINED.
*
{{TTL{27,S P I T B O L - REVISION HISTORY{{{{147
{{EJC{{{{{148
*      R E V I S I O N   H I S T O R Y
*      -------------------------------
*
*
*      VERSION 3.6A TO 3.7 (NOVEMBER 1, 1991, MARK B. EMMER)
*      -----------------------------------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.701  ADD BTKWV AND REFINED TEST AT CDGVL+9 TO PREVENT
*              VARIABLE NAMES ALPHABET, LCASE, UCASE FROM BEING
*              PRE-EVALUATED BECAUSE OF THEIR ASSOCIATED
*              CONSTANT KEYWORDS.  THE CODE
*                 ALPHABET = "ABC"; OUTPUT = SIZE(ALPHABET)
*              RETURNED ZERO BECAUSE OF PRE-EVALUATION.
*      B3.702  DELAY BINDING TO FUNCTION BLOCK OF FOURTH
*              ARGUMENT TO TRACE FUNCTION.  THIS PERMITS THE
*              TRACE FUNCTION TO BE INVOKED BEFORE THE 4TH
*              ARGUMENT FUNCTION IS DEFINED.  ACCOMPLISHED BY
*              STORING A VRBLK POINTER IN TRFNC, AND FETCHING
*              ITS VRFNC ENTRY LATER, IN TRXEQ.
*      B3.703  REFERENCES TO KEYWORDS WITH CONSTANT PATTERN
*              VALUES (&ARB, &BAL, ETC.) DID NOT WORK.  A WTB
*              INSTRUCTION HAD BEEN OMITTED AT ACS14+2.
*      B3.704  IF A PROGRAM EMPLOYED THE CODE FUNCTION TO
*              REDEFINE A LABEL THAT WAS THE ENTRY LOCATION OF
*              A USER-DEFINED FUNCTION, THE FUNCTION WOULD
*              CONTINUE TO JUMP TO ITS OLD FUNCTION BODY.  PFCOD
*              IN PFBLK WAS POINTING DIRECTLY TO THE TARGET CODE
*              BLOCK, INSTEAD OF DOING SO INDIRECTLY THROUGH THE
*              VRBLK FOR THE ENTRY LABEL.
*      B3.705  THE TEST THAT REQUIRED A LABEL TO BE DEFINED
*              BEFORE IT COULD BE USED AS THE ENTRY OF A USER-
*              DEFINED FUNCTION HAS BEEN REMOVED.  FUNCTIONS
*              MAY BE DEFINED EVEN IF THE LABEL IS YET
*              UNDEFINED.
*      B3.706  AFTER A COMPILATION ERROR IN THE CODE FUNCTION,
*              THE EVAL FUNCTION PRODUCES SPURRIOUS ERRORS.  THE
*              CODE OFFSET CWCOF WAS NOT BEING RESET TO THE
*              BEGINNING OF CODE BLOCK.  ADD LINE AT ERR04+1 TO
*              ACCOMPLISH THIS RESET.
*      B3.707  INCONSISTANT TESTS WITH MXLEN CORRECTED.  SEVERAL
*              PLACES WERE TESTING WITH BGE INSTEAD OF BGT,
*              RESULTING IN SUCH ANOMALIES AS THE STATEMENT
*                 &MAXLNGTH = &MAXLNGTH
*              FAILING.  SINCE MXLEN IS GUARANTEED TO BE
*              STRICTLY LESS THAN DNAMB, IT IS PERMISSIBLE TO
*              CREATE OBJECTS OF SIZE MXLEN.  BGE CHANGED TO
*              BGT AT LOCATIONS
*                 S$ARR+14, SAR07+8, ALOBF+3, ASG14+8, GTAR6+10.
*      B3.708  EXIT(COMMAND STRING) WAS NOT LOADING PTR TO FCB
*              CHAIN INTO WB.  CORRECTED AT SEXT1.
*      B3.709  CHANGE PATST TO RETURN NON-STRING ERROR FOR NULL
*              ARGUMENT.  PREVIOUSLY, BREAK(), ANY(), ETC., WERE
*              SUCCEEDING, CONTRARY TO THE LANGUAGE DEFINITION.
*      B3.710  CONVERT FUNCTION WITH NULL SECOND ARGUMENT
*              CRASHED SYSTEM BY CALLING FLSTG WITH WA=0.  ADDED
*              TEST AT S$CNV, MOVED ERROR 74 TO SEPARATE ERB AT
*              SCV29.
*      B3.711  LEQ(,) CRASHED SYSTEM.  LCOMP DID NOT OBEY
*              MINIMAL ASSUMPTION THAT CMC OPCODE WILL ALWAYS
*              BE CALLED WITH WA .GT. 0.  ADDED TEST AT LCMP1.
*      B3.712  MODIFIED LINE AT SDF07+4 TO USE REGISTER WA
*              INSTEAD OF WB.  THIS CORRECTS PROBLEM OF DEFINE
*              FUNCTION WITH LOCAL VARIABLE LIST THAT BEGINS
*              WITH COMMA-  DEFINE("F(X),L1,L2")
*      B3.713  ERRONEOUS PLC ON UNINITIALISED R$CIM IN LISTR.
*      B3.714  ERRONEOUS CALL TO FLSTG POSSIBLE WITH NULL STRING
*              AT SDAT1.
*      B3.715  WHEN COPY FUNCTION USED WITH TABLE ARGUMENT, FIX
*              PROBLEM AT COP07.  WHEN COPYING FIRST TEBLK ON A
*              CHAIN, THE PSEUDO-PREVIOUS BLOCK POINTER IN XR
*              IS PUSHED ON THE STACK PRIOR TO CALLING ALLOC.
*              THIS IS NOT A VALID BLOCK POINTER, AS IT POINTS
*              WITHIN THE TBBLK.  IF THE SUBSEQUENT ALLOC
*              INVOKES GBCOL, THE HEAP BECOMES SCRAMBLED.
*              RECODED TO SAVE POINTER TO START OF BLOCK, PLUS
*              OFFSET IN WB.
*      B3.716  AT IOP01, IF GTVAR TRIGGERED GARBAGE COLLECTION
*              VIA ALOST, TRAP BLOCK IN WC WAS NOT COLLECTED.
*              SAVE WC ON STACK TO MAKE IT COLLECTABLE ACROSS
*              GTVAR CALL.
*      B3.717  AT ASG10, ALLOW CASE OF VARIABLE WITH MORE THAN
*              ONE TRBLK, AS HAPPENS WITH THE FOLLOWING STMT -
*              OUTPUT(.OUTPUT, .OUTPUT, FILENAME).
*      B3.718  AT SENF1, TRBLK CHAIN SEARCH WAS RELOADING CHAIN
*              HEAD, CAUSING INFINITE LOOP IF THE DESIRED TRBLK
*              WAS NOT THE FIRST ON CHAIN.  SYSTEM CRASHED WITH
*              TRACE(.V1) OUTPUT(.V2,.V1,FILE).
*      B3.719  PROTOTYPE STRINGS (DEFINE, LOAD, DATA, ETC.) WERE
*              ALLOWING BLANK CHARACTERS, PRODUCING BOGUS
*              VARIABLE NAMES.
*      B3.720  THE FACT THAT IOFCB DESTROYED REGISTER WC WAS NOT
*              DOCUMENTED.  B$EFC CONVERSION OF FILE ARGUMENT
*              NEVER WORKED BECAUSE WC AND XT WERE DESTROYED BY
*              CALL TO IOFCB.
*      B3.721  IOPUT LEFT A TRBLK ATTACHED TO FILEARG1 IF SYSIO
*              FAILED.  SUBSEQUENT USE OF THIS FILEARG1 VARIABLE
*              IN ANOTHER I/O CALL WOULD CRASH SYSTEM.
*      B3.722  ADD CHK AT EVLP1 TO CATCH RECURSIVE PATTERN ERROR.
*      B3.723  ALLOW -LINE TO WORK PROPERLY WITHIN CODE FUNCTION
*              BY SETTING CMPLN DIRECTLY IN CNC44.  IF FILE NAME
*              ABSENT, DECREMENT SCNPT TO RESCAN TERMINATOR.
*      B3.724  WHEN MXLEN EXCEEDS START OF DYNAMIC MEMORY, ROUND
*              IT UP TO MULTIPLE OF WORD SIZE PRIOR TO STORING
*              IN DNAMB AT INI06.
*      B3.725  PROVIDE RIGHT PADDING OF ZERO CHARACTERS TO ANY
*              STRING RETURNED BY AN EXTERNAL FUNCTION.
*      B3.726  RESET FLPTR AT BPF17 FOR UNDEFINED FUNCTION
*              WHEN EVALX IS EVALUATING AN EXPRESSION.
*      B3.727  MODIFY CODE AFTER READ5 FOR OUTER NESTING OF
*              AN EXECUTE-TIME COMPILE OF -INCLUDE STATEMENT.
*              CREATE A SUBSTRING OF REMAINDER OF ORIGINAL
*              CODE FUNCTION ARGUMENT STRING AND RETURN AS
*              RESULT OF READR FUNCTION
*      B3.728  THE DEFINITION OF THE AOV OPCODE IS CORRECTED.
*              FORMERLY THE DEFINITION SPECIFIED THAT THE BRANCH
*              WAS TO BE TAKEN IF THE RESULT OF THE ADDITION
*              EXCEEDED CFP$M, IMPLYING A TEST FOR OVERFLOW
*              FROM SIGNED ADDITION.
*              HOWEVER, ADDRESS ARITHMETIC MUST BE UNSIGNED TO
*              ALLOW FOR SYSTEMS WHERE THE HIGH ORDER ADDRESS
*              BIT IS SET.  THEREFORE, THE TEST MUST BE FOR
*              CARRY OUT OF THE HIGH ORDER BIT, IF THE RESULT
*              WOULD EXCEED CFP$L.
*      B3.729  A LABEL TRACE ON THE ENTRY LABEL FOR A FUNCTION
*              WAS UNDETECTED, RESULTING IN A TRANSFER TO
*              B$TRT AND SUBSEQUENT CRASH.  SEE BPF08 FOR FIX.
*      B3.730  POP FIRST ARGUMENT TO SUBSTR IF IT IS A BUFFER.
*      B3.731  PATTERN REPLACEMENT WITH BUFFER SUBJECT RETURNED
*              NULL STRING INSTEAD OF NEW SUBJECT VALUE.
*              CHANGED TO BEHAVE AS IF SUBJECT WAS A STRING.
*      B3.732  IF CONVERT FUNCTION WAS CALLED WITH A BUFFER
*              FIRST ARGUMENT AND "BUFFER" SECOND ARGUMENT,
*              IT WOULD CONVERT THE BUFFER TO A STRING, AND
*              THEN BACK TO A BUFFER.  THIS HAS BE CORRECTED
*              TO SIMPLY RETURN THE FIRST ARGUMENT AS THE
*              FUNCTION RESULT.
*      B3.733  DETECT EXTERNAL FUNCTION RETURNING A NULL STRING
*              UNCONVERTED RESULT AT BEF12, AND JUMP TO EXNUL.
*      B3.734  FIX PROBLEM AT INS04 WHEN INSERTING ZERO LENGTH
*              STRING INTO BUFFER.  DEFEND AGAINST INVOKING
*              MVC WITH A ZERO VALUE IN WA, WHICH WILL CAUSE
*              SOME IMPLEMENTATIONS TO WRAP THE COUNTER.
*      B3.735  ADD OVERFLOW TEST FOR COS AND SIN TO DETECT
*              OUT-OF-RANGE ARGUMENT.
*      B3.736  FIXED PROBLEM INTRODUCED WITH B3.727 NOT
*              RESTORING R$CIM, SCNPT AND SCNIL AFTER CREATING
*              SUBSTRING.
*      B3.737  FIXED TFIND TO PLACE DEFAULT VALUE IN NEWLY
*              ALLOCATED TEBLK.
*      B3.738  ADDED BL$P0 TO P$NTH ENTRY POINT.  THE EXPRESSION
*              DATATYPE(CONVERT("","PATTERN")) WOULD CRASH WHEN
*              THE DTYPE FUNCTION USES THE NON-EXISTANT TYPE
*              WORD PRECEDING P$NTH.
*      B3.739  BUG AT GTN35 IN THE CASE OF OVERFLOW DURING CVM.
*              WB CAN BE DESTROYED BY CVM ON SOME PLATFORMS.
*      B3.740  PROTECT SCONTINUE FROM USAGE IN OTHER THAN ERROR
*              320 CASE.
*      B3.741  PROTECT CONTINUE FROM USAGE FOLLOWING ERROR
*              EVALUATING COMPLEX FAILURE GOTO.
*
*
*      CHANGES
*      -------
*
*      C3.701  ADD .CULK CONDITIONAL TO INCLUDE &LCASE, &UCASE.
*      C3.702  ADD -LINE NN "FILENAME" CONTROL CARD.
*      C3.703  MOVE .CNLD CONDITIONAL UP IN ROUTINE DFFNC TO
*              OMIT ALL TESTS FOR B$EFC.
*      C3.704  ADD CONDITIONAL .CICC TO IGNORE UNRECOGNIZED
*              CONTROL CARDS.
*      C3.705  ADD CONDITIONAL .CNSC TO OMIT STRING TO NUMERIC
*              CONVERSION IN SORT.  THE PRESENCE OF THIS
*              CONVERSION MODE PRODUCES A SORT RESULT THAT IS
*              DEPENDENT UPON THE ORDER OF INPUT DATA.
*              FOR EXAMPLE, GIVEN INPUT DATA "2", 5, "10",
*              STRING COMPARISON YIELDS "10" LT "2", BUT STRING
*              TO INTEGER CONVERSION YIELDS "2" LT 5 LT "10".
*      C3.706  ADD SEVENTH RETURN FROM SYSHS THAT ALLOWS CALLEE
*              TO RETURN A STRING POINTER AND LENGTH.  THIS IS
*              DONE TO ELIMINATE THE NEED FOR THE CALLER TO HAVE
*              AN SCBLK BIG ENOUGH TO ACCOMMODATE LONG STRINGS.
*      C3.707  ADD EIGHTH RETURN FROM SYSHS TO FORCE COPY OF
*              BLOCK POINTED TO BY XR.
*      C3.708  MADE -COPY A SYNONYM FOR -INCLUDE.
*      C3.709  ADD CONDITIONAL .CBYT FOR STATISTICS DISPLAYED
*              IN BYTES RATHER THAN WORDS.
*      C3.710  DUMP NULL VALUED VARIABLES WHEN DUMP = 3.  CORE
*              DUMP PRODUCED FOR DUMP = 4.
*      C3.711  RESTRICT MINIMUM VALUE TO WHICH KEYWORD MAXLNGTH
*              CAN BE SET TO 1,024 VIA NEW VARIABLE MNLEN.
*      C3.712  ADD CONDITIONAL SYMBOL .CMTH FOR EXTENDED MATH
*              FUNCTIONS- ATAN, CHOP, COS, EXP, LN, SIN, SQRT,
*              TAN.  X**Y AND REMDR(X,Y) ARE EXTENDED TO INCLUDE
*              REALS.
*      C3.713  ADD BIT TO SYSPP TO SET -PRINT UPON ENTRY
*      C3.714  ADD CONDITIONAL .CSFN TO TRACK SOURCE FILE NAME
*              ASSOCIATED WITH EACH CODE BLOCK.
*      C3.715  ADD CONDITIONAL .CINC FOR -INCLUDE CONTROL CARD
*              FEATURE.  THE FORMAT OF THE CARD IS
*                 -INCLUDE "FILENAME"
*              INCLUDE CONTROL CARDS MAY BE USED DURING BOTH THE
*              INITIAL COMPILE AND EXECUTE-TIME COMPILE.  THE
*              FILENAME IS SAVED IN A TABLE, AND REDUNDANT
*              INCLUDES OF THAT FILE ARE IGNORED.
*      C3.716  ADD CONDITIONAL .CSLN TO INCLUDE SOURCE LINE
*              NUMBER IN CODE BLOCKS.  RELEASE CURRENT CCBLK
*              AFTER INITIAL COMPILE.
*      C3.717  CHANGED RILEN TO 258 (FROM 120) TO PROVIDE
*              UNIFORM INPUT LINE LENGTH WHEN READING FROM
*              TERMINAL OR INPUT.
*      C3.718  ADD ADDITIONAL EXIT TO IOFCB TO DISTINGUISH
*              ARGUMENT NOT CONVERTABLE TO STRING AND ARGUMENT
*              FILE NOT OPEN.
*      C3.719  ADD FOURTH AND FIFTH ARGUMENTS TO HOST FUNCTION.
*      C3.720  ADD &COMPARE KEYWORD TO CONTROL STRING
*              COMPARISONS.
*      C3.721  SETUP PFDMP AT INIY0 IN CASE OSINT FORCED
*              &PROFILE NON-ZERO.
*      C3.722  ADD CONDITIONAL SYMBOL .CAEX TO INCLUDE UP ARROW
*              AS SYNONYM FOR EXPONENTIATION.
*      C3.723  ADD CONDITIONAL .CCMC AND EXTERNAL FUNCTION SYSCM
*              TO PROVIDE STRING COMPARISON USING COLLATION
*              SEQUENCE OTHER THAN STRICT ORDERING OF CHARACTER
*              CODES (INTERNATIONAL COMPARES).
*      C3.724  ADD CONDITIONAL .CPOL AND EXTERNAL FUNCTION SYSPL
*              TO PROVIDE INTERACTIVE CONTROL OF SPITBOL
*              EXECUTION.
*      C3.725  ADD CONDITIONAL SYMBOL .CERA AND EXTERNAL
*              FUNCTION SYSEA TO PROVIDE ADVICE OF COMPILATION
*              AND RUNTIME ERRORS TO OSINT.
*      C3.726  ADD CMPLN, RDCLN, RDNLN TO TRACK SOURCE LINE
*              NUMBER.
*      C3.727  CONVERTED ERROR MESSAGES TO UPPER/LOWER CASE.
*      C3.728  ADD CONDITIONAL .CGBC TO EXTERNAL ROUTINE SYSGC.
*              CALLED AT THE START AND END OF GARBAGE COLLECTION
*              TO PERFORM ANY NEEDED NOTIFICATION TO OPERATING
*              SYSTEM OR USER.
*      C3.729  MODIFIED LAST LINE OF S$SET FROM EXNUL TO EXINT
*              SO SEEK CAN RETURN FINAL FILE POSITION AFTER
*              SEEK.
*      C3.730  PLACE MOV XR,(XS) AT S$RMD+4 TO ALLOW REAL SECOND
*              ARG TO REMDR.
*      C3.731  REMOVE REDUNDANT BGE XR,=CFP$U,SCN07 AT SCN06+4
*      C3.732  CHANGE DEFINITION OF CMC AND TRC SUCH THAT ONLY
*              XL MUST BE CLEARED AFTER OPERATION.  NOTE, THIS
*              CHANGE WAS SUBSEQUENTLY VOIDED.  CMC AND TRC MUST
*              CLEAR BOTH XL AND XR, BECAUSE UTILITY ROUTINES
*              MAY PRESERVE XL OR XR ON THE STACK, AND THE STACK
*              IS COLLECTABLE BY GBCOL.
*      C3.733  REMOVE MOST BRANCHES TO EXITS AND EXIXR.
*              INSTEAD, JUMP DIRECTLY TO NEXT CODE WORD.
*      C3.734  ADD ERROR 260 FOR ARRAY TOO LARGE IN GTARR.
*      C3.735  ADD CONDITIONAL .CS32 TO INITIALIZE STLIM TO
*              2147483647.
*      C3.736  ADD SECOND ARGUMENT TO EXIT FUNCTION, ALLOWING
*              USER TO SPECIFY FILE NAME OF LOAD MODULE BEING
*              WRITTEN.  IF OMITTED, OSINT WILL PROVIDE A
*              DEFAULT NAME.
*      C3.737  ADD CONDITIONAL .CSPR TO INCLUDE SPARE LOCATIONS
*              IN WORKING AREA.  THESE MAY BE USED IN LATER BUG
*              FIXES WITHOUT CHANGING THE SIZE OF THE WORKING
*              STORAGE AND OBSOLETING MODULES CREATED BY EXIT().
*              SUBSUENTLY REMOVED IN C3.767.
*      C3.738  ADD R$CTS TO REMEMBER LAST STRING USED TO BUILD
*              BIT COLUMN IN PATST.
*      C3.739  CHANGE FLSTG TO TYPE E PROCEDURE INSTEAD OF R.
*      C3.740  STANDARDIZE ON BIG-ENDIAN SYSTEMS.  AT THE
*              IMPLEMENTORS CHOICE, THE ZGB OPCODE CAN ALSO
*              PERFORM A BYTE SWAP IF NECESSARY TO ACHIEVE BIG-
*              ENDIAN BYTE ORDERING.  THIS IS DONE SO THAT
*              SYSTEMS WITH SIMILAR WORD LENGTHS WILL PRODUCE
*              THE SAME HASH CODE FOR STRINGS, AND HENCE THE
*              SAME ORDERING FOR TABLE ENTRIES.  THE HASHS
*              PROCEDURE HAS AN ADDITIONAL ZGB ADDED TO REORDER
*              THE LENGTH WORD.
*      C3.741  ADD CONDITIONAL .CSOU TO CAUSE ASSIGNMENTS TO
*              OUTPUT AND TERMINAL VARIABLES TO BE PROCESSED
*              THROUGH CALLS TO SYSOU RATHER THAN THROUGH
*              LISTING BUFFER.  DONE TO ELIMINATE SHORT RECORD
*              LENGTHS ENFORCED BY BUFFER SIZE.  A CODE OF 0 OR
*              1 IS PASSED TO SYSOU INSTEAD OF AN FCBLK.
*      C3.742  INCREASED INILN, INILS, RILEN TO 1024.
*      C3.743  ADD BIT TO SYSPP TO SET NOERRORS MODE.
*      C3.744  ADD .CCMK CONDITIONAL TO INCLUDE KEYWORD COMPARE
*              EVEN IF SYSCM IS NOT BEING INCLUDED.  DONE TO
*              PROVIDE IDENTICAL DATA REGIONS IN SYSTEMS THAT
*              IMPLEMENT SYSCM AND THOSE WHICH DO NOT, SO THAT
*              SAVE FILES CAN BE EXCHANGED IN THE NEXT RELEASE.
*      C3.745  ADD WC RETURN PARAMETER TO SYSIL TO ALLOW
*              INTERFACE TO INFORM SPITBOL IF FILE ABOUT TO BE
*              READ IS A BINARY FILE.  IF SO, NO BLANK TRIMMING
*              OCCURS.
*      C3.746  FOLD LOAD FUNCTION ARGUMENT TYPES TO UPPER CASE.
*      C3.747  ADD .CEXP CONDITIONAL TO HAVE SYSEX POP ITS
*              ARGUMENTS.
*      C3.748  IN STOPR, DO NOT ATTEMPT TO DISPLAY FILE NAME AND
*              LINE NUMBER IF STOPPING BECAUSE OF STACK OVERFLOW
*              DURING GARBAGE COLLECTION.  POINTERS TO FILE NAME
*              TABLE AND CODE BLOCK ARE WRONG.
*      C3.749  ADD BIT TO SYSPP TO SET CASE FOLDING MODE.
*      C3.750  ADD ADDITIONAL RETURN FROM SYSLD IF INSUFFICIENT
*              MEMORY TO LOAD/CALL EXTERNAL FUNCTION.
*      C3.751  ADD ADDITIONAL RETURNS FROM SYSEX IF INSUFFICIENT
*              MEMORY OR BAD ARGUMENT TYPE.
*      C3.752  IGNORE LEADING AND TRAILING BLANKS IN ARGUMENTS
*              WITHIN PROTOTYPE STRINGS TO CLEAR, DATA, DEFINE
*              AND LOAD.
*      C3.753  TEST FOR FATAL ERROR AT ERR04 AND ABORT IF SO.
*              FORCE TERMINATION ON STACK OVERFLOW BY SETTING
*              ERRFT TO 4 IN STACK OVERFLOW SECTION.
*      C3.754  RECODE COPY LOOP AT SRT14 TO EXCHANGE USAGE OF
*              REGISTERS XL AND XR.  THIS PERMITS USE OF THE
*              MVW ORDER INSTEAD OF THE EXPLICIT LOOP CODING
*              PREVIOUSLY EMPLOYED.
*      C3.755  ADD .CENG CONDITIONAL TO INCLUDE ROUTINES NEEDED
*              BY TEXT PROCESSING ENGINE. ADD ROUTINES ENEVS AND
*              ENGTS FOR USE BY ENGINE OR DEBUGGER.  COPY XR TO
*              XL AROUND CALL TO SYSPL TO ALLOW SYSPL TO
*              TRIGGER GARBAGE COLLECTION.
*      C3.756  ADD &FILE, &LASTFILE, &LINE, &LASTLINE KEYWORDS.
*              FOR NOW, LINE AND LASTLINE ARE MAINTAINED IN THE
*              SAME MANNER AS STNO AND LASTNO, WHICH ADDS OVER-
*              HEAD TO THE STATEMENT INITIALIZATION CODE.  A
*              POSSIBLE CHANGE IS TO CREATE A STMLN PROCEDURE
*              THAT MAPS STATEMENT NUMBERS TO LINE NUMBERS.
*              ONE SIMPLE STRATEGY WOULD BE TO SWEEP CODE BLOCKS
*              IN MEMORY LOOKING FOR THE STATEMENT NUMBER AND
*              EXTRACTING THE LINE NUMBER FROM THAT CODE BLOCK.
*              SUCH A PROCEDURE WOULD ALSO ALLOW LINE NUMBERS
*              (AND FILE NAMES) TO BE ADDED TO STATEMENT PROFILE
*              REPORTS.
*      C3.757  CHANGE SORT TO FAIL INSTEAD OF PRODUCING ERROR
*              MESSAGE IF ARGUMENT TABLE IS NULL.  CHANGE SORTA
*              TO RETURN FAILURE.  ADD ANOTHER RETURN TO GTARR
*              TO DISTINGUISH NULL TABLE FROM BAD ARGUMENT.
*      C3.758  CREATE PROCEDURE PRTMM TO DISPLAY MEMORY USAGE
*              STATISTICS, AND CALL IT WHEN PRODUCING END-OF-
*              RUN STATS.
*      C3.759  ADD LABEL SCONTINUE TO ALLOW SETEXIT TO RESUME
*              EXECUTION EXACTLY WHERE IT WAS INTERRUPTED.
*      C3.760  ADD SNOBOL4 BACKSPACE FUNCTION AND CONDITIONAL
*              .CBSP.
*      C3.761  ADD ADDITIONAL ARGUMENTS TO SYSGC TO ASSIST
*              VIRTUAL MEMORY MANAGERS.
*      C3.762  THE METHOD OF CONVERTING A TABLE TO AN ARRAY HAS
*              BEEN REVISED.  PREVIOUSLY, TABLE ELEMENTS WERE
*              COPIED TO THE RESULT ARRAY IN THE ORDER THEY WERE
*              ENCOUNTERED ALONG THE VARIOUS HASH CHAINS.  THIS
*              APPEARED TO THE USER AS A RANDOM ORDERING.  HOW-
*              EVER, SPITBOL/370 AS WELL AS SIL SNOBOL4 ORDERED
*              ARRAY ELEMENTS ACCORDING TO THEIR TIME OF ENTRY
*              INTO THE TABLE.  USER PROGRAMS THAT RELIED UPON
*              THIS BEHAVIOR MALFUNCTIONED WHEN PORTED TO MACRO
*              SPITBOL.
*              TO REMEDY THIS, THE CONVERSION IS PERFORMED IN
*              THREE STEPS:
*              1. CONVERT TABLE TO AN ARRAY PLACING THE ADDRESS
*                 OF EACH TEBLK IN THE ARRAY INSTEAD OF THE KEY
*                 AND VALUE.
*              2. SORT THE ARRAY OF ADDRESSES.  THIS ORDERS ELE-
*                 MENTS BY TIME OF CREATION (ASCENDING ADDRESS).
*              3. SCAN THE ARRAY, REPLACING ADDRESSES WITH THE
*                 KEY AND VALUE FROM THE REFERENCED TEBLK.
*              THE AFFECTED PORTIONS OF THE PROGRAM ARE AT S$CNV
*              AND IN GTARR, WHICH NOW ACCEPTS AN ADDITIONAL
*              ARGUMENT SPECIFYING WHETHER TO PLACE KEY/VALUES
*              IN THE ARRAY OR TEBLK ADDRESSES.
*      C3.763  IF CASE-FOLDING IS ACTIVE, FOLD THE FUNCTION NAME
*              PROVIDED TO THE LOAD() FUNCTION BEFORE PASSING IT
*              TO SYSLD.
*      C3.764  ADD SEDIMENT ALGORITHM TO GARBAGE COLLECTOR,
*              CONDITIONED ON .CSED.
*      C3.765  ADD OPTIMIZATION TO DISCARD NULL STATEMENTS AND
*              STATEMENTS WHICH JUST HAVE A CONSTANT SUBJECT
*              (SEE CODE AT CMP12).
*      C3.766  REARRANGED ORDER OF INITIAL OBJECTS IN STATIC
*              MEMORY SO THAT HASH TABLE IS THE LAST OF THE FOUR
*              OBJECT CREATED BY INITIALIZATION CODE.  THIS IS
*              DONE SO THAT THE PRINT BUFFER, GTS WORK AREA, AND
*              &ALPHABET KEYWORDS DO NOT NEED TO BE SAVED IN
*              ANY SAVE FILE CREATED BY OSINT.  ADDED ROUTINE TO
*              INITIALIZE THESE STRUCTURES.
*      C3.767  REMOVED .CSPR CONDITIONAL AND SPARE LOCATIONS.
*      C3.768  ADDED .CREL CONDITIONAL AND EXTENSIVE ROUTINES
*              (RELOC ET. AL.) TO PERFORM RELOCATION OF DATA
*              IN WORKING SECTION, STATIC REGION, AND DYNAMIC
*              REGION AFTER RELOAD OF A SAVED MEMORY IMAGE.
*              ROUTINES RELAJ, RELCR, AND RELOC ARE INVOKED
*              BY OSINT AFTER RELOADING A SAVE FILE.
*              IT IS NOW POSSIBLE TO RELOAD SUCH AN IMAGE EVEN
*              IF THE SPITBOL COMPILER AND ITS DATA STRUCTURES
*              ARE RELOADED TO OTHER ADDRESSES.  THE WORKING
*              SECTION HAS BEEN EXTENSIVELY REARRANGED TO
*              ACCOMMODATE THE RELOC PROCEDURE.
*      C3.769  ZERO R$CCB (INTERIM CCBLK PTR) IN COLLECT,
*              CONVERT, EVAL, AND EXIT FUNCTIONS TO RELEASE
*              UNNEEDED CCBLK MEMORY.
*      C3.770  ADD EXIT(4) AND EXIT(-4) TO ALLOW EXECUTION TO
*              CONTINUE AFTER WRITING SAVE FILE OR LOAD MODULE.
*              REVISED SYSXI INTERFACE TO DETECT CONTINUATION
*              AFTER PERFORMANCE OF EXIT(4) OR EXIT(-4) ACTION.
*      C3.771  CHANGE FILNM TO PRESERVE REGISTERS.
*      C3.772  ADDITION OF .CNCR AND SYSCR (REAL TO STRING
*              SYSTEM ROUTINE OPTION).
*      C3.773  MODIFIED REPLACE FUNCTION TO OPTIMIZE USAGE
*              WHEN SECOND ARGUMENT IS &ALPHABET.  IN THIS CASE,
*              THE THIRD ARGUMENT CAN BE USED AS THE TRANSLATE
*              TABLE DIRECTLY.
*      C3.774  MODIFIED CONDITIONALS FOR BUFFERS AND REALS SO
*              THAT THEIR RESPECTIVE BLOCK CODES ARE ALWAYS
*              PRESENT, EVEN IF THESE DATA TYPES ARE CONDITIONED
*              OUT.  THIS PROVIDES CONSISTENT BLOCK CODE
*              NUMBERING FOR EXTERNAL FUNCTIONS.
*      C3.775  MODIFIED ALOBF TO TEST STRING LENGTH AGAINST
*              KVMXL INSTEAD OF MXLEN.  ALSO, ALOBF WAS TESTING
*              TOTAL SIZE OF BFBLK, INSTEAD OF JUST STRING LEN.
*      C3.776  MOVE UTILITY ROUTINES SOURCE UP TO LIE BETWEEN
*              PREDEFINED SNOBOL FUNCTIONS (S$XXX) ROUTINES AND
*              UTILITY PROCEDURES.  THIS WAS DONE TO ASSIST
*              TRANSLATION ON PLATFORMS SUCH AS APPLE MACINTOSH
*              THAT USE 15-BIT OFFSETS TO STORE ERROR EXITS (PPM
*              BRANCHES).  OFFSETS TO LABELS LIKE EXFAL WERE
*              JUST TOO FAR AWAY.  SIMILARLY, FUNCTIONS TFIND,
*              TMAKE, AND VMAKE ARE LOCATED OUT OF ALPHABETIC
*              ORDER TO SATISFY THE MACINTOSH'S LIMITED RANGE
*              FOR SUBROUTINE CALLS.  MOVE BUILT-IN LABELS
*              BEYOND THE BLOCK AND PATTERN ROUTINES TO GET IT
*              WITHIN 32K OF THE ERROR ROUTINES.
*      C3.777  AT SCN46, ALLOW COLON, RIGHT PAREN AND RIGHT
*              BRACKET TO TERMINATE = OPERATOR WITH DEFAULT
*              NULL OPERAND.
*      C3.778  ADDED .CTET CONDITIONAL FOR TABLE ENTRY TRACE.
*      C3.779  INTRODUCE CFP$L, THE LARGEST UNSIGNED VALUE
*              THAT MAY BE STORED IN A ONE-WORD INTEGER.  THIS
*              IS DONE TO ACCOMMODATE MACHINES WHERE MEMORY
*              ADDRESSES HAVE THE HIGH-ORDER ADDRESS BIT SET.
*      C3.780  PERFORM REPLACE IN PLACE IF FIRST ARG IS BUFFER.
*      C3.781  PERFORM REVERSE IN PLACE IF FIRST ARG IS BUFFER.
*      C3.782  CHANGE SYSOU TO ACCEPT BUFFER AS WELL AS STRING
*              TO BE OUTPUT.  CHANGE CODE AT ASG11 TO PREVENT
*              CONVERSION OF BUFFER TO STRING.
*      C3.783  OPTIMIZE POS AND RPOS WHEN IT IS THE FIRST NODE
*              OF A PATTERN AND HAS EITHER AN INTEGER OR SIMPLE
*              EXPRESSION VARIABLE ARGUMENT.  IF UNANCHORED MODE
*              AND THE CURSOR IS ZERO, IT IS ADVANCED DIRECTLY
*              TO THE DESIRED CURSOR POSITION.
*      C3.784  PERFORM TRIM FUNCTION IN PLACE IF ARG IS BUFFER.
*      C3.785  ADD GTSTB PROCEDURE TO GET A STRING OR BUFFER
*              ARGUMENT FOR REPLACE, REVERSE, SIZE, TRIM, ETC.
*      C3.786  CHANGE LEQ, LGT, ETC. TO PERFORM COMPARISONS
*              WITHOUT CONVERTING BUFFER ARGUMENTS TO STRINGS.
*              THIS IS DONE BY CHANGING LCOMP TO ACCEPT BUFFER
*              ARGUMENT(S).  THIS ALSO AFFECTS SORT FUNCTION,
*              WHICH WILL COMPARE TWO BUFFERS AS STRINGS.
*      C3.787  CHANGE GTNUM TO USE CHARACTERS IN BUFFER WITHOUT
*              CONVERSION TO A STRING.  THIS IMPLIES THAT ACOMP
*              WILL PERFORM ARITHMETIC COMPARISONS OF BUFFERS
*              WITHOUT CONVERTING TO STRINGS FIRST.
*      C3.788  PERFORM COMPARISONS OF STRINGS AND BUFFERS IN
*              SORTC.
*      C3.789  CHANGE INSBF TO ALLOW INSERTION OF A BUFFER INTO
*              A BUFFER WITHOUT FIRST CONVERTING IT TO A STRING.
*              NOTE THAT THIS ONLY WORKS WHEN THE TWO BUFFERS
*              ARE NOT THE SAME.
*      C3.790  DOCUMENTATION CHANGE:  NOTE THAT ALL OF THE BLOCK
*              MOVE OPCODES SHOULD HAVE WA .GT. 0.  NOT ALL
*              IMPLEMENTATIONS AVOID MOVING OBJECTS WHEN WA IS
*              ZERO.
*      C3.791  CHANGE IDENT TO PROVIDE BUFFER/BUFFER AND
*              BUFFER/STRING COMPARISONS, TO ACCOMMODATE USERS
*              WHO PERFORM IDENT(BUF) TO CHECK FOR NULL STRING
*              IN BUFFER.
*      C3.792  ADDED FULLSCAN KEYWORD INITIALIZED TO ONE.  USER
*              MAY SET TO ANY NON-ZERO VALUE, WILL RECEIVE AN
*              ERROR MESSAGE IF ATTEMPTS TO SET TO ZERO, SINCE
*              QUICKSCAN MODE IS NOT SUPPORTED.
*      C3.793  REWROTE STATEMENT STARTUP CODE AT STMGO TO ONLY
*              PERFORM CHECKING OF PROFILING, STCOUNT TRACING,
*              AND STATEMENT COUNTING IF NECESSARY.
*      C3.794  ADD ADDITIONAL EXIT TO SYSFC AND IOPUT TO SIGNAL
*              THAT I/O CHANNEL (FCBLK) IS ALREADY IN USE.
*              ADDED ERROR MESSAGE NUMBERS 289 AND 290.
*      C3.795  ADDED OPTIONAL INTEGER ARGUMENT TO DATE FUNCTION
*              TO SPECIFY FORMAT OF DATE STRING RETURNED BY
*              SYSDT.
*
*
*      VERSION 3.6 TO 3.6A (OCT 83)
*      ---------------------------
*
*      CHANGES
*      -------
*
*      C3.617  ADD .CNLF. IF DEFINED, THEN ARGUMENTS TO EXTERNAL
*              FUNCTIONS MAY BE DECLARED TO HAVE TYPE FILE.
*              SUCH ARGUMENTS MUST HAVE BEEN USED AS SECOND
*              ARG TO INPUT() OR OUTPUT() AND A POINTER TO THE
*              FCB IS PASSED TO THE EXTERNAL FUNCTION.
*
*
*      VERSION 3.5 TO 3.6 (JUN 83)
*      ---------------------------
*
*      CODES USED TO IDENTIFY AUTHORS ARE (SGD) FOR DUFF,
*      (REG) FOR  GOLDBERG, AND (LDS) FOR SHIELDS.
*
*      BUGS FIXED
*      ----------
*      B3.601  (SGD) TO FIX MULTIPLE TRAP BLOCK PROBLEM IN ASIGN
*      B3.602  (SGD) PATCH IN GTARR TO FIX NULL CONVERT.
*      B3.603  (SGD) INSERTED MISSING WTB AFTER SYSMM CALLS.
*      B3.604  (SGD) USE STRING LENGTH IN HASHS.
*      B3.605  (SGD) FIXED SERIOUS PARSER PROBLEM
*              RELATING TO (X Y) ON LINE BEING VIEWED AS PATTERN
*              MATCH.  FIXED BY ADDITION OF NEW CMTYP VALUE
*              C$CNP (CONCATENATION - NOT PATTERN MATCH).
*      B3.606  (SGD) FIXED EXIT(N) RESPECIFICATION CODE
*              TO PROPERLY OBSERVE HEADER SEMANTICS ON RETURN.
*      B3.607  (SGD) BYPASS PRTPG CALL AT INITIALIZATION
*              FOLLOWING COMPILATION IF NO OUTPUT GENERATED.
*              THIS PREVENTS OUTPUT FILES CONSISTING OF THE
*              HEADERS AND A FEW BLANK LINES WHEN THERE IS NO
*              SOURCE LISTING AND NO COMPILATION STATS.
*              ALSO FIX TIMSX INITIALIZATION IN SAME CODE.
*      B3.608  (SGD) B$EFC CODE DID NOT CHECK FOR
*              UNCONVERTED RESULT RETURNING NULL STRING.
*      B3.609  (SGD) LOAD PFVBL FIELD IN RETRN FOR
*              RETURN TRACING. THIS WAS CAUSING BUG ON RETURN
*              TRACES THAT TRIED TO ACCESS THE VARIABLE NAME.
*      B3.610  (SGD) FIXED PROBLEM RELATING TO COMPILATION OF
*              GOTO FIELDS CONTAINING SMALL INTEGERS
*              (IN CONST SEC).
*      B3.611  (REG) PREVENT CLEAR() FROM CLOBBERING PROTECTED
*              VARIABLES AT LABEL SCLR5.
*      B3.612  (REG) FIXED GTEXP FROM ACCEPTING TRAILING
*              SEMICOLON OR COLON. THIS IS NOT A LEGAL WAY
*              TO END AN EXPRESSION.
*      B3.613  (REG) FIXED DIFFICULTIES WITH LISTINGS DURING
*              EXECUTION WHEN NO LISTING GENERATED DURING
*              COMPILATION. -LIST TO CODE() CAUSED BOMB.
*              FIX IS TO RESET R$TTL AND R$STL TO NULLS NOT 0
*              AFTER COMPILATION.
*              (LISTR AND LISTT EXPECT NULLS)
*              WHEN LISTING AND STATISTICS ROUTED TO DIFFERENT
*              FILE THAN EXECUTION OUTPUT, ERROR MESSAGE IS SENT
*              TO EXECUTION OUTPUT (AND GETS SEPARATED FROM
*              ... IN STATEMENT ... MSG). LABO1 CALLS SYSAX AND
*              STOPR DOES NOT CALL SYSAX IF ENTERED FROM LABO1.
*      B3.614  (LDS) FIX MISUSE OF WC JUST AFTER ASG10.
*      B3.615  (LDS) ADD COMMENT POINTING OUT SUSPICIOUS CODE
*              AFTER TFN02
*      B3.616  (LDS) FIX INCONSISTENT DECLARATION OF SORTH.
*      B3.617  (LDS) INSERT MISSING CONDITIONAL TESTS ON CNBF.
*      B3.618  (LDS) FIX SOME VIOLATIONS OF MINIMAL LANGUAGE
*              THAT HAD SLIPPED PAST SOME TRANSLATORS.
*      B3.619  (LDS) CORRECT ERROR INTRODUCED IN FIXING B3.614.
{{EJC{{{{{708
*      CHANGES
*      -------
*
*
*      C3.601  (SGD) ADDITION OF .CNCI AND SYSCI (INT TO STRING
*              SYSTEM ROUTINE OPTION)
*      C3.602  (REG) CHANGED INILN AND AND INILS TO 258
*      C3.603  (SGD) MERGED IN PROFILER PATCHES, REPAIRED CODE.
*      C3.604  (SGD) ADDED BUFFER TYPE AND SYMBOL CNBF
*      C3.605  (SGD) ADDED CHAR FUNCTION.  CHAR(N) RETURNS NTH
*              CHARACTER OF HOST MACHINE CHARACTER SET.
*      C3.606  (REG) ADDED CFP$U TO EASE TRANSLATION ON SMALLER
*              SYSTEMS - CONDITIONAL .CUCF
*      C3.607  (REG) ADDED LOWER CASE SUPPORT, CONDITIONAL .CULC
*      C3.608  (REG) ADDED SET I/O FUNCTION, CONDITIONAL .CUST
*      C3.609  (REG) CONDITIONALIZED PAGE EJECT AFTER CALL TO
*              SYSBX AND ADDED ANOTHER BEFORE CALL TO SYSBX,
*              SO THAT, IF DESIRED BY THE IMPLEMENTOR,
*              STANDARD OUTPUT WILL REFLECT ASSIGNMENTS MADE
*              BY EXECUTING PROGRAM ONLY.
*              CONDITIONAL .CUEJ CONTROLS - IF DEFINED THEN
*              EJECT IS BEFORE CALL TO SYSBX.
*      C3.610  (LDS) INTRODUCE .CTMD TO SUPPORT SYSTM THAT
*              REPORTS ELAPSED TIME IN DECISECONDS INSTEAD OF
*              MILLISECONDS.
*      C3.611  (LDS)  PROVIDE PLACE FOR .DEF OR .UND FOR EACH
*              CONDITIONAL  OPTION, SO THAT SETTINGS CAN BE
*              CHANGED WITHOUT CHANGING LINE NUMBERS.
*              CURRENT SETTINGS ARE FOR 808X TRANSLATION.
*      C3.612  (LDS) OBEY (NEW) RESTRICTION THAT OPERAND IN
*              CONDITIONAL BRANCH INSTRUCTION CANNOT HAVE FORM
*              (X)+ IN ORDER TO SIMPLIFY TRANSLATIONS FOR WHICH
*              POSTINCREMENT NOT READILY AVAILABLE.
*      C3.613  (REG,LDS) ADD OP
*                    FLC WREG
*              THAT FOLDS CHARACTER IN WREG TO UPPER CASE.
*              THIS OP IS USED ONLY IF .CULC IS DEFINED.
*              THIS CHANGE ALSO INVOLVES ADDITION OF KEYWORD
*              &CASE WHICH WHEN NONZERO (THE INITIAL SETTING)
*              CAUSES THE CASE FOLDING JUST DESCRIBED TO BE
*              DONE.
*      C3.614  (LDS) ADD OPTION .CS16 TO PERMIT INITIALIZATION
*              OF STATEMENT LIMIT VALUES TO 32767 FOR 16 BIT
*              MACHINES.
*      C3.615  (LDS) PERMIT RETURN POINT AND ENTRY POINT
*              ADDRESSES TO BE DISTINGUISHED BY THEIR PARITY
*              INSTEAD OF BY LYING WITHIN A CERTAIN RANGE
*              OF VALUES.  INTRODUCE CONDITIONAL SYMBOLS
*              .CRPP  RETURN POINTS HAVE ODD PARITY
*              .CEPP  ENTRY POINTS HAVE ODD PARITY
*      C3.616  (LDS) INTRODUCE NEW MINIMAL OPCODES TO BRANCH
*              ACCORDING TO PARITY,
*                BEV  OPN,PLBL  BRANCH IF ADDRESS EVEN
*                BOD  OPN,PLBL  BRANCH IF ADDRESS ODD
*              AN ADDRESS IS EVEN IF IT IS A MULTIPLE OF CFP$B.
{{EJC{{{{{764
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.601  (LDS) BRING MINIMAL MACHINE DESCRIPTION UP TO
*              DATE
*
{{EJC{{{{{771
*      VERSION 3.4 TO 3.5 (FEB 79)
*      ---------------------------
*
*
*      BUGS FIXED
*      ----------
*
*      B3.401  PRTST SHOULD BE DECLARED AS AN R TYPE PROCEDURE.
*      B3.402  TIMING ERROR IF SPITBOL FAILS IN DUMP.
*      B3.403  ERROR IN HANDLING OMITTED ARGS OF OPERATORS.
*      B3.404  TOO MANY LINES PUT ON FIRST PAGE OF LISTING.
*      B3.405  LEADING UNARY OPERATOR IN EVAL ERRONEOUSLY NEEDED
*              PRECEDING BLANK.
*      B3.406  IDENTIFYING NAME IN DUMP OF ARRAY OR TABLE VALUES
*              WAS OMITTED.
*      B3.407  EVAL UNABLE TO RETURN A DEFERRED EXPRESSION.
*      B3.408  ILLEGAL IF SETEXIT CODE BRANCHES TO RETURN.
*      B3.409  ILLEGAL ON DETACHING INPUT, OUTPUT, TERMINAL.
*
*      CHANGES
*      -------
*
*      C3.401  -SEQU AND -NOSE CONTROL CARDS REMOVED.
*      C3.402  OPTION PROVIDED TO SUPPRESS SYSTEM IDENTIFICATION
*              ON LISTING.
*      C3.403  DESCRIPTION OF SYSBX SLIGHTLY REVISED.
*      C3.404  PERMISSIBLE TO MODIFY SCBLK LENGTH BEFORE TAKING
*              ERROR RETURNS FROM SYSIN, SYSRD, SYSRI.
*      C3.405  CONDITIONAL .CNLD MAY BE DEFINED TO OMIT LOAD().
*      C3.406  CONDITIONAL .CNEX MAY BE DEFINED TO OMIT EXIT().
*      C3.407  TABLE NOW ACCEPTS A THIRD ARGUMENT SPECIFYING
*              DEFAULT INITIAL LOOKUP VALUE.
*      C3.408  ROUTINES SORT, RSORT FOR SORTING ARRAYS AND TABLE
*              INTRODUCED. SPECIFICATION IS AS IN SITBOL.
*              ROUTINES MAY BE OMITTED BY DEFINING .CNSR .
*      C3.409  ERROR IN CODE(), EVAL() CALL NOW CAUSES STATEMENT
*              FAILURE BUT ERRTEXT KEYWORD IS STILL SET.
*      C3.410  ARG TO CODE() MAY CONTAIN EMBEDDED CONTROL CARDS
*              AND COMMENT DELIMITED BY A SEMICOLON.
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.401  PURPOSE OF RESTRICTION 2 IN MINIMAL SECTION -6-
*              (OPERATIONS ON CHAR VALUES), ERRONEOUSLY STATED
*              TO BE FOR CMC, RATHER THAN FOR CEQ, CNE.
*              DESCRIPTIONS OF ABOVE OPCODES REVISED.
*      D3.402  DESCRIPTION OF ENT CLARIFIED.
*      D3.403  DESCRIPTIONS OF SEVERAL OPCODES REVISED TO REMOVE
*              TECHNICALLY INVALID LITERALS E.G. =0 , *1.
*      D3.405  RESTRICTED USE OF LETTER Z IN MINIMAL CLARIFIED.
*      D3.406  DIVIDE BY ZERO EXPLICITLY MENTIONED IN RELATION
*              TO OVERFLOW SETTING.
{{EJC{{{{{825
*      VERSION 3.3 TO 3.4 (OCT 78)
*      ---------------------------
*
*
*      BUGS FIXED
*      ----------
*
*      B3.301  ILLEGAL FOR ERRONEOUS EVAL() ARG.
*      B3.302  ADDRESS ARITHMETIC OVERFLOW IN ALLOC AND ALOCS.
*      B3.303  -EJECT AND -SPACE IGNORED -NOLIST OPTION.
*      B3.304  ERRONEOUS ARGUMENT SCAN IN LOAD().
*      B3.305  ERRONEOUS PLC ON UNINITIALISED R$CIM IN NEXTS.
*      B3.306  LDI USED INSTEAD OF MTI AFTER PRV07.
*      B3.307  MISUSE OF RMI AT ERRA2.
*      B3.308  MISUSE OF MTI IN HASHS.
*      B3.309  BUG IN -SEQU CARD SEQUENCE NUMBER CHECKING.
*      B3.310  STACK OVERFLOW ERROR MESSAGE NOT ALWAYS PRINTED.
*      B3.311  CORRUPT PROTOTYPE PRINT FOR TRACED ARRAYS.
*      B3.312  PATTERN FIRST ARG IN DUPL CAUSED ERROR.
*      B3.313  OMITTED CSC IN S$RPD, ERRONEOUS CSC IN CONVERT.
*      B3.314  MISPLACED BTW IN EXBLD.
*      B3.315  INCORRECT CODE IN HASHS.
*      B3.316  FAILURE OF LOAD TO SCAN INTEGER ARG.
*      B3.317  TABLE ACCESS WITH NEGATIVE INTEGER ARG. FAILED.
*      B3.318  ERROR IN RETURNING RESULT OF LOADED FUNCTION.
*      B3.319  =E$SRS USED AFTER INI01 INSTEAD OF *E$SRS.
*      B3.320  ERR USED INSTEAD OF ERB AFTER SYSTU
*      B3.321  LABEL COULD START WITH DISALLOWED CHARACTER.
*      B3.322  CONTINUE AFTER SETEXIT HAD BAD HEURISTIC.
{{EJC{{{{{855
*
*
*      CHANGES
*      -------
*
*      C3.301  SYSAX AND .CSAX INTRODUCED - SEE SYSAX
*              IN PROCEDURES SECTION.
*      C3.302  VARIABLE MXLEN INTRODUCED. CONTAINS THE MAXIMUM
*              SIZE OF A SPITBOL OBJECT AND IS NOT CHANGEABLE
*              AFTER INITIALISATION. MAY BE DEFAULTED OR SET
*              EXPLICITLY BY SYSMX.
*      C3.303  SYSHS RETURNS REVISED - SEE SYSHS.
*      C3.304  NEW MINIMAL OPCODE AOV TO FIX B3.302.
*      C3.305  INHIBIT STLIMIT CHECK IF STLIMIT MADE NEGATIVE.
*      C3.306  CFP$M IS REQUIRED TO BE OF FORM 2**N - 1.
*      C3.307  DUPL MADE TO CONFORM TO SIL SNOBOL4 STANDARD.
*      C3.308  LCH AND SCH ACTIONS MORE CLOSELY DEFINED.
*      C3.309  BATCH INITIALISATION CODE OMITTED IF CONDITIONAL
*              ASSEMBLY SYMBOL .CNBT (NO BATCH) DEFINED.
*      C3.310  (WA) CONTAINS ARGUMENT COUNT IN SYSEX CALL.
*      C3.311  SYSFC  MAY REQUEST ALLOCATION OF STATIC FCBLK.
*      C3.312  IF IA,WC OVERLAP, RESTRICTION PUT ON DUMPING/
*              RESTORING THESE REGISTERS.
*      C3.313  NEW LISTING OPTION INTERMEDIATE BETWEEN COMPACT
*              AND EXTENDED PROVIDED (SEE SYSPP).
*      C3.314  REVISION OF SYSXI INTERFACE TO PERMIT OPTIONS FOR
*              LOAD MODULE STANDARD O/P FILE (SEE SYSXI,SYSPP).
*      C3.315  LAST ARG OF SUBSTR MAY BE OMITTED - TREATED
*              AS REMAINDER OF STRING.
{{EJC{{{{{885
*      VERSION 3.2 TO 3.3 (JAN 78)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.201  ARRAY REFERENCE AND EXTERNAL FUNCTION LOAD
*              ROUTINES ILLEGALLY ACCESSED INFORMATION
*              BEYOND THE STACK FRONT.
*              SIMILAR FAULT IN UNANCHORED PATTERN MATCHING.
*      B3.202  DUMP(1) PRODUCED DUMP(2) TYPE OUTPUT.
*      B3.203  WTB CONVERSION OMITTED IN CODE FOLLOWING
*              INI01, INI02, EXBLD.
*      B3.204  INCORRECT FAIL RETURN FROM TFIND IN ARREF.
*      B3.205  ENDFILE DID NOT DETACH I/O ASSOCIATED VARIABLES.
*      B3.206  -SPACE WITH OMITTED ARG. FAILED
*      B3.207  LOOPED IF DUMP KEYWORD NON-ZERO AFTER STACK
*              OVERFLOW IN GARBAGE COLLECT FAILURE.
*      B3.208  FAILURE IN READING NUMBERS WITH TRAILING BLANKS.
*
*      CHANGES
*      -------
*
*      THE EXTENSIVE CHANGES MADE HERE MOSTLY RESULT FROM A
*      SNOBOL4 IMPLEMENTORS MEETING HELD AT NEW YORK UNIVERSITY
*      IN AUGUST 1977. THEY ARE AIMED AT
*           (1) HAVING SPITBOL CONFORM TO CERTAIN SNOBOL4
*           LANGUAGE STANDARDS  AND
*           (2) PRODUCING A STABLE DEFINITION OF MINIMAL BY
*           CARRYING OUT A FEW ESSENTIAL REVISIONS IN THE LIGHT
*           OF EXPERIENCE IN ITS USE.
*
*      CHANGES TO SPITBOL
*      ------------------
*
*      C3.201  DEFAULT VALUES FOR KEYWORDS TRIM AND ANCHOR ARE
*              ZERO. ON SYSTEMS WHERE RECORDS ARE CUSTOMARILY
*              HANDLED WITHOUT TRALING BLANKS, THERE IS NO
*              OBLIGATION TO SUPPLY SUCH BLANKS.
*      C3.202  DEFAULT VALUE OF -INXX CONTROL CARD IS -IN72.
{{EJC{{{{{926
*      C3.203  THE SECOND ARGUMENT OF INPUT AND OUTPUT IS
*              PERMITTED TO BE AN INTEGER AS IN SNOBOL4.
*              IN ADDITION INPUT(), OUTPUT() NOW GIVE A SNOBOL4
*              STATEMENT FAILURE IF SYSIO USES THE FILE NOT
*              FOUND RETURN.
*              THE THIRD ARGUMENT HAS A RECOMMENDED FORMAT AND
*              TO OVERRIDE ITS DEFAULT DELIMITER (,) A
*              CONDITIONAL ASSEMBLY SYMBOL, .CIOD, IS USED.
*              INTERFACES TO SYSEF,SYSEJ,SYFC,SYSIO,SYSRW
*              ARE REVISED.
*              WC MAY NOW BE USED TO RETURN FROM SYSIO, A MAX
*              RECORD LENGTH.
*      C3.204  A NEW CONFIGURATION PARAMETER CFP$F (SCBLK OFFSET
*              IS INTRODUCED. CFP$U IS REMOVED.
*      C3.205  IMPLEMENTATION AND VERSION IDENTIFICATION IS
*              REQUIRED - SEE SYSID.
*      C3.206  ROUTINE SYSMX RETURNS THE MAXIMUM LENGTH OF
*              SPITBOL OBJECTS (STRINGS ARRAYS ETC).  THIS
*              INFORMATION IS NOT NOW NEEDED AT TIME OF ENTRY TO
*              SPITBOL AND HENCE WC SHOULD BE ZERO ON ENTRY.
*      C3.207  A CONDITIONAL PARAMETER .CNRA PERMITS ASSEMBLY
*              OF A MORE COMPACT VERSION WITH NO REAL
*              ARITHMETIC CODE.
*      C3.208  TERMINAL IS A NEW PRE-ASSOCIATED VARIABLE
*              CAPABLE OF PERFORMING INPUT AND OUTPUT TO AN
*              ONLINE TERMINAL.
*              SYSRI IS A NEW ROUTINE USED IN THE IMPLEMENTATION
*              OF THIS. SEE ALSO SYSPP.
*      C3.209  THE ENVIRONMENT PARAMETERS E$--- ARE NOW
*              PROVIDED BY THE MINIMAL TRANSLATOR USING THE
*              REVISED   EQU  *   FORMAT (SEE C3.229 AND START
*              OF SPITBOL DEFINITIONS SECTION - SOME REORDERING
*              OF SYMBOLS HAS OCCURRED).
*      C3.210  THE INTERFACE OF SYSXI HAS BEEN SLIGHTLY REVISED.
*              UNAVAILABILITY OF I/O CHANNELS AFTER EXIT(1),
*              EXIT(-1) IS DOCUMENTED TOGETHER WITH ADDITIONAL
*              ERROR RETURN USAGE FOR SYSIN,SYSOU,SYSPR,SYSRD.
*      C3.211  SPITBOL ERROR CODES HAVE BEEN FROZEN - SEE C3.230
*      C3.212  THE UTILITY ROUTINES ARREF ETC. ARE NOW
*              INTRODUCED BY RTN STATEMENTS.
*      C3.213  SYSRL (RECORD LENGTH FOR STD INPUT FILE) IS
*              REMOVED. SINCE IMPLEMENTATION OF A GENERAL -INXXX
*              CONTROL CARD AND AN ABILITY TO SPECIFY MAX RECORD
*              LENGTH USING THE THIRD ARGUMENT OF INPUT, SYSRL
*              HAS BECOME REDUNDANT.
*      C3.214  SYSEJ AND SYSXI ARE NOW PASSED A CHAIN LINKING
*              ALL FCBLKS IN USE.
*      C3.215  A SPECIAL ENDING CODE IN SYSEJ IS USED WHEN
*              ATTEMPTS TO USE STANDARD OUTPUT CHANNEL FAIL.
*      C3.216  RESTRICTION C3.233 OBSERVED SO SIMPLIFYING
*              OPTIMISED TRANSLATION OF ENT WITH OMITTED VAL.
{{EJC{{{{{978
*
*      CHANGES TO MINIMAL
*      ------------------
*
*      C3.220  MINIMAL OPCODES DEC, DIM, INC, AND BMP
*              ARE WITHDRAWN AND REPLACED BY THE MORE CONSISTENT
*              SET DCA, DCV, ICA, ICV.
*      C3.221  CHS HAS BEEN REPLACED BY THE MORE GENERALLY
*              USEFUL ZGB (STILL LIKELY TO BE A NO-OP FOR MOST
*              IMPLEMENTATIONS HOWEVER).
*      C3.222  THE SET OF CHARACTER COMPARISONS HAS BEEN
*              REDUCED TO CEQ AND CNE TO EASE IMPLEMENTATION
*              PROBLEMS.
*      C3.223  OPCODE IRZ IS REMOVED AND DVI, RMI ORDERS ARE
*              REDEFINED TO CONFORM TO MORE COMMON USAGE.
*      C3.224  NEW OPCODES SSL AND SSS ARE DEFINED. THEIR USE
*              PERMITS RETURN LINKS FOR N TYPE PROCEDURES TO BE
*              PLACED ON A LOCAL STACK IF DESIRED.
*      C3.225  OPCODE MNZ COMPLEMENTS ZER. IT MOVES A NON-ZERO
*              FLAG TO ITS DESTINATION.
*      C3.226  FOR SOME MACHINES IT IS PREFERABLE FOR THE STACK
*              TO BUILD UP RATHER THAN DOWN. TO PERMIT THIS
*              WITHOUT NEED FOR MASSIVE CHANGES IN MINIMAL AND
*              RECODING OF EXISTING PROGRAMS, A SCHEME HAS BEEN
*              DEVISED IN WHICH AN ADDITIONAL REGISTER NAME, XT,
*              IS USED AS A SYNONYM FOR XL WHEN THIS REGISTER
*              IS INVOLVED IN STACK MANIPULATION- SEE SECTION 4.
*      C3.227  SECTION 0 OF A MINIMAL PROGRAM IS RENAMED THE
*              PROCEDURE SECTION. IT NOW CONTAINS, IN ADDITION
*              TO EXP, SPECIFICATIONS OF INTERNAL PROCEDURES
*              AND ROUTINES BY MEANS OF THE INP AND INR OPCODES.
*      C3.228  THE LITERAL OPERAND FORMATS =INT AND *INT HAVE
*              BEEN WITHDRAWN. =DLBL AND *DLBL MUST BE USED IN
*              THEIR STEAD.
*      C3.229  THE FORMAT
*              LABEL  EQU  *NN
*              USED TO SPECIFY VALUES SUPPLIED BY THE MINIMAL
*              TRANSLATOR FOR CHAR. CODES ETC. IS REPLACED BY
*              LABEL  EQU  *
*              WHERE THE ORDER IN WHICH THE DEFINITIONS ARE
*              SUPPLIED BY THE TRANSLATOR SHOULD MATCH THE
*              ORDER OF OCCURRENCE IN THE DEFINITIONS SECTION.
*      C3.230  THE FORMAT OF ERR,ERB OPCODES IS CHANGED TO
*              REQUIRE A NUMERIC OPERAND.
*      C3.231  THE RTN OPCODE IS USED TO INTRODUCE ROUTINES
*              (WHICH ARE QUITE DISTINCT FROM PROCEDURES).
*      C3.232  CONDITIONAL ASSEMBLY DIRECTIVES MAY BE NESTED.
*      C3.233  MINOR RESTRICTION PLACED ON THE OMISSION OF
*              VAL WITH THE ENT OPCODE.
{{EJC{{{{{1028
*      VERSION 3.1 TO 3.2 (AUG 77)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.101  ASTONISHING THIS WAS UNNOTICED FOR THREE YEARS.
*              BAD CODE FOR SNOBOL4 INTEGER DIVIDE, /, GAVE
*              WRONG RESULT FOR OPERANDS OF OPPOSITE SIGNS.
*              IMPLEMENTATIONS HAVE EITHER WRONGLY TRANSLATED
*              DVI AND GOT CORRECT RESULT OR CORRECTLY
*              TRANSLATED DVI AND GOT WRONG RESULT - LEEDS HAD
*              ONE OF EACH. SEE ALSO C3.106.
*              TEST PROGRAM NO. 1 NOW EXTENDED TO CHECK /
*              MORE THOROUGHLY.
*      B3.102  GARBAGE COLLECTION BUG IN SCANE
*
*      CHANGES
*      -------
*
*      C3.101  OPTION TO USE ADDITIONAL CHARACTERS CH$HT,CH$VT
*              (HORIZONTAL AND VERTICAL TAB) WITH SAME SYNTACTIC
*              SIGNIFICANCE AS CH$BL (BLANK).
*      C3.102  OPTION TO USE A SET OF SHIFTED CASE ALPHABETIC
*              CHARACTERS CH$$A ... CH$$$.
*      C3.103  CONDITIONAL ASSEMBLY FEATURES ARE INTRODUCED INTO
*              MINIMAL ON ACCOUNT OF THE ABOVE.
*              SEE MINIMAL DOCUMENTATION SECTION FOR DETAILS
*              OF ABOVE CHANGES.
*      C3.104  LCH AND SCH MAY USE AN X REGISTER FIRST
*              OPERAND AS ALTERNATIVE TO A W REGISTER.
*      C3.105  SPITBOL STATEMENT NUMBERS IN THE LISTING MAY
*              OPTIONALLY BE PADDED TO 6 OR 8 CHARS INSTEAD OF 5
*              BY DEFINING CONDITIONAL ASSEMBLY SYMBOLS
*              .CSN6 OR .CSN8 .
*      C3.106  TO FIX BUG 3.101. AT MODERATE COST,
*              OPCODE IRZ (BRANCH IF INTEGER DIVIDE REMAINDER
*              ZERO) INTRODUCED.
*      C3.107  TO HANDLE POSSIBLE MACHINE DEPENDENCY IN STRING
*              HASHING, CHS (COMPLETE HASHING OF STRING) OPCODE
*              IS INTRODUCED. PROBABLY A NO-OP ON MOST MACHINES
*              - NOT ON THE DEC10.
*      C3.108  PROCEDURES PATIN,TFIND,TRACE HAVE BEEN
*              MODIFIED TO CONFORM TO THE MINIMAL STANDARD
*              CALL AND RETURN REGIME.
*      C3.109  SYSFC INTERFACE REVISED SLIGHTLY TO PERMIT
*              OSINT TO RETURN A POINTER TO A PRIVATELY
*              ALLOCATED FCBLK WHICH SPITBOL WILL RETURN ON
*              SUBSEQUENT I/O - SEE SYSFC DOC.
*      C3.110  TO REMOVE INCONSISTENCIES IN CALLING SEQUENCES,
*              ALL SYS ROUTINES HAVING ACCESS TO A POSSIBLE
*              FCBLK HAVE FCBLK PTR OR ZERO IN REG. WA ON ENTRY.
*              CHANGE AFFECTS SYSEF, SYSEN, SYSIL, SYSIN,
*              SYSOU, SYSRW.
*      C3.111  SYSPP BIT ALLOCATED TO PROVIDE
*               -NOEXEC OPTION ON ENTRY TO SPITBOL.
{{EJC{{{{{1085
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D3.101  NEED TO PRESERVE REGISTERS IN SYSPI, SYSPR,
*              SYSRD CALLS WAS OVERSTATED.
{{EJC{{{{{1092
*      VERSION 3.0 TO 3.1 (MAR 77)
*      ---------------------------
*
*      BUGS FIXED
*      ----------
*
*      B3.001  REPLACE() COULD FAIL DURING PRE-EVALUATION.
*              SPITBOL NOW SIGNALS AN ERROR FOR NULL OR
*              UNEQUALLY LONG 2ND AND 3RD ARGUMENTS.
*      B3.002  NEGATIVE SECOND ARGUMENTS TO DUPL, LPAD, RPAD
*              CAUSED SPITBOL TO SIGNAL AN ERROR. NOW CAUSES
*              RETURN OF NULL STRING OR FIRST ARG RESPECTIVELY.
*      B3.003  BRN-S USED INSTEAD OF PPM-S IN S$SUB.
*      B3.004  ERR USED INSTEAD OF ERB AFTER CMP30.
*      B3.005  B$PFC, S$CNV, S$DEF, ARITH AND ARREF KEPT
*              INFORMATION ILLEGALLY ABOVE THE STACK TOP.
*      B3.006  PRE-EVALUATION OF CONSTANT PARTS OF
*              COMPLEX GOTOS WAS ERRONEOUS.
*      B3.007  INCORRECT HANDLING OF LABELS COMPILED BY CODE().
*      B3.008  THE SINGLE USE OF TRC (IN S$RPL) WAS NOT IN
*              ACCORD WITH ITS DEFINITION. SOME TRANSLATIONS OF
*              TRC MAY NEED REVISION NOW THAT THE USE
*              HAS BEEN BROUGHT INTO LINE WITH DEFINITION.
*
*      CHANGES
*      -------
*
*      A DEBATE ON A FEW WEAKNESSES IN MINIMAL DESIGN HAS
*      BEEN RESOLVED BY INTRODUCING 4 NEW OPCODES.
*
*      C3.001  NEW MINIMAL OPCODES BMP AND DIM INTRODUCED
*              TO AUGMENT INC AND DEC WHICH ARE APPLICABLE
*              ONLY TO ADDRESSES.
*      C3.002  THE OPCODE SZC (STORE ZERO CHARACTERS) HAD
*              A RESTRICTED APPLICABILITY. IT HAS BEEN
*              REPLACED BY THE MORE GENERAL ZER (ZEROISE).
*      C3.003  FCBLKS MAY BE OPTIONALLY ALLOCATED AS XRBLK-S OR
*              XNBLK-S  - SEE SYSFC FOR VITAL INFORMATION.
*      C3.004  CONTROL CARD PROCESSING HAS BEEN RECODED.
*              -INXXX ALLOWS SPECIFICATION OF STANDARD INPUT
*              FILE RECORD LENGTHS OTHER THAN 72 OR 80, SEE ALSO
*              SYSRL. -SEQU IS IGNORED UNLESS -IN80 IS IN EFFECT
*      C3.005  TO ENABLE EFFICIENT BUFFERING OF CHARS ON
*              MACHINES WITHOUT CHAR. HANDLING ORDERS, THE
*              CSC (COMPLETE STORE CHARACTERS) INSTRUCTION
*              IS INTRODUCED. CURRENT IMPLEMENTATIONS CAN
*              TRANSLATE IT AS A NO-OP IF IT IS OF NO BENEFIT.
*      C3.006  INTEGERS 0,1,2 ARE TREATED SPECIALLY.
*              ICBLKS IN STATIC ARE USED INSTEAD OF
*              ALLOCATING SPACE IN DYNAMIC.
{{EJC{{{{{1143
*
*      VERSION 2.7 (JUNE 76) TO 3.0 (JAN 77)
*      -------------------------------------
*
*      BUGS FIXED
*      ----------
*
*      B2.701  GOES ILLEGAL IF TIMED OUT DURING PROCESSING OF
*              DUMP() CALL.
*      B2.702  GOES ILLEGAL IF SPITBOL ERROR DETECTED IN ARGS OF
*              CODE() OR EVAL(). BUG FIXED SO THAT USER NOW GETS
*              A SPITBOL ERROR REPORT (TRAPPABLE BY SETEXIT)
*              BEFORE STATEMENT FAILURE.
*      B2.703  GOES ILLEGAL IN SOME CIRCUMSTANCES WHEN
*              MULTIPLE COMPILATION ERRORS OCCUR IN A STATEMENT
*      B2.704  GOES ILLEGAL IF GARBAGE COLLECTOR RUNS OUT OF
*              STACK SPACE.
*      B2.705  CONTROL CARD PROCESSING INCORRECT FOR CDC 6400.
*      B2.706  INCORRECT HANDLING OF MULTIPLE OCCURRENCES OF
*              CHARS IN REPLACE 2ND AND 3RD ARGS.
*      B2.707  STACK OVERFLOW IN PRE-EVALUATION OF REPLACE IN
*              CDC 6400 VERSION.
*      B2.708  AN EXPLICIT CALL OF SYSMW WAS CODED IN S$DAT
*              INSTEAD OF THE MVW OPCODE.
*      B2.709  CALL OF GARBAGE COLLECTOR WHILST DUMPING
*              CAUSED HAVOC.
*      B2.710  SIZE RESTRICTION ON SPITBOL OBJECTS (SIZE MUST BE
*              NUMERICALLY LESS THAN LOWEST DYNAMIC ADDRESS)
*              WAS NOT ENFORCED, WITH POTENTIAL FOR CATASTROPHE.
*      B2.711  DEFERRED EXPRESSIONS INVOLVING ALTERNATION OR
*              NEGATION WERE INCORRECTLY TRANSLATED.
*      B2.712  LISTING OF A COMPILATION ERROR AT THE END OF A
*              LONG LINE COULD CAUSE COMPILER TO GO ILLEGAL.
*      B2.713  INCORRECT -NOFAIL CODE WITH SUCCESS GOTO.
{{EJC{{{{{1178
*
*
*      CHANGES
*      -------
*
*      (IT IS NOT ANTICIPATED THAT MAJOR REVISIONS ON THIS
*      SCALE WILL BE FREQUENT).
*
*      C2.701  DEFAULT VALUE OF ANCHOR KEYWORD IS SET TO 1. THIS
*              CONFLICTS WITH SNOBOL4 PRACTICE BUT IS A
*              PREFERABLE DEFAULT FOR MOST APPLICATIONS.
*      C2.702  IF ERRTYPE IS OUT OF RANGE THE STRING IN KEYWORD
*              ERRTEXT IS PRINTED AS THE ERROR MESSAGE.
*      C2.703  IF STLIMIT IS EXCEEDED, UP TO 10 MORE STATEMENTS
*              MAY BE OBEYED TO PERMIT SETEXIT TRAP TO GAIN
*              CONTROL.
*      C2.704  THE CONCEPT OF AN INTERACTIVE CHANNEL IS
*              INTRODUCED FOR IMPLEMENTATIONS WHERE AN ONLINE
*              TERMINAL MAY BE USED FOR SPITBOL. THE STANDARD
*              PRINT FILE MAY BE SPECIFIED AS INTERACTIVE IN
*              WHICH CASE SHORTER TITLE LINES ARE OUTPUT.
*              ALTERNATIVELY COPIES OF COMPILATION AND
*              EXECUTION ERRORS ONLY MAY BE SENT TO THIS CHANNEL
*      C2.705  PRINTING OF COMPILATION STATISTICS MAY BE
*              SUPPRESSED.
*      C2.706  PRINTING OF EXECUTION STATISTICS MAY BE
*              SUPPRESSED.
*      C2.707  EXTENDED OR COMPACT LISTING FORMAT MAY BE
*              SELECTED.
*      C2.708  AN INITIAL -NOLIST OPTION MAY BE SPECIFIED
*              BEFORE COMPILATION STARTS.
*      C2.709  TO SPECIFY CHOICES IMPLIED BY C2.704 TO C2.708
*              SYSPP INTERFACE IS REVISED AND SYSPI IS DEFINED.
*      C2.710  COMPILATION AND EXECUTION TIME STATISTICS
*              MESSAGES HAVE BEEN SHORTENED.
*      C2.711  THE EXIT FUNCTION AS IN SITBOL IS INTRODUCED
*              TO PERMIT SAVING LOAD MODULES - SEE SYSXI, S$EXT.
*      C2.712  DIAGNOSTIC ROUTINES SYSGB AND SYSGD HAVE BEEN
*              REMOVED. THEY WERE USEFUL IN THE EARLY DEBUGGING
*              DAYS BUT HAVE FALLEN INTO DISUSE NOW.
*      C2.713  SZC MAY HAVE AN OPERAND OF TYPE OPN INSTEAD OF
*              TYPE OPW
*      C2.714  INPUT/OUTPUT ASSOCIATION INTERFACE HAS BEEN
*              REVISED. SYSIF,SYSOF HAVE BEEN CONSOLIDATED INTO
*              THE NEW SYSTEM ROUTINE, SYSIO, AND THE
*              SPECIFICATION OF SYSFC HAS BEEN SLIGHTLY CHANGED.
*      C2.715  CONFIGURATION PARAMETER MXLEN HAS BEEN WITHDRAWN
*              AND THE MAXIMUM SIZE OF A SPITBOL OBJECT WHICH
*              WAS FORMERLY FIXED AT SPITBOL COMPILE TIME BY
*              REFERENCE TO IT MAY NOW BE SPECIFIED AS A RUN
*              TIME OPTION BY PLACING A VALUE IN WC BEFORE ENTRY
*              TO SPITBOL. (SEE COMMENT ON DYNAMIC AREA IN
*              BASIC INFORMATION SECTION).
*      C2.716  A FUNCTION, HOST, IS INTRODUCED WHICH YIELDS
*              INFORMATION ABOUT THE HOST MACHINE - SEE SYSHS
*              AND S$HST.
{{EJC{{{{{1235
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D2.701  THE DESCRIPTION OF MVC HAS BEEN REVISED TO
*              REFLECT THE FACT THAT SOME SPITBOL CODE SEQUENCES
*              RELY ON MVC NOT DESTROYING WB. MINOR CHANGES
*              HAVE BEEN MADE TO MWB AND MVW DESCRIPTIONS TO
*              EMPHASISE SIMILARITIES IN THE IMPLICIT LOOPS OF
*              THESE ORDERS.
*      D2.702  DESCRIPTIONS OF DVI AND RMI HAVE BEEN CLARIFIED.
*      D2.703  IMPLEMENTATION OF RSX,LSX,CEQ,CGE,CGT,CHI,CLO,CLT
*              IS OPTIONAL AT PRESENT SINCE THEY ARE CURRENTLY
*              UNUSED. THEIR USE IN LATER VERSIONS IS NOT
*              EXCLUDED.
*      D2.704  IMPOSSIBILITY OF USING STACK FOR RETURN LINKS OF
*              N TYPE PROCEDURES IS EMPHASISED.
*      D2.705  NOTATION (XL),(WC) ETC IN LANGUAGE DESCRIPTION IS
*              CLARIFIED.
*      D2.706  DOCUMENTATION OF SYSFC, SYSIO HAS BEEN IMPROVED.
*      D2.707  OPCODE DESCRIPTIONS ARE CROSS REFERENCED FROM
*              THE ALPHABETICAL OPCODE LIST.
*      D2.708  GENERAL DESCRIPTION OF COMPILER HAS BEEN MOVED TO
*              THE START OF THE COMPILER PROPER.
*      D2.709  DEFINITIONS OF ENVIRONMENT PARAMETERS HAVE BEEN
*              PUT NEAR THE FRONT OF THE DEFINITIONS SECTION.
{{TTL{27,MINIMAL -- MACHINE INDEPENDENT MACRO ASSEMBLY LANG.{{{{1262
{{EJC{{{{{1263
*
*      THE FOLLOWING SECTIONS DESCRIBE THE IMPLEMENTATION
*      LANGUAGE ORIGINALLY DEVELOPED FOR SPITBOL BUT NOW MORE
*      WIDELY USED. MINIMAL IS AN ASSEMBLY LANGUAGE
*      FOR AN IDEALIZED MACHINE. THE FOLLOWING DESCRIBES THE
*      BASIC CHARACTERISTICS OF THIS MACHINE.
*
*      SECTION 1 - CONFIGURATION PARAMETERS
*
*      THERE ARE SEVERAL PARAMETERS WHICH MAY VARY WITH THE
*      TARGET MACHINE. THE MACRO-PROGRAM IS INDEPENDENT OF THE
*      ACTUAL DEFINITIONS OF THESE PARAMETERS.
*
*      THE DEFINITIONS OF THESE PARAMETERS ARE SUPPLIED BY
*      THE TRANSLATION PROGRAM TO MATCH THE TARGET MACHINE.
*
*      CFP$A                 NUMBER OF DISTINCT CHARACTERS IN
*                            INTERNAL ALPHABET IN THE RANGE
*                            64 LE CFP$A LE MXLEN.
*
*      CFP$B                 NUMBER OF BYTES IN A WORD WHERE A
*                            BYTE IS THE AMOUNT OF STORAGE
*                            ADDRESSED BY THE LEAST SIGNIFICANT
*                            ADDRESS BIT.
*
*      CFP$C                 NUMBER OF CHARACTERS WHICH CAN
*                            BE STORED IN A SINGLE WORD.
*
*      CFP$F                 BYTE OFFSET FROM START OF A STRING
*                            BLOCK TO THE FIRST CHARACTER.
*                            DEPENDS BOTH ON TARGET MACHINE AND
*                            STRING DATA STRUCTURE. SEE PLC, PSC
*
*      CFP$I                 NUMBER OF WORDS IN A SIGNED
*                            INTEGER CONSTANT
*
*      CFP$L                 THE LARGEST UNSIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N BUT NEED NOT BE.
*
*      CFP$M                 THE LARGEST POSITIVE SIGNED INTEGER
*                            OF FORM 2**N - 1 WHICH CAN BE
*                            STORED IN A SINGLE WORD.  N WILL
*                            OFTEN BE CFP$N-1 BUT NEED NOT BE.
*
*      CFP$N                 NUMBER OF BITS WHICH CAN BE STORED
*                            IN A ONE WORD BIT STRING.
*
*      CFP$R                 NUMBER OF WORDS IN A REAL CONSTANT
*
*      CFP$S                 NUMBER OF SIGNIFICANT DIGITS TO
*                            BE OUTPUT IN CONVERSION OF A REAL
*                            QUANTITY.
*
*      CFP$U                 REALISTIC UPPER BOUND ON ALPHABET.
*
*
*      CFP$X                 NUMBER OF DIGITS IN REAL EXPONENT
{{EJC{{{{{1331
*
*      SECTION 2 - MEMORY
*
*      MEMORY IS ORGANIZED INTO WORDS WHICH EACH CONTAIN CFP$B
*      BYTES. FOR WORD MACHINES CFP$B, WHICH IS A CONFIGURATION
*      PARAMETER, MAY BE ONE IN WHICH CASE WORDS AND BYTES ARE
*      IDENTICAL. TO EACH WORD CORRESPONDS AN ADDRESS WHICH IS
*      A NON-NEGATIVE QUANTITY WHICH IS A MULTIPLE OF CFP$B.
*      DATA IS ORGANIZED INTO WORDS AS FOLLOWS.
*
*      1)   A SIGNED INTEGER VALUE OCCUPIES CFP$I CONSECUTIVE
*           WORDS (CFP$I IS A CONFIGURATION PARAMETER).
*           THE RANGE MAY INCLUDE MORE NEGATIVE NUMBERS THAN
*           POSITIVE (E.G. THE TWOS COMPLEMENT REPRESENTATION).
*
*      2)   A SIGNED REAL VALUE OCCUPIES CFP$R CONSECUTIVE
*           WORDS. (CFP$R IS A CONFIGURATION PARAMETER).
*
*      3)   CFP$C CHARACTERS MAY BE STORED IN A SINGLE WORD
*           (CFP$C IS A CONFIGURATION PARAMETER).
*
*      4)   A BIT STRING CONTAINING CFP$N BITS CAN BE STORED IN
*           A SINGLE WORD (CFP$N IS A CONFIGURATION PARAMETER).
*
*      5)   A WORD CAN CONTAIN A UNSIGNED INTEGER VALUE IN
*           THE RANGE (0 LE N LE CFP$L). THESE INTEGER VALUES
*           MAY REPRESENT ADDRESSES OF OTHER WORDS AND SOME OF
*           THE INSTRUCTIONS USE THIS FACT TO PROVIDE INDEXING
*           AND INDIRECTION FACILITIES.
*
*      6)   PROGRAM INSTRUCTIONS OCCUPY WORDS IN AN UNDEFINED
*           MANNER. DEPENDING ON THE ACTUAL IMPLEMENTATION,
*           INSTRUCTIONS MAY OCCUPY SEVERAL WORDS, OR PART OF
*           A WORD, OR EVEN BE SPLIT OVER WORD BOUNDARIES.
*
*      THE FOLLOWING REGIONS OF MEMORY ARE AVAILABLE TO THE
*      PROGRAM. EACH REGION CONSISTS OF A SERIES OF WORDS WITH
*      CONSECUTIVE ADDRESSES.
*
*      1)   CONSTANT SECTION           ASSEMBLED CONSTANTS
*      2)   WORKING STORAGE SECTION    ASSEMBLED WORK AREAS
*      3)   PROGRAM SECTION            ASSEMBLED INSTRUCTIONS
*      4)   STACK AREA                 ALLOCATED STACK AREA
*      5)   DATA AREA                  ALLOCATED DATA AREA
{{EJC{{{{{1376
*
*      SECTION 3 - REGISTERS
*
*      THERE ARE THREE INDEX REGISTERS CALLED XR,XL,XS. IN
*      ADDITION XL MAY SOMETIMES BE REFERRED TO BY THE ALIAS
*      OF XT - SEE SECTION 4. ANY OF THE ABOVE REGISTERS
*      MAY HOLD A POSITIVE UNSIGNED INTEGER IN THE RANGE
*      (0 LE N LE CFP$L). WHEN THE INDEX REGISTER IS USED FOR
*      INDEXING PURPOSES, THIS MUST BE AN APPROPRIATE ADDRESS.
*      XS IS SPECIAL IN THAT IT IS USED TO POINT TO THE TOP
*      ITEM OF A STACK IN MEMORY. THE STACK MAY BUILD UP OR
*      DOWN IN MEMORY.SINCE IT IS REQUIRED THAT XS POINTS TO THE
*      STACK TOP BUT ACCESS TO ITEMS BELOW THE TOP IS PERMITTED,
*      REGISTERS XS AND XT MAY BE USED WITH SUITABLE OFFSETS
*      TO INDEX STACKED ITEMS. ONLY XS AND XT MAY BE USED FOR
*      THIS PURPOSE SINCE THE DIRECTION OF THE OFFSET IS
*      TARGET MACHINE DEPENDENT. XT IS A SYNONYM FOR XL
*      WHICH THEREFORE CANNOT BE USED IN CODE SEQUENCES
*      REFERENCING XT.
*      THE STACK IS USED FOR S-R LINKAGE AND TEMPORARY
*      DATA STORAGE FOR WHICH THE STACK ARRANGEMENT IS SUITABLE.
*      XR,XL CAN ALSO CONTAIN A CHARACTER POINTER IN CONJUNCTION
*      WITH THE CHARACTER INSTRUCTIONS (SEE DESCRIPTION OF PLC).
{{EJC{{{{{1400
*
*      THERE ARE THREE WORK REGISTERS CALLED WA,WB,WC WHICH
*      CAN CONTAIN ANY DATA ITEM WHICH CAN BE STORED IN A
*      SINGLE MEMORY WORD. IN FACT, THE WORK REGISTERS ARE JUST
*      LIKE MEMORY LOCATIONS EXCEPT THAT THEY HAVE NO ADDRESSES
*      AND ARE REFERENCED IN A SPECIAL WAY BY THE INSTRUCTIONS.
*      NOTE THAT REGISTERS WA,WB HAVE SPECIAL USES IN CONNECTION
*      WITH THE CVD, CVM, MVC, MVW, MWB, CMC, TRC INSTRUCTIONS.
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE FOLLOWING RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*          RESTRICTION
*          -----------
*
*      IF IA AND WC OVERLAP THEN
*          STI  IASAV
*          LDI  IASAV
*      DOES NOT CHANGE WC, AND
*          MOV  WC,WCSAV
*          MOV  WCSAV,WC
*      DOES NOT CHANGE IA.
*
*
*
*      THERE IS AN INTEGER ACCUMULATOR (IA) WHICH IS CAPABLE OF
*      HOLDING A SIGNED INTEGER VALUE (CFP$I WORDS LONG).
*      REGISTER WC MAY OVERLAP THE INTEGER ACCUMULATOR (IA) IN
*      SOME IMPLEMENTATIONS. THUS ANY OPERATION CHANGING THE
*      VALUE IN WC LEAVES (IA) UNDEFINED AND VICE VERSA
*      EXCEPT AS NOTED IN THE ABOVE RESTRICTION ON SIMPLE
*      DUMP/RESTORE OPERATIONS.
*
*
*
*      THERE IS A SINGLE REAL ACCUMULATOR (RA) WHICH CAN HOLD
*      ANY REAL VALUE AND IS COMPLETELY SEPARATE FROM ANY OF
*      THE OTHER REGISTERS OR PROGRAM ACCESSIBLE LOCATIONS.
*
*
*
*      THE CODE POINTER REGISTER (CP) IS A SPECIAL INDEX
*      REGISTER FOR USE IN IMPLEMENTATIONS OF INTERPRETORS.
*      IT IS USED TO CONTAIN A PSEUDO-CODE POINTER AND CAN
*      ONLY BE AFFECTED BY ICP, LCP, SCP AND LCW INSTRUCTIONS.
{{EJC{{{{{1448
*      SECTION 4 - THE STACK
*
*      THE FOLLOWING NOTES ARE TO GUIDE BOTH IMPLEMENTORS OF
*      SYSTEMS WRITTEN IN MINIMAL AND MINIMAL PROGRAMMERS IN
*      DEALING WITH STACK MANIPULATION. IMPLEMENTATION OF A
*      DOWNWARDS BUILDING STACK IS EASIEST AND IN GENERAL IS
*      TO BE PREFERRED, IN WHICH CASE IT IS MERELY NECESSARY TO
*      CONSIDER XT AS AN ALTERNATIVE NAME FOR XL.
*
*      THE MINIMAL VIRTUAL MACHINE INCLUDES A STACK AND HAS
*      OPERAND FORMATS -(XS) AND (XS)+ FOR PUSHING AND POPPING
*      ITEMS WITH AN IMPLICATION THAT THE STACK BUILDS DOWN IN
*      MEMORY (A D-STACK). HOWEVER ON SOME TARGET MACHINES IT IS
*      BETTER FOR THE STACK TO BUILD UP (A U-STACK).
*      A STACK ADDRESSED ONLY BY PUSH AND POP OPERATIONS CAN
*      BUILD IN EITHER DIRECTION WITH NO COMPLICATION BUT
*      SUCH A PURE SCHEME OF STACK ACCESS PROVES RESTRICTIVE.
*      HENCE IT IS PERMITTED TO ACCESS BURIED ITEMS USING AN
*      INTEGER OFFSET PAST THE INDEX REGISTER POINTING TO THE
*      STACK TOP. ON TARGET MACHINES THIS OFFSET WILL BE
*      POSITIVE/NEGATIVE FOR D-STACKS/U-STACKS AND THIS MUST
*      BE ALLOWED FOR IN THE TRANSLATION.
*      A FURTHER RESTRICTION IS THAT AT NO TIME MAY AN ITEM BE
*      PLACED ABOVE THE STACK TOP. FOR SOME OPERATIONS THIS
*      MAKES IT CONVENIENT TO ADVANCE THE STACK POINTER AND THEN
*      ADDRESS ITEMS BELOW IT USING A SECOND INDEX REGISTER.
*      THE PROBLEM OF SIGNED OFFSETS PAST SUCH A REGISTER THEN
*      ARISES. TO DISTINGUISH STACK OFFSETS, WHICH IN SOME
*      IMPLEMENTATIONS MAY BE NEGATIVE, FROM NON-STACK OFFSETS
*      WHICH ARE INVARIABLY POSITIVE, XT, AN ALIAS OR
*      SYNONYM FOR XL IS USED. FOR A U-STACK IMPLEMENTATION, THE
*      MINIMAL TRANSLATOR SHOULD NEGATE THE SIGN OF OFFSETS
*      APPLIED TO BOTH (XS) AND (XT).
*      PROGRAMMERS SHOULD NOTE THAT SINCE XT IS NOT A
*      SEPARATE REGISTER, XL SHOULD NOT BE USED IN CODE WHERE
*      XT IS REFERENCED. OTHER MODIFICATIONS NEEDED IN U-STACK
*      TRANSLATIONS ARE IN THE ADD, SUB, ICA, DCA OPCODES
*      APPLIED TO XS, XT. FOR EXAMPLE
*
*      MINIMAL           D-STACK TRANS.  U-STACK TRANS.
*
*      MOV  WA,-(XS)     SBI  XS,1       ADI  XS,1
*                        STO  WA,(XS)    STO  WA,(XS)
*      MOV  (XT)+,WC     LOD  WC,(XL)    LOD  WC,(XL)
*                        ADI  XL,1       SBI  XL,1
*      ADD  =SEVEN,XS    ADI  XS,7       SBI  XS,7
*      MOV  2(XT),WA     LOD  WA,2(XL)   LOD  WA,-2(XL)
*      ICA  XS           ADI  XS,1       SBI  XS,1
*
*      NOTE THAT FORMS SUCH AS
*      MOV  -(XS),WA
*      ADD  WA,(XS)+
*      ARE ILLEGAL, SINCE THEY ASSUME INFORMATION STORAGE
*      ABOVE THE STACK TOP.
{{EJC{{{{{1503
*      SECTION 5 - INTERNAL CHARACTER SET
*
*      THE INTERNAL CHARACTER SET IS REPRESENTED BY A SET OF
*      CONTIGUOUS CODES FROM 0 TO CFP$A-1. THE CODES FOR THE
*      DIGITS 0-9 MUST BE CONTIGUOUS AND IN SEQUENCE. OTHER
*      THAN THIS, THERE ARE NO RESTRAINTS.
*
*      THE FOLLOWING SYMBOLS ARE AUTOMATICALLY DEFINED TO HAVE
*      THE VALUE OF THE CORRESPONDING INTERNAL CHARACTER CODE.
*
*      CH$LA                 LETTER A
*      CH$LB                 LETTER B
*      .                     .
*      CH$L$                 LETTER Z
*
*      CH$D0                 DIGIT 0
*      .                     .
*      CH$D9                 DIGIT 9
*
*      CH$AM                 AMPERSAND
*      CH$AS                 ASTERISK
*      CH$AT                 AT
*      CH$BB                 LEFT BRACKET
*      CH$BL                 BLANK
*      CH$BR                 VERTICAL BAR
*      CH$CL                 COLON
*      CH$CM                 COMMA
*      CH$DL                 DOLLAR SIGN
*      CH$DT                 DOT (PERIOD)
*      CH$DQ                 DOUBLE QUOTE
*      CH$EQ                 EQUAL SIGN
*      CH$EX                 EXCLAMATION MARK
*      CH$MN                 MINUS
*      CH$NM                 NUMBER SIGN
*      CH$NT                 NOT
*      CH$PC                 PERCENT
*      CH$PL                 PLUS
*      CH$PP                 LEFT PAREN
*      CH$RB                 RIGHT BRACKET
*      CH$RP                 RIGHT PAREN
*      CH$QU                 QUESTION MARK
*      CH$SL                 SLASH
*      CH$SM                 SEMI-COLON
*      CH$SQ                 SINGLE QUOTE
*      CH$UN                 UNDERLINE
*
*      THE FOLLOWING OPTIONAL SYMBOLS ARE INCORPORATED
*      BY DEFINING THE CONDITIONAL ASSEMBLY SYMBOL NAMED.
*
*      26 SHIFTED LETTERS INCORPORATED BY DEFINING .CASL
*
*      CH$$A                 SHIFTED A
*      CH$$B                 SHIFTED B
*      .                     .
*      CH$$$                 SHIFTED Z
*
*      CH$HT                 HORIZONTAL TAB - DEFINE .CAHT
*      CH$VT                 VERTICAL TAB   - DEFINE .CAVT
*      CH$EY                 UP ARROW       - DEFINE .CAEX
{{EJC{{{{{1563
*
*      SECTION 6 - CONDITIONAL ASSEMBLY FEATURES
*
*      SOME FEATURES OF THE INTERPRETER ARE APPLICABLE TO ONLY
*      CERTAIN TARGET MACHINES. THEY MAY BE INCORPORATED OR
*      OMITTED BY USE OF CONDITIONAL ASSEMBLY. THE FULL
*      FORM OF A CONDITION IS -
*      .IF    CONDITIONAL ASSEMBLY SYMBOL    (CAS)
*      .THEN
*             MINIMAL STATEMENTS1   (MS1)
*      .ELSE
*             MINIMAL STATEMENTS2   (MS2)
*      .FI
*      THE FOLLOWING RULES APPLY
*      1.   THE DIRECTIVES .IF, .THEN, .ELSE, .FI MUST
*           START IN COLUMN 1.
*      2.   THE CONDITIONAL ASSEMBLY SYMBOL MUST START WITH A
*           DOT IN COLUMN 8 FOLLOWED BY 4 LETTERS OR DIGITS E.G.
*              .CA$1
*      3.   .THEN IS REDUNDANT AND MAY BE OMITTED IF WISHED.
*      4.   MS1, MS2 ARE ARBITRARY SEQUENCES OF MINIMAL
*           STATEMENTS EITHER OF WHICH MAY BE NULL.
*      5.   IF MS2 IS OMITTED, .ELSE MAY ALSO BE OMITTED.
*      6.   .FI IS REQUIRED.
*      7.   CONDITIONS MAY BE NESTED TO A DEPTH DETERMINED
*           BY THE TRANSLATOR (NOT LESS THAN 20, SAY).
*
*      SELECTION OF THE ALTERNATIVES MS1, MS2 IS BY MEANS OF THE
*      DEFINE AND UNDEFINE DIRECTIVES OF FORM -
*      .DEF   CAS
*      .UNDEF CAS
*      WHICH OBEY RULES 1. AND 2. ABOVE AND MAY OCCUR AT ANY
*      POINT IN A MINIMAL PROGRAM, INCLUDING WITHIN A CONDITION.
*      MULTIPLY DEFINING A SYMBOL IS AN ERROR.
*      UNDEFINING A SYMBOL WHICH IS NOT DEFINED IS NOT AN ERROR.
*
*      THE EFFECT IS THAT IF A SYMBOL IS CURRENTLY DEFINED,
*      THEN IN ANY CONDITION DEPENDING ON IT, MS1 WILL BE
*      PROCESSED AND MS2 OMITTED. CONVERSELY IF IT IS UNDEFINED,
*      MS1 WILL BE OMITTED AND MS2 PROCESSED.
{{EJC{{{{{1604
*
*      SECTION 7 - OPERAND FORMATS
*
*      THE FOLLOWING SECTION DESCRIBES THE VARIOUS POSSIBILITIES
*      FOR OPERANDS OF INSTRUCTIONS AND ASSEMBLY OPERATIONS.
*
*      01   INT              UNSIGNED INTEGER LE CFP$L
*      02   DLBL             SYMBOL DEFINED IN DEFINITIONS SEC
*      03   WLBL             LABEL IN WORKING STORAGE SECTION
*      04   CLBL             LABEL IN CONSTANT SECTION
*      05   ELBL             PROGRAM SECTION ENTRY LABEL
*      06   PLBL             PROGRAM SECTION LABEL (NON-ENTRY)
*      07   X                ONE OF THE THREE INDEX REGISTERS
*      08   W                ONE OF THE THREE WORK REGISTERS
*      09   (X)              LOCATION INDEXED BY X
*      10   (X)+             LIKE (X) BUT POST INCREMENT X
*      11   -(X)             LIKE (X) BUT PREDECREMENT X
*      12   INT(X)           LOCATION INT WORDS BEYOND ADDR IN X
*      13   DLBL(X)          LOCATION DLBL WORDS PAST ADDR IN X
*      14   CLBL(X)          LOCATION (X) BYTES BEYOND CLBL
*      15   WLBL(X)          LOCATION (X) BYTES BEYOND WLBL
*      16   INTEGER          SIGNED INTEGER (DIC)
*      17   REAL             SIGNED REAL (DRC)
*      18   =DLBL            LOCATION CONTAINING DAC DLBL
*      19   *DLBL            LOCATION CONTAINING DAC CFP$B*DLBL
*      20   =WLBL            LOCATION CONTAINING DAC WLBL
*      21   =CLBL            LOCATION CONTAINING DAC CLBL
*      22   =ELBL            LOCATION CONTAINING DAC ELBL
*      23   PNAM             PROCEDURE LABEL (ON PRC INSTRUC)
*      24   EQOP             OPERAND FOR EQU INSTRUCTION
*      25   PTYP             PROCEDURE TYPE (SEE PRC)
*      26   TEXT             ARBITRARY TEXT (ERB,ERR,TTL)
*      27   DTEXT            DELIMITED TEXT STRING (DTC)
*
*      THE NUMBERS IN THE ABOVE LIST ARE USED IN SUBSEQUENT
*      DESCRIPTION AND IN SOME OF THE MINIMAL TRANSLATORS.
{{EJC{{{{{1641
*
*      OPERAND FORMATS (CONTINUED)
*
*      THE FOLLOWING SPECIAL SYMBOLS REFER TO A COLLECTION OF
*      THE LISTED POSSIBILITIES
*
*      VAL  01,02                      PREDEFINED VALUE
*
*           VAL IS USED TO REFER TO A PREDEFINED ONE WORD
*           INTEGER VALUE IN THE RANGE 0 LE N LE CFP$L.
*
*      REG  07,08                      REGISTER
*
*           REG IS USED TO DESCRIBE AN OPERAND WHICH CAN BE
*           ANY OF THE REGISTERS (XL,XR,XS,XT,WA,WB,WC). SUCH
*           AN OPERAND CAN HOLD A ONE WORD INTEGER (ADDRESS).
*
*      OPC  09,10,11                   CHARACTER
*
*           OPC IS USED TO DESIGNATE A SPECIFIC CHARACTER
*           OPERAND FOR USE IN THE LCH AND SCH INSTRUCTIONS.
*           THE INDEX REGISTER REFERENCED MUST BE EITHER XR OR
*           XL (NOT XS,XT). SEE SECTION ON CHARACTER OPERATIONS.
*
*      OPS  03,04,09,12,13,14,15       MEMORY REFERENCE
*
*           OPS IS USED TO DESCRIBE AN OPERAND WHICH IS IN
*           MEMORY. THE OPERAND MAY BE ONE OR MORE WORDS LONG
*           DEPENDING ON THE DATA TYPE. IN THE CASE OF MULTIWORD
*           OPERANDS, THE ADDRESS GIVEN IS THE FIRST WORD.
*
*      OPW  AS FOR OPS + 08,10,11      FULL WORD
*
*           OPW IS USED TO REFER TO AN OPERAND WHOSE CAPACITY IS
*           THAT OF A FULL MEMORY WORD. OPW INCLUDES ALL THE
*           POSSIBILITIES FOR OPS (THE REFERENCED WORD IS USED)
*           PLUS THE USE OF ONE OF THE THREE WORK REGISTERS
*           (WA,WB,WC). IN ADDITION, THE FORMATS (X)+ AND -(X)
*           ALLOW INDEXED OPERATIONS IN WHICH THE INDEX REGISTER
*           IS POPPED BY ONE WORD AFTER THE REFERENCE (X)+,
*           OR PUSHED BY ONE WORD BEFORE THE REFERENCE -(X)
*           THESE LATTER TWO FORMATS PROVIDE A FACILITY FOR
*           MANIPULATION OF STACKS. THE FORMAT DOES NOT IMPLY
*           A PARTICULAR DIRECTION IN WHICH STACKS MUST BUILD -
*           IT IS USED FOR COMPACTNESS. NOTE THAT THERE IS A
*           RESTRICTION WHICH DISALLOWS AN INSTRUCTION TO USE
*           AN INDEX REGISTER IN ONE OF THESE FORMATS
*           IN SOME OTHER MANNER IN THE SAME INSTRUCTION.
*           E.G.   MOV  XL,(XL)+   IS ILLEGAL.
*           THE FORMATS -(X) AND (X)+ MAY ALSO BE USED IN
*           PRE-DECREMENTATION, POST-INCREMENTATION TO ACCESS
*           THE ADJACENT CHARACTER OF A STRING.
{{EJC{{{{{1694
*
*      OPERAND FORMATS (CONTINUED)
*
*      OPN  AS FOR OPW + 07            ONE WORD INTEGER
*
*           OPN IS USED TO REPRESENT AN OPERAND LOCATION WHICH
*           CAN CONTAIN A ONE WORD INTEGER (E.G. AN ADDRESS).
*           THIS INCLUDES ALL THE POSSIBILITIES FOR OPW PLUS
*           THE USE OF ONE OF THE INDEX REGISTERS (XL,XR,XT,
*           XS). THE RANGE OF INTEGER VALUES IS 0 LE N LE CFP$L.
*
*      OPV  AS FOR OPN + 18-22         ONE WORD INTEGER VALUE
*
*           OPV IS USED FOR AN OPERAND WHICH CAN YIELD A ONE
*           WORD INTEGER VALUE (E.G. AN ADDRESS). IT INCLUDES
*           ALL THE POSSIBILITIES FOR OPN (THE CURRENT VALUE OF
*           THE LOCATION IS USED) PLUS THE USE OF LITERALS. NOTE
*           THAT ALTHOUGH THE LITERAL FORMATS ARE DESCRIBED IN
*           TERMS OF A REFERENCE TO A LOCATION CONTAINING AN
*           ADDRESS CONSTANT, THIS LOCATION MAY NOT ACTUALLY
*           EXIST IN SOME IMPLEMENTATIONS SINCE ONLY THE VALUE
*           IS REQUIRED. A RESTRICTION IS PLACED ON LITERALS
*           WHICH MAY CONSIST ONLY OF DEFINED SYMBOLS AND
*           CERTAIN LABELS. CONSEQUENTLY SMALL INTEGERS TO BE
*           USED AS LITERALS MUST BE PRE-DEFINED, A DISCIPLINE
*           AIDING PROGRAM MAINTENANCE AND REVISION.
*
*      ADDR 01,02,03,04,05             ADDRESS
*
*           ADDR IS USED TO DESCRIBE AN EXPLICIT ADDRESS VALUE
*           (ONE WORD INTEGER VALUE) FOR USE WITH DAC.
*
*
*           ****************************************************
*           *   IN THE FOLLOWING DESCRIPTIONS THE USAGE --     *
*           *      (XL),(XR), ... ,(IA)                        *
*           *   IN THE DESCRIPTIVE TEXT SIGNIFIES THE          +
*           *   CONTENTS OF THE STATED REGISTER.               *
*           ****************************************************
{{EJC{{{{{1734
*
*      SECTION 8 - LIST OF INSTRUCTION MNEMONICS
*
*      THE FOLLOWING LIST INCLUDES ALL INSTRUCTION AND
*      ASSEMBLY OPERATION MNEMONICS IN ALPHABETICAL ORDER.
*      THE MNEMONICS ARE PRECEDED BY A NUMBER IDENTIFYING
*      THE FOLLOWING SECTION WHERE THE INSTRUCTION IS DESCRIBED.
*      A STAR (*) IS APPENDED TO THE MNEMONIC IF THE LAST
*      OPERAND MAY OPTIONALLY BE OMITTED.
*      SEE SECTION -15- FOR DETAILS OF STATEMENT FORMAT AND
*      COMMENT CONVENTIONS.
*
*       2.1  ADD  OPV,OPN      ADD ADDRESS
*       4.2  ADI  OPS          ADD INTEGER
*       5.3  ADR  OPS          ADD REAL
*       7.1  ANB  OPW,W        AND BIT STRING
*       2.17 AOV  OPV,OPN,PLBL ADD ADDRESS, FAIL IF OVERFLOW
*       5.16 ATN               ARCTANGENT OF REAL ACCUM
*       2.16 BCT  W,PLBL       BRANCH AND COUNT
*       2.5  BEQ  OPN,OPV,PLBL BRANCH IF ADDRESS EQUAL
*       2.18 BEV  OPN,PLBL     BRANCH IF ADDRESS EVEN
*       2.8  BGE  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER OR EQUL
*       2.7  BGT  OPN,OPV,PLBL BRANCH IF ADDRESS GREATER
*       2.12 BHI  OPN,OPV,PLBL BRANCH IF ADDRESS HIGH
*       2.10 BLE  OPN,OPV,PLBL BRANCH IF ADDRESS LESS OR EQUAL
*       2.11 BLO  OPN,OPV,PLBL BRANCH IF ADDRESS LOW
*       2.9  BLT  OPN,OPV,PLBL BRANCH IF ADDRESS LESS THAN
*       2.6  BNE  OPN,OPV,PLBL BRANCH IF ADDRESS NOT EQUAL
*       2.13 BNZ  OPN,PLBL     BRANCH IF ADDRESS NON-ZERO
*       2.19 BOD  OPN,PLBL     BRANCH IF ADDRESS ODD
*       1.2  BRN  PLBL         BRANCH UNCONDITIONAL
*       1.7  BRI  OPN          BRANCH INDIRECT
*       1.3  BSW* X,VAL,PLBL   BRANCH ON SWITCH VALUE
*       8.2  BTW  REG          CONVERT BYTES TO WORDS
*       2.14 BZE  OPN,PLBL     BRANCH IF ADDRESS ZERO
*       6.6  CEQ  OPW,OPW,PLBL BRANCH IF CHARACTERS EQUAL
*      10.1  CHK               CHECK STACK OVERFLOW
*       5.17 CHP               INTEGER PORTION OF REAL ACCUM
*       7.4  CMB  W            COMPLEMENT BIT STRING
*       6.8  CMC  PLBL,PLBL    COMPARE CHARACTER STRINGS
*       6.7  CNE  OPW,OPW,PLBL BRANCH IF CHARACTERS NOT EQUAL
*       6.5  CSC  X            COMPLETE STORE CHARACTERS
*       5.18 COS               COSINE OF REAL ACCUM
*       8.8  CTB  W,VAL        CONVERT CHARACTER COUNT TO BYTES
*       8.7  CTW  W,VAL        CONVERT CHARACTER COUNT TO WORDS
*       8.10 CVD               CONVERT BY DIVISION
*       8.9  CVM  PLBL         CONVERT BY MULTIPLICATION
*      11.1  DAC  ADDR         DEFINE ADDRESS CONSTANT
*      11.5  DBC  VAL          DEFINE BIT STRING CONSTANT
*       2.4  DCA  OPN          DECREMENT ADDRESS BY ONE WORD
*       1.17 DCV  OPN          DECREMENT VALUE BY ONE
*      11.2  DIC  INTEGER      DEFINE INTEGER CONSTANT
{{EJC{{{{{1787
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*      11.3  DRC  REAL         DEFINE REAL CONSTANT
*      11.4  DTC  DTEXT        DEFINE TEXT (CHARACTER) CONSTANT
*       4.5  DVI  OPS          DIVIDE INTEGER
*       5.6  DVR  OPS          DIVIDE REAL
*      13.1  EJC               EJECT ASSEMBLY LISTING
*      14.2  END               END OF ASSEMBLY
*       1.13 ENP               DEFINE END OF PROCEDURE
*       1.6  ENT* VAL          DEFINE ENTRY POINT
*      12.1  EQU  EQOP         DEFINE SYMBOLIC VALUE
*       1.15 ERB  INT,TEXT     ASSEMBLE ERROR CODE AND BRANCH
*       1.14 ERR  INT,TEXT     ASSEMBLE ERROR CODE
*       1.5  ESW               END OF SWITCH LIST FOR BSW
*       5.19 ETX               E TO THE POWER IN THE REAL ACCUM
*       1.12 EXI* INT          EXIT FROM PROCEDURE
*      12.2  EXP               DEFINE EXTERNAL PROCEDURE
*       6.10 FLC  W            FOLD CHARACTER TO UPPER CASE
*       2.3  ICA  OPN          INCREMENT ADDRESS BY ONE WORD
*       3.4  ICP               INCREMENT CODE POINTER
*       1.16 ICV  OPN          INCREMENT VALUE BY ONE
*       4.11 IEQ  PLBL         JUMP IF INTEGER ZERO
*       1.4  IFF  VAL,PLBL     SPECIFY BRANCH FOR BSW
*       4.12 IGE  PLBL         JUMP IF INTEGER NON-NEGATIVE
*       4.13 IGT  PLBL         JUMP IF INTEGER POSITIVE
*       4.14 ILE  PLBL         JUMP IF INTEGER NEGATIVE OR ZERO
*       4.15 ILT  PLBL         JUMP IF INTEGER NEGATIVE
*       4.16 INE  PLBL         JUMP IF INTEGER NON-ZERO
*       4.9  INO  PLBL         JUMP IF NO INTEGER OVERFLOW
*      12.3  INP  PTYP,INT     INTERNAL PROCEDURE
*      12.4  INR               INTERNAL ROUTINE
*       4.10 IOV  PLBL         JUMP IF INTEGER OVERFLOW
*       8.5  ITR               CONVERT INTEGER TO REAL
*       1.9  JSR  PNAM         CALL PROCEDURE
*       6.3  LCH  REG,OPC      LOAD CHARACTER
*       2.15 LCT  W,OPV        LOAD COUNTER FOR LOOP
*       3.1  LCP  REG          LOAD CODE POINTER REGISTER
*       3.3  LCW  REG          LOAD NEXT CODE WORD
*       4.1  LDI  OPS          LOAD INTEGER
*       5.1  LDR  OPS          LOAD REAL
*       1.8  LEI  X            LOAD ENTRY POINT ID
*       5.20 LNF               NATURAL LOGORITHM OF REAL ACCUM
*       7.6  LSH  W,VAL        LEFT SHIFT BIT STRING
*       7.8  LSX  W,(X)        LEFT SHIFT INDEXED
*       8.4  MFI* OPN,PLBL     CONVERT (IA) TO ADDRESS VALUE
*       4.3  MLI  OPS          MULTIPLY INTEGER
*       5.5  MLR  OPS          MULTIPLY REAL
*       1.19 MNZ  OPN          MOVE NON-ZERO
*       1.1  MOV  OPV,OPN      MOVE
*       8.3  MTI  OPN          MOVE ADDRESS VALUE TO (IA)
*       9.1  MVC               MOVE CHARACTERS
*       9.2  MVW               MOVE WORDS
*       9.3  MWB               MOVE WORDS BACKWARDS
*       9.4  MCB               MOVE CHARACTERSWORDS BACKWARDS
*       4.8  NGI               NEGATE INTEGER
{{EJC{{{{{1844
*
*      ALPHABETICAL LIST OF MNEMONICS (CONTINUED)
*
*       5.9  NGR               NEGATE REAL
*       7.9  NZB  W,PLBL       JUMP IF NOT ALL ZERO BITS
*       7.2  ORB  OPW,W        OR BIT STRINGS
*       6.1  PLC* X,OPV        PREPARE TO LOAD CHARACTERS
*       1.10 PPM* PLBL         PROVIDE PROCEDURE EXIT PARAMETER
*       1.11 PRC  PTYP,VAL     DEFINE START OF PROCEDURE
*       6.2  PSC* X,OPV        PREPARE TO STORE CHARACTERS
*       5.10 REQ  PLBL         JUMP IF REAL ZERO
*       5.11 RGE  PLBL         JUMP IF REAL POSITIVE OR ZERO
*       5.12 RGT  PLBL         JUMP IF REAL POSITIVE
*       5.13 RLE  PLBL         JUMP IF REAL NEGATIVE OR ZERO
*       5.14 RLT  PLBL         JUMP IF REAL NEGATIVE
*       4.6  RMI  OPS          REMAINDER INTEGER
*       5.15 RNE  PLBL         JUMP IF REAL NON-ZERO
*       5.8  RNO  PLBL         JUMP IF NO REAL OVERFLOW
*       5.7  ROV  PLBL         JUMP IF REAL OVERFLOW
*       7.5  RSH  W,VAL        RIGHT SHIFT BIT STRING
*       7.7  RSX  W,(X)        RIGHT SHIFT INDEXED
*       8.6  RTI* PLBL         CONVERT REAL TO INTEGER
*       1.22 RTN               DEFINE START OF ROUTINE
*       4.4  SBI  OPS          SUBTRACT INTEGER
*       5.4  SBR  OPS          SUBTRACT REALS
*       6.4  SCH  REG,OPC      STORE CHARACTER
*       3.2  SCP  REG          STORE CODE POINTER
*      14.1  SEC               DEFINE START OF ASSEMBLY SECTION
*       5.21 SIN               SINE OF REAL ACCUM
*       5.22 SQR               SQUARE ROOT OF REAL ACCUM
*       1.20 SSL  OPW          SUBROUTINE STACK LOAD
*       1.21 SSS  OPW          SUBROUTINE STACK STORE
*       4.7  STI  OPS          STORE INTEGER
*       5.2  STR  OPS          STORE REAL
*       2.2  SUB  OPV,OPN      SUBTRACT ADDRESS
*       5.23 TAN               TANGENT OF REAL ACCUM
*       6.9  TRC               TRANSLATE CHARACTER STRING
*      13.2  TTL  TEXT         SUPPLY ASSEMBLY TITLE
*       8.1  WTB  REG          CONVERT WORDS TO BYTES
*       7.3  XOB  OPW,W        EXCLUSIVE OR BIT STRINGS
*       1.18 ZER  OPN          ZEROISE INTEGER LOCATION
*       7.11 ZGB  OPN          ZEROISE GARBAGE BITS
*       7.10 ZRB  W,PLBL       JUMP IF ALL ZERO BITS
{{EJC{{{{{1888
*
*      SECTION 9 - MINIMAL INSTRUCTIONS
*
*      THE FOLLOWING DESCRIPTIONS ASSUME THE DEFINITIONS -
*
*      ZEROE  EQU  0
*      UNITY  EQU  1
*
*      -1-  BASIC INSTRUCTION SET
*
*      1.1  MOV  OPV,OPN     MOVE ONE WORD VALUE
*
*           MOV CAUSES THE VALUE OF OPERAND OPV TO BE SET AS
*           THE NEW CONTENTS OF OPERAND LOCATION OPN. IN THE
*           CASE WHERE OPN IS NOT AN INDEX REGISTER, ANY VALUE
*           WHICH CAN NORMALLY OCCUPY A MEMORY WORD (INCLUDING
*           A PART OF A MULTIWORD REAL OR INTEGER VALUE)
*           CAN BE TRANSFERRED USING MOV. IF THE TARGET LOCATION
*           OPN IS AN INDEX REGISTER, THEN OPV MUST SPECIFY AN
*           APPROPRIATE ONE WORD VALUE OR OPERAND CONTAINING
*           SUCH AN APPROPRIATE VALUE.
*
*      1.2  BRN  PLBL        UNCONDITIONAL BRANCH
*
*           BRN CAUSES CONTROL TO BE PASSED TO THE INDICATED
*           LABEL IN THE PROGRAM SECTION.
*
*      1.3  BSW  X,VAL,PLBL  BRANCH ON SWITCH VALUE
*      1.4  IFF  VAL,PLBL    PROVIDE BRANCH FOR SWITCH
*           IFF  VAL,PLBL     ...
*           ...
*           ...
*      1.5  ESW              END OF BRANCH SWITCH TABLE
*
*           BSW,IFF,ESW PROVIDE A CAPABILITY FOR A SWITCHED
*           BRANCH SIMILAR TO A FORTRAN COMPUTED GOTO. THE
*           VAL ON THE BSW INSTRUCTION IS THE MAXIMUM NUMBER
*           OF BRANCHES. THE VALUE IN X RANGES FROM ZERO UP TO
*           BUT NOT INCLUDING THIS MAXIMUM. EACH IFF PROVIDES A
*           BRANCH. VAL MUST BE LESS THAN THAT GIVEN ON THE BSW
*           AND CONTROL GOES TO PLBL IF THE VALUE IN X MATCHES.
*           IF THE VALUE IN X DOES NOT CORRESPOND TO ANY OF THE
*           IFF ENTRIES, THEN CONTROL PASSES TO THE PLBL ON THE
*           BSW. THIS PLBL OPERAND MAY BE OMITTED IF THERE ARE
*           NO VALUES MISSING FROM THE LIST.
*
*           IFF AND ESW MAY ONLY BE USED IN THIS CONTEXT.
*           EXECUTION OF BSW MAY DESTROY THE CONTENTS OF X.
*           THE IFF ENTRIES MAY BE IN ANY ORDER AND SINCE
*           A TRANSLATOR MAY THUS NEED TO STORE AND SORT THEM,
*           THE COMMENT FIELD IS RESTRICTED IN LENGTH (SEC 11).
{{EJC{{{{{1940
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.6  ENT  VAL         DEFINE PROGRAM ENTRY POINT
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE A PROGRAM ENTRY POINT WHICH CAN SUBSEQUENTLY
*           BE USED IN CONJUNCTION WITH THE BRI INSTRUCTION,
*           WHICH PROVIDES THE ONLY MEANS OF ENTERING THE
*           CODE. IT IS ILLEGAL TO FALL INTO CODE
*           IDENTIFIED BY AN ENTRY POINT. THE
*           ENTRY SYMBOL IS ASSIGNED AN ADDRESS WHICH NEED NOT
*           BE A MULTIPLE OF CFP$B BUT WHICH MUST BE IN THE
*           RANGE 0 LE CFP$L AND THE ADDRESS MUST NOT LIE WITHIN
*           THE ADDRESS RANGE OF THE ALLOCATED DATA AREA.
*           FURTHERMORE, ADDRESSES OF SUCCESSIVE ENTRY POINTS
*           MUST BE ASSIGNED IN SOME ASCENDING SEQUENCE SO
*           THAT THE ADDRESS COMPARISON INSTRUCTIONS CAN BE
*           USED TO TEST THE ORDER IN WHICH TWO ENTRY POINTS
*           OCCUR. THE SYMBOL VAL GIVES AN IDENTIFYING VALUE
*           TO THE ENTRY POINT WHICH CAN BE ACCESSED WITH THE
*           LEI INSTRUCTION.
*           NOTE - SUBJECT TO THE RESTRICTION BELOW, VAL MAY
*           BE OMITTED IF NO SUCH IDENTIFICATION IS NEEDED I.E.
*           IF NO LEI REFERENCES THE ENTRY POINT. FOR THIS
*           CASE, A TRANSLATION OPTIMISATION IS POSSIBLE IN
*           WHICH NO MEMORY NEED BE RESERVED FOR A NULL
*           IDENTIFICATION WHICH IS NEVER TO BE REFERENCED, BUT
*           ONLY PROVIDED THIS IS DONE SO AS NOT TO INTERFERE
*           WITH THE STRICTLY ASCENDING SEQUENCE OF ENTRY POINT
*           ADDRESSES. TO SIMPLIFY THIS OPTIMISATION FOR ALL
*           IMPLEMENTORS, THE FOLLOWING RESTRICTION IS OBSERVED
*                VAL MAY ONLY BE OMITTED IF THE ENTRY POINT IS
*                SEPARATED FROM A FOLLOWING ENTRY POINT BY A
*                NON-NULL MINIMAL CODE SEQUENCE.
*           ENTRY POINT ADDRESSES ARE ACCESSIBLE ONLY BY USE OF
*           LITERALS (=ELBL, SECTION 7) OR DAC CONSTANTS
*           (SECTION 8-11.1).
*
*      1.7  BRI  OPN         BRANCH INDIRECT
*
*           OPN CONTAINS THE ADDRESS OF A PROGRAM ENTRY POINT
*           (SEE ENT). CONTROL IS PASSED TO THE EXECUTABLE
*           CODE STARTING AT THE ENTRY POINT ADDRESS. OPN IS
*           LEFT UNCHANGED.
*
*      1.8  LEI  X           LOAD ENTRY POINT IDENTIFICATION
*
*           X CONTAINS THE ADDRESS OF AN ENTRY POINT FOR WHICH
*           AN IDENTIFYING VALUE WAS GIVEN ON THE THE ENT LINE.
*           LEI REPLACES THE CONTENTS OF X BY THIS VALUE.
{{EJC{{{{{1992
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.9  JSR  PNAM        CALL PROCEDURE PNAM
*      1.10 PPM  PLBL        PROVIDE EXIT PARAMETER
*           PPM  PLBL         ...
*           ...
*           PPM  PLBL         ...
*
*           JSR CAUSES CONTROL TO BE PASSED TO THE NAMED
*           PROCEDURE. PNAM IS THE LABEL ON A PRC STATEMENT
*           ELSEWHERE IN THE PROGRAM SECTION (SEE PRC)
*           OR HAS BEEN DEFINED USING AN EXP INSTRUCTION.
*           THE PPM EXIT PARAMETERS FOLLOWING THE CALL GIVE
*           NAMES OF PROGRAM LOCATIONS (PLBL-S) TO WHICH
*           ALTERNATIVE EXI RETURNS OF THE CALLED PROCEDURE MAY
*           PASS CONTROL. THEY MAY OPTIONALLY BE REPLACED BY
*           ERROR RETURNS (SEE ERR). THE NUMBER OF EXIT
*           PARAMETERS FOLLOWING A JSR MUST EQUAL THE INT IN THE
*           PROCEDURE DEFINITION. THE OPERAND OF PPM MAY BE
*           OMITTED IF THE CORRESPONDING EXI RETURN IS CERTAIN
*           NOT TO BE TAKEN.
*
*      1.11 PRC  PTYP,INT    DEFINE START OF PROCEDURE
*
*           THE SYMBOL APPEARING IN THE LABEL FIELD IS DEFINED
*           TO BE THE NAME OF A PROCEDURE FOR USE WITH JSR.
*           A PROCEDURE IS A CONTIGUOUS SECTION OF INSTRUCTIONS
*           TO WHICH CONTROL MAY BE PASSED WITH A JSR
*           INSTRUCTION. THIS IS THE ONLY WAY IN WHICH THE
*           INSTRUCTIONS IN A PROCEDURE MAY BE EXECUTED. IT IS
*           NOT PERMITTED TO FALL INTO A PROCEDURE.
*           ALL PROCEDURES SHOULD BE NAMED IN SECTION 0
*           INP  STATEMENTS.
*
*           INT IS THE NUMBER OF EXIT PARAMETERS (PPM-S) TO
*           BE USED IN JSR CALLS.
*
*           THERE ARE THREE POSSIBILITIES FOR PTYP, EACH
*           CONSISTING OF A SINGLE LETTER AS FOLLOWS.
*
*           R                RECURSIVE
*
*           THE RETURN POINT (ONE OR MORE WORDS) IS STORED ON
*           THE STACK AS THOUGH ONE OR MORE MOV ...,-(XS)
*           INSTRUCTIONS WERE EXECUTED.
{{EJC{{{{{2039
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*           N                NON-RECURSIVE
*
*           THE RETURN POINT IS TO BE STORED EITHER
*           (1) IN A LOCAL STORAGE WORD ASSOCIATED
*           WITH THE PROCEDURE AND NOT DIRECTLY
*           AVAILABLE TO THE PROGRAM IN ANY OTHER MANNER OR
*           (2) ON A SUBROUTINE LINK STACK QUITE DISTINCT FROM
*           THE MINIMAL STACK ADDRESSED BY XS.
*           IT IS AN ERROR TO USE THE STACK FOR N-LINKS, SINCE
*           PROCEDURE PARAMETERS OR RESULTS MAY BE PASSED VIA
*           THE STACK.
*           IF METHOD (2) IS USED FOR LINKS, ERROR EXITS
*           (ERB,ERR) FROM A PROCEDURE WILL NECESSITATE LINK
*           STACK RESETTING. THE SSL AND SSS ORDERS PROVIDED
*           FOR THIS MAY BE REGARDED AS NO-OPS FOR
*           IMPLEMENTATIONS USING METHOD (1).
*
*           E                EITHER
*
*           THE RETURN POINT MAY BE STORED IN EITHER MANNER
*           ACCORDING TO EFFICIENCY REQUIREMENTS OF THE ACTUAL
*           PHYSICAL MACHINE USED FOR THE IMPLEMENTATION. NOTE
*           THAT PROGRAMMING OF E TYPE PROCEDURES MUST BE
*           INDEPENDENT OF THE ACTUAL IMPLEMENTATION.
*
*           THE ACTUAL FORM OF THE RETURN POINT IS UNDEFINED.
*           HOWEVER, EACH WORD STORED ON THE STACK FOR AN
*           R-TYPE CALL MUST MEET THE FOLLOWING REQUIREMENTS.
*
*           1)               IT CAN BE HANDLED AS AN ADDRESS
*                            AND PLACED IN AN INDEX REGISTER.
*
*           2)               WHEN USED AS AN OPERAND IN AN
*                            ADDRESS COMPARISON INSTRUCTION, IT
*                            MUST NOT APPEAR TO LIE WITHIN
*                            THE ALLOCATED DATA AREA.
*
*           3)               IT IS NOT REQUIRED TO APPEAR
*                            TO LIE WITHIN THE PROGRAM SECTION.
{{EJC{{{{{2082
*
*      -1-  BASIC INSTRUCTIONS (CONTINUED)
*
*      1.12 EXI  INT         EXIT FROM PROCEDURE
*
*           THE PPM AND ERR PARAMETERS FOLLOWING A JSR ARE
*           NUMBERED STARTING FROM 1.  EXI  INT CAUSES CONTROL
*           TO BE RETURNED TO THE INT-TH SUCH PARAM. EXI 1 GIVES
*           CONTROL TO THE PLBL OF THE FIRST PPM AFTER THE JSR.
*           IF INT IS OMITTED, CONTROL IS PASSED BACK PAST THE
*           LAST EXIT PARAMETER (OR PAST THE JSR IF THERE ARE
*           NONE). FOR R AND E TYPE PROCEDURES, THE
*           STACK POINTER XS MUST BE SET TO ITS APPROPRIATE
*           ENTRY VALUE BEFORE EXECUTING AN EXI INSTRUCTION.
*           IN THIS CASE, EXI REMOVES RETURN POINTS FROM THE
*           STACK IF ANY ARE STORED THERE SO THAT THE STACK
*           POINTER IS RESTORED TO ITS CALLING VALUE.
*
*      1.13 ENP              DEFINE END OF PROCEDURE BODY
*
*           ENP DELIMITS A PROCEDURE BODY AND MAY NOT ACTUALLY
*           BE EXECUTED, HENCE IT MUST HAVE NO LABEL.
*
*      1.14 ERR  INT,TEXT    PROVIDE ERROR RETURN
*
*           ERR MAY REPLACE AN EXIT PARAMETER (PPM) IN
*           ANY PROCEDURE CALL. THE INT ARGUMENT IS A UNIQUE
*           ERROR CODE IN 0 TO 899.
*           THE TEXT SUPPLIED AS THE OTHER OPERAND IS
*           ARBITRARY TEXT IN THE FORTRAN CHARACTER SET AND
*           MAY BE USED IN CONSTRUCTING A FILE OF ERROR
*           MESSAGES FOR DOCUMENTING PURPOSES OR FOR BUILDING
*           A DIRECT ACCESS OR OTHER FILE OF MESSAGES TO BE
*           USED BY THE ERROR HANDLING CODE.
*           IN THE EVENT THAT AN EXI ATTEMPTS
*           TO RETURN CONTROL VIA AN EXIT PARAMETER TO
*           AN ERR, CONTROL IS INSTEAD PASSED TO THE FIRST
*           INSTRUCTION IN THE ERROR SECTION (WHICH FOLLOWS THE
*           PROGRAM SECTION) WITH THE ERROR CODE IN WA.
*
*      1.15 ERB  INT,TEXT    ERROR BRANCH
*
*           THIS INSTRUCTION RESEMBLES ERR EXCEPT THAT IT MAY
*           OCCUR AT ANY POINT WHERE A BRANCH IS PERMITTED.
*           IT EFFECTS A TRANSFER OF CONTROL TO THE ERROR
*           SECTION WITH THE ERROR CODE IN WA.
*
*      1.16 ICV  OPN         INCREMENT VALUE BY ONE
*
*           ICV INCREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   ADD  =UNITY,OPN
*
*      1.17 DCV  OPN         DECREMENT VALUE BY ONE
*
*           DCV DECREMENTS THE VALUE OF THE OPERAND BY UNITY.
*           IT IS EQUIVALENT TO   SUB  =UNITY,OPN
{{EJC{{{{{2139
*
*      BASIC INSTRUCTIONS (CONTINUED)
*
*      1.18 ZER  OPN         ZEROISE OPN
*
*           ZER IS EQUIVALENT TO  MOV  =ZEROE,OPN
*
*      1.19 MNZ  OPN         MOVE NON-ZERO TO OPN
*
*           ANY NON-ZERO COLLECTABLE VALUE MAY USED, FOR WHICH
*           THE OPCODES BNZ/BZE WILL BRANCH/FAIL TO BRANCH.
*
*      1.20 SSL  OPW         SUBROUTINE STACK LOAD
*
*      1.21 SSS  OPW         SUBROUTINE STACK STORE
*
*           THIS PAIR OF OPERATIONS IS PROVIDED TO MAKE POSSIBLE
*           THE USE OF A LOCAL STACK TO HOLD SUBROUTINE (S-R)
*           RETURN LINKS FOR N-TYPE PROCEDURES. SSS STORES THE
*           S-R STACK POINTER IN OPW AND SSL LOADS THE S-R
*           STACK POINTER FROM OPW. BY USING SSS IN THE MAIN
*           PROGRAM OR ON ENTRY TO A PROCEDURE WHICH SHOULD
*           REGAIN CONTROL ON OCCURRENCE OF AN ERR OR ERB AND BY
*           USE OF SSL IN THE ERROR PROCESSING SECTIONS THE
*           S-R STACK POINTER CAN BE RESTORED GIVING A LINK
*           STACK CLEANED UP READY FOR RESUMED EXECUTION.
*           THE FORM OF THE LINK STACK POINTER IS UNDEFINED IN
*           MINIMAL (IT IS LIKELY TO BE A PRIVATE REGISTER
*           KNOWN TO THE TRANSLATOR) AND THE ONLY REQUIREMENT
*           IS THAT IT SHOULD FIT INTO A SINGLE FULL WORD.
*           SSL AND SSS ARE NO-OPS IF A PRIVATE LINK STACK IS
*           NOT USED.
*
*      1.22 RTN              DEFINE START OF ROUTINE
*
*           A ROUTINE IS A CODE CHUNK USED FOR SIMILAR PURPOSES
*           TO A PROCEDURE. HOWEVER IT IS ENTERED BY ANY TYPE OF
*           CONDITIONAL OR UNCONDITIONAL BRANCH (NOT BY JSR). ON
*           TERMINATION IT PASSES CONTROL BY A BRANCH (OFTEN
*           BRI THROUGH A CODE WORD) OR EVEN PERMITS CONTROL
*           TO DROP THROUGH TO ANOTHER ROUTINE. NO RETURN LINK
*           EXISTS AND THE END OF A ROUTINE IS NOT MARKED BY
*           AN EXPLICIT OPCODE (COMPARE ENP).
*           ALL ROUTINES SHOULD BE NAMED IN SECTION 0
*           INR  STATEMENTS.
{{EJC{{{{{2185
*
*      -2-  OPERATIONS ON ONE WORD INTEGER VALUES (ADDRESSES)
*
*      2.1  ADD  OPV,OPN     ADDS OPV TO THE VALUE IN OPN AND
*                            STORES THE RESULT IN OPN. UNDEFINED
*                            IF THE RESULT EXCEEDS CFP$L.
*
*      2.2  SUB  OPV,OPN     SUBTRACTS OPV FROM OPN. STORES THE
*                            RESULT IN OPN. UNDEFINED IF THE
*                            RESULT IS NEGATIVE.
*
*      2.3  ICA  OPN         INCREMENT ADDRESS IN OPN
*                            EQUIVALENT TO ADD *UNITY,OPN
*
*      2.4  DCA  OPN         DECREMENT ADDRESS IN OPN
*                            EQUIVALENT TO SUB *UNITY,OPN
*
*      2.5  BEQ  OPN,OPV,PLBL BRANCH TO PLBL IF OPN EQ OPV
*      2.6  BNE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN NE OPV
*      2.7  BGT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GT OPV
*      2.8  BGE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN GE OPV
*      2.9  BLT  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LT OPV
*      2.10 BLE  OPN,OPV,PLBL BRANCH TO PLBL IF OPN LE OPV
*      2.11 BLO  OPN,OPV,PLBL EQUIVALENT TO BLT OR BLE
*      2.12 BHI  OPN,OPV,PLBL EQUIVALENT TO BGT OR BGE
*
*           THE ABOVE INSTRUCTIONS COMPARE TWO ADDRESS
*           VALUES AS UNSIGNED INTEGER VALUES.
*           THE BLO AND BHI INSTRUCTIONS ARE USED IN CASES WHERE
*           THE EQUAL CONDITION EITHER DOES NOT OCCUR OR CAN
*           RESULT EITHER IN A BRANCH OR NO BRANCH. THIS AVOIDS
*           INEFFICIENT TRANSLATIONS IN SOME IMPLEMENTATIONS.
*
*      2.13 BNZ  OPN,PLBL    EQUIVALENT TO BNE OPN,=ZEROE,PLBL
*
*      2.14 BZE  OPN,PLBL    EQUIVALENT TO BEQ OPN,=ZEROE,PLBL
*
*
*      2.15 LCT  W,OPV       LOAD COUNTER FOR BCT
*
*           LCT LOADS A COUNTER VALUE FOR USE WITH THE BCT
*           INSTRUCTION. THE VALUE IN OPV IS THE NUMBER OF LOOPS
*           TO BE EXECUTED. THE VALUE IN W AFTER THIS OPERATION
*           IS AN UNDEFINED ONE WORD INTEGER QUANTITY.
*
*      2.16 BCT  W,PLBL      BRANCH AND COUNT
*
*           BCT USES THE COUNTER VALUE IN W TO BRANCH THE
*           REQUIRED NUMBER OF TIMES AND THEN FINALLY TO FALL
*           THROUGH TO THE NEXT INSTRUCTION. BCT CAN ONLY BE
*           USED FOLLOWING AN APPROPRIATE LCT INSTRUCTION.
*           THE VALUE IN W AFTER EXECUTION OF BCT IS UNDEFINED.
*
*      2.17 AOV  OPV,OPN,PLBL ADD WITH CARRY TEST
*
*           ADDS OPV TO THE VALUE IN OPN AND STORES RESULT IN
*           OPN. BRANCHES TO PLBL IF RESULT EXCEEDS CFP$L
*           WITH RESULT IN OPN UNDEFINED. CF. ADD.
*
*      2.18 BEV  OPN,PLBL     BRANCH IF EVEN
*      2.19 BOD  OPN,PLBL     BRANCH IF ODD
*
*           THESE OPERATIONS ARE USED ONLY IF .CEPP OR .CRPP IS
*           DEFINED.  ON SOME IMPLEMENTATIONS, A MORE EFFICIENT
*           IMPLEMENTATION IS POSSIBLE BY NOTING THAT ADDRESS OF
*           BLOCKS MUST ALWAYS BE A MULTIPLE OF CFP$B. WE CALL
*           SUCH ADDRESSES EVEN.  THUS RETURN ADDRESS ON THE
*           STACK (.CRPP) AND ENTRY POINT ADDRESSES (.CEPP) CAN
*           BE DISTINGUISHED FROM BLOCK ADDRESSES IF THEY ARE
*           FORCED TO BE ODD (NOT A MULTIPLE OF CFP$B).
*           BEV AND BOD BRANCH ACCORDING AS OPERAND IS EVEN
*           OR ODD, RESPECTIVELY.
{{EJC{{{{{2258
*
*      -3-  OPERATIONS ON THE CODE POINTER REGISTER (CP)
*
*           THE CODE POINTER REGISTER PROVIDES A PSUEDO
*           INSTRUCTION COUNTER FOR USE IN AN INTERPRETOR. IT
*           MAY BE IMPLEMENTED AS A REAL REGISTER OR AS A
*           MEMORY LOCATION, BUT IN EITHER CASE IT IS SEPARATE
*           FROM ANY OTHER REGISTER. THE VALUE IN THE CODE
*           POINTER REGISTER IS ALWAYS A WORD ADDRESS (I.E.
*           A ONE WORD INTEGER WHICH IS A MULTIPLE OF CFP$B).
*
*      3.1  LCP  REG         LOAD CODE POINTER REGISTER
*                            THIS INSTRUCTION CAUSES THE CODE
*                            POINTER REGISTER TO BE SET FROM
*                            THE VALUE IN REG WHICH IS UNCHANGED
*
*      3.2  SCP  REG         STORE CODE POINTER REGISTER
*                            THIS INSTRUCTION LOADS THE CURRENT
*                            VALUE IN THE CODE POINTER REGISTER
*                            INTO REG. (CP) IS UNCHANGED.
*
*      3.3  LCW  REG         LOAD NEXT CODE WORD
*                            THIS INSTRUCTION CAUSES THE WORD
*                            POINTED TO BY CP TO BE LOADED INTO
*                            THE INDICATED REG. THE VALUE IN CP
*                            IS THEN INCREMENTED BY ONE WORD.
*                            EXECUTION OF LCW MAY DESTROY XL.
*
*      3.4  ICP              INCREMENT CP BY ONE WORD
*
*           ON MACHINES WITH MORE THAN THREE INDEX REGISTERS,
*           CP CAN BE TREATED SIMPLY AS AN INDEX REGISTER.
*           IN THIS CASE, THE FOLLOWING EQUIVALENCES APPLY.
*
*           LCP REG IS LIKE MOV REG,CP
*           SCP REG IS LIKE MOV CP,REG
*           LCW REG IS LIKE MOV (CP)+,REG
*           ICP     IS LIKE ICA CP
*
*           SINCE LCW IS ALLOWED TO DESTROY XL, THE FOLLOWING
*           IMPLEMENTATION USING A WORK LOCATION CP$$$ CAN
*           ALSO BE USED.
*
*           LCP  REG         MOV  REG,CP$$$
*
*           SCP  REG         MOV  CP$$$,REG
*
*           LCW  REG         MOV  CP$$$,XL
*                            MOV  (XL)+,REG
*                            MOV  XL,CP$$$
*
*           ICP              ICA  CP$$$
{{EJC{{{{{2311
*
*      -4-  OPERATIONS ON SIGNED INTEGER VALUES
*
*      4.1  LDI  OPS         LOAD INTEGER ACCUMULATOR FROM OPS
*      4.2  ADI  OPS         ADD OPS TO INTEGER ACCUMULATOR
*      4.3  MLI  OPS         MULTIPLY INTEGER ACCUMULATOR BY OPS
*      4.4  SBI  OPS         SUBTRACT OPS FROM INT ACCUMULATOR
*      4.5  DVI  OPS         DIVIDE INTEGER ACCUMULATOR BY OPS
*      4.6  RMI  OPS         SET INT ACCUM TO MOD(INTACC,OPS)
*      4.7  STI  OPS         STORE INTEGER ACCUMULATOR AT OPS
*      4.8  NGI              NEGATE THE VALUE IN THE INTEGER
*                            ACCUMULATOR (CHANGE ITS SIGN)
*
*           THE EQUATION SATISFIED BY OPERANDS AND RESULTS OF
*           DVI AND RMI IS
*                  DIV = QOT * OPS + REM          WHERE
*           DIV = DIVIDEND IN INTEGER ACCUMULATOR
*           QOT = QUOTIENT LEFT IN IA BY DIV
*           OPS = THE DIVISOR
*           REM = REMAINDER LEFT IN IA BY RMI
*           THE SIGN OF THE RESULT OF DVI IS + IF (IA) AND (OPS)
*           HAVE THE SAME SIGN AND IS - IF THEY HAVE OPPOSITE
*           SIGNS. THE SIGN OF (IA) IS ALWAYS USED AS THE SIGN
*           OF THE RESULT OF REM.
*           ASSUMING IN EACH CASE THAT IA CONTAINS THE NUMBER
*           SPECIFIED IN PARENTHESES AND THAT SEVEN AND MSEVN
*           HOLD +7 AND -7 RESP. THE ALGORITHM IS ILLUSTRATED
*           BELOW.
*           (IA = 13)
*           DVI  SEVEN       IA = 1
*           RMI  SEVEN       IA = 6
*           DVI  MSEVN       IA = -1
*           RMI  MSEVN       IA = 6
*           (IA = -13)
*           DVI  SEVEN       IA = -1
*           RMI  SEVEN       IA = -6
*           DVI  MSEVN       IA = 1
*           RMI  MSEVN       IA = -6
{{EJC{{{{{2350
*
*           THE ABOVE INSTRUCTIONS OPERATE ON A FULL RANGE OF
*           SIGNED INTEGER VALUES. WITH THE EXCEPTION OF LDI AND
*           STI, THESE INSTRUCTIONS MAY CAUSE INTEGER OVERFLOW
*           BY ATTEMPTING TO PRODUCE AN UNDEFINED OR OUT OF
*           RANGE RESULT IN WHICH CASE INTEGER OVERFLOW IS SET,
*           THE RESULT IN (IA) IS UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE IOV OR INO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      4.9  INO  PLBL        JUMP TO PLBL IF NO INTEGER OVERFLOW
*      4.10 IOV  PLBL        JUMP TO PLBL IF INTEGER OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE INTEGER
*           OVERFLOW (ADI, SBI, MLI, DVI, RMI, NGI) AND
*           TEST THE RESULT OF THE PRECEDING INSTRUCTION.
*           IOV AND INO MAY NOT HAVE LABELS.
*
*      4.11 IEQ  PLBL        JUMP TO PLBL IF (IA) EQ 0
*      4.12 IGE  PLBL        JUMP TO PLBL IF (IA) GE 0
*      4.13 IGT  PLBL        JUMP TO PLBL IF (IA) GT 0
*      4.14 ILE  PLBL        JUMP TO PLBL IF (IA) LE 0
*      4.15 ILT  PLBL        JUMP TO PLBL IF (IA) LT 0
*      4.16 INE  PLBL        JUMP TO PLBL IF (IA) NE 0
*
*           THE ABOVE CONDITIONAL JUMP INSTRUCTIONS DO
*           NOT CHANGE THE CONTENTS OF THE ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN IA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
{{EJC{{{{{2384
*
*      -5-  OPERATIONS ON REAL VALUES
*
*      5.1  LDR  OPS         LOAD REAL ACCUMULATOR FROM OPS
*      5.2  STR  OPS         STORE REAL ACCUMULATOR AT OPS
*      5.3  ADR  OPS         ADD OPS TO REAL ACCUMULATOR
*      5.4  SBR  OPS         SUBTRACT OPS FROM REAL ACCUMULATOR
*      5.5  MLR  OPS         MULTIPLY REAL ACCUMULATOR BY OPS
*      5.6  DVR  OPS         DIVIDE REAL ACCUMULATOR BY OPS
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS CAUSES
*           UNDERFLOW, THE RESULT YIELDED IS 0.0.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
*           PARTICULAR CARE MAY BE NEEDED ON TARGET MACHINES
*           HAVING DISTINCT OVERFLOW AND DIVIDE BY ZERO
*           CONDITIONS.
*
*      5.7  ROV  PLBL        JUMP TO PLBL IF REAL OVERFLOW
*      5.8  RNO  PLBL        JUMP TO PLBL IF NO REAL OVERFLOW
*
*           THESE INSTRUCTIONS CAN ONLY OCCUR IMMEDIATELY
*           FOLLOWING AN INSTRUCTION WHICH CAN CAUSE REAL
*           OVERFLOW (ADR,SBR,MLR,DVR).
*
*      5.9  NGR              NEGATE REAL ACCUM (CHANGE SIGN)
*
*      5.10 REQ  PLBL        JUMP TO PLBL IF (RA) EQ 0.0
*      5.11 RGE  PLBL        JUMP TO PLBL IF (RA) GE 0.0
*      5.12 RGT  PLBL        JUMP TO PLBL IF (RA) GT 0.0
*      5.13 RLE  PLBL        JUMP TO PLBL IF (RA) LE 0.0
*      5.14 RLT  PLBL        JUMP TO PLBL IF (RA) LT 0.0
*      5.15 RNE  PLBL        JUMP TO PLBL IF (RA) NE 0.0
*
*           THE ABOVE CONDITIONAL INSTRUCTIONS DO NOT AFFECT
*           THE VALUE STORED IN THE REAL ACCUMULATOR.
*           ON A ONES COMPLEMENT MACHINE, IT IS PERMISSIBLE TO
*           PRODUCE NEGATIVE ZERO IN RA PROVIDED THESE
*           INSTRUCTIONS OPERATE CORRECTLY WITH SUCH A VALUE.
*
*      5.16 ATN              ARCTANGENT OF REAL ACCUM
*      5.17 CHP              INTEGER PORTION OF REAL ACCUM
*      5.18 COS              COSINE OF REAL ACCUM
*      5.19 ETX              E TO THE POWER IN THE REAL ACCUM
*      5.20 LNF              NATURAL LOGORITHM OF REAL ACCUM
*      5.21 SIN              SINE OF REAL ACCUM
*      5.22 SQR              SQUARE ROOT OF REAL ACCUM
*      5.23 TAN              TANGENT OF REAL ACCUM
*
*           THE ABOVE ORDERS OPERATE UPON THE REAL ACCUMULATOR,
*           AND REPLACE THE CONTENTS OF THE ACCUMULATOR WITH THE
*           RESULT.
*
*           IF THE RESULT OF ANY OF THE ABOVE OPERATIONS IS
*           UNDEFINED OR OUT OF RANGE, REAL OVERFLOW IS SET,
*           THE CONTENTS OF (RA) ARE UNDEFINED AND THE FOLLOWING
*           INSTRUCTION MUST BE EITHER ROV OR RNO.
{{EJC{{{{{2447
*
*      -6-  OPERATIONS ON CHARACTER VALUES
*
*           CHARACTER OPERATIONS EMPLOY THE CONCEPT OF A
*           CHARACTER POINTER WHICH USES EITHER
*           INDEX REGISTER XR OR XL (NOT XS).
*
*           A CHARACTER POINTER POINTS TO A SPECIFIC CHARACTER
*           IN A STRING OF CHARACTERS STORED CFP$C CHARS TO A
*           WORD. THE ONLY OPERATIONS PERMITTED ON A CHARACTER
*           POINTER ARE LCH AND SCH. IN PARTICULAR, A CHARACTER
*           POINTER MAY NOT EVEN BE MOVED WITH MOV.
*
*              RESTRICTION 1.
*              --------------
*           IT IS IMPORTANT WHEN CODING IN MINIMAL TO ENSURE
*           THAT NO ACTION OCCURRING BETWEEN THE INITIAL USE OF
*           PLC OR PSC AND THE EVENTUAL CLEARING OF XL OR XR ON
*           COMPLETION OF CHARACTER OPERATIONS CAN INITIATE A
*           GARBAGE COLLECTION. THE LATTER OF COURSE COULD CAUSE
*           THE ADDRESSED CHARACTERS TO BE MOVED LEAVING THE
*           CHARACTER POINTERS POINTING TO RUBBISH.
*
*              RESTRICTION 2.
*              --------------
*           A FURTHER RESTRICTION TO BE OBSERVED IN CODE
*           HANDLING CHARACTER STRINGS, IS THAT STRINGS BUILT
*           DYNAMICALLY SHOULD BE RIGHT PADDED WITH ZERO
*           CHARACTERS TO A FULL WORD BOUNDARY TO PERMIT EASY
*           HASHING AND USE OF CEQ OR CNE IN TESTING STRINGS
*           FOR EQUALITY.
*
*      6.1  PLC  X,OPV       PREPARE CH PTR FOR LCH,CMC,MVC,TRC
*
*      6.2  PSC  X,OPV       PREPARE CHAR. PTR FOR SCH,MVC.
*
*           OPV CAN BE OMITTED IF IT IS ZERO.
*           THE CHAR. INITIALLY ADDRESSED IS DETERMINED BY THE
*           WORD ADDRESS IN X AND THE INTEGER OFFSET OPV.
*           THERE IS AN AUTOMATIC IMPLIED OFFSET OF CFP$F BYTES.
*           CFP$F IS USED TO FORMALLY INTRODUCE INTO MINIMAL A
*           VALUE NEEDED IN TRANSLATING THESE OPCODES WHICH,
*           SINCE MINIMAL ITSELF DOES NOT PRESCRIBE A STRING
*           STRUCTURE IN DETAIL, DEPENDS ON THE CHOICE OF A DATA
*           STRUCTURE FOR STRINGS IN THE MINIMAL PROGRAM.
*           E.G. IF CFP$B = CFP$C = 3, CFP$F = 6, NUM01 = 1, XL
*           POINTS TO A SERIES OF 4 WORDS, ABC/DEF/GHI/JKL, THEN
*               PLC  XL,=NUM01
*           POINTS TO H.
{{EJC{{{{{2497
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.3  LCH  REG,OPC     LOAD CHARACTER INTO REG
*
*      6.4  SCH  REG,OPC     STORE CHARACTER FROM REG
*
*           THESE OPERATIONS ARE DEFINED SUCH THAT THE CHARACTER
*           IS RIGHT JUSTIFIED IN REGISTER REG WITH ZERO BITS TO
*           THE LEFT. AFTER LCH FOR EXAMPLE, IT IS LEGITIMATE
*           TO REGARD REG AS CONTAINING THE ORDINAL INTEGER
*           CORRESPONDING TO THE CHARACTER.
*
*           OPC IS ONE OF THE FOLLOWING THREE POSSIBILITIES.
*
*           (X)              THE CHARACTER POINTED TO BY THE
*                            CHARACTER POINTER IN X. THE
*                            CHARACTER POINTER IS NOT CHANGED.
*
*           (X)+             SAME CHARACTER AS (X) BUT THE
*                            CHARACTER POINTER IS INCREMENTED
*                            TO POINT TO THE NEXT CHARACTER
*                            FOLLOWING EXECUTION.
*
*           -(X)             THE CHARACTER POINTER IS DECRE-
*                            MENTED BEFORE ACCESSING THE
*                            CHARACTER SO THAT THE PREVIOUS
*                            CHARACTER IS REFERENCED.
*
*      6.5  CSC  X           COMPLETE STORE CHARACTERS
*
*           THIS INSTRUCTION MARKS COMPLETION OF A
*           PSC,SCH,SCH,...,SCH SEQUENCE INITIATED BY
*           A  PSC  X INSTRUCTION. NO MORE SCH INSTRUCTIONS
*           USING  X  SHOULD BE OBEYED UNTIL ANOTHER PSC
*           IS OBEYED. THIS MAKES BUFFERING OF SCH CHARS
*           FEASIBLE ON MACHINES LACKING CHARACTER ORDERS.
*           IF CSC IS NOT A NO-OP, IT MUST OBSERVE RESTRICTION 2
*
*           THE FOLLOWING INSTRUCTIONS ARE USED TO COMPARE
*           TWO WORDS CONTAINING CFP$C CHARACTERS.
*           COMPARISONS DISTINCT FROM BEQ,BNE ARE PROVIDED AS
*           ON SOME TARGET MACHINES, THE POSSIBILITY OF THE SIGN
*           BIT BEING SET MAY REQUIRE SPECIAL ACTION.
*           NOTE THAT RESTRICTION 2 ABOVE, EASES USE OF THESE
*           ORDERS IN TESTING COMPLETE STRINGS FOR EQUALITY,
*           SINCE WHOLE WORD TESTS ARE POSSIBLE.
*
*      6.6  CEQ  OPW,OPW,PLBL JUMP TO PLBL IF OPW EQ OPW
*      6.7  CNE  OPW,OPW,PLBL JUMP TO PLBL IF OPW NE OPW
{{EJC{{{{{2548
*
*      -6- OPERATIONS ON CHARACTER VALUES (CONTINUED)
*
*      6.8  CMC  PLBL,PLBL   COMPARE CHARACTERS
*
*           CMC IS USED TO COMPARE TWO CHARACTER STRINGS. BEFORE
*           EXECUTING CMC, REGISTERS ARE SET UP AS FOLLOWS.
*           (XL)             CHARACTER PTR FOR FIRST STRING
*           (XR)             CHARACTER POINTER FOR SECOND STRING
*           (WA)             CHARACTER COUNT (MUST BE .GT. ZERO)
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           CONTROL PASSES TO FIRST PLBL IF THE FIRST STRING
*           IS LEXICALLY LESS THAN THE SECOND STRING, AND TO
*           THE SECOND PLBL IF THE FIRST STRING IS LEXICALLY
*           GREATER. CONTROL PASSES TO THE FOLLOWING INSTRUCTION
*           IF THE STRINGS ARE IDENTICAL. AFTER EXECUTING THIS
*           INSTRUCTION, THE VALUES OF (XR) AND (XL) ARE SET TO
*           ZERO AND THE VALUE IN (WA) IS UNDEFINED.
*           ARGUMENTS TO CMC MAY BE COMPLETE OR PARTIAL
*           STRINGS, SO MAKING OPTIMISATION TO USE WHOLE WORD
*           COMPARISONS DIFFICULT (DEPENDENT IN GENERAL ON
*           SHIFTS AND MASKING).
*
*      6.9  TRC              TRANSLATE CHARACTERS
*
*           TRC IS USED TO TRANSLATE A CHARACTER STRING USING A
*           SUPPLIED TRANSLATION TABLE. BEFORE EXECUTING TRC THE
*           REGISTERS ARE SET AS FOLLOWS.
*           (XL)             CHAR PTR TO STRING TO BE TRANSLATED
*           (XR)             CHAR PTR TO TRANSLATE TABLE
*           (WA)             LENGTH OF STRING TO BE TRANSLATED
*           XL AND XR SHOULD HAVE BEEN PREPARED BY PLC.
*           THE TRANSLATE TABLE CONSISTS OF CFP$A CONTIGUOUS
*           CHARACTERS GIVING THE TRANSLATIONS OF THE CFP$A
*           CHARACTERS IN THE ALPHABET. ON COMPLETION, (XR) AND
*           (XL) ARE SET TO ZERO AND (WA) IS UNDEFINED.
*
*      6.10 FLC  W           FOLD CHARACTER TO UPPER CASE
*           FLC IS USED ONLY IF .CULC IS DEFINED. THE CHARACTER
*           CODE VALUE IN W IS TRANSLATED TO UPPER CASE IF IT
*           CORRESPONDS TO A LOWER CASE CHARACTER.
{{EJC{{{{{2590
*
*      -7-  OPERATIONS ON BIT STRING VALUES
*
*      7.1  ANB  OPW,W       AND BIT STRING VALUES
*      7.2  ORB  OPW,W       OR BIT STRING VALUES
*      7.3  XOB  OPW,W       EXCLUSIVE OR BIT STRING VALUES
*
*           IN THE ABOVE OPERATIONS, THE LOGICAL CONNECTIVE IS
*           APPLIED SEPARATELY TO EACH OF THE CFP$N BITS.
*           THE RESULT IS STORED IN THE SECOND OPERAND LOCATION.
*
*      7.4  CMB  W           COMPLEMENT ALL BITS IN OPW
*
*      7.5  RSH  W,VAL       RIGHT SHIFT BY VAL BITS
*      7.6  LSH  W,VAL       LEFT SHIFT BY VAL BITS
*      7.7  RSX  W,(X)       RIGHT SHIFT W NUMBER OF BITS IN X
*      7.8  LSX  W,(X)       LEFT SHIFT W NUMBER OF BITS IN X
*
*           THE ABOVE SHIFTS ARE LOGICAL SHIFTS IN WHICH BITS
*           SHIFTED OUT ARE LOST AND ZERO BITS SUPPLIED AS
*           REQUIRED. THE SHIFT COUNT IS IN THE RANGE 0-CFP$N.
*
*      7.9  NZB  W,PLBL      JUMP TO PLBL IF W IS NOT
*                            ALL ZERO BITS.
*
*      7.10 ZRB  W,PLBL      JUMP TO PLBL IF W IS ALL ZERO BITS
*
*      7.11 ZGB  OPN         ZEROISE GARBAGE BITS
*
*           OPN CONTAINS A BIT STRING REPRESENTING A WORD
*           OF CHARACTERS FROM A STRING OR SOME FUNCTION
*           FORMED FROM SUCH CHARACTERS (E.G. AS A RESULT OF
*           HASHING). ON A MACHINE WHERE THE WORD SIZE IS NOT A
*           MULTIPLE OF THE CHARACTER SIZE, SOME BITS IN REG MAY
*           BE UNDEFINED. THIS OPCODE REPLACES SUCH BITS BY THE
*           ZERO BIT. ZGB IS A NO-OP IF THE WORD SIZE IS A
*           MULTIPLE OF THE CHARACTER SIZE.
{{EJC{{{{{2628
*
*      -8-  CONVERSION INSTRUCTIONS
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN LENGTHS IN BYTES AND LENGTHS IN WORDS.
*
*      8.1  WTB  REG         CONVERT REG FROM WORDS TO BYTES.
*                            THAT IS, MULTIPLY BY CFP$B. THIS IS
*                            A NO-OP IF CFP$B IS ONE.
*
*      8.2  BTW  REG         CONVERT REG FROM BYTES TO WORDS
*                            BY DIVIDING REG BY CFP$B DISCARDING
*                            THE FRACTION. NO-OP IF CFP$B IS ONE
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           OF ONE WORD INTEGER VALUES (ADDRESSES) TO AND
*           FROM THE FULL SIGNED INTEGER FORMAT.
*
*      8.3  MTI  OPN         THE VALUE OF OPN (AN ADDRESS)
*                            IS MOVED AS A POSITIVE INTEGER
*                            TO THE INTEGER ACCUMULATOR.
*
*      8.4  MFI  OPN,PLBL    THE VALUE CURRENTLY STORED IN THE
*                            INTEGER ACCUMULATOR IS MOVED
*                            TO OPN AS AN ADDRESS IF IT IS IN
*                            THE RANGE 0 TO CFP$M INCLUSIVE.
*                            IF THE ACCUMULATOR VALUE IS
*                            OUTSIDE THIS RANGE, THEN THE RESULT
*                            IN OPN IS UNDEFINED AND CONTROL IS
*                            PASSED TO PLBL. MFI DESTROYS THE
*                            VALUE OF (IA) WHETHER OR NOT
*                            INTEGER OVERFLOW IS SIGNALLED.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           BETWEEN REAL VALUES AND INTEGER VALUES.
*
*      8.5  ITR              CONVERT INTEGER VALUE IN INTEGER
*                            ACCUMULATOR TO REAL AND STORE IN
*                            REAL ACCUMULATOR (MAY LOSE
*                            PRECISION IN SOME CASES)
*
*      8.6  RTI  PLBL        CONVERT THE REAL VALUE IN RA TO
*                            AN INTEGER AND PLACE RESULT IN IA.
*                            CONVERSION IS BY TRUNCATION OF THE
*                            FRACTION - NO ROUNDING OCCURS.
*                            JUMP TO PLBL IF OUT OF RANGE. (RA)
*                            IS NOT CHANGED IN EITHER CASE.
*                            PLBL MAY BE OMITTED IF OVERFLOW
*                            IS IMPOSSIBLE.
{{EJC{{{{{2680
*
*      -8-  CONVERSION INSTRUCTIONS (CONTINUED)
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR COMPUTING
*           THE LENGTH OF STORAGE REQUIRED FOR A TEXT STRING.
*
*      8.7  CTW  W,VAL       THIS INSTRUCTION COMPUTES THE SUM
*                            (NUMBER OF WORDS REQUIRED TO STORE
*                            W CHARACTERS) + (VAL). THE SUM
*                            IS STORED IN W.
*                            FOR EXAMPLE, IF CFP$C IS 5, AND WA
*                            CONTAINS 32, THEN CTW WA,2
*                            GIVES A RESULT OF 9 IN WA.
*
*      8.8  CTB  W,VAL       CTB IS EXACTLY LIKE CTW EXCEPT THAT
*                            THE RESULT IS IN BYTES. IT HAS THE
*                            SAME EFFECT AS CTW W,VAL  WTB W
*
*           THE FOLLOWING INSTRUCTIONS PROVIDE FOR CONVERSION
*           FROM INTEGERS TO AND FROM NUMERIC DIGIT CHARACTERS
*           FOR USE IN NUMERIC CONVERSION ROUTINES. THEY EMPLOY
*           NEGATIVE INTEGER VALUES TO ALLOW FOR PROPER
*           CONVERSION OF NUMBERS WHICH CANNOT BE COMPLEMENTED.
*
*      8.9  CVM  PLBL        CONVERT BY MULTIPLICATION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS MULTIPLIED BY 10. WB CONTAINS THE CHARACTER
*           CODE FOR A DIGIT. THE VALUE OF THIS DIGIT IS THEN
*           SUBTRACTED FROM THE RESULT. IF THE RESULT IS OUT OF
*           RANGE, THEN CONTROL IS PASSED TO PLBL WITH THE
*           RESULT IN (IA) UNDEFINED. EXECUTION OF CVM LEAVES
*           THE RESULT IN (WB) UNDEFINED.
*
*      8.10 CVD              CONVERT BY DIVISION
*
*           THE INTEGER ACCUMULATOR, WHICH IS ZERO OR NEGATIVE,
*           IS DIVIDED BY 10. THE QUOTIENT (ZERO OR NEGATIVE)
*           IS REPLACED IN THE ACCUMULATOR. THE REMAINDER IS
*           CONVERTED TO THE CHARACTER CODE OF A DIGIT AND
*           PLACED IN WA. FOR EXAMPLE, AN OPERAND OF -523 GIVES
*           A QUOTIENT OF -52 AND A REMAINDER IN WA OF CH$D3.
{{EJC{{{{{2723
*
*      -9-  BLOCK MOVE INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED FOR TRANSFERRING
*      DATA FROM ONE AREA OF MEMORY TO ANOTHER IN BLOCKS.
*      THEY CAN BE IMPLEMENTED WITH THE INDICATED SERIES OF
*      OTHER MACRO-INSTRUCTIONS, BUT MORE EFFICIENT IMPLE-
*      MENTATIONS WILL BE POSSIBLE ON MOST MACHINES.
*
*      NOTE THAT IN THE EQUIVALENT CODE SEQUENCE SHOWN BELOW, A
*      ZERO VALUE IN WA WILL MOVE AT LEAST ONE ITEM, AND MAY
*      MAY WRAP THE COUNTER CAUSING A CORE DUMP IN SOME IMPLE-
*      MENTATIONS.  THUS WA SHOULD BE .GT. 0 PRIOR TO INVOKING
*      ANY OF THESE BLOCK MOVE INSTRUCTIONS.
*
*      9.1  MVC              MOVE CHARACTERS
*
*           BEFORE OBEYING THIS ORDER WA,XL,XR SHOULD HAVE BEEN
*           SET UP, THE LATTER TWO BY PLC, PSC RESP.
*           MVC IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,(XL)+
*                  SCH  WB,(XR)+
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THE CHARACTER POINTERS ARE BUMPED AS INDICATED
*           AND THE FINAL VALUE OF WA IS UNDEFINED.
*
*
*      9.2  MVW              MOVE WORDS
*
*           MVW IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPW  MOV  (XL)+,(XR)+
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPW
*
*           NOTE THAT THIS IMPLIES THAT THE VALUE IN WA IS THE
*           LENGTH IN BYTES WHICH IS A MULTIPLE OF CFP$B.
*           THE INITIAL ADDRESSES IN XR,XL ARE WORD ADDRESSES.
*           AS INDICATED, THE FINAL XR,XL VALUES POINT PAST THE
*           NEW AND OLD REGIONS OF MEMORY RESPECTIVELY.
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MVW.
*
*      9.3  MWB              MOVE WORDS BACKWARDS
*
*           MWB IS EQUIVALENT TO THE SEQUENCE
*
*           LOOPB  MOV  -(XL),-(XR)
*                  DCA  WA               WA = BYTES TO MOVE
*                  BNZ  WA,LOOPB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MWB.
*
*      9.4  MCB              MOVE CHARACTERS BACKWARDS
*
*           MCB IS EQUIVALENT TO THE SEQUENCE
*
*                  MOV  WB,DUMPB
*                  LCT  WA,WA
*           LOOPC  LCH  WB,-(XL)
*                  SCH  WB,-(XR)
*                  BCT  WA,LOOPC
*                  CSC  XR
*                  MOV  DUMPB,WB
*
*           THERE IS A REQUIREMENT THAT THE INITIAL VALUE IN XL
*           BE AT LEAST 256 LESS THAN THE VALUE IN XR. THIS
*           ALLOWS AN IMPLEMENTATION IN WHICH CHUNKS OF 256
*           BYTES ARE MOVED FORWARD (IBM 360, ICL 1900).
*           THE FINAL VALUE OF WA IS UNDEFINED.
*           WA,XL,XR MUST BE SET UP BEFORE OBEYING MCB.
{{EJC{{{{{2806
*
*      -10- OPERATIONS CONNECTED WITH THE STACK
*
*      THE STACK IS AN AREA IN MEMORY WHICH IS DEDICATED FOR USE
*      IN CONJUNCTION WITH THE STACK POINTER REGISTER (XS). AS
*      PREVIOUSLY DESCRIBED, IT IS USED BY THE JSR AND EXI
*      INSTRUCTIONS AND MAY BE USED FOR STORAGE OF ANY OTHER
*      DATA AS REQUIRED.
*
*      THE STACK BUILDS EITHER WAY IN MEMORY AND AN IMPORTANT
*      RESTRICTION IS THAT THE VALUE IN (XS) MUST BE THE ADDRESS
*      OF THE STACK FRONT AT ALL TIMES SINCE
*      SOME IMPLEMENTATIONS MAY RANDOMLY DESTROY STACK LOCATIONS
*      BEYOND (XS).
*
*      THE STARTING STACK BASE ADDRESS IS PASSED
*      IN (XS) AT THE START OF EXECUTION. DURING EXECUTION IT
*      IS NECESSARY TO MAKE SURE THAT THE STACK DOES NOT
*      OVERFLOW. THIS IS ACHIEVED BY EXECUTING THE FOLLOWING
*      INSTRUCTION PERIODICALLY.
*
*      10.1 CHK              CHECK STACK OVERFLOW
*
*      AFTER SUCCESSFULLY EXECUTING CHK, IT IS PERMISSIBLE TO
*      USE UP TO 100 ADDITIONAL WORDS BEFORE ISSUING ANOTHER CHK
*      THUS CHK NEED NOT BE ISSUED EVERY TIME THE STACK IS
*      EXPANDED. IN SOME IMPLEMENTATIONS, THE CHECKING MAY BE
*      AUTOMATIC AND CHK WILL HAVE NO EFFECT. FOLLOWING THE
*      ABOVE RULE MAKES SURE THAT THE PROGRAM WILL OPERATE
*      CORRECTLY IN IMPLEMENTATIONS WITH NO AUTOMATIC CHECK.
*
*      IF STACK OVERFLOW OCCURS (DETECTED EITHER AUTOMATICALLY
*      OR BY A CHK INSTRUCTION), THEN CONTROL IS PASSED TO THE
*      STACK OVERFLOW SECTION (SEE PROGRAM FORM). NOTE THAT THIS
*      TRANSFER MAY TAKE PLACE FOLLOWING ANY INSTRUCTION WHICH
*      STORES DATA AT A NEW LOCATION ON THE STACK.
*      AFTER STACK OVERFLOW, STACK IS ARBITRARILY POPPED
*      TO GIVE SOME SPACE IN WHICH THE ERROR PROCEDURE MAY
*      OPERATE. OTHERWISE A LOOP OF STACK OVERFLOWS MAY OCCUR.
{{EJC{{{{{2846
*
*      -11- DATA GENERATION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTIONS ARE USED TO GENERATE CONSTANT
*      VALUES IN THE CONSTANT SECTION AND ALSO TO ASSEMBLE
*      INITIAL VALUES IN THE WORKING STORAGE SECTION. THEY
*      MAY NOT APPEAR EXCEPT IN THESE TWO SECTIONS.
*
*      11.1 DAC  ADDR        ASSEMBLE ADDRESS CONSTANT.
*                            GENERATES ONE WORD CONTAINING THE
*                            SPECIFIED ONE WORD INTEGER
*                            VALUE (ADDRESS).
*
*      11.2 DIC  INTEGER     GENERATES AN INTEGER VALUE WHICH
*                            OCCUPIES CFP$I CONSECUTIVE WORDS.
*                            THE OPERAND IS A DIGIT STRING WITH
*                            A REQUIRED LEADING SIGN.
*
*      11.3 DRC  REAL        ASSEMBLES A REAL CONSTANT WHICH
*                            OCCUPIES CFP$R CONSECUTIVE WORDS.
*                            THE OPERAND FORM MUST OBEY THE
*                            RULES FOR A FORTRAN REAL CONSTANT
*                            WITH THE EXTRA REQUIREMENT THAT A
*                            LEADING SIGN BE PRESENT.
*
*      11.4 DTC  DTEXT       DEFINE TEXT CONSTANT. DTEXT
*                            IS STARTED AND ENDED WITH ANY
*                            CHARACTER NOT CONTAINED IN THE
*                            CHARACTERS TO BE ASSEMBLED. THE
*                            CONSTANT OCCUPIES CONSECUTIVE WORDS
*                            AS DICTATED BY THE CONFIGURATION
*                            PARAMETER CFP$C. ANY UNUSED CHARS
*                            IN THE LAST WORD ARE RIGHT FILLED
*                            WITH ZEROS (I.E. THE CHARACTER
*                            WHOSE INTERNAL CODE IS ZERO).
*                            THE STRING CONTAINS A SEQUENCE OF
*                            LETTERS, DIGITS, BLANKS AND ANY OF
*                            THE FOLLOWING SPECIAL CHARACTERS.
*                            =,$.(*)/+-
*                            NO OTHER CHARACTERS
*                            MAY BE USED IN A DTEXT OPERAND.
*
*      11.5 DBC  VAL         ASSEMBLE BIT STRING CONSTANT. THE
*                            OPERAND IS A POSITIVE INTEGER
*                            VALUE WHICH IS INTERPRETED IN
*                            BINARY, RIGHT JUSTIFIED AND LEFT
*                            FILLED WITH ZERO BITS. THUS 5 WOULD
*                            IMPLY THE BIT STRING VALUE 00...101.
{{EJC{{{{{2895
*
*      -12- SYMBOL DEFINITION INSTRUCTIONS
*
*      THE FOLLOWING INSTRUCTION IS USED TO DEFINE SYMBOLS
*      IN THE DEFINITIONS SECTION. IT MAY NOT BE USED ELSEWHERE.
*
*      12.1 EQU  EQOP        DEFINE SYMBOL
*
*           THE SYMBOL WHICH APPEARS IN THE LABEL FIELD IS
*           DEFINED TO HAVE THE ABSOLUTE VALUE GIVEN
*           BY THE EQOP OPERAND. A GIVEN SYMBOL MAY BE DEFINED
*           ONLY ONCE IN THIS MANNER, AND ANY SYMBOLS OCCURING
*           IN EQOP MUST BE PREVIOUSLY DEFINED.
*
*           THE FOLLOWING ARE THE POSSIBILITIES FOR EQOP
*
*           VAL              THE INDICATED VALUE IS USED
*
*           VAL+VAL          THE SUM OF THE TWO VALUES IS USED.
*                            THIS SUM MUST NOT EXCEED CFP$M
*
*           VAL-VAL          THE DIFFERENCE BETWEEN THE TWO
*                            VALUES (MUST BE POSITIVE) IS USED.
*
*           *                THIS FORMAT DEFINES THE LABEL BY
*                            USING A VALUE SUPPLIED BY THE
*                            MINIMAL TRANSLATOR. VALUES ARE
*                            REQUIRED FOR THE
*           CFP$X            (CONFIGURATION PARAMETERS)
*           E$XXX            (ENVIRONMENT PARAMETERS)
*           CH$XX            (CHARACTER CODES).
*                            IN ORDER FOR A TRANSLATOR TO
*                            HANDLE THIS FORMAT CORRECTLY THE
*                            DEFINITIONS SECTION MUST BE
*                            CONSULTED FOR DETAILS OF REQUIRED
*                            SYMBOLS AS LISTED AT THE FRONT OF
*                            THE SECTION.
{{EJC{{{{{2933
*
*      SYMBOL DEFINITION INSTRUCTIONS (CONTINUED)
*
*      THE FOLLOWING INSTRUCTIONS MAY BE USED TO DEFINE SYMBOLS
*      IN THE PROCEDURE SECTION. THEY MAY NOT BE USED IN
*      ANY OTHER PART OF THE PROGRAM.
*
*      12.2 EXP              DEFINE EXTERNAL PROCEDURE
*
*           EXP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN EXTERNAL PROCEDURE WHICH CAN BE
*           REFERENCED IN A SUBSEQUENT JSR INSTRUCTION. THE
*           CODING FOR THE PROCEDURE IS EXTERNAL TO THE
*           CODING OF THE SOURCE PROGRAM IN THIS LANGUAGE.
*           THE CODE FOR EXTERNAL PROCEDURES MAY BE
*           REFERRED TO COLLECTIVELY AS THE OPERATING SYSTEM
*           INTERFACE, OR MORE BRIEFLY, OSINT, AND WILL
*           FREQUENTLY BE A SEPARATELY COMPILED SEGMENT OF CODE
*           LOADED WITH SPITBOL TO PRODUCE A COMPLETE SYSTEM.
*
*      12.3 INP  PTYP,INT    DEFINE INTERNAL PROCEDURE
*
*           INP DEFINES THE SYMBOL APPEARING IN THE LABEL FIELD
*           TO BE THE NAME OF AN INTERNAL PROCEDURE AND GIVES
*           ITS TYPE AND NUMBER OF EXIT PARAMETERS. THE LABEL
*           CAN BE REFERENCED IN JSR INSTRUCTIONS AND
*           IT MUST APPEAR LABELLING A PRC INSTRUCTION IN THE
*           PROGRAM SECTION.
*
*      12.4 INR              DEFINE INTERNAL ROUTINE
*
*           INR DEFINES THE SYMBOL APPEARING IN THE LABEL
*           FIELD TO BE THE NAME OF AN INTERNAL ROUTINE. THE
*           LABEL MAY BE REFERENCED IN ANY TYPE OF BRANCH ORDER
*           AND IT MUST APPEAR LABELLING A RTN INSTRUCTION IN
*           THE PROGRAM SECTION.
{{EJC{{{{{2970
*
*      -13- ASSEMBLY LISTING LAYOUT INSTRUCTIONS
*
*      13.1 EJC              EJECT TO NEXT PAGE
*
*      13.2 TTL  TEXT        SET NEW ASSEMBLY TITLE
*
*           TTL IMPLIES AN IMMEDIATE EJECT OF THE
*           ASSEMBLY LISTING TO PRINT THE NEW TITLE.
*
*           THE USE OF TTL AND EJC CARDS IS SUCH THAT THE
*           PROGRAM WILL LIST NEATLY IF THE PRINTER PRINTS
*           AS MANY AS 58 LINES PER PAGE. IN THE EVENT THAT
*           THE PRINTER DEPTH IS LESS THAN THIS, OR IF THE
*           LISTING CONTAINS INTERSPERSED LINES (SUCH AS ACTUAL
*           GENERATED CODE), THEN THE FORMAT MAY BE UPSET.
*
*           LINES STARTING WITH AN ASTERISK ARE COMMENT LINES
*           WHICH CAUSE NO CODE TO BE GENERATED AND MAY OCCUR
*           FREELY ANYWHERE IN THE PROGRAM. THE FORMAT FOR
*           COMMENT LINES IS GIVEN IN SECTION -15-.
{{EJC{{{{{2992
*
*      -14- PROGRAM FORM
*
*           THE PROGRAM CONSISTS OF SEPARATE SECTIONS SEPARATED
*           BY SEC OPERATIONS. THE SECTIONS MUST APPEAR IN THE
*           FOLLOWING SPECIFIED ORDER.
*
*      14.1 SEC              START OF PROCEDURE SECTION
*
*           (PROCEDURE SECTION)
*
*           SEC               START OF DEFINITIONS SECTION
*
*           (DEFINITIONS SECTION)
*
*           SEC               START OF CONSTANT STORAGE SECTION
*
*           (CONSTANT STORAGE SECTION)
*
*           SEC               START OF WORKING STORAGE SECTION
*
*           (WORKING STORAGE SECTION)
*
*           SEC               START OF PROGRAM SECTION
*
*           (PROGRAM SECTION)
*
*           SEC               START OF STACK OVERFLOW SECTION
*
*           (STACK OVERFLOW SECTION)
*
*           SEC               START OF ERROR SECTION
*
*           (ERROR SECTION)
*
*      14.2 END              END OF ASSEMBLY
{{EJC{{{{{3029
*
*      SECTION 10 - PROGRAM FORM
*
*      PROCEDURE SECTION
*
*           THE PROCEDURE SECTION CONTAINS ALL THE EXP
*           INSTRUCTIONS FOR EXTERNALLY AVAILABLE PROCEDURES
*           AND INP,INR OPCODES FOR INTERNAL PROCEDURES,ROUTINES
*           SO THAT A SINGLE PASS MINIMAL TRANSLATOR HAS ADVANCE
*           KNOWLEDGE OF PROCEDURE TYPES WHEN TRANSLATING CALLS.
*
*      DEFINITIONS SECTION
*
*           THE DEFINITIONS SECTION CONTAINS EQU INSTRUCTIONS
*           WHICH DEFINE SYMBOLS REFERENCED LATER ON IN THE
*           PROGRAM, CONSTANT AND WORK SECTIONS.
*
*      CONSTANT STORAGE SECTION
*
*           THE CONSTANT STORAGE SECTION CONSISTS ENTIRELY
*           OF CONSTANTS ASSEMBLED WITH THE DAC,DIC,DRC,DTC,DBC
*           ASSEMBLY OPERATIONS. THESE CONSTANTS CAN BE FREELY
*           REFERENCED BY THE PROGRAM INSTRUCTIONS.
*
*      WORKING STORAGE SECTION
*
*           THE WORKING STORAGE SECTION CONSISTS ENTIRELY OF
*           DAC,DIC,DRC,DBC,DTC INSTRUCTIONS TO DEFINE A FIXED
*           LENGTH WORK AREA. THE WORK LOCATIONS IN THIS AREA
*           CAN BE DIRECTLY REFERENCED IN PROGRAM INSTRUCTIONS.
*           THE AREA IS INITIALIZED IN ACCORDANCE WITH THE
*           VALUES ASSEMBLED IN THE INSTRUCTIONS.
*
*      PROGRAM SECTION
*
*           THE PROGRAM SECTION CONTAINS PROGRAM INSTRUCTIONS
*           AND ASSOCIATED OPERATIONS (SUCH AS PRC, ENP, ENT).
*           CONTROL IS PASSED TO THE FIRST INSTRUCTION IN THIS
*           SECTION WHEN EXECUTION IS INITIATED.
*
*      STACK OVERFLOW SECTION
*
*           THE STACK OVERFLOW SECTION CONTAINS INSTRUCTIONS
*           LIKE THE PROGRAM SECTION. CONTROL IS PASSED TO THE
*           FIRST INSTRUCTION IN THIS SECTION FOLLOWING THE
*           OCCURRENCE OF STACK OVERFLOW, SEE CHK INSTRUCTION.
*
*      ERROR SECTION
*
*           THE ERROR SECTION CONTAINS INSTRUCTIONS LIKE THE
*           PROGRAM SECTION. CONTROL IS PASSED TO THE FIRST
*           INSTRUCTION IN THIS SECTION WHEN A PROCEDURE EXIT
*           CORRESPONDS TO AN ERROR PARAMETER (SEE ERR)
*           OR WHEN AN ERB OPCODE IS OBEYED. THE ERROR CODE
*           MUST CLEAN UP THE MAIN STACK AND CATER FOR THE
*           POSSIBILITY THAT A SUBROUTINE STACK MAY NEED CLEAN
*           UP.
{{EJC{{{{{3087
*      OSINT
*
*           THOUGH NOT PART OF THE MINIMAL SOURCE, IT IS USEFUL
*           TO REFER TO THE COLLECTION OF INITIALISATION AND
*           EXP ROUTINES AS OSINT (OPERATING SYSTEM INTERFACE).
*           ERRORS OCCURRING WITHIN OSINT PROCEDURES ARE
*           USUALLY HANDLED BY MAKING AN ERROR RETURN. IF THIS
*           IS NOT FEASIBLE OR APPROPRIATE, OSINT MAY USE THE
*           MINIMAL ERROR SECTION TO REPORT ERRORS DIRECTLY BY
*           BRANCHING TO IT WITH A SUITABLE NUMERIC ERROR
*           CODE IN WA.
{{EJC{{{{{3099
*
*      SECTION 11 - STATEMENT FORMAT
*
*      ALL LABELS ARE EXACTLY FIVE CHARACTERS LONG AND START
*      WITH THREE LETTERS (ABCDEFGHIJKLMNOPQRSTUVWXY$) FOLLOWED
*      BY TWO LETTERS OR DIGITS.
*      THE LETTER Z MAY NOT BE USED IN MINIMAL SYMBOLS BUT $ IS
*      PERMITTED.
*      FOR IMPLEMENTATIONS WHERE $ MAY NOT APPEAR IN THE
*      TARGET CODE , A SIMPLE SUBSTITUTION OF Z FOR $
*      MAY THUS BE MADE WITHOUT RISK OF PRODUCING NON-UNIQUE
*      SYMBOLS.
*      THE LETTER Z IS HOWEVER PERMITTED IN OPCODE MNEMONICS AND
*      IN COMMENTS.
*
*      MINIMAL STATEMENTS ARE IN A FIXED FORMAT AS FOLLOWS.
*
*      COLS 1-5              LABEL IF ANY (ELSE BLANK)
*
*      COLS 6-7              ALWAYS BLANK
*
*      COLS 8-10             OPERATION MNEMONIC
*
*      COLS 11-12            BLANKS
*
*      COLS 13-28            OPERAND FIELD, TERMINATED BY A
*                            BLANK. MAY OCCASIONALLY
*                            EXTEND PAST COLUMN 28.
*
*      COLS 30-64            COMMENT. ALWAYS SEPARATED FROM THE
*                            OPERAND FIELD BY AT LEAST ONE BLANK
*                            MAY OCCASIONALLY START AFTER COLUMN
*                            30 IF THE OPERAND EXTENDS PAST 28.
*                            A SPECIAL EXCEPTION OCCURS FOR THE
*                            IFF INSTRUCTION, WHOSE COMMENT MAY
*                            BE ONLY 20 CHARACTERS LONG (30-49).
*
*      COLS 65 ON            UNUSED
*
*
*      COMMENT LINES HAVE THE FOLLOWING FORMAT
*
*      COL 1                 ASTERISK
*
*      COLS 2-7              BLANK
*
*      COLS 8-64             ARBITRARY TEXT, RESTRICTED TO THE
*                            FORTRAN CHARACTER SET.
*
*
*      THE FORTRAN CHARACTER SET IS A-Z 0-9 =,$.(*)-/+
{{EJC{{{{{3151
*
*      SECTION 12 - PROGRAM EXECUTION
*
*      EXECUTION OF THE PROGRAM BEGINS WITH THE FIRST
*      INSTRUCTION IN THE PROGRAM SECTION.
*
*      IN ADDITION TO THE FIXED LENGTH MEMORY REGIONS DEFINED
*      BY THE ASSEMBLY, THERE ARE TWO DYNAMICALLY ALLOCATED
*      MEMORY REGIONS AS FOLLOWS.
*
*      DATA AREA             THIS IS AN AREA AVAILABLE TO THE
*                            PROGRAM FOR GENERAL STORAGE OF DATA
*                            ANY DATA VALUE MAY BE STORED IN
*                            THIS AREA EXCEPT INSTRUCTIONS.
*                            IN SOME IMPLEMENTATIONS, IT MAY BE
*                            POSSIBLE TO INCREASE THE SIZE OF
*                            THIS AREA DYNAMICALLY BY ADDING
*                            WORDS AT THE TOP END WITH A CALL
*                            TO A SYSTEM PROCEDURE.
*
*      STACK AREA            THIS REGION OF MEMORY HOLDS
*                            THE STACK USED FOR SUBROUTINE CALLS
*                            AND OTHER STORAGE OF ONE WORD
*                            INTEGER VALUES (ADDRESSES). THIS
*                            IS THE STACK ASSOCIATED WITH
*                            INDEX REGISTER XS.
*
*      THE LOCATIONS AND SIZES OF THESE AREAS ARE SPECIFIED
*      BY THE VALUES IN THE REGISTERS AT THE START OF PROGRAM
*      EXECUTION AS FOLLOWS.
*
*      (XS)                  ADDRESS ONE PAST THE STACK BASE.
*                            E.G. IF XS IS 23456, A D-STACK WILL
*                            OCCUPY WORDS 23455,23454,...
*                            WHEREAS A U-STACK WILL OCCUPY
*                            23457,23458,...
*
*      (XR)                  ADDRESS OF THE FIRST WORD
*                            IN THE DATA AREA
*
*      (XL)                  ADDRESS OF THE LAST WORD IN THE
*                            DATA AREA.
*
*
*      (WA,WB,WC,IA,RA,CP)      ZERO
*
*      THERE IS NO EXPLICIT WAY TO TERMINATE THE EXECUTION OF A
*      PROGRAM. THIS FUNCTION IS PERFORMED BY AN APPROPRIATE
*      SYSTEM PROCEDURE REFERENCED WITH THE SYSEJ INSTRUCTION.
{{TTL{27,S P I T B O L  -- BASIC INFORMATION{{{{3201
{{EJC{{{{{3202
*
*      GENERAL STRUCTURE
*      -----------------
*
*      THIS PROGRAM IS A TRANSLATOR FOR A VERSION OF THE SNOBOL4
*      PROGRAMMING LANGUAGE. LANGUAGE DETAILS ARE CONTAINED IN
*      THE MANUAL MACRO SPITBOL BY DEWAR AND MCCANN, TECHNICAL
*      REPORT 90, UNIVERSITY OF LEEDS 1976.  THE LANGUAGE
*      IS IDENTICAL TO THAT IMPLEMENTED BY THE BTL TRANSLATOR
*      (R. E. GRISWOLD ET AL.) WITH THE FOLLOWING EXCEPTIONS.
*
*      1)   REDEFINITION OF STANDARD SYSTEM FUNCTIONS AND
*           OPERATORS IS NOT PERMITTED.
*
*      2)   THE VALUE FUNCTION IS NOT PROVIDED.
*
*      3)   ACCESS TRACING IS PROVIDED IN ADDITION TO THE
*           OTHER STANDARD TRACE MODES.
*
*      4)   THE KEYWORD STFCOUNT IS NOT PROVIDED.
*
*      5)   THE KEYWORD FULLSCAN IS NOT PROVIDED AND ALL PATTERN
*           MATCHING TAKES PLACE IN FULLSCAN MODE (I.E. WITH NO
*           HEURISTICS APPLIED).
*
*      6)   A SERIES OF EXPRESSIONS SEPARATED BY COMMAS MAY
*           BE GROUPED WITHIN PARENTHESES TO PROVIDE A SELECTION
*           CAPABILITY. THE SEMANTICS ARE THAT THE SELECTION
*           ASSUMES THE VALUE OF THE FIRST EXPRESSION WITHIN IT
*           WHICH SUCCEEDS AS THEY ARE EVALUATED FROM THE LEFT.
*           IF NO EXPRESSION SUCCEEDS THE ENTIRE STATEMENT FAILS
*
*      7)   AN EXPLICIT PATTERN MATCHING OPERATOR IS PROVIDED.
*           THIS IS THE BINARY QUERY (SEE GIMPEL SIGPLAN OCT 74)
*
*      8)   THE ASSIGNMENT OPERATOR IS INTRODUCED AS IN THE
*           GIMPEL REFERENCE.
*
*      9)   THE EXIT FUNCTION IS PROVIDED FOR GENERATING LOAD
*           MODULES - CF. GIMPELS SITBOL.
*
*
*      THE METHOD USED IN THIS PROGRAM IS TO TRANSLATE THE
*      SOURCE CODE INTO AN INTERNAL PSEUDO-CODE (SEE FOLLOWING
*      SECTION). AN INTERPRETOR IS THEN USED TO EXECUTE THIS
*      GENERATED PSEUDO-CODE. THE NATURE OF THE SNOBOL4 LANGUAGE
*      IS SUCH THAT THE LATTER TASK IS MUCH MORE COMPLEX THAN
*      THE ACTUAL TRANSLATION PHASE. ACCORDINGLY, NEARLY ALL THE
*      CODE IN THE PROGRAM SECTION IS CONCERNED WITH THE ACTUAL
*      EXECUTION OF THE SNOBOL4 PROGRAM.
{{EJC{{{{{3253
*
*      INTERPRETIVE CODE FORMAT
*      ------------------------
*
*      THE INTERPRETIVE PSEUDO-CODE CONSISTS OF A SERIES OF
*      ADDRESS POINTERS. THE EXACT FORMAT OF THE CODE IS
*      DESCRIBED IN CONNECTION WITH THE CDBLK FORMAT. THE
*      PURPOSE OF THIS SECTION IS TO GIVE GENERAL INSIGHT INTO
*      THE INTERPRETIVE APPROACH INVOLVED.
*
*      THE BASIC FORM OF THE CODE IS RELATED TO REVERSE POLISH.
*      IN OTHER WORDS, THE OPERANDS PRECEDE THE OPERATORS WHICH
*      ARE ZERO ADDRESS OPERATORS. THERE ARE SOME EXCEPTIONS TO
*      THESE RULES, NOTABLY THE UNARY NOT OPERATOR AND THE
*      SELECTION CONSTRUCTION WHICH CLEARLY REQUIRE ADVANCE
*      KNOWLEDGE OF THE OPERATOR INVOLVED.
*
*      THE OPERANDS ARE MOVED TO THE TOP OF THE MAIN STACK AND
*      THE OPERATORS ARE APPLIED TO THE TOP STACK ENTRIES. LIKE
*      OTHER VERSIONS OF SPITBOL, THIS PROCESSOR DEPENDS ON
*      KNOWING WHETHER OPERANDS ARE REQUIRED BY NAME OR BY VALUE
*      AND MOVES THE APPROPRIATE OBJECT TO THE STACK. THUS NO
*      NAME/VALUE CHECKS ARE INCLUDED IN THE OPERATOR CIRCUITS.
*
*      THE ACTUAL POINTERS IN THE CODE POINT TO A BLOCK WHOSE
*      FIRST WORD IS THE ADDRESS OF THE INTERPRETOR ROUTINE
*      TO BE EXECUTED FOR THE CODE WORD.
*
*      IN THE CASE OF OPERATORS, THE POINTER IS TO A WORD WHICH
*      CONTAINS THE ADDRESS OF THE OPERATOR TO BE EXECUTED. IN
*      THE CASE OF OPERANDS SUCH AS CONSTANTS, THE POINTER IS TO
*      THE OPERAND ITSELF. ACCORDINGLY, ALL OPERANDS CONTAIN
*      A FIELD WHICH POINTS TO THE ROUTINE TO LOAD THE VALUE OF
*      THE OPERAND ONTO THE STACK. IN THE CASE OF A VARIABLE,
*      THERE ARE THREE SUCH POINTERS. ONE TO LOAD THE VALUE,
*      ONE TO STORE THE VALUE AND A THIRD TO JUMP TO THE LABEL.
*
*      THE HANDLING OF FAILURE RETURNS DESERVES SPECIAL COMMENT.
*      THE LOCATION FLPTR CONTAINS THE POINTER TO THE LOCATION
*      ON THE MAIN STACK WHICH CONTAINS THE FAILURE RETURN
*      WHICH IS IN THE FORM OF A BYTE OFFSET IN THE CURRENT
*      CODE BLOCK (CDBLK OR EXBLK). WHEN A FAILURE OCCURS, THE
*      STACK IS POPPED AS INDICATED BY THE SETTING OF FLPTR AND
*      CONTROL IS PASSED TO THE APPROPRIATE LOCATION IN THE
*      CURRENT CODE BLOCK WITH THE STACK POINTER POINTING TO THE
*      FAILURE OFFSET ON THE STACK AND FLPTR UNCHANGED.
{{EJC{{{{{3300
*
*      INTERNAL DATA REPRESENTATIONS
*      -----------------------------
*
*      REPRESENTATION OF VALUES
*
*      A VALUE IS REPRESENTED BY A POINTER TO A BLOCK WHICH
*      DESCRIBES THE TYPE AND PARTICULARS OF THE DATA VALUE.
*      IN GENERAL, A VARIABLE IS A LOCATION CONTAINING SUCH A
*      POINTER (ALTHOUGH IN THE CASE OF TRACE ASSOCIATIONS THIS
*      IS MODIFIED, SEE DESCRIPTION OF TRBLK).
*
*      THE FOLLOWING IS A LIST OF POSSIBLE DATATYPES SHOWING THE
*      TYPE OF BLOCK USED TO HOLD THE VALUE. THE DETAILS OF
*      EACH BLOCK FORMAT ARE GIVEN LATER.
*
*      DATATYPE              BLOCK TYPE
*      --------              ----------
*
*
*      ARRAY                 ARBLK OR VCBLK
*
*      CODE                  CDBLK
*
*      EXPRESSION            EXBLK OR SEBLK
*
*      INTEGER               ICBLK
*
*      NAME                  NMBLK
*
*      PATTERN               P0BLK OR P1BLK OR P2BLK
*
*      REAL                  RCBLK
*
*      STRING                SCBLK
*
*      TABLE                 TBBLK
*
*      PROGRAM DATATYPE      PDBLK
{{EJC{{{{{3340
*
*      REPRESENTATION OF VARIABLES
*      ---------------------------
*
*      DURING THE COURSE OF EVALUATING EXPRESSIONS, IT IS
*      NECESSARY TO GENERATE NAMES OF VARIABLES (FOR EXAMPLE
*      ON THE LEFT SIDE OF A BINARY EQUALS OPERATOR). THESE ARE
*      NOT TO BE CONFUSED WITH OBJECTS OF DATATYPE NAME WHICH
*      ARE IN FACT VALUES.
*
*      FROM A LOGICAL POINT OF VIEW, SUCH NAMES COULD BE SIMPLY
*      REPRESENTED BY A POINTER TO THE APPROPRIATE VALUE CELL.
*      HOWEVER IN THE CASE OF ARRAYS AND PROGRAM DEFINED
*      DATATYPES, THIS WOULD VIOLATE THE RULE THAT THERE MUST BE
*      NO POINTERS INTO THE MIDDLE OF A BLOCK IN DYNAMIC STORE.
*      ACCORDINGLY, A NAME IS ALWAYS REPRESENTED BY A BASE AND
*      OFFSET. THE BASE POINTS TO THE START OF THE BLOCK
*      CONTAINING THE VARIABLE VALUE AND THE OFFSET IS THE
*      OFFSET WITHIN THIS BLOCK IN BYTES. THUS THE ADDRESS
*      OF THE ACTUAL VARIABLE IS DETERMINED BY ADDING THE BASE
*      AND OFFSET VALUES.
*
*      THE FOLLOWING ARE THE INSTANCES OF VARIABLES REPRESENTED
*      IN THIS MANNER.
*
*      1)   NATURAL VARIABLE BASE IS PTR TO VRBLK
*                            OFFSET IS *VRVAL
*
*      2)   TABLE ELEMENT    BASE IS PTR TO TEBLK
*                            OFFSET IS *TEVAL
*
*      3)   ARRAY ELEMENT    BASE IS PTR TO ARBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      4)   VECTOR ELEMENT   BASE IS PTR TO VCBLK
*                            OFFSET IS OFFSET TO ELEMENT
*
*      5)   PROG DEF DTP     BASE IS PTR TO PDBLK
*                            OFFSET IS OFFSET TO FIELD VALUE
*
*      IN ADDITION THERE ARE TWO CASES OF OBJECTS WHICH ARE
*      LIKE VARIABLES BUT CANNOT BE HANDLED IN THIS MANNER.
*      THESE ARE CALLED PSEUDO-VARIABLES AND ARE REPRESENTED
*      WITH A SPECIAL BASE POINTER AS FOLLOWS=
*
*      EXPRESSION VARIABLE   PTR TO EVBLK (SEE EVBLK)
*
*      KEYWORD VARIABLE      PTR TO KVBLK (SEE KVBLK)
*
*      PSEUDO-VARIABLES ARE HANDLED AS SPECIAL CASES BY THE
*      ACCESS PROCEDURE (ACESS) AND THE ASSIGNMENT PROCEDURE
*      (ASIGN). SEE THESE TWO PROCEDURES FOR DETAILS.
{{EJC{{{{{3393
*
*      ORGANIZATION OF DATA AREA
*      -------------------------
*
*
*      THE DATA AREA IS DIVIDED INTO TWO REGIONS.
*
*      STATIC AREA
*
*      THE STATIC AREA BUILDS UP FROM THE BOTTOM AND CONTAINS
*      DATA AREAS WHICH ARE ALLOCATED DYNAMICALLY BUT ARE NEVER
*      DELETED OR MOVED AROUND. THE MACRO-PROGRAM ITSELF
*      USES THE STATIC AREA FOR THE FOLLOWING.
*
*      1)   ALL VARIABLE BLOCKS (VRBLK).
*
*      2)   THE HASH TABLE FOR VARIABLE BLOCKS.
*
*      3)   MISCELLANEOUS BUFFERS AND WORK AREAS (SEE PROGRAM
*           INITIALIZATION SECTION).
*
*      IN ADDITION, THE SYSTEM PROCEDURES MAY USE THIS AREA FOR
*      INPUT/OUTPUT BUFFERS, EXTERNAL FUNCTIONS ETC. SPACE IN
*      THE STATIC REGION IS ALLOCATED BY CALLING PROCEDURE ALOST
*
*      THE FOLLOWING GLOBAL VARIABLES DEFINE THE CURRENT
*      LOCATION AND SIZE OF THE STATIC AREA.
*
*      STATB                 ADDRESS OF START OF STATIC AREA
*      STATE                 ADDRESS+1 OF LAST WORD IN AREA.
*
*      THE MINIMUM SIZE OF STATIC IS GIVEN APPROXIMATELY BY
*           12 + *E$HNB + *E$STS + SPACE FOR ALPHABET STRING
*           AND STANDARD PRINT BUFFER.
{{EJC{{{{{3428
*
*      DYNAMIC AREA
*
*      THE DYNAMIC AREA IS BUILT UPWARDS IN MEMORY AFTER THE
*      STATIC REGION. DATA IN THIS AREA MUST ALL BE IN STANDARD
*      BLOCK FORMATS SO THAT IT CAN BE PROCESSED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL). GBCOL COMPACTS BLOCKS DOWN
*      IN THIS REGION AS REQUIRED BY SPACE EXHAUSTION AND CAN
*      ALSO MOVE ALL BLOCKS UP TO ALLOW FOR EXPANSION OF THE
*      STATIC REGION.
*      WITH THE EXCEPTION OF TABLES AND ARRAYS, NO SPITBOL
*      OBJECT ONCE BUILT IN DYNAMIC MEMORY IS EVER SUBSEQUENTLY
*      MODIFIED. OBSERVING THIS RULE NECESSITATES A COPYING
*      ACTION DURING STRING AND PATTERN CONCATENATION.
*
*      GARBAGE COLLECTION IS FUNDAMENTAL TO THE ALLOCATION OF
*      SPACE FOR VALUES. SPITBOL USES A VERY EFFICIENT GARBAGE
*      COLLECTOR WHICH INSISTS THAT POINTERS INTO DYNAMIC STORE
*      SHOULD BE IDENTIFIABLE WITHOUT USE OF BIT TABLES,
*      MARKER BITS ETC. TO SATISFY THIS REQUIREMENT, DYNAMIC
*      MEMORY MUST NOT START AT TOO LOW AN ADDRESS AND LENGTHS
*      OF ARRAYS, TABLES, STRINGS, CODE AND EXPRESSION BLOCKS
*      MAY NOT EXCEED THE NUMERICAL VALUE OF THE LOWEST DYNAMIC
*      ADDRESS. TO AVOID EITHER PENALIZING USERS WITH MODEST
*      REQUIREMENTS OR RESTRICTING THOSE WITH GREATER NEEDS ON
*      HOST SYSTEMS WHERE DYNAMIC MEMORY IS ALLOCATED IN LOW
*      ADDRESSES, THE MINIMUM DYNAMIC ADDRESS MAY BE SPECIFIED
*      SUFFICIENTLY HIGH TO PERMIT ARBITRARILY LARGE SPITBOL
*      OBJECTS TO BE CREATED ( WITH THE POSSIBILITY IN EXTREME
*      CASES OF WASTING LARGE AMOUNTS OF MEMORY BELOW THE
*      START ADDRESS). THIS MINIMUM VALUE IS MADE AVAILABLE
*      IN VARIABLE MXLEN BY A SYSTEM ROUTINE, SYSMX.
*      ALTERNATIVELY SYSMX MAY INDICATE THAT A
*      DEFAULT MAY BE USED IN WHICH DYNAMIC IS PLACED
*      AT THE LOWEST POSSIBLE ADDRESS FOLLOWING STATIC.
*
*      THE FOLLOWING GLOBAL WORK CELLS DEFINE THE LOCATION AND
*      LENGTH OF THE DYNAMIC AREA.
*
*      DNAMB                 START OF DYNAMIC AREA
*      DNAMP                 NEXT AVAILABLE LOCATION
*      DNAME                 LAST AVAILABLE LOCATION + 1
*
*      DNAMB IS ALWAYS HIGHER THAN STATE SINCE THE ALOST
*      PROCEDURE MAINTAINS SOME EXPANSION SPACE ABOVE STATE.
*      *** DNAMB MUST NEVER BE PERMITTED TO HAVE A VALUE LESS
*      THAN THAT IN MXLEN ***
*
*      SPACE IN THE DYNAMIC REGION IS ALLOCATED BY THE ALLOC
*      PROCEDURE. THE DYNAMIC REGION MAY BE USED BY SYSTEM
*      PROCEDURES PROVIDED THAT ALL THE RULES ARE OBEYED.
{{EJC{{{{{3480
*
*      REGISTER USAGE
*      --------------
*
*      (CP)                  CODE POINTER REGISTER. USED TO
*                            HOLD A POINTER TO THE CURRENT
*                            LOCATION IN THE INTERPRETIVE PSEUDO
*                            CODE (I.E. PTR INTO A CDBLK).
*
*      (XL,XR)               GENERAL INDEX REGISTERS. USUALLY
*                            USED TO HOLD POINTERS TO BLOCKS IN
*                            DYNAMIC STORAGE. AN IMPORTANT
*                            RESTRICTION IS THAT THE VALUE IN
*                            XL MUST BE COLLECTABLE FOR
*                            A GARBAGE COLLECT CALL. A VALUE
*                            IS COLLECTABLE IF IT EITHER POINTS
*                            OUTSIDE THE DYNAMIC AREA, OR IF IT
*                            POINTS TO THE START OF A BLOCK IN
*                            THE DYNAMIC AREA.
*
*      (XS)                  STACK POINTER. USED TO POINT TO
*                            THE STACK FRONT. THE STACK MAY
*                            BUILD UP OR DOWN AND IS USED
*                            TO STACK SUBROUTINE RETURN POINTS
*                            AND OTHER RECURSIVELY SAVED DATA.
*
*      (XT)                  AN ALTERNATIVE NAME FOR XL DURING
*                            ITS USE IN ACCESSING STACKED ITEMS.
*
*      (WA,WB,WC)            GENERAL WORK REGISTERS. CANNOT BE
*                            USED FOR INDEXING, BUT MAY HOLD
*                            VARIOUS TYPES OF DATA.
*
*      (IA)                  USED FOR ALL SIGNED INTEGER
*                            ARITHMETIC, BOTH THAT USED BY THE
*                            TRANSLATOR AND THAT ARISING FROM
*                            USE OF SNOBOL4 ARITHMETIC OPERATORS
*
*      (RA)                  REAL ACCUMULATOR. USED FOR ALL
*                            FLOATING POINT ARITHMETIC.
{{EJC{{{{{3521
*
*      SPITBOL CONDITIONAL ASSEMBLY SYMBOLS
*      ------------------------------------
*
*      IN THE SPITBOL TRANSLATOR, THE FOLLOWING CONDITIONAL
*      ASSEMBLY SYMBOLS ARE REFERRED TO. TO INCORPORATE THE
*      FEATURES REFERRED TO, THE MINIMAL SOURCE SHOULD BE
*      PREFACED BY SUITABLE CONDITIONAL ASSEMBLY SYMBOL
*      DEFINITIONS.
*      IN ALL CASES IT IS PERMISSIBLE TO DEFAULT THE DEFINITIONS
*      IN WHICH CASE THE ADDITIONAL FEATURES WILL BE OMITTED
*      FROM THE TARGET CODE.
*
*      .CAEX                 DEFINE TO ALLOW UP ARROW FOR EXPON.
*      .CAHT                 DEFINE TO INCLUDE HORIZONTAL TAB
*      .CASL                 DEFINE TO INCLUDE 26 SHIFTED LETTRS
*      .CAVT                 DEFINE TO INCLUDE VERTICAL TAB
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CGBC                 DEFINE TO INCLUDE SYSGC FUNCTION
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*      .CIOD                 DEFINE TO NOT USE DEFAULT DELIMITER
*                              IN PROCESSING 3RD ARG OF INPUT()
*                              AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNBF                 DEFINE TO OMIT BUFFER EXTENSION
*      .CNBT                 DEFINE TO OMIT BATCH INITIALISATION
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLD                 DEFINE TO OMIT LOAD() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE FOR LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE TO NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*                            OMIT TO TAKE DEFAULT OF 50000
*      .CSAX                 DEFINE IF SYSAX IS TO BE CALLED
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSN8                 DEFINE TO PAD STMT NOS TO 8 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTET                 DEFINE TO TABLE ENTRY TRACE WANTED
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*      .CUCF                 DEFINE TO INCLUDE CFP$U
*      .CUEJ                 DEFINE TO SUPPRESS NEEDLESS EJECTS
*      .CULK                 DEFINE TO INCLUDE &L/UCASE KEYWORDS
*      .CULC                 DEFINE TO INCLUDE &CASE (LC NAMES)
*                            IF CUCL DEFINED, MUST SUPPORT
*                            MINIMAL OP FLC WREG THAT FOLDS
*                            ARGUMENT TO UPPER CASE
*      .CUST                 DEFINE TO INCLUDE SET() CODE
*
*                            CONDITIONAL OPTIONS
*                            SINCE .UNDEF NOT ALLOWED IF SYMBOL
*                            NOT DEFINED, A FULL COMMENT LINE
*                            INDICATES SYMBOL INITIALLY NOT
*                            DEFINED.
*
*      .CBYT                 DEFINE FOR STATISTICS IN BYTES
*      .CCMC                 DEFINE TO INCLUDE SYSCM FUNCTION
*      .CCMK                 DEFINE TO INCLUDE COMPARE KEYWORD
*      .CEPP                 DEFINE IF ENTRYS HAVE ODD PARITY
*      .CERA                 DEFINE TO INCLUDE SYSEA FUNCTION
*      .CEXP                 DEFINE IF SPITBOL POPS SYSEX ARGS
*      .CICC                 DEFINE TO IGNORE BAD CONTROL CARDS
*      .CINC                 DEFINE TO ADD -INCLUDE CONTROL CARD
*                            IN PROCESSING 3RD ARG OF INPUT()
*                            AND OUTPUT()
*      .CMTH                 DEFINE TO INCLUDE MATH FUNCTIONS
*      .CNCI                 DEFINE TO ENABLE SYSCI ROUTINE
*      .CNCR                 DEFINE TO ENABLE SYSCR ROUTINE
*      .CNEX                 DEFINE TO OMIT EXIT() CODE.
*      .CNLF                 DEFINE TO ADD FILE TYPE TO LOAD()
*      .CNPF                 DEFINE TO OMIT PROFILE STUFF
*      .CNRA                 DEFINE TO OMIT ALL REAL ARITHMETIC
*      .CNSC                 DEFINE IF NO NUMERIC-STRING COMPARE
*      .CNSR                 DEFINE TO OMIT SORT, RSORT
*      .CPOL                 DEFINE IF INTERFACE POLLING DESIRED
*      .CREL                 DEFINE TO INCLUDE RELOC ROUTINES
*      .CRPP                 DEFINE IF RETURNS HAVE ODD PARITY
*      .CS16                 DEFINE TO INITIALIZE STLIM TO 32767
*      .CS32                 DEFINE TO INIT STLIM TO 2147483647
*      .CSED                 DEFINE TO USE SEDIMENT IN GBCOL
*      .CSFN                 DEFINE TO TRACK SOURCE FILE NAMES
*      .CSLN                 DEFINE IF LINE NUMBER IN CODE BLOCK
*      .CSN5                 DEFINE TO PAD STMT NOS TO 5 CHARS
*      .CSN6                 DEFINE TO PAD STMT NOS TO 6 CHARS
*      .CSOU                 DEFINE IF OUTPUT, TERMINAL TO SYSOU
*      .CTMD                 DEFINE IF SYSTM UNIT IS DECISECOND
*
*      FORCE DEFINITION OF .CCMK IF .CCMC IS DEFINED
*
{{TTL{27,S P I T B O L -- PROCEDURES SECTION{{{{3648
*
*      THIS SECTION STARTS WITH DESCRIPTIONS OF THE OPERATING
*      SYSTEM DEPENDENT PROCEDURES WHICH ARE USED BY THE SPITBOL
*      TRANSLATOR. ALL SUCH PROCEDURES HAVE FIVE LETTER NAMES
*      BEGINNING WITH SYS. THEY ARE LISTED IN ALPHABETICAL
*      ORDER.
*      ALL PROCEDURES HAVE A  SPECIFICATION CONSISTING OF A
*      MODEL CALL, PRECEDED BY A POSSIBLY EMPTY LIST OF REGISTER
*      CONTENTS GIVING PARAMETERS AVAILABLE TO THE PROCEDURE AND
*      FOLLOWED BY A POSSIBLY EMPTY LIST OF REGISTER CONTENTS
*      REQUIRED ON RETURN FROM THE CALL OR WHICH MAY HAVE HAD
*      THEIR CONTENTS DESTROYED. ONLY THOSE REGISTERS EXPLICITLY
*      MENTIONED IN THE LIST AFTER THE CALL MAY HAVE THEIR
*      VALUES CHANGED.
*      THE SEGMENT OF CODE PROVIDING THE EXTERNAL PROCEDURES IS
*      CONVENIENTLY REFERRED TO AS OSINT (OPERATING SYSTEM
*      INTERFACE). THE SYSXX PROCEDURES IT CONTAINS PROVIDE
*      FACILITIES NOT USUALLY AVAILABLE AS PRIMITIVES IN
*      ASSEMBLY LANGUAGES. FOR PARTICULAR TARGET MACHINES,
*      IMPLEMENTORS MAY CHOOSE FOR SOME MINIMAL OPCODES WHICH
*      DO NOT HAVE REASONABLY DIRECT TRANSLATIONS, TO USE CALLS
*      OF ADDITIONAL PROCEDURES WHICH THEY PROVIDE IN OSINT.
*      E.G. MWB OR TRC MIGHT BE TRANSLATED AS JSR SYSMB,
*      JSR SYSTC IN SOME IMPLEMENTATIONS.
*
*      IN THE DESCRIPTIONS, REFERENCE IS MADE TO --BLK
*      FORMATS (-- = A PAIR OF LETTERS). SEE THE SPITBOL
*      DEFINITIONS SECTION FOR DETAILED DESCRIPTIONS OF ALL
*      SUCH BLOCK FORMATS EXCEPT FCBLK FOR WHICH SYSFC SHOULD
*      BE CONSULTED.
*
*      SECTION 0 CONTAINS INP,INR SPECIFICATIONS OF INTERNAL
*      PROCEDURES,ROUTINES. THIS GIVES A SINGLE PASS TRANSLATOR
*      INFORMATION MAKING IT EASY TO GENERATE ALTERNATIVE CALLS
*      IN THE TRANSLATION OF JSR-S FOR PROCEDURES OF DIFFERENT
*      TYPES IF THIS PROVES NECESSARY.
*
{{SEC{{{{START OF PROCEDURES SECTION{3686
{{EJC{{{{{3688
*
*      SYSAX -- AFTER EXECUTION
*
{SYSAX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3692
*
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CSAX IS DEFINED,
*      THIS ROUTINE IS CALLED IMMEDIATELY AFTER EXECUTION AND
*      BEFORE PRINTING OF EXECUTION STATISTICS OR DUMP OUTPUT.
*      PURPOSE OF CALL IS FOR IMPLEMENTOR TO DETERMINE AND
*      IF THE CALL IS NOT REQUIRED IT WILL BE OMITTED IF .CSAX
*      IS UNDEFINED. IN THIS CASE SYSAX NEED NOT BE CODED.
*
*      JSR  SYSAX            CALL AFTER EXECUTION
{{EJC{{{{{3704
*
*      SYSBS -- BACKSPACE FILE
*
{SYSBS{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3709
*
*      SYSBS IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION BACKSPACE
*      IF THE CONDITIONAL ASSEMBLY SYMBOL .CBSP IS DEFINED.
*      THE MEANING IS SYSTEM DEPENDENT.  IN GENERAL, BACKSPACE
*      REPOSITIONS THE FILE ONE RECORD CLOSER TO THE BEGINNING
*      OF FILE, SUCH THAT A SUBSEQUENT READ OR WRITE WILL
*      OPERATE ON THE PREVIOUS RECORD.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  BACKSPACE ARGUMENT (SCBLK PTR)
*      JSR  SYSBS            CALL TO BACKSPACE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF BACKSPACE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      BACKSPACE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      FILES ON CHARACTER DEVICES ARE IN THIS CATEGORY.
{{EJC{{{{{3729
*
*      SYSBX -- BEFORE EXECUTION
*
{SYSBX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3734
*
*      CALLED AFTER INITIAL SPITBOL COMPILATION AND BEFORE
*      COMMENCING EXECUTION IN CASE OSINT NEEDS
*      TO ASSIGN FILES OR PERFORM OTHER NECESSARY SERVICES.
*      OSINT MAY ALSO CHOOSE TO SEND A MESSAGE TO ONLINE
*      TERMINAL (IF ANY) INDICATING THAT EXECUTION IS STARTING.
*
*      JSR  SYSBX            CALL BEFORE EXECUTION STARTS
{{EJC{{{{{3743
*
*      SYSCR -- CONVERT REAL
*
{SYSCR{EXP{{{{{3801
*
*      SYSCR IS AN OPTIONAL OSINT ROUTINE THAT CAUSES SPITBOL TO
*      CALL SYSCR TO CONVERT REAL VALUES TO STRINGS, RATHER
*      THAN USING THE INTERNAL SPITBOL CONVERSION CODE.  THIS
*      CODE MAY BE DESIRED ON MACHINES WHERE THE INTEGER SIZE
*      IS TOO SMALL TO ALLOW PRODUCTION OF A SUFFICIENT NUMBER
*      OF SIGNIFICANT DIGITS.  THE SYMBOL .CNCR MUST BE DEFINED
*      IF THIS ROUTINE IS TO BE USED.
*
*      THE RULES FOR CONVERTING REALS TO STRINGS ARE THAT
*      POSITIVE VALUES ARE REPRESENTED WITHOUT ANY SIGN, AND
*      THERE ARE NEVER ANY LEADING BLANKS OR ZEROS, EXCEPT IN
*      THE CASE OF ZERO ITSELF WHICH IS REPRESENTED AS A SINGLE
*      ZERO DIGIT.  NEGATIVE NUMBERS ARE REPRESENTED WITH A
*      PRECEEDING MINUS SIGN.  THERE ARE NEVER ANY TRAILING
*      BLANKS, OR TRAILING ZEROS IN THE FRACTIONAL PART.
*      CONVERSION CANNOT FAIL.
*
*      (RA)                  VALUE TO BE CONVERTED
*      (WA)                  NO. OF SIGNIFICANT DIGITS DESIRED
*      (WB)                  CONVERSION TYPE:
*                             NEGATIVE FOR E-TYPE CONVERSION
*                             ZERO FOR G-TYPE CONVERSION
*                             POSITIVE FOR F-TYPE CONVERSION
*      (WC)                  CHARACTER POSITIONS IN RESULT SCBLK
*      (XR)                  SCBLK FOR RESULT
*      JSR  SYSCR            CALL TO CONVERT REAL VALUE
*      (XR)                  RESULT SCBLK
*      (WA)                  NUMBER OF RESULT CHARACTERS
{{EJC{{{{{3831
*
*      SYSDC -- DATE CHECK
*
{SYSDC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3837
*
*      SYSDC IS CALLED TO CHECK THAT THE EXPIRY DATE FOR A TRIAL
*      VERSION OF SPITBOL IS UNEXPIRED.
*
*      JSR  SYSDC            CALL TO CHECK DATE
*      RETURN ONLY IF DATE IS OK
{{EJC{{{{{3844
*
*      SYSDM  -- DUMP CORE
*
{SYSDM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3848
*
*      SYSDM IS CALLED BY A SPITBOL PROGRAM CALL OF DUMP(N) WITH
*      N GE 4.  ITS PURPOSE IS TO PROVIDE A CORE DUMP.
*      N COULD HOLD AN ENCODING OF THE START ADRS FOR DUMP AND
*      AMOUNT TO BE DUMPED E.G.  N = 256*A + S , S = START ADRS
*      IN KILOWORDS,  A = KILOWORDS TO DUMP
*
*      (XR)                  PARAMETER N OF CALL DUMP(N)
*      JSR  SYSDM            CALL TO ENTER ROUTINE
{{EJC{{{{{3858
*
*      SYSDT -- GET CURRENT DATE
*
{SYSDT{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3862
*
*      SYSDT IS USED TO OBTAIN THE CURRENT DATE. THE DATE IS
*      RETURNED AS A CHARACTER STRING IN ANY FORMAT APPROPRIATE
*      TO THE OPERATING SYSTEM IN USE. IT MAY ALSO CONTAIN THE
*      CURRENT TIME OF DAY. SYSDT IS USED TO IMPLEMENT THE
*      SNOBOL4 FUNCTION DATE.
*
*      (XR)                  PARAMETER N OF CALL DATE(N)
*      JSR  SYSDT            CALL TO GET DATE
*      (XL)                  POINTER TO BLOCK CONTAINING DATE
*
*      THE FORMAT OF THE BLOCK IS LIKE AN SCBLK EXCEPT THAT
*      THE FIRST WORD NEED NOT BE SET. THE RESULT IS COPIED
*      INTO SPITBOL DYNAMIC MEMORY ON RETURN.
{{EJC{{{{{3878
*
*      SYSEA -- INFORM OSINT OF COMPILATION AND RUNTIME ERRORS
*
{SYSEA{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3882
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS ON
*      ERRORS
*
*      (WA)                  ERROR CODE
*      (WB)                  LINE NUMBER
*      (WC)                  COLUMN NUMBER
*      (XR)                  SYSTEM STAGE
*      (XL)                  FILE NAME (SCBLK)
*      JSR  SYSEA            CALL TO SYSEA FUNCTION
*      PPM  LOC              SUPPRESS PRINTING OF ERROR MESSAGE
*      (XR)                  MESSAGE TO PRINT (SCBLK) OR 0
*
*      SYSEA MAY NOT RETURN IF INTERFACE CHOOSES TO RETAIN
*      CONTROL.  CLOSING FILES VIA THE FCB CHAIN WILL BE THE
*      RESPONSIBILITY OF THE INTERFACE.
*
*      ALL REGISTERS PRESERVED
{{EJC{{{{{3904
*
*      SYSEF -- EJECT FILE
*
{SYSEF{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3908
*
*      SYSEF IS USED TO WRITE A PAGE EJECT TO A NAMED FILE. IT
*      MAY ONLY BE USED FOR FILES WHERE THIS CONCEPT MAKES
*      SENSE. NOTE THAT SYSEF IS NOT NORMALLY USED FOR THE
*      STANDARD OUTPUT FILE (SEE SYSEP).
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  EJECT ARGUMENT (SCBLK PTR)
*      JSR  SYSEF            CALL TO EJECT FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF INAPPROPRIATE FILE
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{3921
*
*      SYSEJ -- END OF JOB
*
{SYSEJ{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3925
*
*      SYSEJ IS CALLED ONCE AT THE END OF EXECUTION TO
*      TERMINATE THE RUN. THE SIGNIFICANCE OF THE ABEND AND
*      CODE VALUES IS SYSTEM DEPENDENT. IN GENERAL, THE CODE
*      VALUE SHOULD BE MADE AVAILABLE FOR TESTING, AND THE
*      ABEND VALUE SHOULD CAUSE SOME POST-MORTEM ACTION SUCH AS
*      A DUMP. NOTE THAT SYSEJ DOES NOT RETURN TO ITS CALLER.
*      SEE SYSXI FOR DETAILS OF FCBLK CHAIN
*
*      (WA)                  VALUE OF ABEND KEYWORD
*      (WB)                  VALUE OF CODE KEYWORD
*      (XL)                  O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSEJ            CALL TO END JOB
*
*      THE FOLLOWING SPECIAL VALUES ARE USED AS CODES IN (WB)
*      999  EXECUTION SUPPRESSED
*      998  STANDARD OUTPUT FILE FULL OR UNAVAILABLE IN A SYSXI
*           LOAD MODULE. IN THESE CASES (WA) CONTAINS THE NUMBER
*           OF THE STATEMENT CAUSING PREMATURE TERMINATION.
{{EJC{{{{{3945
*
*      SYSEM -- GET ERROR MESSAGE TEXT
*
{SYSEM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3949
*
*      SYSEM IS USED TO OBTAIN THE TEXT OF ERR, ERB CALLS IN THE
*      SOURCE PROGRAM GIVEN THE ERROR CODE NUMBER. IT IS ALLOWED
*      TO RETURN A NULL STRING IF THIS FACILITY IS UNAVAILABLE.
*
*      (WA)                  ERROR CODE NUMBER
*      JSR  SYSEM            CALL TO GET TEXT
*      (XR)                  TEXT OF MESSAGE
*
*      THE RETURNED VALUE IS A POINTER TO A BLOCK IN SCBLK
*      FORMAT EXCEPT THAT THE FIRST WORD NEED NOT BE SET. THE
*      STRING IS COPIED INTO DYNAMIC MEMORY ON RETURN.
*      IF THE NULL STRING IS RETURNED EITHER BECAUSE SYSEM DOES
*      NOT PROVIDE ERROR MESSAGE TEXTS OR BECAUSE WA IS OUT OF
*      RANGE, SPITBOL WILL PRINT THE STRING STORED IN ERRTEXT
*      KEYWORD.
{{EJC{{{{{3966
*
*      SYSEN -- ENDFILE
*
{SYSEN{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3970
*
*      SYSEN IS USED TO IMPLEMENT THE SNOBOL4 FUNCTION ENDFILE.
*      THE MEANING IS SYSTEM DEPENDENT. IN GENERAL, ENDFILE
*      IMPLIES THAT NO FURTHER I/O OPERATIONS WILL BE PERFORMED,
*      BUT DOES NOT GUARANTEE THIS TO BE THE CASE. THE FILE
*      SHOULD BE CLOSED AFTER THE CALL, A SUBSEQUENT READ
*      OR WRITE MAY REOPEN THE FILE AT THE START OR IT MAY BE
*      NECESSARY TO REOPEN THE FILE VIA SYSIO.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  ENDFILE ARGUMENT (SCBLK PTR)
*      JSR  SYSEN            CALL TO ENDFILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF ENDFILE NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED FOR FILES FOR WHICH
*      ENDFILE IS NOT PERMITTED. FOR EXAMPLE, IT MAY BE EXPECTED
*      THAT THE STANDARD INPUT AND OUTPUT FILES ARE IN THIS
*      CATEGORY.
{{EJC{{{{{3992
*
*      SYSEP -- EJECT PRINTER PAGE
*
{SYSEP{EXP{{{{DEFINE EXTERNAL ENTRY POINT{3996
*
*      SYSEP IS CALLED TO PERFORM A PAGE EJECT ON THE STANDARD
*      PRINTER OUTPUT FILE (CORRESPONDING TO SYSPR OUTPUT).
*
*      JSR  SYSEP            CALL TO EJECT PRINTER OUTPUT
{{EJC{{{{{4002
*
*      SYSEX -- CALL EXTERNAL FUNCTION
*
{SYSEX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4006
*
*      SYSEX IS CALLED TO PASS CONTROL TO AN EXTERNAL FUNCTION
*      PREVIOUSLY LOADED WITH A CALL TO SYSLD.
*
*      (XS)                  POINTER TO ARGUMENTS ON STACK
*      (XL)                  POINTER TO CONTROL BLOCK (EFBLK)
*      (WA)                  NUMBER OF ARGUMENTS ON STACK
*      JSR  SYSEX            CALL TO PASS CONTROL TO FUNCTION
*      PPM  LOC              RETURN HERE IF FUNCTION CALL FAILS
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      PPM  LOC              RETURN HERE IF BAD ARGUMENT TYPE
*      (XR)                  RESULT RETURNED
*
*      THE ARGUMENTS ARE STORED ON THE STACK WITH
*      THE LAST ARGUMENT AT 0(XS). ON RETURN, XS
*      IS POPPED PAST THE ARGUMENTS.
*
*      THE FORM OF THE ARGUMENTS AS PASSED IS THAT USED IN THE
*      SPITBOL TRANSLATOR (SEE DEFINITIONS AND DATA STRUCTURES
*      SECTION). THE CONTROL BLOCK FORMAT IS ALSO DESCRIBED
*      (UNDER EFBLK) IN THIS SECTION.
*
*      THERE ARE TWO WAYS OF RETURNING A RESULT.
*
*      1)   RETURN A POINTER TO A BLOCK IN DYNAMIC STORAGE. THIS
*           BLOCK MUST BE IN EXACTLY CORRECT FORMAT, INCLUDING
*           THE FIRST WORD. ONLY FUNCTIONS WRITTEN WITH INTIMATE
*           KNOWLEDGE OF THE SYSTEM WILL RETURN IN THIS WAY.
*
*      2)   STRING, INTEGER AND REAL RESULTS MAY BE RETURNED BY
*           POINTING TO A PSEUDO-BLOCK OUTSIDE DYNAMIC MEMORY.
*           THIS BLOCK IS IN ICBLK, RCBLK OR SCBLK FORMAT EXCEPT
*           THAT THE FIRST WORD WILL BE OVERWRITTEN
*           BY A TYPE WORD ON RETURN AND SO NEED NOT
*           BE CORRECTLY SET. SUCH A RESULT IS
*           COPIED INTO MAIN STORAGE BEFORE PROCEEDING.
*           UNCONVERTED RESULTS MAY SIMILARLY BE RETURNED IN A
*           PSEUDO-BLOCK WHICH IS IN CORRECT FORMAT INCLUDING
*           TYPE WORD RECOGNISABLE BY GARBAGE COLLECTOR SINCE
*           BLOCK IS COPIED INTO DYNAMIC MEMORY.
{{EJC{{{{{4051
*
*      SYSFC -- FILE CONTROL BLOCK ROUTINE
*
{SYSFC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4055
*
*      SEE ALSO SYSIO
*      INPUT AND OUTPUT HAVE 3 ARGUMENTS REFERRED TO AS SHOWN
*           INPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*           OUTPUT(VARIABLE NAME,FILE ARG1,FILE ARG2)
*      FILE ARG1 MAY BE AN INTEGER OR STRING USED TO IDENTIFY
*      AN I/O CHANNEL. IT IS CONVERTED TO A STRING FOR CHECKING.
*      THE EXACT SIGNIFICANCE OF FILE ARG2
*      IS NOT RIGOROUSLY PRESCRIBED BUT TO IMPROVE PORTABILITY,
*      THE SCHEME DESCRIBED IN THE SPITBOL USER MANUAL
*      SHOULD BE ADOPTED WHEN POSSIBLE. THE PREFERRED FORM IS
*      A STRING $F$,R$R$,C$C$,I$I$,...,Z$Z$  WHERE
*      $F$ IS AN OPTIONAL FILE NAME WHICH IS PLACED FIRST.
*       REMAINING ITEMS MAY BE OMITTED OR INCLUDED IN ANY ORDER.
*      $R$ IS MAXIMUM RECORD LENGTH
*      $C$ IS A CARRIAGE CONTROL CHARACTER OR CHARACTER STRING
*      $I$ IS SOME FORM OF CHANNEL IDENTIFICATION USED IN THE
*         ABSENCE OF $F$ TO ASSOCIATE THE VARIABLE
*         WITH A FILE ALLOCATED DYNAMICALLY BY JCL COMMANDS AT
*         SPITBOL LOAD TIME.
*      ,...,Z$Z$ ARE ADDITIONAL FIELDS.
*      IF , (COMMA) CANNOT BE USED AS A DELIMITER, .CIOD
*      SHOULD BE DEFINED TO INTRODUCE BY CONDITIONAL ASSEMBLY
*      ANOTHER DELIMITER (SEE
*        IODEL  EQU  *
*      EARLY IN DEFINITIONS SECTION).
*      SYSFC IS CALLED WHEN A VARIABLE IS INPUT OR OUTPUT
*      ASSOCIATED TO CHECK FILE ARG1 AND FILE ARG2 AND
*      TO  REPORT WHETHER AN FCBLK (FILE CONTROL
*      BLOCK) IS NECESSARY AND IF SO WHAT SIZE IT SHOULD BE.
*      THIS MAKES IT POSSIBLE FOR SPITBOL RATHER THAN OSINT TO
*      ALLOCATE SUCH A BLOCK IN DYNAMIC MEMORY IF REQUIRED
*      OR ALTERNATIVELY IN STATIC MEMORY.
*      THE SIGNIFICANCE OF AN FCBLK , IF ONE IS REQUESTED, IS
*      ENTIRELY UP TO THE SYSTEM INTERFACE. THE ONLY RESTRICTION
*      IS THAT IF THE FCBLK SHOULD APPEAR TO LIE IN DYNAMIC
*      MEMORY, POINTERS TO IT SHOULD BE PROPER POINTERS TO
*      THE START OF A RECOGNISABLE AND GARBAGE COLLECTABLE
*      BLOCK (THIS CONDITION WILL BE MET IF SYSFC REQUESTS
*      SPITBOL TO PROVIDE AN FCBLK).
*      AN OPTION IS PROVIDED FOR OSINT TO RETURN A POINTER IN
*      XL TO AN FCBLK WHICH IT PRIVATELY ALLOCATED. THIS PTR
*      WILL BE MADE AVAILABLE WHEN I/O OCCURS LATER.
*      PRIVATE FCBLKS MAY HAVE ARBITRARY CONTENTS AND SPITBOL
*      STORES NOTHING IN THEM.
{{EJC{{{{{4101
*      THE REQUESTED SIZE FOR AN FCBLK IN DYNAMIC MEMORY
*      SHOULD ALLOW A 2 WORD OVERHEAD FOR BLOCK TYPE AND
*      LENGTH FIELDS. INFORMATION SUBSEQUENTLY STORED IN THE
*      REMAINING WORDS MAY BE ARBITRARY IF AN XNBLK (EXTERNAL
*      NON-RELOCATABLE BLOCK) IS REQUESTED. IF THE REQUEST IS
*      FOR AN XRBLK (EXTERNAL RELOCATABLE BLOCK) THE
*      CONTENTS OF WORDS SHOULD BE COLLECTABLE (I.E. ANY
*      APPARENT POINTERS INTO DYNAMIC SHOULD BE GENUINE BLOCK
*      POINTERS). THESE RESTRICTIONS DO NOT APPLY IF AN FCBLK
*      IS ALLOCATED OUTSIDE DYNAMIC OR IS NOT ALLOCATED AT ALL.
*      IF AN FCBLK IS REQUESTED, ITS FIELDS WILL BE INITIALISED
*      TO ZERO BEFORE ENTRY TO SYSIO WITH THE EXCEPTION OF
*      WORDS 0 AND 1 IN WHICH THE BLOCK TYPE AND LENGTH
*      FIELDS ARE PLACED FOR FCBLKS IN DYNAMIC MEMORY ONLY.
*      FOR THE POSSIBLE USE OF SYSEJ AND SYSXI, IF FCBLKS
*      ARE USED, A CHAIN IS BUILT SO THAT THEY MAY ALL BE
*      FOUND - SEE SYSXI FOR DETAILS.
*      IF BOTH FILE ARG1 AND FILE ARG2 ARE NULL, CALLS OF SYSFC
*      AND SYSIO ARE OMITTED.
*      IF FILE ARG1 IS NULL (STANDARD INPUT/OUTPUT FILE), SYSFC
*      IS CALLED TO CHECK NON-NULL FILE ARG2 BUT ANY REQUEST
*      FOR AN FCBLK WILL BE IGNORED, SINCE SPITBOL HANDLES THE
*      STANDARD FILES SPECIALLY AND CANNOT READILY KEEP FCBLK
*      POINTERS FOR THEM.
*      FILEARG1 IS TYPE CHECKED BY SPITBOL SO FURTHER CHECKING
*      MAY BE UNNECCESSARY IN MANY IMPLEMENTATIONS.
*      FILE ARG2 IS PASSED SO THAT SYSFC MAY ANALYSE AND
*      CHECK IT. HOWEVER TO ASSIST IN THIS, SPITBOL ALSO PASSES
*      ON THE STACK THE COMPONENTS OF THIS ARGUMENT WITH
*      FILE NAME, $F$ (OTHERWISE NULL) EXTRACTED AND STACKED
*      FIRST.
*      THE OTHER FIELDS, IF ANY, ARE EXTRACTED AS SUBSTRINGS,
*      POINTERS TO THEM ARE STACKED AND A COUNT OF ALL ITEMS
*      STACKED IS PLACED IN WC. IF AN FCBLK WAS EARLIER
*      ALLOCATED AND POINTED TO VIA FILE ARG1, SYSFC IS ALSO
*      PASSED A POINTER TO THIS FCBLK.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILEARG2 (3RD ARG) OR NULL
*      -(XS)...-(XS)         SCBLKS FOR $F$,$R$,$C$,...
*      (WC)                  NO. OF STACKED SCBLKS ABOVE
*      (WA)                  EXISTING FILE ARG1 FCBLK PTR OR 0
*      (WB)                  0/3 FOR INPUT/OUTPUT ASSOCN
*      JSR  SYSFC            CALL TO CHECK NEED FOR FCBLK
*      PPM  LOC              INVALID FILE ARGUMENT
*      PPM  LOC              FCBLK ALREADY IN USE
*      (XS)                  POPPED (WC) TIMES
*      (WA NON ZERO)         BYTE SIZE OF REQUESTED FCBLK
*      (WA=0,XL NON ZERO)    PRIVATE FCBLK PTR IN XL
*      (WA=XL=0)             NO FCBLK WANTED, NO PRIVATE FCBLK
*      (WC)                  0/1/2 REQUEST ALLOC OF XRBLK/XNBLK
*                            /STATIC BLOCK FOR USE AS FCBLK
*      (WB)                  DESTROYED
{{EJC{{{{{4156
*
*      SYSGC -- INFORM INTERFACE OF GARBAGE COLLECTIONS
*
{SYSGC{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4160
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS
*      PRIOR TO AND AFTER A GARBAGE COLLECTION.
*
*      POSSIBLE USAGES-
*      1. PROVIDE VISIBLE SCREEN ICON OF GARBAGE COLLECTION
*         IN PROGRESS
*      2. INFORM VIRTUAL MEMORY MANAGER TO IGNORE PAGE ACCESS
*         PATTERNS DURING GARBAGE COLLECTION.  SUCH ACCESSES
*         TYPICALLY DESTROY THE PAGE WORKING SET ACCUMULATED
*         BY THE PROGRAM.
*      3. INFORM VIRTUAL MEMORY MANAGER THAT CONTENTS OF MEMORY
*         FREED BY GARBAGE COLLECTION CAN BE DISCARDED.
*
*      (XR)                  NON-ZERO IF BEGINNING GC
*                            =0 IF COMPLETING GC
*      (WA)                  DNAMB=START OF DYNAMIC AREA
*      (WB)                  DNAMP=NEXT AVAILABLE LOCATION
*      (WC)                  DNAME=LAST AVAILABLE LOCATION + 1
*      JSR  SYSGC            CALL TO SYSGC FUNCTION
*      ALL REGISTERS PRESERVED
{{EJC{{{{{4184
*
*      SYSHS -- GIVE ACCESS TO HOST COMPUTER FEATURES
*
{SYSHS{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4188
*
*      PROVIDES MEANS FOR IMPLEMENTING SPECIAL FEATURES
*      ON DIFFERENT HOST COMPUTERS. THE ONLY DEFINED ENTRY IS
*      THAT WHERE ALL ARGUMENTS ARE NULL IN WHICH CASE SYSHS
*      RETURNS AN SCBLK CONTAINING NAME OF COMPUTER,
*      NAME OF OPERATING SYSTEM AND NAME OF SITE SEPARATED BY
*      COLONS. THE SCBLK NEED NOT HAVE A CORRECT FIRST FIELD
*      AS THIS IS SUPPLIED ON COPYING STRING TO DYNAMIC MEMORY.
*      SPITBOL DOES NO ARGUMENT CHECKING BUT DOES PROVIDE A
*      SINGLE ERROR RETURN FOR ARGUMENTS CHECKED AS ERRONEOUS
*      BY OSINT. IT ALSO PROVIDES A SINGLE EXECUTION ERROR
*      RETURN. IF THESE ARE INADEQUATE, USE MAY BE MADE OF THE
*      MINIMAL ERROR SECTION DIRECT AS DESCRIBED IN MINIMAL
*      DOCUMENTATION, SECTION 10.
*      SEVERAL NON-ERROR RETURNS ARE PROVIDED. THE FIRST
*      CORRESPONDS TO THE DEFINED ENTRY OR, FOR IMPLEMENTATION
*      DEFINED ENTRIES, ANY STRING MAY BE RETURNED. THE OTHERS
*      PERMIT RESPECTIVELY,  RETURN A NULL RESULT, RETURN WITH A
*      RESULT TO BE STACKED WHICH IS POINTED AT BY XR, AND A
*      RETURN CAUSING SPITBOL STATEMENT FAILURE. IF A RETURNED
*      RESULT IS IN DYNAMIC MEMORY IT MUST OBEY GARBAGE
*      COLLECTOR RULES. THE ONLY RESULTS COPIED ON RETURN
*      ARE STRINGS RETURNED VIA PPM LOC3 RETURN.
*
*      (WA)                  ARGUMENT 1
*      (XL)                  ARGUMENT 2
*      (XR)                  ARGUMENT 3
*      (WB)                  ARGUMENT 4
*      (WC)                  ARGUMENT 5
*      JSR  SYSHS            CALL TO GET HOST INFORMATION
*      PPM  LOC1             ERRONEOUS ARG
*      PPM  LOC2             EXECUTION ERROR
*      PPM  LOC3             SCBLK PTR IN XL OR 0 IF UNAVAILABLE
*      PPM  LOC4             RETURN A NULL RESULT
*      PPM  LOC5             RETURN RESULT IN XR
*      PPM  LOC6             CAUSE STATEMENT FAILURE
*      PPM  LOC7             RETURN STRING AT XL, LENGTH WA
*      PPM  LOC8             RETURN COPY OF RESULT IN XR
{{EJC{{{{{4227
*
*      SYSID -- RETURN SYSTEM IDENTIFICATION
*
{SYSID{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4231
*
*      THIS ROUTINE SHOULD RETURN STRINGS TO HEAD THE STANDARD
*      PRINTER OUTPUT. THE FIRST STRING WILL BE APPENDED TO
*      A HEADING LINE OF THE FORM
*           MACRO SPITBOL VERSION V.V
*      SUPPLIED BY SPITBOL ITSELF. V.V ARE DIGITS GIVING THE
*      MAJOR VERSION NUMBER AND GENERALLY AT LEAST A MINOR
*      VERSION NUMBER RELATING TO OSINT SHOULD BE SUPPLIED TO
*      GIVE SAY
*           MACRO SPITBOL VERSION V.V(M.M)
*      THE SECOND STRING SHOULD IDENTIFY AT LEAST THE MACHINE
*      AND OPERATING SYSTEM.  PREFERABLY IT SHOULD INCLUDE
*      THE DATE AND TIME OF THE RUN.
*      OPTIONALLY THE STRINGS MAY INCLUDE SITE NAME OF THE
*      THE IMPLEMENTOR AND/OR MACHINE ON WHICH RUN TAKES PLACE,
*      UNIQUE SITE OR COPY NUMBER AND OTHER INFORMATION AS
*      APPROPRIATE WITHOUT MAKING IT SO LONG AS TO BE A
*      NUISANCE TO USERS.
*      THE FIRST WORDS OF THE SCBLKS POINTED AT NEED NOT BE
*      CORRECTLY SET.
*
*      JSR  SYSID            CALL FOR SYSTEM IDENTIFICATION
*      (XR)                  SCBLK PTR FOR ADDITION TO HEADER
*      (XL)                  PTR TO SECOND HEADER SCBLK
{{EJC{{{{{4256
*
*      SYSIF -- SWITCH TO NEW INCLUDE FILE
*
{SYSIF{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4261
*
*      SYSIF IS USED FOR INCLUDE FILE PROCESSING, BOTH TO INFORM
*      THE INTERFACE WHEN A NEW INCLUDE FILE IS DESIRED, AND
*      WHEN THE END OF FILE OF AN INCLUDE FILE HAS BEEN REACHED
*      AND IT IS DESIRED TO RETURN TO READING FROM THE PREVIOUS
*      NESTED FILE.
*
*      IT IS THE RESPONSIBILITY OF SYSIF TO REMEMBER THE FILE
*      ACCESS PATH TO THE PRESENT INPUT FILE BEFORE SWITCHING TO
*      THE NEW INCLUDE FILE.
*
*      (XL)                  PTR TO SCBLK OR ZERO
*      (XR)                  PTR TO VACANT SCBLK OF LENGTH CSWIN
*                            (XR NOT USED IF XL IS ZERO)
*      JSR  SYSIF            CALL TO CHANGE FILES
*      PPM  LOC              UNABLE TO OPEN FILE
*      (XR)                  SCBLK WITH FULL PATH NAME OF FILE
*                            (XR NOT USED IF INPUT XL IS ZERO)
*
*      REGISTER XL POINTS TO AN SCBLK CONTAINING THE NAME OF THE
*      INCLUDE FILE TO WHICH THE INTERFACE SHOULD SWITCH.  DATA
*      IS FETCHED FROM THE FILE UPON THE NEXT CALL TO SYSRD.
*
*      SYSIF MAY HAVE THE ABILITY TO SEARCH MULTIPLE LIBRARIES
*      FOR THE INCLUDE FILE NAMED IN (XL).  IT IS THEREFORE
*      REQUIRED THAT THE FULL PATH NAME OF THE FILE WHERE THE
*      FILE WAS FINALLY LOCATED BE RETURNED IN (XR).  IT IS THIS
*      NAME THAT IS RECORDED ALONG WITH THE SOURCE STATEMENTS,
*      AND WILL ACCOMPANY SUBSEQUENT ERROR MESSAGES.
*
*      REGISTER XL IS ZERO TO MARK CONCLUSION OF USE OF AN
*      INCLUDE FILE.
{{EJC{{{{{4294
*
*      SYSIL -- GET INPUT RECORD LENGTH
*
{SYSIL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4299
*
*      SYSIL IS USED TO GET THE LENGTH OF THE NEXT INPUT RECORD
*      FROM A FILE PREVIOUSLY INPUT ASSOCIATED WITH A SYSIO
*      CALL. THE LENGTH RETURNED IS USED TO ESTABLISH A BUFFER
*      FOR A SUBSEQUENT SYSIN CALL.  SYSIL ALSO INDICATES TO THE
*      CALLER IF THIS IS A BINARY OR TEXT FILE.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      JSR  SYSIL            CALL TO GET RECORD LENGTH
*      (WA)                  LENGTH OR ZERO IF FILE CLOSED
*      (WC)                  ZERO IF BINARY, NON-ZERO IF TEXT
*
*      NO HARM IS DONE IF THE VALUE RETURNED IS TOO LONG SINCE
*      UNUSED SPACE WILL BE RECLAIMED AFTER THE SYSIN CALL.
*
*      NOTE THAT IT IS THE SYSIL CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD INPUT FROM THE FILE.
{{EJC{{{{{4318
*
*      SYSIN -- READ INPUT RECORD
*
{SYSIN{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4322
*
*      SYSIN IS USED TO READ A RECORD FROM THE FILE WHICH WAS
*      REFERENCED IN A PRIOR CALL TO SYSIL (I.E. THESE CALLS
*      ALWAYS OCCUR IN PAIRS). THE BUFFER PROVIDED IS AN
*      SCBLK FOR A STRING OF LENGTH SET FROM THE SYSIL CALL.
*      IF THE ACTUAL LENGTH READ IS LESS THAN THIS, THE LENGTH
*      FIELD OF THE SCBLK MUST BE MODIFIED BEFORE RETURNING
*      UNLESS BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE ANY OF THE ALTERNATIVE
*      RETURNS AFTER SCBLK LENGTH HAS BEEN MODIFIED.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      JSR  SYSIN            CALL TO READ RECORD
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF RECORD FORMAT ERROR
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{4341
*
*      SYSIO -- INPUT/OUTPUT FILE ASSOCIATION
*
{SYSIO{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4345
*
*      SEE ALSO SYSFC.
*      SYSIO IS CALLED IN RESPONSE TO A SNOBOL4 INPUT OR OUTPUT
*      FUNCTION CALL EXCEPT WHEN FILE ARG1 AND FILE ARG2
*      ARE BOTH NULL.
*      ITS CALL ALWAYS FOLLOWS IMMEDIATELY AFTER A CALL
*      OF SYSFC. IF SYSFC REQUESTED ALLOCATION
*      OF AN FCBLK, ITS ADDRESS WILL BE IN WA.
*      FOR INPUT FILES, NON-ZERO VALUES OF $R$ SHOULD BE
*      COPIED TO WC FOR USE IN ALLOCATING INPUT BUFFERS. IF $R$
*      IS DEFAULTED OR NOT IMPLEMENTED, WC SHOULD BE ZEROISED.
*      ONCE A FILE HAS BEEN OPENED, SUBSEQUENT INPUT(),OUTPUT()
*      CALLS IN WHICH THE SECOND ARGUMENT IS IDENTICAL WITH THAT
*      IN A PREVIOUS CALL, MERELY ASSOCIATE THE ADDITIONAL
*      VARIABLE NAME (FIRST ARGUMENT) TO THE FILE AND DO NOT
*      RESULT IN RE-OPENING THE FILE.
*      IN SUBSEQUENT ASSOCIATED ACCESSES TO THE FILE A POINTER
*      TO ANY FCBLK ALLOCATED WILL BE MADE AVAILABLE.
*
*      (XL)                  FILE ARG1 SCBLK PTR (2ND ARG)
*      (XR)                  FILE ARG2 SCBLK PTR (3RD ARG)
*      (WA)                  FCBLK PTR (0 IF NONE)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT
*      JSR  SYSIO            CALL TO ASSOCIATE FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN IF INPUT/OUTPUT NOT ALLOWED
*      (XL)                  FCBLK POINTER (0 IF NONE)
*      (WC)                  0 (FOR DEFAULT) OR MAX RECORD LNGTH
*      (WA,WB)               DESTROYED
*
*      THE SECOND ERROR RETURN IS USED IF THE FILE NAMED EXISTS
*      BUT INPUT/OUTPUT FROM THE FILE IS NOT ALLOWED. FOR
*      EXAMPLE, THE STANDARD OUTPUT FILE MAY BE IN THIS CATEGORY
*      AS REGARDS INPUT ASSOCIATION.
{{EJC{{{{{4380
*
*      SYSLD -- LOAD EXTERNAL FUNCTION
*
{SYSLD{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4384
*
*      SYSLD IS CALLED IN RESPONSE TO THE USE OF THE SNOBOL4
*      LOAD FUNCTION. THE NAMED FUNCTION IS LOADED (WHATEVER
*      THIS MEANS), AND A POINTER IS RETURNED. THE POINTER WILL
*      BE USED ON SUBSEQUENT CALLS TO THE FUNCTION (SEE SYSEX).
*
*      (XR)                  POINTER TO FUNCTION NAME (SCBLK)
*      (XL)                  POINTER TO LIBRARY NAME (SCBLK)
*      JSR  SYSLD            CALL TO LOAD FUNCTION
*      PPM  LOC              RETURN HERE IF FUNC DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      (XR)                  POINTER TO LOADED CODE
*
*      THE SIGNIFICANCE OF THE POINTER RETURNED IS UP TO THE
*      SYSTEM INTERFACE ROUTINE. THE ONLY RESTRICTION IS THAT
*      IF THE POINTER IS WITHIN DYNAMIC STORAGE, IT MUST BE
*      A PROPER BLOCK POINTER.
{{EJC{{{{{4403
*
*      SYSMM -- GET MORE MEMORY
*
{SYSMM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4407
*
*      SYSMM IS CALLED IN AN ATTEMPT TO ALLOCATE MORE DYNAMIC
*      MEMORY. THIS MEMORY MUST BE ALLOCATED CONTIGUOUSLY WITH
*      THE CURRENT DYNAMIC DATA AREA.
*
*      THE AMOUNT ALLOCATED IS UP TO THE SYSTEM TO DECIDE. ANY
*      VALUE IS ACCEPTABLE INCLUDING ZERO IF ALLOCATION IS
*      IMPOSSIBLE.
*
*      JSR  SYSMM            CALL TO GET MORE MEMORY
*      (XR)                  NUMBER OF ADDITIONAL WORDS OBTAINED
{{EJC{{{{{4419
*
*      SYSMX -- SUPPLY MXLEN
*
{SYSMX{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4423
*
*      BECAUSE OF THE METHOD OF GARBAGE COLLECTION, NO SPITBOL
*      OBJECT IS ALLOWED TO OCCUPY MORE BYTES OF MEMORY THAN
*      THE INTEGER GIVING THE LOWEST ADDRESS OF DYNAMIC
*      (GARBAGE COLLECTABLE) MEMORY. MXLEN IS THE NAME USED TO
*      REFER TO THIS MAXIMUM LENGTH OF AN OBJECT AND FOR MOST
*      USERS OF MOST IMPLEMENTATIONS, PROVIDED DYNAMIC MEMORY
*      STARTS AT AN ADDRESS OF AT LEAST A FEW THOUSAND WORDS,
*      THERE IS NO PROBLEM.
*      IF THE DEFAULT STARTING ADDRESS IS LESS THAN SAY 10000 OR
*      20000, THEN A LOAD TIME OPTION SHOULD BE PROVIDED WHERE A
*      USER CAN REQUEST THAT HE BE ABLE TO CREATE LARGER
*      OBJECTS. THIS ROUTINE INFORMS SPITBOL OF THIS REQUEST IF
*      ANY. THE VALUE RETURNED IS EITHER AN INTEGER
*      REPRESENTING THE DESIRED VALUE OF MXLEN (AND HENCE THE
*      MINIMUM DYNAMIC STORE ADDRESS WHICH MAY RESULT IN
*      NON-USE OF SOME STORE) OR ZERO IF A DEFAULT IS ACCEPTABLE
*      IN WHICH MXLEN IS SET TO THE LOWEST ADDRESS ALLOCATED
*      TO DYNAMIC STORE BEFORE COMPILATION STARTS.
*      IF A NON-ZERO VALUE IS RETURNED, THIS IS USED FOR KEYWORD
*      MAXLNGTH. OTHERWISE THE INITIAL LOW ADDRESS OF DYNAMIC
*      MEMORY IS USED FOR THIS KEYWORD.
*
*      JSR  SYSMX            CALL TO GET MXLEN
*      (WA)                  EITHER MXLEN OR 0 FOR DEFAULT
{{EJC{{{{{4449
*
*      SYSOU -- OUTPUT RECORD
*
{SYSOU{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4453
*
*      SYSOU IS USED TO WRITE A RECORD TO A FILE PREVIOUSLY
*      ASSOCIATED WITH A SYSIO CALL.
*
*      (WA)                  PTR TO FCBLK
*                            OR 0 FOR TERMINAL OR 1 FOR OUTPUT
*      (XR)                  RECORD TO BE WRITTEN (SCBLK)
*      JSR  SYSOU            CALL TO OUTPUT RECORD
*      PPM  LOC              FILE FULL OR NO FILE AFTER SYSXI
*      PPM  LOC              RETURN HERE IF I/O ERROR
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT IT IS THE SYSOU CALL (NOT THE SYSIO CALL) WHICH
*      CAUSES THE FILE TO BE OPENED AS REQUIRED FOR THE FIRST
*      RECORD OUTPUT TO THE FILE.
{{EJC{{{{{4475
*
*      SYSPI -- PRINT ON INTERACTIVE CHANNEL
*
{SYSPI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4479
*
*      IF SPITBOL IS RUN FROM AN ONLINE TERMINAL, OSINT CAN
*      REQUEST THAT MESSAGES SUCH AS COPIES OF COMPILATION
*      ERRORS BE SENT TO THE TERMINAL (SEE SYSPP). IF RELEVANT
*      REPLY WAS MADE BY SYSPP THEN SYSPI IS CALLED TO SEND SUCH
*      MESSAGES TO THE INTERACTIVE CHANNEL.
*      SYSPI IS ALSO USED FOR SENDING OUTPUT TO THE TERMINAL
*      THROUGH THE SPECIAL VARIABLE NAME, TERMINAL.
*
*      (XR)                  PTR TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPI            CALL TO PRINT LINE
*      PPM  LOC              FAILURE RETURN
*      (WA,WB)               DESTROYED
{{EJC{{{{{4495
*
*      SYSPL -- PROVIDE INTERACTIVE CONTROL OF SPITBOL
*
{SYSPL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4499
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS,
*      SUCH AS INTERRUPTING EXECUTION, BREAKPOINTING, STEPPING,
*      AND EXPRESSION EVALUATION.  THESE LAST THREE OPTIONS ARE
*      NOT PRESENTLY IMPLEMENTED BY THE CODE CALLING SYSPL.
*
*
*      (WA)                  OPCODE AS FOLLOWS-
*                            =0 POLL TO ALLOW OSINT TO INTERRUPT
*                            =1 BREAKPOINT HIT
*                            =2 COMPLETION OF STATEMENT STEPPING
*                            =3 EXPRESSION EVALUATION RESULT
*      (WB)                  STATEMENT NUMBER
*      R$FCB                 O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSPL            CALL TO SYSPL FUNCTION
*      PPM  LOC              USER INTERRUPTION
*      PPM  LOC              STEP ONE STATEMENT
*      PPM  LOC              EVALUATE EXPRESSION
*      ---                   RESUME EXECUTION
*                            (WA) = NEW POLLING INTERVAL
*
{{EJC{{{{{4522
*
*      SYSPP -- OBTAIN PRINT PARAMETERS
*
{SYSPP{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4526
*
*      SYSPP IS CALLED ONCE DURING COMPILATION TO OBTAIN
*      PARAMETERS REQUIRED FOR CORRECT PRINTED OUTPUT FORMAT
*      AND TO SELECT OTHER OPTIONS. IT MAY ALSO BE CALLED AGAIN
*      AFTER SYSXI WHEN A LOAD MODULE IS RESUMED. IN THIS
*      CASE THE VALUE RETURNED IN WA MAY BE LESS THAN OR EQUAL
*      TO THAT RETURNED IN INITIAL CALL BUT MAY NOT BE
*      GREATER.
*      THE INFORMATION RETURNED IS -
*      1.   LINE LENGTH IN CHARS FOR STANDARD PRINT FILE
*      2.   NO OF LINES/PAGE. 0 IS PREFERABLE FOR A NON-PAGED
*           DEVICE (E.G. ONLINE TERMINAL) IN WHICH CASE LISTING
*           PAGE THROWS ARE SUPPRESSED AND PAGE HEADERS
*           RESULTING FROM -TITLE,-STITL LINES ARE KEPT SHORT.
*      3.   AN INITIAL -NOLIST OPTION TO SUPPRESS LISTING UNLESS
*           THE PROGRAM CONTAINS AN EXPLICIT -LIST.
*      4.   OPTIONS TO SUPPRESS LISTING OF COMPILATION AND/OR
*           EXECUTION STATS (USEFUL FOR ESTABLISHED PROGRAMS) -
*           COMBINED WITH 3. GIVES POSSIBILITY OF LISTING
*           FILE NEVER BEING OPENED.
*      5.   OPTION TO HAVE COPIES OF ERRORS SENT TO AN
*           INTERACTIVE CHANNEL IN ADDITION TO STANDARD PRINTER.
*      6.   OPTION TO KEEP PAGE HEADERS SHORT (E.G. IF LISTING
*           TO AN ONLINE TERMINAL).
*      7.   AN OPTION TO CHOOSE EXTENDED OR COMPACT LISTING
*           FORMAT. IN THE FORMER A PAGE EJECT AND IN THE LATTER
*           A FEW LINE FEEDS PRECEDE THE PRINTING OF EACH
*           OF-- LISTING, COMPILATION STATISTICS, EXECUTION
*           OUTPUT AND EXECUTION STATISTICS.
*      8.   AN OPTION TO SUPPRESS EXECUTION AS THOUGH A
*           -NOEXECUTE CARD WERE SUPPLIED.
*      9.   AN OPTION TO REQUEST THAT NAME /TERMINAL/  BE PRE-
*           ASSOCIATED TO AN ONLINE TERMINAL VIA SYSPI AND SYSRI
*      10.  AN INTERMEDIATE (STANDARD) LISTING OPTION REQUIRING
*           THAT PAGE EJECTS OCCUR IN SOURCE LISTINGS. REDUNDANT
*           IF EXTENDED OPTION CHOSEN BUT PARTIALLY EXTENDS
*           COMPACT OPTION.
*      11.  OPTION TO SUPPRESS SYSID IDENTIFICATION.
*
*      JSR  SYSPP            CALL TO GET PRINT PARAMETERS
*      (WA)                  PRINT LINE LENGTH IN CHARS
*      (WB)                  NUMBER OF LINES/PAGE
*      (WC)                  BITS VALUE ...MLKJIHGFEDCBA WHERE
*                            A = 1 TO SEND ERROR COPY TO INT.CH.
*                            B = 1 MEANS STD PRINTER IS INT. CH.
*                            C = 1 FOR -NOLIST OPTION
*                            D = 1 TO SUPPRESS COMPILN. STATS
*
*                            E = 1 TO SUPPRESS EXECN. STATS
*                            F = 1/0 FOR EXTNDED/COMPACT LISTING
*                            G = 1 FOR -NOEXECUTE
*                            H = 1 PRE-ASSOCIATE /TERMINAL/
*
*                            I = 1 FOR STANDARD LISTING OPTION.
*                            J = 1 SUPPRESSES LISTING HEADER
*                            K = 1 FOR -PRINT
*                            L = 1 FOR -NOERRORS
*
*                            M = 1 FOR -CASE 1
{{EJC{{{{{4588
*
*      SYSPR -- PRINT LINE ON STANDARD OUTPUT FILE
*
{SYSPR{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4592
*
*      SYSPR IS USED TO PRINT A SINGLE LINE ON THE STANDARD
*      OUTPUT FILE.
*
*      (XR)                  POINTER TO LINE BUFFER (SCBLK)
*      (WA)                  LINE LENGTH
*      JSR  SYSPR            CALL TO PRINT LINE
*      PPM  LOC              TOO MUCH O/P OR NO FILE AFTER SYSXI
*      (WA,WB)               DESTROYED
*
*      THE BUFFER POINTED TO IS THE LENGTH OBTAINED FROM THE
*      SYSPP CALL AND IS FILLED OUT WITH TRAILING BLANKS. THE
*      VALUE IN WA IS THE ACTUAL LINE LENGTH WHICH MAY BE LESS
*      THAN THE MAXIMUM LINE LENGTH POSSIBLE. THERE IS NO SPACE
*      CONTROL ASSOCIATED WITH THE LINE, ALL LINES ARE PRINTED
*      SINGLE SPACED. NOTE THAT NULL LINES (WA=0) ARE POSSIBLE
*      IN WHICH CASE A BLANK LINE IS TO BE PRINTED.
*
*      THE ERROR EXIT IS USED FOR SYSTEMS WHICH LIMIT THE AMOUNT
*      OF PRINTED OUTPUT. IF POSSIBLE, PRINTING SHOULD BE
*      PERMITTED AFTER THIS CONDITION HAS BEEN SIGNALLED ONCE TO
*      ALLOW FOR DUMP AND OTHER DIAGNOSTIC INFORMATION.
*      ASSUMING THIS TO BE POSSIBLE, SPITBOL MAY MAKE MORE SYSPR
*      CALLS. IF THE ERROR RETURN OCCURS ANOTHER TIME, EXECUTION
*      IS TERMINATED BY A CALL OF SYSEJ WITH ENDING CODE 998.
{{EJC{{{{{4618
*
*      SYSRD -- READ RECORD FROM STANDARD INPUT FILE
*
{SYSRD{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4622
*
*      SYSRD IS USED TO READ A RECORD FROM THE STANDARD INPUT
*      FILE. THE BUFFER PROVIDED IS AN SCBLK FOR A STRING THE
*      LENGTH OF WHICH IN CHARACTERS IS GIVEN IN WC, THIS
*      CORRESPONDING TO THE MAXIMUM LENGTH OF STRING WHICH
*      SPITBOL IS PREPARED TO RECEIVE. AT COMPILE TIME IT
*      CORRESPONDS TO XXX IN THE MOST RECENT -INXXX CARD
*      (DEFAULT 72) AND AT EXECUTION TIME TO THE MOST RECENT
*      ,R$R$ (RECORD LENGTH) IN THE THIRD ARG OF AN INPUT()
*      STATEMENT FOR THE STANDARD INPUT FILE (DEFAULT 80).
*      IF FEWER THAN (WC) CHARACTERS ARE READ, THE LENGTH
*      FIELD OF THE SCBLK MUST BE ADJUSTED BEFORE RETURNING
*      UNLESS THE BUFFER IS RIGHT PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE RETURN
*      AFTER SUCH AN ADJUSTMENT HAS BEEN MADE.
*      SPITBOL MAY CONTINUE TO MAKE CALLS AFTER AN ENDFILE
*      RETURN SO THIS ROUTINE SHOULD BE PREPARED TO MAKE
*      REPEATED ENDFILE RETURNS.
*
*      (XR)                  POINTER TO BUFFER (SCBLK PTR)
*      (WC)                  LENGTH OF BUFFER IN CHARACTERS
*      JSR  SYSRD            CALL TO READ LINE
*      PPM  LOC              ENDFILE OR NO I/P FILE AFTER SYSXI
*                            OR INPUT FILE NAME CHANGE.  IF
*                            THE FORMER, SCBLK LENGTH IS ZERO.
*                            IF INPUT FILE NAME CHANGE, LENGTH
*                            IS NON-ZERO. CALLER SHOULD RE-ISSUE
*                            SYSRD TO OBTAIN INPUT RECORD.
*      (WA,WB,WC)            DESTROYED
{{EJC{{{{{4654
*
*      SYSRI -- READ RECORD FROM INTERACTIVE CHANNEL
*
{SYSRI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4658
*
*      READS A RECORD FROM ONLINE TERMINAL FOR SPITBOL VARIABLE,
*      TERMINAL. IF ONLINE TERMINAL IS UNAVAILABLE THEN CODE THE
*      ENDFILE RETURN ONLY.
*      THE BUFFER PROVIDED IS OF LENGTH 258 CHARACTERS. SYSRI
*      SHOULD REPLACE THE COUNT IN THE SECOND WORD OF THE SCBLK
*      BY THE ACTUAL CHARACTER COUNT UNLESS BUFFER IS RIGHT
*      PADDED WITH ZEROES.
*      IT IS ALSO PERMISSIBLE TO TAKE THE ALTERNATIVE
*      RETURN AFTER ADJUSTING THE COUNT.
*      THE END OF FILE RETURN MAY BE USED IF THIS MAKES
*      SENSE ON THE TARGET MACHINE (E.G. IF THERE IS AN
*      EOF CHARACTER.)
*
*      (XR)                  PTR TO 258 CHAR BUFFER (SCBLK PTR)
*      JSR  SYSRI            CALL TO READ LINE FROM TERMINAL
*      PPM  LOC              END OF FILE RETURN
*      (WA,WB,WC)            MAY BE DESTROYED
{{EJC{{{{{4677
*
*      SYSRW -- REWIND FILE
*
{SYSRW{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4681
*
*      SYSRW IS USED TO REWIND A FILE I.E. REPOSITION THE FILE
*      AT THE START BEFORE THE FIRST RECORD. THE FILE SHOULD BE
*      CLOSED AND THE NEXT READ OR WRITE CALL WILL OPEN THE
*      FILE AT THE START.
*
*      (WA)                  PTR TO FCBLK OR ZERO
*      (XR)                  REWIND ARG (SCBLK PTR)
*      JSR  SYSRW            CALL TO REWIND FILE
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF REWIND NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
{{EJC{{{{{4694
*
*      SYSST -- SET FILE POINTER
*
{SYSST{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4699
*
*      SYSST IS CALLED TO CHANGE THE POSITION OF A FILE
*      POINTER. THIS IS ACCOMPLISHED IN A SYSTEM DEPENDENT
*      MANNER, AND THUS THE 2ND AND 3RD ARGUMENTS ARE PASSED
*      UNCONVERTED.
*
*      (WA)                  FCBLK POINTER
*      (WB)                  2ND ARGUMENT
*      (WC)                  3RD ARGUMENT
*      JSR  SYSST            CALL TO SET FILE POINTER
*      PPM  LOC              RETURN HERE IF INVALID 2ND ARG
*      PPM  LOC              RETURN HERE IF INVALID 3RD ARG
*      PPM  LOC              RETURN HERE IF FILE DOES NOT EXIST
*      PPM  LOC              RETURN HERE IF SET NOT ALLOWED
*      PPM  LOC              RETURN HERE IF I/O ERROR
*
{{EJC{{{{{4716
*
*      SYSTM -- GET EXECUTION TIME SO FAR
*
{SYSTM{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4721
*
*      SYSTM IS USED TO OBTAIN THE AMOUNT OF EXECUTION TIME
*      USED SO FAR SINCE SPITBOL WAS GIVEN CONTROL. THE UNITS
*      ARE DESCRIBED AS MILLISECONDS IN THE SPITBOL OUTPUT, BUT
*      THE EXACT MEANING IS SYSTEM DEPENDENT. WHERE APPROPRIATE,
*      THIS VALUE SHOULD RELATE TO PROCESSOR RATHER THAN CLOCK
*      TIMING VALUES.
*      IF THE SYMBOL .CTMD IS DEFINED, THE UNITS ARE DESCRIBED
*      AS DECISECONDS (0.1 SECOND).
*
*      JSR  SYSTM            CALL TO GET TIMER VALUE
*      (IA)                  TIME SO FAR IN MILLISECONDS
*                            (DECISECONDS IF .CTMD DEFINED)
{{EJC{{{{{4735
*
*      SYSTT -- TRACE TOGGLE
*
{SYSTT{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4739
*
*      CALLED BY SPITBOL FUNCTION TRACE() WITH NO ARGS TO
*      TOGGLE THE SYSTEM TRACE SWITCH.  THIS PERMITS TRACING OF
*      LABELS IN SPITBOL CODE TO BE TURNED ON OR OFF.
*
*      JSR  SYSTT            CALL TO TOGGLE TRACE SWITCH
{{EJC{{{{{4746
*
*      SYSUL -- UNLOAD EXTERNAL FUNCTION
*
{SYSUL{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4750
*
*      SYSUL IS USED TO UNLOAD A FUNCTION PREVIOUSLY
*      LOADED WITH A CALL TO SYSLD.
*
*      (XR)                  PTR TO CONTROL BLOCK (EFBLK)
*      JSR  SYSUL            CALL TO UNLOAD FUNCTION
*
*      THE FUNCTION CANNOT BE CALLED FOLLOWING A SYSUL CALL
*      UNTIL ANOTHER SYSLD CALL IS MADE FOR THE SAME FUNCTION.
*
*      THE EFBLK CONTAINS THE FUNCTION CODE POINTER AND ALSO A
*      POINTER TO THE VRBLK CONTAINING THE FUNCTION NAME (SEE
*      DEFINITIONS AND DATA STRUCTURES SECTION).
{{EJC{{{{{4766
*
*      SYSXI -- EXIT TO PRODUCE LOAD MODULE
*
{SYSXI{EXP{{{{DEFINE EXTERNAL ENTRY POINT{4770
*
*      WHEN SYSXI IS CALLED, XL CONTAINS EITHER A STRING POINTER
*      OR ZERO. IN THE FORMER CASE, THE STRING GIVES THE
*      CHARACTER NAME OF A PROGRAM. THE INTENTION IS THAT
*      SPITBOL EXECUTION SHOULD BE TERMINATED FORTHWITH AND
*      THE NAMED PROGRAM LOADED AND EXECUTED. THIS TYPE OF CHAIN
*      EXECUTION IS VERY SYSTEM DEPENDENT AND IMPLEMENTORS MAY
*      CHOOSE TO OMIT IT OR FIND IT IMPOSSIBLE TO PROVIDE.
*      IF (XL) IS ZERO,IA CONTAINS ONE OF THE FOLLOWING INTEGERS
*
*      -1, -2, -3, -4
*           CREATE IF POSSIBLE A LOAD MODULE CONTAINING ONLY THE
*           IMPURE AREA OF MEMORY WHICH NEEDS TO BE LOADED WITH
*           A COMPATIBLE PURE SEGMENT FOR SUBSEQUENT EXECUTIONS.
*           VERSION NUMBERS TO CHECK COMPATIBILITY SHOULD BE
*           KEPT IN BOTH SEGMENTS AND CHECKED ON LOADING.
*           TO ASSIST WITH THIS CHECK, (XR) ON ENTRY IS A
*           POINTER TO AN SCBLK CONTAINING THE SPITBOL MAJOR
*           VERSION NUMBER V.V (SEE SYSID).  THE FILE THUS
*           CREATED IS CALLED A SAVE FILE.
*
*      0    IF POSSIBLE, RETURN CONTROL TO JOB CONTROL
*           COMMAND LEVEL. THE EFFECT IF AVAILABLE WILL BE
*           SYSTEM DEPENDENT.
*
*      +1, +2, +3, +4
*           CREATE IF POSSIBLE A LOAD MODULE FROM ALL OF
*           MEMORY. IT SHOULD BE POSSIBLE TO LOAD AND EXECUTE
*           THIS MODULE DIRECTLY.
*
*      IN THE CASE OF SAVED LOAD MODULES, THE STATUS OF OPEN
*      FILES IS NOT PRESERVED AND IMPLEMENTORS MAY CHOOSE TO
*      OFFER MEANS OF ATTACHING FILES BEFORE EXECUTION OF LOAD
*      MODULES STARTS OR LEAVE IT TO THE USER TO INCLUDE
*      SUITABLE INPUT(), OUTPUT() CALLS IN HIS PROGRAM.
*      SYSXI SHOULD MAKE A NOTE THAT NO I/O CHANNELS,
*      INCLUDING STANDARD FILES, HAVE FILES ATTACHED SO THAT
*      CALLS OF SYSIN, SYSOU, SYSPR, SYSRD SHOULD FAIL UNLESS
*      NEW ASSOCIATIONS ARE MADE FOR THE LOAD MODULE.
*      AT LEAST IN THE CASE OF THE STANDARD OUTPUT FILE, IT IS
*      RECOMMENDED THAT EITHER THE USER BE REQUIRED TO ATTACH
*      A FILE OR THAT A DEFAULT FILE IS ATTACHED, SINCE THE
*      PROBLEM OF ERROR MESSAGES GENERATED BY THE LOAD MODULE
*      IS OTHERWISE SEVERE. AS A LAST RESORT, IF SPITBOL
*      ATTEMPTS TO WRITE TO THE STANDARD OUTPUT FILE AND GETS A
*      REPLY INDICATING THAT SUCH OUPUT IS UNACCEPTABLE IT STOPS
*      BY USING AN ENTRY TO SYSEJ WITH ENDING CODE 998.
*      AS DESCRIBED BELOW, PASSING OF SOME ARGUMENTS MAKES IT
*      CLEAR THAT LOAD MODULE WILL USE A STANDARD OUTPUT FILE.
*
*      IF USE IS MADE OF FCBLKS FOR I/O ASSOCIATION, SPITBOL
*      BUILDS A CHAIN SO THAT THOSE IN USE MAY BE FOUND IN SYSXI
*      AND SYSEJ. THE NODES ARE 4 WORDS LONG. THIRD WORD
*      CONTAINS LINK TO NEXT NODE OR 0, FOURTH WORD CONTAINS
*      FCBLK POINTER.
{{EJC{{{{{4826
*
*      SYSXI (CONTINUED)
*
*      (XL)                  ZERO OR SCBLK PTR TO FIRST ARGUMENT
*      (XR)                  PTR TO V.V SCBLK
*      (IA)                  SIGNED INTEGER ARGUMENT
*      (WA)                  SCBLK PTR TO SECOND ARGUMENT
*      (WB)                  0 OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSXI            CALL TO EXIT
*      PPM  LOC              REQUESTED ACTION NOT POSSIBLE
*      PPM  LOC              ACTION CAUSED IRRECOVERABLE ERROR
*      (WB,WC,IA,XR,XL,CP)   SHOULD BE PRESERVED OVER CALL
*      (WA)                  0 IN ALL CASES EXCEPT SUCESSFUL
*                            PERFORMANCE OF EXIT(4) OR EXIT(-4),
*                            IN WHICH CASE 1 SHOULD BE RETURNED.
*
*      LOADING AND RUNNING THE LOAD MODULE OR RETURNING FROM
*      JCL COMMAND LEVEL CAUSES EXECUTION TO RESUME AT THE POINT
*      AFTER THE ERROR RETURNS WHICH FOLLOW THE CALL OF SYSXI.
*      THE VALUE PASSED AS EXIT ARGUMENT IS USED TO INDICATE
*      OPTIONS REQUIRED ON RESUMPTION OF LOAD MODULE.
*      +1 OR -1 REQUIRE THAT ON RESUMPTION, SYSID AND SYSPP BE
*      CALLED AND A HEADING PRINTED ON THE STANDARD OUTPUT FILE.
*      +2 OR -2 INDICATE THAT SYSPP WILL BE CALLED BUT NOT SYSID
*      AND NO HEADING WILL BE PUT ON STANDARD OUTPUT FILE.
*      ABOVE OPTIONS HAVE THE OBVIOUS IMPLICATION THAT A
*      STANDARD O/P FILE MUST BE PROVIDED FOR THE LOAD MODULE.
*      +3, +4, -3 OR -4 INDICATE CALLS OF NEITHER SYSID NOR
*      SYSPP AND NO HEADING WILL BE PLACED ON STANDARD OUTPUT
*      FILE.
*      +4 OR -4 INDICATE THAT EXECUTION IS TO CONTINUE AFTER
*      CREATION OF THE SAVE FILE OR LOAD MODULE, ALTHOUGH ALL
*      FILES WILL BE CLOSED BY THE SYSXI ACTION.  THIS PERMITS
*      THE USER TO CHECKPOINT LONG-RUNNING PROGRAMS WHILE
*      CONTINUING EXECUTION.
*
*      NO RETURN FROM SYSXI IS POSSIBLE IF ANOTHER PROGRAM
*      IS LOADED AND ENTERED.
{{EJC{{{{{4866
*
*      INTRODUCE THE INTERNAL PROCEDURES.
*
{ACESS{INP{25,R{1,1{{{4870
{ACOMP{INP{25,N{1,5{{{4871
{ALLOC{INP{25,E{1,0{{{4872
{ALOCS{INP{25,E{1,0{{{4877
{ALOST{INP{25,E{1,0{{{4878
{ARITH{INP{25,N{1,3{{{4886
{ASIGN{INP{25,R{1,1{{{4888
{ASINP{INP{25,R{1,1{{{4889
{BLKLN{INP{25,E{1,0{{{4890
{CDGCG{INP{25,E{1,0{{{4891
{CDGEX{INP{25,R{1,0{{{4892
{CDGNM{INP{25,R{1,0{{{4893
{CDGVL{INP{25,R{1,0{{{4894
{CDWRD{INP{25,E{1,0{{{4895
{CMGEN{INP{25,R{1,0{{{4896
{CMPIL{INP{25,E{1,0{{{4897
{CNCRD{INP{25,E{1,0{{{4898
{COPYB{INP{25,N{1,1{{{4899
{DFFNC{INP{25,E{1,0{{{4900
{DTACH{INP{25,E{1,0{{{4901
{DTYPE{INP{25,E{1,0{{{4902
{DUMPR{INP{25,E{1,0{{{4903
{ERMSG{INP{25,E{1,0{{{4908
{ERTEX{INP{25,E{1,0{{{4909
{EVALI{INP{25,R{1,4{{{4910
{EVALP{INP{25,R{1,1{{{4911
{EVALS{INP{25,R{1,3{{{4912
{EVALX{INP{25,R{1,1{{{4913
{EXBLD{INP{25,E{1,0{{{4914
{EXPAN{INP{25,E{1,0{{{4915
{EXPAP{INP{25,E{1,1{{{4916
{EXPDM{INP{25,N{1,0{{{4917
{EXPOP{INP{25,N{1,0{{{4918
{FILNM{INP{25,E{1,0{{{4920
{FLSTG{INP{25,E{1,0{{{4923
{GBCOL{INP{25,E{1,0{{{4925
{GBCPF{INP{25,E{1,0{{{4926
{GTARR{INP{25,E{1,2{{{4927
{{EJC{{{{{4928
{GTCOD{INP{25,E{1,1{{{4929
{GTEXP{INP{25,E{1,1{{{4930
{GTINT{INP{25,E{1,1{{{4931
{GTNUM{INP{25,E{1,1{{{4932
{GTNVR{INP{25,E{1,1{{{4933
{GTPAT{INP{25,E{1,1{{{4934
{GTREA{INP{25,E{1,1{{{4937
{GTSMI{INP{25,N{1,2{{{4939
{GTSTG{INP{25,N{1,1{{{4944
{GTVAR{INP{25,E{1,1{{{4945
{HASHS{INP{25,E{1,0{{{4946
{ICBLD{INP{25,E{1,0{{{4947
{IDENT{INP{25,E{1,1{{{4948
{INOUT{INP{25,E{1,0{{{4949
{INSTA{INP{25,E{1,0{{{4954
{IOFCB{INP{25,N{1,3{{{4955
{IOPPF{INP{25,N{1,0{{{4956
{IOPUT{INP{25,N{1,7{{{4957
{KTREX{INP{25,R{1,0{{{4958
{KWNAM{INP{25,N{1,0{{{4959
{LCOMP{INP{25,N{1,5{{{4960
{LISTR{INP{25,E{1,0{{{4961
{LISTT{INP{25,E{1,0{{{4962
{NEWFN{INP{25,E{1,0{{{4964
{NEXTS{INP{25,E{1,0{{{4966
{PATIN{INP{25,N{1,2{{{4967
{PATST{INP{25,N{1,1{{{4968
{PBILD{INP{25,E{1,0{{{4969
{PCONC{INP{25,E{1,0{{{4970
{PCOPY{INP{25,N{1,0{{{4971
{PRFLR{INP{25,E{1,0{{{4974
{PRFLU{INP{25,E{1,0{{{4975
{PRPAR{INP{25,E{1,0{{{4977
{PRTCH{INP{25,E{1,0{{{4978
{PRTIC{INP{25,E{1,0{{{4979
{PRTIS{INP{25,E{1,0{{{4980
{PRTIN{INP{25,E{1,0{{{4981
{PRTMI{INP{25,E{1,0{{{4982
{PRTMM{INP{25,E{1,0{{{4983
{PRTMX{INP{25,E{1,0{{{4984
{PRTNL{INP{25,R{1,0{{{4985
{PRTNM{INP{25,R{1,0{{{4986
{PRTNV{INP{25,E{1,0{{{4987
{PRTPG{INP{25,E{1,0{{{4988
{PRTPS{INP{25,E{1,0{{{4989
{PRTSN{INP{25,E{1,0{{{4990
{PRTST{INP{25,R{1,0{{{4991
{{EJC{{{{{4992
{PRTTR{INP{25,E{1,0{{{4993
{PRTVL{INP{25,R{1,0{{{4994
{PRTVN{INP{25,E{1,0{{{4995
{RCBLD{INP{25,E{1,0{{{4998
{READR{INP{25,E{1,0{{{5000
{RSTRT{INP{25,E{1,0{{{5009
{SBSTR{INP{25,E{1,0{{{5013
{SCANE{INP{25,E{1,0{{{5014
{SCNGF{INP{25,E{1,0{{{5015
{SETVR{INP{25,E{1,0{{{5016
{SORTA{INP{25,N{1,1{{{5019
{SORTC{INP{25,E{1,1{{{5020
{SORTF{INP{25,E{1,0{{{5021
{SORTH{INP{25,N{1,0{{{5022
{START{INP{25,E{1,0{{{5024
{STGCC{INP{25,E{1,0{{{5025
{TFIND{INP{25,E{1,1{{{5026
{TMAKE{INP{25,E{1,0{{{5027
{TRACE{INP{25,N{1,2{{{5028
{TRBLD{INP{25,E{1,0{{{5029
{TRIMR{INP{25,E{1,0{{{5030
{TRXEQ{INP{25,R{1,0{{{5031
{VMAKE{INP{25,E{1,1{{{5032
{XSCAN{INP{25,E{1,0{{{5033
{XSCNI{INP{25,N{1,2{{{5034
*
*      INTRODUCE THE INTERNAL ROUTINES
*
{ARREF{INR{{{{{5038
{CFUNC{INR{{{{{5039
{EXFAL{INR{{{{{5040
{EXINT{INR{{{{{5041
{EXITS{INR{{{{{5042
{EXIXR{INR{{{{{5043
{EXNAM{INR{{{{{5044
{EXNUL{INR{{{{{5045
{EXREA{INR{{{{{5048
{EXSID{INR{{{{{5050
{EXVNM{INR{{{{{5051
{FAILP{INR{{{{{5052
{FLPOP{INR{{{{{5053
{INDIR{INR{{{{{5054
{MATCH{INR{{{{{5055
{RETRN{INR{{{{{5056
{STCOV{INR{{{{{5057
{STMGO{INR{{{{{5058
{STOPR{INR{{{{{5059
{SUCCP{INR{{{{{5060
{SYSAB{INR{{{{{5061
{SYSTU{INR{{{{{5062
{{TTL{27,S P I T B O L -- DEFINITIONS AND DATA STRUCTURES{{{{5063
{{SEC{{{{START OF DEFINITIONS SECTION{5064
*
*      DEFINITIONS OF MACHINE PARAMETERS
*
*      THE MINIMAL TRANSLATOR SHOULD SUPPLY APPROPRIATE VALUES
*      FOR THE PARTICULAR TARGET MACHINE FOR ALL THE
*      EQU  *
*      DEFINITIONS GIVEN AT THE START OF THIS SECTION.
*
{CFP$A{EQU{24,256{{{NUMBER OF CHARACTERS IN ALPHABET{5073
*
{CFP$B{EQU{24,2{{{BYTES/WORD ADDRESSING FACTOR{5075
*
{CFP$C{EQU{24,2{{{NUMBER OF CHARACTERS PER WORD{5077
*
{CFP$F{EQU{24,4{{{OFFSET IN BYTES TO CHARS IN{5079
*                            SCBLK. SEE SCBLK FORMAT.
*
{CFP$I{EQU{24,2{{{NUMBER OF WORDS IN INTEGER CONSTANT{5082
*
{CFP$M{EQU{24,32767{{{MAX POSITIVE INTEGER IN ONE WORD{5084
*
{CFP$N{EQU{24,16{{{NUMBER OF BITS IN ONE WORD{5086
*
*      THE FOLLOWING DEFINITIONS REQUIRE THE SUPPLY OF EITHER
*      A SINGLE PARAMETER IF REAL ARITHMETIC IS OMITTED OR
*      THREE PARAMETERS IF REAL ARITHMETIC IS INCLUDED.
*
*
{CFP$R{EQU{24,4{{{NUMBER OF WORDS IN REAL CONSTANT{5096
*
{CFP$S{EQU{24,9{{{NUMBER OF SIG DIGS FOR REAL OUTPUT{5098
*
{CFP$X{EQU{24,3{{{MAX DIGITS IN REAL EXPONENT{5100
{NSTMX{EQU{24,10{{{NO. OF DECIMAL DIGITS IN CFP$M{5102
*
{MXDGS{EQU{24,CFP$S+CFP$X{{{MAX DIGITS IN REAL NUMBER{5104
*
*      MAX SPACE FOR REAL (FOR +0.E+) NEEDS FIVE MORE PLACES
*
{NSTMR{EQU{24,MXDGS+5{{{MAX SPACE FOR REAL{5108
*
*      THE FOLLOWING DEFINITION FOR CFP$U SUPPLIES A REALISTIC
*      UPPER BOUND ON THE SIZE OF THE ALPHABET.  CFP$U IS USED
*      TO SAVE SPACE IN THE SCANE BSW-IFF-ESW TABLE AND TO EASE
*      TRANSLATION STORAGE REQUIREMENTS.
*
{CFP$U{EQU{24,128{{{REALISTIC UPPER BOUND ON ALPHABET{5126
{{EJC{{{{{5128
*
*      ENVIRONMENT PARAMETERS
*
*      THE SPITBOL PROGRAM IS ESSENTIALLY INDEPENDENT OF
*      THE DEFINITIONS OF THESE PARAMETERS. HOWEVER, THE
*      EFFICIENCY OF THE SYSTEM MAY BE AFFECTED. CONSEQUENTLY,
*      THESE PARAMETERS MAY REQUIRE TUNING FOR A GIVEN VERSION
*      THE VALUES GIVEN IN COMMENTS HAVE BEEN SUCCESSFULLY USED.
*
*      E$SRS IS THE NUMBER OF WORDS TO RESERVE AT THE END OF
*      STORAGE FOR END OF RUN PROCESSING. IT SHOULD BE
*      SET AS SMALL AS POSSIBLE WITHOUT CAUSING MEMORY OVERFLOW
*      IN CRITICAL SITUATIONS (E.G. MEMORY OVERFLOW TERMINATION)
*      AND SHOULD THUS RESERVE SUFFICIENT SPACE AT LEAST FOR
*      AN SCBLK CONTAINING SAY 30 CHARACTERS.
*
{E$SRS{EQU{24,200{{{30 WORDS{5145
*
*      E$STS IS THE NUMBER OF WORDS GRABBED IN A CHUNK WHEN
*      STORAGE IS ALLOCATED IN THE STATIC REGION. THE MINIMUM
*      PERMITTED VALUE IS 256/CFP$B. LARGER VALUES WILL LEAD
*      TO INCREASED EFFICIENCY AT THE COST OF WASTING MEMORY.
*
{E$STS{EQU{24,256{{{500 WORDS{5152
*
*      E$CBS IS THE SIZE OF CODE BLOCK ALLOCATED INITIALLY AND
*      THE EXPANSION INCREMENT IF OVERFLOW OCCURS. IF THIS VALUE
*      IS TOO SMALL OR TOO LARGE, EXCESSIVE GARBAGE COLLECTIONS
*      WILL OCCUR DURING COMPILATION AND MEMORY MAY BE LOST
*      IN THE CASE OF A TOO LARGE VALUE.
*
{E$CBS{EQU{24,500{{{500 WORDS{5160
*
*      E$HNB IS THE NUMBER OF BUCKET HEADERS IN THE VARIABLE
*      HASH TABLE. IT SHOULD ALWAYS BE ODD. LARGER VALUES WILL
*      SPEED UP COMPILATION AND INDIRECT REFERENCES AT THE
*      EXPENSE OF ADDITIONAL STORAGE FOR THE HASH TABLE ITSELF.
*
{E$HNB{EQU{24,127{{{127 BUCKET HEADERS{5167
*
*      E$HNW IS THE MAXIMUM NUMBER OF WORDS OF A STRING
*      NAME WHICH PARTICIPATE IN THE STRING HASH ALGORITHM.
*      LARGER VALUES GIVE A BETTER HASH AT THE EXPENSE OF TAKING
*      LONGER TO COMPUTE THE HASH. THERE IS SOME OPTIMAL VALUE.
*
{E$HNW{EQU{24,6{{{6 WORDS{5174
*
*      E$FSP.  IF THE AMOUNT OF FREE SPACE LEFT AFTER A GARBAGE
*      COLLECTION IS SMALL COMPARED TO THE TOTAL AMOUNT OF SPACE
*      IN USE GARBAGE COLLECTOR THRASHING IS LIKELY TO OCCUR AS
*      THIS SPACE IS USED UP.  E$FSP IS A MEASURE OF THE
*      MINIMUM PERCENTAGE OF DYNAMIC MEMORY LEFT AS FREE SPACE
*      BEFORE THE SYSTEM ROUTINE SYSMM IS CALLED TO TRY TO
*      OBTAIN MORE MEMORY.
*
{E$FSP{EQU{24,15{{{15 PERCENT{5184
{{EJC{{{{{5194
*
*      DEFINITIONS OF CODES FOR LETTERS
*
{CH$LA{EQU{24,65{{{LETTER A{5198
{CH$LB{EQU{24,66{{{LETTER B{5199
{CH$LC{EQU{24,67{{{LETTER C{5200
{CH$LD{EQU{24,68{{{LETTER D{5201
{CH$LE{EQU{24,69{{{LETTER E{5202
{CH$LF{EQU{24,70{{{LETTER F{5203
{CH$LG{EQU{24,71{{{LETTER G{5204
{CH$LH{EQU{24,72{{{LETTER H{5205
{CH$LI{EQU{24,73{{{LETTER I{5206
{CH$LJ{EQU{24,74{{{LETTER J{5207
{CH$LK{EQU{24,75{{{LETTER K{5208
{CH$LL{EQU{24,76{{{LETTER L{5209
{CH$LM{EQU{24,77{{{LETTER M{5210
{CH$LN{EQU{24,78{{{LETTER N{5211
{CH$LO{EQU{24,79{{{LETTER O{5212
{CH$LP{EQU{24,80{{{LETTER P{5213
{CH$LQ{EQU{24,81{{{LETTER Q{5214
{CH$LR{EQU{24,82{{{LETTER R{5215
{CH$LS{EQU{24,83{{{LETTER S{5216
{CH$LT{EQU{24,84{{{LETTER T{5217
{CH$LU{EQU{24,85{{{LETTER U{5218
{CH$LV{EQU{24,86{{{LETTER V{5219
{CH$LW{EQU{24,87{{{LETTER W{5220
{CH$LX{EQU{24,88{{{LETTER X{5221
{CH$LY{EQU{24,89{{{LETTER Y{5222
{CH$L${EQU{24,90{{{LETTER Z{5223
*
*      DEFINITIONS OF CODES FOR DIGITS
*
{CH$D0{EQU{24,48{{{DIGIT 0{5227
{CH$D1{EQU{24,49{{{DIGIT 1{5228
{CH$D2{EQU{24,50{{{DIGIT 2{5229
{CH$D3{EQU{24,51{{{DIGIT 3{5230
{CH$D4{EQU{24,52{{{DIGIT 4{5231
{CH$D5{EQU{24,53{{{DIGIT 5{5232
{CH$D6{EQU{24,54{{{DIGIT 6{5233
{CH$D7{EQU{24,55{{{DIGIT 7{5234
{CH$D8{EQU{24,56{{{DIGIT 8{5235
{CH$D9{EQU{24,57{{{DIGIT 9{5236
{{EJC{{{{{5237
*
*      DEFINITIONS OF CODES FOR SPECIAL CHARACTERS
*
*      THE NAMES OF THESE CHARACTERS ARE RELATED TO THEIR
*      ORIGINAL REPRESENTATION IN THE EBCDIC SET CORRESPONDING
*      TO THE DESCRIPTION IN STANDARD SNOBOL4 MANUALS AND TEXTS.
*
{CH$AM{EQU{24,38{{{KEYWORD OPERATOR (AMPERSAND){5245
{CH$AS{EQU{24,42{{{MULTIPLICATION SYMBOL (ASTERISK){5246
{CH$AT{EQU{24,64{{{CURSOR POSITION OPERATOR (AT){5247
{CH$BB{EQU{24,60{{{LEFT ARRAY BRACKET (LESS THAN){5248
{CH$BL{EQU{24,32{{{BLANK{5249
{CH$BR{EQU{24,124{{{ALTERNATION OPERATOR (VERTICAL BAR){5250
{CH$CL{EQU{24,58{{{GOTO SYMBOL (COLON){5251
{CH$CM{EQU{24,44{{{COMMA{5252
{CH$DL{EQU{24,36{{{INDIRECTION OPERATOR (DOLLAR){5253
{CH$DT{EQU{24,46{{{NAME OPERATOR (DOT){5254
{CH$DQ{EQU{24,34{{{DOUBLE QUOTE{5255
{CH$EQ{EQU{24,61{{{EQUAL SIGN{5256
{CH$EX{EQU{24,33{{{EXPONENTIATION OPERATOR (EXCLM){5257
{CH$MN{EQU{24,45{{{MINUS SIGN{5258
{CH$NM{EQU{24,35{{{NUMBER SIGN{5259
{CH$NT{EQU{24,126{{{NEGATION OPERATOR (NOT){5260
{CH$PC{EQU{24,37{{{PERCENT{5261
{CH$PL{EQU{24,43{{{PLUS SIGN{5262
{CH$PP{EQU{24,40{{{LEFT PARENTHESIS{5263
{CH$RB{EQU{24,62{{{RIGHT ARRAY BRACKET (GRTR THAN){5264
{CH$RP{EQU{24,41{{{RIGHT PARENTHESIS{5265
{CH$QU{EQU{24,63{{{INTERROGATION OPERATOR (QUESTION){5266
{CH$SL{EQU{24,47{{{SLASH{5267
{CH$SM{EQU{24,59{{{SEMICOLON{5268
{CH$SQ{EQU{24,39{{{SINGLE QUOTE{5269
{CH$UN{EQU{24,95{{{SPECIAL IDENTIFIER CHAR (UNDERLINE){5270
{CH$OB{EQU{24,91{{{OPENING BRACKET{5271
{CH$CB{EQU{24,93{{{CLOSING BRACKET{5272
{{EJC{{{{{5273
*
*      REMAINING CHARS ARE OPTIONAL ADDITIONS TO THE STANDARDS.
*
*      TAB CHARACTERS - SYNTACTICALLY EQUIVALENT TO BLANK
*
{CH$HT{EQU{24,9{{{HORIZONTAL TAB{5280
*
*      UP ARROW SAME AS EXCLAMATION MARK FOR EXPONENTIATION
*
{CH$EY{EQU{24,94{{{UP ARROW{5289
*
*      LOWER CASE OR SHIFTED CASE ALPHABETIC CHARS
*
{CH$$A{EQU{24,97{{{SHIFTED A{5295
{CH$$B{EQU{24,98{{{SHIFTED B{5296
{CH$$C{EQU{24,99{{{SHIFTED C{5297
{CH$$D{EQU{24,100{{{SHIFTED D{5298
{CH$$E{EQU{24,101{{{SHIFTED E{5299
{CH$$F{EQU{24,102{{{SHIFTED F{5300
{CH$$G{EQU{24,103{{{SHIFTED G{5301
{CH$$H{EQU{24,104{{{SHIFTED H{5302
{CH$$I{EQU{24,105{{{SHIFTED I{5303
{CH$$J{EQU{24,106{{{SHIFTED J{5304
{CH$$K{EQU{24,107{{{SHIFTED K{5305
{CH$$L{EQU{24,108{{{SHIFTED L{5306
{CH$$M{EQU{24,109{{{SHIFTED M{5307
{CH$$N{EQU{24,110{{{SHIFTED N{5308
{CH$$O{EQU{24,111{{{SHIFTED O{5309
{CH$$P{EQU{24,112{{{SHIFTED P{5310
{CH$$Q{EQU{24,113{{{SHIFTED Q{5311
{CH$$R{EQU{24,114{{{SHIFTED R{5312
{CH$$S{EQU{24,115{{{SHIFTED S{5313
{CH$$T{EQU{24,116{{{SHIFTED T{5314
{CH$$U{EQU{24,117{{{SHIFTED U{5315
{CH$$V{EQU{24,118{{{SHIFTED V{5316
{CH$$W{EQU{24,119{{{SHIFTED W{5317
{CH$$X{EQU{24,120{{{SHIFTED X{5318
{CH$$Y{EQU{24,121{{{SHIFTED Y{5319
{CH$$${EQU{24,122{{{SHIFTED Z{5320
*      IF A DELIMITER OTHER THAN CH$CM MUST BE USED IN
*      THE THIRD ARGUMENT OF INPUT(),OUTPUT() THEN .CIOD SHOULD
*      BE DEFINED AND A PARAMETER SUPPLIED FOR IODEL.
*
{IODEL{EQU{24,32{{{{5327
{{EJC{{{{{5331
*
*      DATA BLOCK FORMATS AND DEFINITIONS
*
*      THE FOLLOWING SECTIONS DESCRIBE THE DETAILED FORMAT OF
*      ALL POSSIBLE DATA BLOCKS IN STATIC AND DYNAMIC MEMORY.
*
*      EVERY BLOCK HAS A NAME OF THE FORM XXBLK WHERE XX IS A
*      UNIQUE TWO CHARACTER IDENTIFIER. THE FIRST WORD OF EVERY
*      BLOCK MUST CONTAIN A POINTER TO A PROGRAM LOCATION IN THE
*      INTERPRETOR WHICH IS IMMEDIATELY PRECEDED BY AN ADDRESS
*      CONSTANT CONTAINING THE VALUE BL$XX WHERE XX IS THE BLOCK
*      IDENTIFIER. THIS PROVIDES A UNIFORM MECHANISM FOR
*      DISTINGUISHING BETWEEN THE VARIOUS BLOCK TYPES.
*
*      IN SOME CASES, THE CONTENTS OF THE FIRST WORD IS CONSTANT
*      FOR A GIVEN BLOCK TYPE AND MERELY SERVES AS A POINTER
*      TO THE IDENTIFYING ADDRESS CONSTANT. HOWEVER, IN OTHER
*      CASES THERE ARE SEVERAL POSSIBILITIES FOR THE FIRST
*      WORD IN WHICH CASE EACH OF THE SEVERAL PROGRAM ENTRY
*      POINTS MUST BE PRECEDED BY THE APPROPRIATE CONSTANT.
*
*      IN EACH BLOCK, SOME OF THE FIELDS ARE RELOCATABLE. THIS
*      MEANS THAT THEY MAY CONTAIN A POINTER TO ANOTHER BLOCK
*      IN THE DYNAMIC AREA. (TO BE MORE PRECISE, IF THEY CONTAIN
*      A POINTER WITHIN THE DYNAMIC AREA, THEN IT IS A POINTER
*      TO A BLOCK). SUCH FIELDS MUST BE MODIFIED BY THE GARBAGE
*      COLLECTOR (PROCEDURE GBCOL) WHENEVER BLOCKS ARE COMPACTED
*      IN THE DYNAMIC REGION. THE GARBAGE COLLECTOR (ACTUALLY
*      PROCEDURE GBCPF) REQUIRES THAT ALL SUCH RELOCATABLE
*      FIELDS IN A BLOCK MUST BE CONTIGUOUS.
{{EJC{{{{{5362
*
*      THE DESCRIPTION FORMAT USES THE FOLLOWING SCHEME.
*
*      1)   BLOCK TITLE AND TWO CHARACTER IDENTIFIER
*
*      2)   DESCRIPTION OF BASIC USE OF BLOCK AND INDICATION
*           OF CIRCUMSTANCES UNDER WHICH IT IS CONSTRUCTED.
*
*      3)   PICTURE OF THE BLOCK FORMAT. IN THESE PICTURES LOW
*           MEMORY ADDRESSES ARE AT THE TOP OF THE PAGE. FIXED
*           LENGTH FIELDS ARE SURROUNDED BY I (LETTER I). FIELDS
*           WHICH ARE FIXED LENGTH BUT WHOSE LENGTH IS DEPENDENT
*           ON A CONFIGURATION PARAMETER ARE SURROUNDED BY *
*           (ASTERISK). VARIABLE LENGTH FIELDS ARE SURROUNDED
*           BY / (SLASH).
*
*      4)   DEFINITION OF SYMBOLIC OFFSETS TO FIELDS IN
*           BLOCK AND OF THE SIZE OF THE BLOCK IF FIXED LENGTH
*           OR OF THE SIZE OF THE FIXED LENGTH FIELDS IF THE
*           BLOCK IS VARIABLE LENGTH.
*           NOTE THAT SOME ROUTINES SUCH AS GBCPF ASSUME
*           CERTAIN OFFSETS ARE EQUAL. THE DEFINITIONS
*           GIVEN HERE ENFORCE THIS.  MAKE CHANGES TO
*           THEM ONLY WITH DUE CARE.
*
*      DEFINITIONS OF COMMON OFFSETS
*
{OFFS1{EQU{24,1{{{{5390
{OFFS2{EQU{24,2{{{{5391
{OFFS3{EQU{24,3{{{{5392
*
*      5)   DETAILED COMMENTS ON THE SIGNIFICANCE AND FORMATS
*           OF THE VARIOUS FIELDS.
*
*      THE ORDER IS ALPHABETICAL BY IDENTIFICATION CODE.
{{EJC{{{{{5398
*
*      DEFINITIONS OF BLOCK CODES
*
*      THIS TABLE PROVIDES A UNIQUE IDENTIFICATION CODE FOR
*      EACH SEPARATE BLOCK TYPE. THE FIRST WORD OF A BLOCK IN
*      THE DYNAMIC AREA ALWAYS CONTAINS THE ADDRESS OF A PROGRAM
*      ENTRY POINT. THE BLOCK CODE IS USED AS THE ENTRY POINT ID
*      THE ORDER OF THESE CODES DICTATES THE ORDER OF THE TABLE
*      USED BY THE DATATYPE FUNCTION (SCNMT IN THE CONSTANT SEC)
*
*      BLOCK CODES FOR ACCESSIBLE DATATYPES
*
*      NOTE THAT REAL AND BUFFER TYPES ARE ALWAYS INCLUDED, EVEN
*      IF THEY ARE CONDITIONALLY EXCLUDED ELSEWHERE.  THIS MAIN-
*      TAINS BLOCK TYPE CODES ACROSS ALL VERSIONS OF SPITBOL,
*      PROVIDING CONSISTANCY FOR EXTERNAL FUNCTIONS.  BUT NOTE
*      THAT THE BCBLK IS OUT OF ALPHABETIC ORDER, PLACED AT THE
*      END OF THE LIST SO AS NOT TO CHANGE THE BLOCK TYPE
*      ORDERING IN USE IN EXISTING EXTERNAL FUNCTIONS.
*
{BL$AR{EQU{24,0{{{ARBLK     ARRAY{5419
{BL$CD{EQU{24,BL$AR+1{{{CDBLK     CODE{5420
{BL$EX{EQU{24,BL$CD+1{{{EXBLK     EXPRESSION{5421
{BL$IC{EQU{24,BL$EX+1{{{ICBLK     INTEGER{5422
{BL$NM{EQU{24,BL$IC+1{{{NMBLK     NAME{5423
{BL$P0{EQU{24,BL$NM+1{{{P0BLK     PATTERN{5424
{BL$P1{EQU{24,BL$P0+1{{{P1BLK     PATTERN{5425
{BL$P2{EQU{24,BL$P1+1{{{P2BLK     PATTERN{5426
{BL$RC{EQU{24,BL$P2+1{{{RCBLK     REAL{5427
{BL$SC{EQU{24,BL$RC+1{{{SCBLK     STRING{5428
{BL$SE{EQU{24,BL$SC+1{{{SEBLK     EXPRESSION{5429
{BL$TB{EQU{24,BL$SE+1{{{TBBLK     TABLE{5430
{BL$VC{EQU{24,BL$TB+1{{{VCBLK     ARRAY{5431
{BL$XN{EQU{24,BL$VC+1{{{XNBLK     EXTERNAL{5432
{BL$XR{EQU{24,BL$XN+1{{{XRBLK     EXTERNAL{5433
{BL$BC{EQU{24,BL$XR+1{{{BCBLK     BUFFER{5434
{BL$PD{EQU{24,BL$BC+1{{{PDBLK     PROGRAM DEFINED DATATYPE{5435
*
{BL$$D{EQU{24,BL$PD+1{{{NUMBER OF BLOCK CODES FOR DATA{5437
*
*      OTHER BLOCK CODES
*
{BL$TR{EQU{24,BL$PD+1{{{TRBLK{5441
{BL$BF{EQU{24,BL$TR+1{{{BFBLK{5442
{BL$CC{EQU{24,BL$BF+1{{{CCBLK{5443
{BL$CM{EQU{24,BL$CC+1{{{CMBLK{5444
{BL$CT{EQU{24,BL$CM+1{{{CTBLK{5445
{BL$DF{EQU{24,BL$CT+1{{{DFBLK{5446
{BL$EF{EQU{24,BL$DF+1{{{EFBLK{5447
{BL$EV{EQU{24,BL$EF+1{{{EVBLK{5448
{BL$FF{EQU{24,BL$EV+1{{{FFBLK{5449
{BL$KV{EQU{24,BL$FF+1{{{KVBLK{5450
{BL$PF{EQU{24,BL$KV+1{{{PFBLK{5451
{BL$TE{EQU{24,BL$PF+1{{{TEBLK{5452
*
{BL$$I{EQU{24,0{{{DEFAULT IDENTIFICATION CODE{5454
{BL$$T{EQU{24,BL$TR+1{{{CODE FOR DATA OR TRACE BLOCK{5455
{BL$$${EQU{24,BL$TE+1{{{NUMBER OF BLOCK CODES{5456
{{EJC{{{{{5457
*
*      FIELD REFERENCES
*
*      REFERENCES TO THE FIELDS OF DATA BLOCKS ARE SYMBOLIC
*      (I.E. USE THE SYMBOLIC OFFSETS) WITH THE FOLLOWING
*      EXCEPTIONS.
*
*      1)   REFERENCES TO THE FIRST WORD ARE USUALLY NOT
*           SYMBOLIC SINCE THEY USE THE (X) OPERAND FORMAT.
*
*      2)   THE CODE WHICH CONSTRUCTS A BLOCK IS OFTEN NOT
*           SYMBOLIC AND SHOULD BE CHANGED IF THE CORRESPONDING
*           BLOCK FORMAT IS MODIFIED.
*
*      3)   THE PLC AND PSC INSTRUCTIONS IMPLY AN OFFSET
*           CORRESPONDING TO THE DEFINITION OF CFP$F.
*
*      4)   THERE ARE NON-SYMBOLIC REFERENCES (EASILY CHANGED)
*           IN THE GARBAGE COLLECTOR (PROCEDURES GBCPF, BLKLN).
*
*      5)   THE FIELDS IDVAL, FARGS APPEAR IN SEVERAL BLOCKS
*           AND ANY CHANGES MUST BE MADE IN PARALLEL TO ALL
*           BLOCKS CONTAINING THE FIELDS. THE ACTUAL REFERENCES
*           TO THESE FIELDS ARE SYMBOLIC WITH THE ABOVE
*           LISTED EXCEPTIONS.
*
*      6)   SEVERAL SPOTS IN THE CODE ASSUME THAT THE
*           DEFINITIONS OF THE FIELDS VRVAL, TEVAL, TRNXT ARE
*           THE SAME (THESE ARE SECTIONS OF CODE WHICH SEARCH
*           OUT ALONG A TRBLK CHAIN FROM A VARIABLE).
*
*      7)   REFERENCES TO THE FIELDS OF AN ARRAY BLOCK IN THE
*           ARRAY REFERENCE ROUTINE ARREF ARE NON-SYMBOLIC.
*
*      APART FROM THE EXCEPTIONS LISTED, REFERENCES ARE SYMBOLIC
*      AS FAR AS POSSIBLE AND MODIFYING THE ORDER OR NUMBER
*      OF FIELDS WILL NOT REQUIRE CHANGES.
{{EJC{{{{{5495
*
*      COMMON FIELDS FOR FUNCTION BLOCKS
*
*      BLOCKS WHICH REPRESENT CALLABLE FUNCTIONS HAVE TWO
*      COMMON FIELDS AT THE START OF THE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           /                                    /
*           /       REST OF FUNCTION BLOCK       /
*           /                                    /
*           +------------------------------------+
*
{FCODE{EQU{24,0{{{POINTER TO CODE FOR FUNCTION{5512
{FARGS{EQU{24,1{{{NUMBER OF ARGUMENTS{5513
*
*      FCODE IS A POINTER TO THE LOCATION IN THE INTERPRETOR
*      PROGRAM WHICH PROCESSES THIS TYPE OF FUNCTION CALL.
*
*      FARGS IS THE EXPECTED NUMBER OF ARGUMENTS. THE ACTUAL
*      NUMBER OF ARGUMENTS IS ADJUSTED TO THIS AMOUNT BY
*      DELETING EXTRA ARGUMENTS OR SUPPLYING TRAILING NULLS
*      FOR MISSING ONES BEFORE TRANSFERRING THOUGH FCODE.
*      A VALUE OF 999 MAY BE USED IN THIS FIELD TO INDICATE A
*      VARIABLE NUMBER OF ARGUMENTS (SEE SVBLK FIELD SVNAR).
*
*      THE BLOCK TYPES WHICH FOLLOW THIS SCHEME ARE.
*
*      FFBLK                 FIELD FUNCTION
*      DFBLK                 DATATYPE FUNCTION
*      PFBLK                 PROGRAM DEFINED FUNCTION
*      EFBLK                 EXTERNAL LOADED FUNCTION
{{EJC{{{{{5531
*
*      IDENTIFICATION FIELD
*
*
*      ID   FIELD
*
*      CERTAIN PROGRAM ACCESSIBLE OBJECTS (THOSE WHICH CONTAIN
*      OTHER DATA VALUES AND CAN BE COPIED) ARE GIVEN A UNIQUE
*      IDENTIFICATION NUMBER (SEE EXSID). THIS ID VALUE IS AN
*      ADDRESS INTEGER VALUE WHICH IS ALWAYS STORED IN WORD TWO.
*
{IDVAL{EQU{24,1{{{ID VALUE FIELD{5543
*
*      THE BLOCKS CONTAINING AN IDVAL FIELD ARE.
*
*      ARBLK                 ARRAY
*      PDBLK                 PROGRAM DEFINED DATATYPE
*      TBBLK                 TABLE
*      VCBLK                 VECTOR BLOCK (ARRAY)
*
*      NOTE THAT A ZERO IDVAL MEANS THAT THE BLOCK IS ONLY
*      HALF BUILT AND SHOULD NOT BE DUMPED (SEE DUMPR).
{{EJC{{{{{5558
*
*      ARRAY BLOCK (ARBLK)
*
*      AN ARRAY BLOCK REPRESENTS AN ARRAY VALUE OTHER THAN ONE
*      WITH ONE DIMENSION WHOSE LOWER BOUND IS ONE (SEE VCBLK).
*      AN ARBLK IS BUILT WITH A CALL TO THE FUNCTIONS CONVERT
*      (S$CNV) OR ARRAY (S$ARR).
*
*           +------------------------------------+
*           I                ARTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                ARLEN               I
*           +------------------------------------+
*           I                AROFS               I
*           +------------------------------------+
*           I                ARNDM               I
*           +------------------------------------+
*           *                ARLBD               *
*           +------------------------------------+
*           *                ARDIM               *
*           +------------------------------------+
*           *                                    *
*           * ABOVE 2 FLDS REPEATED FOR EACH DIM *
*           *                                    *
*           +------------------------------------+
*           I                ARPRO               I
*           +------------------------------------+
*           /                                    /
*           /                ARVLS               /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{5592
*
*      ARRAY BLOCK (CONTINUED)
*
{ARTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$ART{5596
{ARLEN{EQU{24,IDVAL+1{{{LENGTH OF ARBLK IN BYTES{5597
{AROFS{EQU{24,ARLEN+1{{{OFFSET IN ARBLK TO ARPRO FIELD{5598
{ARNDM{EQU{24,AROFS+1{{{NUMBER OF DIMENSIONS{5599
{ARLBD{EQU{24,ARNDM+1{{{LOW BOUND (FIRST SUBSCRIPT){5600
{ARDIM{EQU{24,ARLBD+CFP$I{{{DIMENSION (FIRST SUBSCRIPT){5601
{ARLB2{EQU{24,ARDIM+CFP$I{{{LOW BOUND (SECOND SUBSCRIPT){5602
{ARDM2{EQU{24,ARLB2+CFP$I{{{DIMENSION (SECOND SUBSCRIPT){5603
{ARPRO{EQU{24,ARDIM+CFP$I{{{ARRAY PROTOTYPE (ONE DIMENSION){5604
{ARVLS{EQU{24,ARPRO+1{{{START OF VALUES (ONE DIMENSION){5605
{ARPR2{EQU{24,ARDM2+CFP$I{{{ARRAY PROTOTYPE (TWO DIMENSIONS){5606
{ARVL2{EQU{24,ARPR2+1{{{START OF VALUES (TWO DIMENSIONS){5607
{ARSI${EQU{24,ARLBD{{{NUMBER OF STANDARD FIELDS IN BLOCK{5608
{ARDMS{EQU{24,ARLB2-ARLBD{{{SIZE OF INFO FOR ONE SET OF BOUNDS{5609
*
*      THE BOUNDS AND DIMENSION FIELDS ARE SIGNED INTEGER
*      VALUES AND EACH OCCUPY CFP$I WORDS IN THE ARBLK.
*
*      THE LENGTH OF AN ARBLK IN BYTES MAY NOT EXCEED MXLEN.
*      THIS IS REQUIRED TO KEEP NAME OFFSETS GARBAGE COLLECTABLE
*
*      THE ACTUAL VALUES ARE ARRANGED IN ROW-WISE ORDER AND
*      CAN CONTAIN A DATA POINTER OR A POINTER TO A TRBLK.
{{EJC{{{{{5695
*
*      CODE CONSTRUCTION BLOCK (CCBLK)
*
*      AT ANY ONE MOMENT THERE IS AT MOST ONE CCBLK INTO
*      WHICH THE COMPILER IS CURRENTLY STORING CODE (CDWRD).
*
*           +------------------------------------+
*           I                CCTYP               I
*           +------------------------------------+
*           I                CCLEN               I
*           +------------------------------------+
*           I                CCSLN               I
*           +------------------------------------+
*           I                CCUSE               I
*           +------------------------------------+
*           /                                    /
*           /                CCCOD               /
*           /                                    /
*           +------------------------------------+
*
{CCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CCT{5718
{CCLEN{EQU{24,CCTYP+1{{{LENGTH OF CCBLK IN BYTES{5719
{CCSLN{EQU{24,CCLEN+1{{{SOURCE LINE NUMBER{5721
{CCUSE{EQU{24,CCSLN+1{{{OFFSET PAST LAST USED WORD (BYTES){5722
{CCCOD{EQU{24,CCUSE+1{{{START OF GENERATED CODE IN BLOCK{5726
*
*      THE REASON THAT THE CCBLK IS A SEPARATE BLOCK TYPE FROM
*      THE USUAL CDBLK IS THAT THE GARBAGE COLLECTOR MUST
*      ONLY PROCESS THOSE FIELDS WHICH HAVE BEEN SET (SEE GBCPF)
{{EJC{{{{{5731
*
*      CODE BLOCK (CDBLK)
*
*      A CODE BLOCK IS BUILT FOR EACH STATEMENT COMPILED DURING
*      THE INITIAL COMPILATION OR BY SUBSEQUENT CALLS TO CODE.
*
*           +------------------------------------+
*           I                CDJMP               I
*           +------------------------------------+
*           I                CDSTM               I
*           +------------------------------------+
*           I                CDSLN               I
*           +------------------------------------+
*           I                CDLEN               I
*           +------------------------------------+
*           I                CDFAL               I
*           +------------------------------------+
*           /                                    /
*           /                CDCOD               /
*           /                                    /
*           +------------------------------------+
*
{CDJMP{EQU{24,0{{{PTR TO ROUTINE TO EXECUTE STATEMENT{5756
{CDSTM{EQU{24,CDJMP+1{{{STATEMENT NUMBER{5757
{CDSLN{EQU{24,CDSTM+1{{{SOURCE LINE NUMBER{5759
{CDLEN{EQU{24,CDSLN+1{{{LENGTH OF CDBLK IN BYTES{5760
{CDFAL{EQU{24,CDLEN+1{{{FAILURE EXIT (SEE BELOW){5761
{CDCOD{EQU{24,CDFAL+1{{{EXECUTABLE PSEUDO-CODE{5766
{CDSI${EQU{24,CDCOD{{{NUMBER OF STANDARD FIELDS IN CDBLK{5767
*
*      CDSTM IS THE STATEMENT NUMBER OF THE CURRENT STATEMENT.
*
*      CDJMP, CDFAL ARE SET AS FOLLOWS.
*
*      1)   IF THE FAILURE EXIT IS THE NEXT STATEMENT
*
*           CDJMP = B$CDS
*           CDFAL = PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   IF THE FAILURE EXIT IS A SIMPLE LABEL NAME
*
*           CDJMP = B$CDS
*           CDFAL IS A PTR TO THE VRTRA FIELD OF THE VRBLK
*
*      3)   IF THERE IS NO FAILURE EXIT (-NOFAIL MODE)
*
*           CDJMP = B$CDS
*           CDFAL = O$UNF
*
*      4)   IF THE FAILURE EXIT IS COMPLEX OR DIRECT
*
*           CDJMP = B$CDC
*           CDFAL IS THE OFFSET TO THE O$GOF WORD
{{EJC{{{{{5792
*
*      CODE BLOCK (CONTINUED)
*
*      CDCOD IS THE START OF THE ACTUAL CODE. FIRST WE DESCRIBE
*      THE CODE GENERATED FOR AN EXPRESSION. IN AN EXPRESSION,
*      ELEMENTS ARE FETCHED BY NAME OR BY VALUE. FOR EXAMPLE,
*      THE BINARY EQUAL OPERATOR FETCHES ITS LEFT ARGUMENT
*      BY NAME AND ITS RIGHT ARGUMENT BY VALUE. THESE TWO
*      CASES GENERATE QUITE DIFFERENT CODE AND ARE DESCRIBED
*      SEPARATELY. FIRST WE CONSIDER THE CODE BY VALUE CASE.
*
*      GENERATION OF CODE BY VALUE FOR EXPRESSIONS ELEMENTS.
*
*      EXPRESSION            POINTER TO EXBLK OR SEBLK
*
*      INTEGER CONSTANT      POINTER TO ICBLK
*
*      NULL CONSTANT         POINTER TO NULLS
*
*      PATTERN               (RESULTING FROM PREEVALUATION)
*                            =O$LPT
*                            POINTER TO P0BLK,P1BLK OR P2BLK
*
*      REAL CONSTANT         POINTER TO RCBLK
*
*      STRING CONSTANT       POINTER TO SCBLK
*
*      VARIABLE              POINTER TO VRGET FIELD OF VRBLK
*
*      ADDITION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ADD
*
*      AFFIRMATION           VALUE CODE FOR OPERAND
*                            =O$AFF
*
*      ALTERNATION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ALT
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O$AOV
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O$AMV
*                            NUMBER OF SUBSCRIPTS
{{EJC{{{{{5846
*
*      CODE BLOCK (CONTINUED)
*
*      ASSIGNMENT            (TO NATURAL VARIABLE)
*                            VALUE CODE FOR RIGHT OPERAND
*                            POINTER TO VRSTO FIELD OF VRBLK
*
*                            (TO ANY OTHER VARIABLE)
*                            NAME CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$ASS
*
*      COMPILE ERROR         =O$CER
*
*
*      COMPLEMENTATION       VALUE CODE FOR OPERAND
*                            =O$COM
*
*      CONCATENATION         (CASE OF PRED FUNC LEFT OPERAND)
*                            VALUE CODE FOR LEFT OPERAND
*                            =O$POP
*                            VALUE CODE FOR RIGHT OPERAND
*
*                            (ALL OTHER CASES)
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$CNC
*
*      CURSOR ASSIGNMENT     NAME CODE FOR OPERAND
*                            =O$CAS
*
*      DIVISION              VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$DVD
*
*      EXPONENTIATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$EXP
*
*      FUNCTION CALL         (CASE OF CALL TO SYSTEM FUNCTION)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            POINTER TO SVFNC FIELD OF SVBLK
*
{{EJC{{{{{5893
*
*      CODE BLOCK (CONTINUED)
*
*      FUNCTION CALL         (CASE OF NON-SYSTEM FUNCTION 1 ARG)
*                            VALUE CODE FOR ARGUMENT
*                            =O$FNS
*                            POINTER TO VRBLK FOR FUNCTION
*
*                            (NON-SYSTEM FUNCTION, GT 1 ARG)
*                            VALUE CODE FOR FIRST ARGUMENT
*                            VALUE CODE FOR SECOND ARGUMENT
*                            ...
*                            VALUE CODE FOR LAST ARGUMENT
*                            =O$FNC
*                            NUMBER OF ARGUMENTS
*                            POINTER TO VRBLK FOR FUNCTION
*
*      IMMEDIATE ASSIGNMENT  VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O$IMA
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O$INV
*
*      INTERROGATION         VALUE CODE FOR OPERAND
*                            =O$INT
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O$KWV
*
*      MULTIPLICATION        VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$MLT
*
*      NAME REFERENCE        (NATURAL VARIABLE CASE)
*                            POINTER TO NMBLK FOR NAME
*
*                            (ALL OTHER CASES)
*                            NAME CODE FOR OPERAND
*                            =O$NAM
*
*      NEGATION              =O$NTA
*                            CDBLK OFFSET OF O$NTC WORD
*                            VALUE CODE FOR OPERAND
*                            =O$NTB
*                            =O$NTC
{{EJC{{{{{5940
*
*      CODE BLOCK (CONTINUED)
*
*      PATTERN ASSIGNMENT    VALUE CODE FOR LEFT OPERAND
*                            NAME CODE FOR RIGHT OPERAND
*                            =O$PAS
*
*      PATTERN MATCH         VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$PMV
*
*      PATTERN REPLACEMENT   NAME CODE FOR SUBJECT
*                            VALUE CODE FOR PATTERN
*                            =O$PMN
*                            VALUE CODE FOR REPLACEMENT
*                            =O$RPL
*
*      SELECTION             (FOR FIRST ALTERNATIVE)
*                            =O$SLA
*                            CDBLK OFFSET TO NEXT O$SLC WORD
*                            VALUE CODE FOR FIRST ALTERNATIVE
*                            =O$SLB
*                            CDBLK OFFSET PAST ALTERNATIVES
*
*                            (FOR SUBSEQUENT ALTERNATIVES)
*                            =O$SLC
*                            CDBLK OFFSET TO NEXT O$SLC,O$SLD
*                            VALUE CODE FOR ALTERNATIVE
*                            =O$SLB
*                            OFFSET IN CDBLK PAST ALTERNATIVES
*
*                            (FOR LAST ALTERNATIVE)
*                            =O$SLD
*                            VALUE CODE FOR LAST ALTERNATIVE
*
*      SUBTRACTION           VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$SUB
{{EJC{{{{{5979
*
*      CODE BLOCK (CONTINUED)
*
*      GENERATION OF CODE BY NAME FOR EXPRESSION ELEMENTS.
*
*      VARIABLE              =O$LVN
*                            POINTER TO VRBLK
*
*      EXPRESSION            (CASE OF *NATURAL VARIABLE)
*                            =O$LVN
*                            POINTER TO VRBLK
*
*                            (ALL OTHER CASES)
*                            =O$LEX
*                            POINTER TO EXBLK
*
*
*      ARRAY REFERENCE       (CASE OF ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR SUBSCRIPT OPERAND
*                            =O$AON
*
*                            (CASE OF MORE THAN ONE SUBSCRIPT)
*                            VALUE CODE FOR ARRAY OPERAND
*                            VALUE CODE FOR FIRST SUBSCRIPT
*                            VALUE CODE FOR SECOND SUBSCRIPT
*                            ...
*                            VALUE CODE FOR LAST SUBSCRIPT
*                            =O$AMN
*                            NUMBER OF SUBSCRIPTS
*
*      COMPILE ERROR         =O$CER
*
*      FUNCTION CALL         (SAME CODE AS FOR VALUE CALL)
*                            =O$FNE
*
*      INDIRECTION           VALUE CODE FOR OPERAND
*                            =O$INN
*
*      KEYWORD REFERENCE     NAME CODE FOR OPERAND
*                            =O$KWN
*
*      ANY OTHER OPERAND IS AN ERROR IN A NAME POSITION
*
*      NOTE THAT IN THIS DESCRIPTION, =O$XXX REFERS TO THE
*      GENERATION OF A WORD CONTAINING THE ADDRESS OF ANOTHER
*      WORD WHICH CONTAINS THE ENTRY POINT ADDRESS O$XXX.
{{EJC{{{{{6027
*
*      CODE BLOCK (CONTINUED)
*
*      NOW WE CONSIDER THE OVERALL STRUCTURE OF THE CODE BLOCK
*      FOR A STATEMENT WITH POSSIBLE GOTO FIELDS.
*
*      FIRST COMES THE CODE FOR THE STATEMENT BODY.
*      THE STATEMENT BODY IS AN EXPRESSION TO BE EVALUATED
*      BY VALUE ALTHOUGH THE VALUE IS NOT ACTUALLY REQUIRED.
*      NORMAL VALUE CODE IS GENERATED FOR THE BODY OF THE
*      STATEMENT EXCEPT IN THE CASE OF A PATTERN MATCH BY
*      VALUE, IN WHICH CASE THE FOLLOWING IS GENERATED.
*
*                            VALUE CODE FOR LEFT OPERAND
*                            VALUE CODE FOR RIGHT OPERAND
*                            =O$PMS
*
*      NEXT WE HAVE THE CODE FOR THE SUCCESS GOTO. THERE ARE
*      SEVERAL CASES AS FOLLOWS.
*
*      1)   NO SUCCESS GOTO  PTR TO CDBLK FOR NEXT STATEMENT
*
*      2)   SIMPLE LABEL     PTR TO VRTRA FIELD OF VRBLK
*
*      3)   COMPLEX GOTO     (CODE BY NAME FOR GOTO OPERAND)
*                            =O$GOC
*
*      4)   DIRECT GOTO      (CODE BY VALUE FOR GOTO OPERAND)
*                            =O$GOD
*
*      FOLLOWING THIS WE GENERATE CODE FOR THE FAILURE GOTO IF
*      IT IS DIRECT OR IF IT IS COMPLEX, SIMPLE FAILURE GOTOS
*      HAVING BEEN HANDLED BY AN APPROPRIATE SETTING OF THE
*      CDFAL FIELD OF THE CDBLK. THE GENERATED CODE IS ONE
*      OF THE FOLLOWING.
*
*      1)   COMPLEX FGOTO    =O$FIF
*                            =O$GOF
*                            NAME CODE FOR GOTO OPERAND
*                            =O$GOC
*
*      2)   DIRECT FGOTO     =O$FIF
*                            =O$GOF
*                            VALUE CODE FOR GOTO OPERAND
*                            =O$GOD
*
*      AN OPTIMIZATION OCCURS IF THE SUCCESS AND FAILURE GOTOS
*      ARE IDENTICAL AND EITHER COMPLEX OR DIRECT. IN THIS CASE,
*      NO CODE IS GENERATED FOR THE SUCCESS GOTO AND CONTROL
*      IS ALLOWED TO FALL INTO THE FAILURE GOTO ON SUCCESS.
{{EJC{{{{{6078
*
*      COMPILER BLOCK (CMBLK)
*
*      A COMPILER BLOCK (CMBLK) IS BUILT BY EXPAN TO REPRESENT
*      ONE NODE OF A TREE STRUCTURED EXPRESSION REPRESENTATION.
*
*           +------------------------------------+
*           I                CMIDN               I
*           +------------------------------------+
*           I                CMLEN               I
*           +------------------------------------+
*           I                CMTYP               I
*           +------------------------------------+
*           I                CMOPN               I
*           +------------------------------------+
*           /           CMVLS OR CMROP           /
*           /                                    /
*           /                CMLOP               /
*           /                                    /
*           +------------------------------------+
*
{CMIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CMT{6100
{CMLEN{EQU{24,CMIDN+1{{{LENGTH OF CMBLK IN BYTES{6101
{CMTYP{EQU{24,CMLEN+1{{{TYPE (C$XXX, SEE LIST BELOW){6102
{CMOPN{EQU{24,CMTYP+1{{{OPERAND POINTER (SEE BELOW){6103
{CMVLS{EQU{24,CMOPN+1{{{OPERAND VALUE POINTERS (SEE BELOW){6104
{CMROP{EQU{24,CMVLS{{{RIGHT (ONLY) OPERATOR OPERAND{6105
{CMLOP{EQU{24,CMVLS+1{{{LEFT OPERATOR OPERAND{6106
{CMSI${EQU{24,CMVLS{{{NUMBER OF STANDARD FIELDS IN CMBLK{6107
{CMUS${EQU{24,CMSI$+1{{{SIZE OF UNARY OPERATOR CMBLK{6108
{CMBS${EQU{24,CMSI$+2{{{SIZE OF BINARY OPERATOR CMBLK{6109
{CMAR1{EQU{24,CMVLS+1{{{ARRAY SUBSCRIPT POINTERS{6110
*
*      THE CMOPN AND CMVLS FIELDS ARE SET AS FOLLOWS
*
*      ARRAY REFERENCE       CMOPN = PTR TO ARRAY OPERAND
*                            CMVLS = PTRS TO SUBSCRIPT OPERANDS
*
*      FUNCTION CALL         CMOPN = PTR TO VRBLK FOR FUNCTION
*                            CMVLS = PTRS TO ARGUMENT OPERANDS
*
*      SELECTION             CMOPN = ZERO
*                            CMVLS = PTRS TO ALTERNATE OPERANDS
*
*      UNARY OPERATOR        CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO OPERAND
*
*      BINARY OPERATOR       CMOPN = PTR TO OPERATOR DVBLK
*                            CMROP = PTR TO RIGHT OPERAND
*                            CMLOP = PTR TO LEFT OPERAND
{{EJC{{{{{6129
*
*      CMTYP IS SET TO INDICATE THE TYPE OF EXPRESSION ELEMENT
*      AS SHOWN BY THE FOLLOWING TABLE OF DEFINITIONS.
*
{C$ARR{EQU{24,0{{{ARRAY REFERENCE{6134
{C$FNC{EQU{24,C$ARR+1{{{FUNCTION CALL{6135
{C$DEF{EQU{24,C$FNC+1{{{DEFERRED EXPRESSION (UNARY *){6136
{C$IND{EQU{24,C$DEF+1{{{INDIRECTION (UNARY $){6137
{C$KEY{EQU{24,C$IND+1{{{KEYWORD REFERENCE (UNARY AMPERSAND){6138
{C$UBO{EQU{24,C$KEY+1{{{UNDEFINED BINARY OPERATOR{6139
{C$UUO{EQU{24,C$UBO+1{{{UNDEFINED UNARY OPERATOR{6140
{C$UO${EQU{24,C$UUO+1{{{TEST VALUE (=C$UUO+1=C$UBO+2){6141
{C$$NM{EQU{24,C$UUO+1{{{NUMBER OF CODES FOR NAME OPERANDS{6142
*
*      THE REMAINING TYPES INDICATE EXPRESSION ELEMENTS WHICH
*      CAN ONLY BE EVALUATED BY VALUE (NOT BY NAME).
*
{C$BVL{EQU{24,C$UUO+1{{{BINARY OP WITH VALUE OPERANDS{6147
{C$UVL{EQU{24,C$BVL+1{{{UNARY OPERATOR WITH VALUE OPERAND{6148
{C$ALT{EQU{24,C$UVL+1{{{ALTERNATION (BINARY BAR){6149
{C$CNC{EQU{24,C$ALT+1{{{CONCATENATION{6150
{C$CNP{EQU{24,C$CNC+1{{{CONCATENATION, NOT PATTERN MATCH{6151
{C$UNM{EQU{24,C$CNP+1{{{UNARY OP WITH NAME OPERAND{6152
{C$BVN{EQU{24,C$UNM+1{{{BINARY OP (OPERANDS BY VALUE, NAME){6153
{C$ASS{EQU{24,C$BVN+1{{{ASSIGNMENT{6154
{C$INT{EQU{24,C$ASS+1{{{INTERROGATION{6155
{C$NEG{EQU{24,C$INT+1{{{NEGATION (UNARY NOT){6156
{C$SEL{EQU{24,C$NEG+1{{{SELECTION{6157
{C$PMT{EQU{24,C$SEL+1{{{PATTERN MATCH{6158
*
{C$PR${EQU{24,C$BVN{{{LAST PREEVALUABLE CODE{6160
{C$$NV{EQU{24,C$PMT+1{{{NUMBER OF DIFFERENT CMBLK TYPES{6161
{{EJC{{{{{6162
*
*      CHARACTER TABLE BLOCK (CTBLK)
*
*      A CHARACTER TABLE BLOCK IS USED TO HOLD LOGICAL CHARACTER
*      TABLES FOR USE WITH ANY,NOTANY,SPAN,BREAK,BREAKX
*      PATTERNS. EACH CHARACTER TABLE CAN BE USED TO STORE
*      CFP$N DISTINCT TABLES AS BIT COLUMNS. A BIT COLUMN
*      ALLOCATED FOR EACH ARGUMENT OF MORE THAN ONE CHARACTER
*      IN LENGTH TO ONE OF THE ABOVE LISTED PATTERN PRIMITIVES.
*
*           +------------------------------------+
*           I                CTTYP               I
*           +------------------------------------+
*           *                                    *
*           *                                    *
*           *                CTCHS               *
*           *                                    *
*           *                                    *
*           +------------------------------------+
*
{CTTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$CTT{6183
{CTCHS{EQU{24,CTTYP+1{{{START OF CHARACTER TABLE WORDS{6184
{CTSI${EQU{24,CTCHS+CFP$A{{{NUMBER OF WORDS IN CTBLK{6185
*
*      CTCHS IS CFP$A WORDS LONG AND CONSISTS OF A ONE WORD
*      BIT STRING VALUE FOR EACH POSSIBLE CHARACTER IN THE
*      INTERNAL ALPHABET. EACH OF THE CFP$N POSSIBLE BITS IN
*      A BITSTRING IS USED TO FORM A COLUMN OF BIT INDICATORS.
*      A BIT IS SET ON IF THE CHARACTER IS IN THE TABLE AND OFF
*      IF THE CHARACTER IS NOT PRESENT.
{{EJC{{{{{6193
*
*      DATATYPE FUNCTION BLOCK (DFBLK)
*
*      A DATATYPE FUNCTION IS USED TO CONTROL THE CONSTRUCTION
*      OF A PROGRAM DEFINED DATATYPE OBJECT. A CALL TO THE
*      SYSTEM FUNCTION DATA BUILDS A DFBLK FOR THE DATATYPE NAME
*
*      NOTE THAT THESE BLOCKS ARE BUILT IN STATIC BECAUSE PDBLK
*      LENGTH IS GOT FROM DFLEN FIELD.  IF DFBLK WAS IN DYNAMIC
*      STORE THIS WOULD CAUSE TROUBLE DURING PASS TWO OF GARBAGE
*      COLLECTION.  SCBLK REFERRED TO BY DFNAM FIELD IS ALSO PUT
*      IN STATIC SO THAT THERE ARE NO RELOC. FIELDS. THIS CUTS
*      GARBAGE COLLECTION TASK APPRECIABLY FOR PDBLKS WHICH ARE
*      LIKELY TO BE PRESENT IN LARGE NUMBERS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                DFLEN               I
*           +------------------------------------+
*           I                DFPDL               I
*           +------------------------------------+
*           I                DFNAM               I
*           +------------------------------------+
*           /                                    /
*           /                DFFLD               /
*           /                                    /
*           +------------------------------------+
*
{DFLEN{EQU{24,FARGS+1{{{LENGTH OF DFBLK IN BYTES{6225
{DFPDL{EQU{24,DFLEN+1{{{LENGTH OF CORRESPONDING PDBLK{6226
{DFNAM{EQU{24,DFPDL+1{{{POINTER TO SCBLK FOR DATATYPE NAME{6227
{DFFLD{EQU{24,DFNAM+1{{{START OF VRBLK PTRS FOR FIELD NAMES{6228
{DFFLB{EQU{24,DFFLD-1{{{OFFSET BEHIND DFFLD FOR FIELD FUNC{6229
{DFSI${EQU{24,DFFLD{{{NUMBER OF STANDARD FIELDS IN DFBLK{6230
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$DFC
*
*      FARGS (THE NUMBER OF ARGUMENTS) IS THE NUMBER OF FIELDS.
{{EJC{{{{{6235
*
*      DOPE VECTOR BLOCK (DVBLK)
*
*      A DOPE VECTOR IS ASSEMBLED FOR EACH POSSIBLE OPERATOR IN
*      THE SNOBOL4 LANGUAGE AS PART OF THE CONSTANT SECTION.
*
*           +------------------------------------+
*           I                DVOPN               I
*           +------------------------------------+
*           I                DVTYP               I
*           +------------------------------------+
*           I                DVLPR               I
*           +------------------------------------+
*           I                DVRPR               I
*           +------------------------------------+
*
{DVOPN{EQU{24,0{{{ENTRY ADDRESS (PTR TO O$XXX){6252
{DVTYP{EQU{24,DVOPN+1{{{TYPE CODE (C$XXX, SEE CMBLK){6253
{DVLPR{EQU{24,DVTYP+1{{{LEFT PRECEDENCE (LLXXX, SEE BELOW){6254
{DVRPR{EQU{24,DVLPR+1{{{RIGHT PRECEDENCE (RRXXX, SEE BELOW){6255
{DVUS${EQU{24,DVLPR+1{{{SIZE OF UNARY OPERATOR DV{6256
{DVBS${EQU{24,DVRPR+1{{{SIZE OF BINARY OPERATOR DV{6257
{DVUBS{EQU{24,DVUS$+DVBS${{{SIZE OF UNOP + BINOP (SEE SCANE){6258
*
*      THE CONTENTS OF THE DVTYP FIELD IS COPIED INTO THE CMTYP
*      FIELD OF THE CMBLK FOR THE OPERATOR IF IT IS USED.
*
*      THE CMOPN FIELD OF AN OPERATOR CMBLK POINTS TO THE DVBLK
*      ITSELF, PROVIDING THE REQUIRED ENTRY ADDRESS POINTER PTR.
*
*      FOR NORMALLY UNDEFINED OPERATORS, THE DVOPN (AND CMOPN)
*      FIELDS CONTAIN A WORD OFFSET FROM R$UBA OF THE FUNCTION
*      BLOCK POINTER FOR THE OPERATOR (INSTEAD OF O$XXX PTR).
*      FOR CERTAIN SPECIAL OPERATORS, THE DVOPN FIELD IS NOT
*      REQUIRED AT ALL AND IS ASSEMBLED AS ZERO.
*
*      THE LEFT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE LEFT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS THE
*      PRECEDENCE OF THE OPERATOR TOWARDS ITS RIGHT OPERAND.
*
*      THE RIGHT PRECEDENCE IS USED IN COMPARING AN OPERATOR TO
*      THE RIGHT OF SOME OTHER OPERATOR. IT THEREFORE GOVERNS
*      THE PRECEDENCE OF THE OPERATOR TOWARDS ITS LEFT OPERAND.
*
*      HIGHER PRECEDENCE VALUES CORRESPOND TO A TIGHTER BINDING
*      CAPABILITY. THUS WE HAVE THE LEFT PRECEDENCE LOWER
*      (HIGHER) THAN THE RIGHT PRECEDENCE FOR RIGHT (LEFT)
*      ASSOCIATIVE BINARY OPERATORS.
*
*      THE LEFT PRECEDENCE OF UNARY OPERATORS IS SET TO AN
*      ARBITRARY HIGH VALUE. THE RIGHT VALUE IS NOT REQUIRED AND
*      CONSEQUENTLY THE DVRPR FIELD IS OMITTED FOR UNARY OPS.
{{EJC{{{{{6288
*
*      TABLE OF OPERATOR PRECEDENCE VALUES
*
{RRASS{EQU{24,10{{{RIGHT     EQUAL{6292
{LLASS{EQU{24,00{{{LEFT      EQUAL{6293
{RRPMT{EQU{24,20{{{RIGHT     QUESTION MARK{6294
{LLPMT{EQU{24,30{{{LEFT      QUESTION MARK{6295
{RRAMP{EQU{24,40{{{RIGHT     AMPERSAND{6296
{LLAMP{EQU{24,50{{{LEFT      AMPERSAND{6297
{RRALT{EQU{24,70{{{RIGHT     VERTICAL BAR{6298
{LLALT{EQU{24,60{{{LEFT      VERTICAL BAR{6299
{RRCNC{EQU{24,90{{{RIGHT     BLANK{6300
{LLCNC{EQU{24,80{{{LEFT      BLANK{6301
{RRATS{EQU{24,110{{{RIGHT     AT{6302
{LLATS{EQU{24,100{{{LEFT      AT{6303
{RRPLM{EQU{24,120{{{RIGHT     PLUS, MINUS{6304
{LLPLM{EQU{24,130{{{LEFT      PLUS, MINUS{6305
{RRNUM{EQU{24,140{{{RIGHT     NUMBER{6306
{LLNUM{EQU{24,150{{{LEFT      NUMBER{6307
{RRDVD{EQU{24,160{{{RIGHT     SLASH{6308
{LLDVD{EQU{24,170{{{LEFT      SLASH{6309
{RRMLT{EQU{24,180{{{RIGHT     ASTERISK{6310
{LLMLT{EQU{24,190{{{LEFT      ASTERISK{6311
{RRPCT{EQU{24,200{{{RIGHT     PERCENT{6312
{LLPCT{EQU{24,210{{{LEFT      PERCENT{6313
{RREXP{EQU{24,230{{{RIGHT     EXCLAMATION{6314
{LLEXP{EQU{24,220{{{LEFT      EXCLAMATION{6315
{RRDLD{EQU{24,240{{{RIGHT     DOLLAR, DOT{6316
{LLDLD{EQU{24,250{{{LEFT      DOLLAR, DOT{6317
{RRNOT{EQU{24,270{{{RIGHT     NOT{6318
{LLNOT{EQU{24,260{{{LEFT      NOT{6319
{LLUNO{EQU{24,999{{{LEFT      ALL UNARY OPERATORS{6320
*
*      PRECEDENCES ARE THE SAME AS IN BTL SNOBOL4 WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      1)   BINARY QUESTION MARK IS LOWERED AND MADE LEFT ASSOC-
*           IATIVE TO REFLECT ITS NEW USE FOR PATTERN MATCHING.
*
*      2)   ALTERNATION AND CONCATENATION ARE MADE RIGHT
*           ASSOCIATIVE FOR GREATER EFFICIENCY IN PATTERN
*           CONSTRUCTION AND MATCHING RESPECTIVELY. THIS CHANGE
*           IS TRANSPARENT TO THE SNOBOL4 PROGRAMMER.
*
*      3)   THE EQUAL SIGN HAS BEEN ADDED AS A LOW PRECEDENCE
*           OPERATOR WHICH IS RIGHT ASSOCIATIVE TO REFLECT ITS
*           MORE GENERAL USAGE IN THIS VERSION OF SNOBOL4.
{{EJC{{{{{6336
*
*      EXTERNAL FUNCTION BLOCK (EFBLK)
*
*      AN EXTERNAL FUNCTION BLOCK IS USED TO CONTROL THE CALLING
*      OF AN EXTERNAL FUNCTION. IT IS BUILT BY A CALL TO LOAD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                EFLEN               I
*           +------------------------------------+
*           I                EFUSE               I
*           +------------------------------------+
*           I                EFCOD               I
*           +------------------------------------+
*           I                EFVAR               I
*           +------------------------------------+
*           I                EFRSL               I
*           +------------------------------------+
*           /                                    /
*           /                EFTAR               /
*           /                                    /
*           +------------------------------------+
*
{EFLEN{EQU{24,FARGS+1{{{LENGTH OF EFBLK IN BYTES{6363
{EFUSE{EQU{24,EFLEN+1{{{USE COUNT (FOR OPSYN){6364
{EFCOD{EQU{24,EFUSE+1{{{PTR TO CODE (FROM SYSLD){6365
{EFVAR{EQU{24,EFCOD+1{{{PTR TO ASSOCIATED VRBLK{6366
{EFRSL{EQU{24,EFVAR+1{{{RESULT TYPE (SEE BELOW){6367
{EFTAR{EQU{24,EFRSL+1{{{ARGUMENT TYPES (SEE BELOW){6368
{EFSI${EQU{24,EFTAR{{{NUMBER OF STANDARD FIELDS IN EFBLK{6369
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$EFC.
*
*      EFUSE IS USED TO KEEP TRACK OF MULTIPLE USE WHEN OPSYN
*      IS EMPLOYED. THE FUNCTION IS AUTOMATICALLY UNLOADED
*      WHEN THERE ARE NO MORE REFERENCES TO THE FUNCTION.
*
*      EFRSL AND EFTAR ARE TYPE CODES AS FOLLOWS.
*
*           0                TYPE IS UNCONVERTED
*           1                TYPE IS STRING
*           2                TYPE IS INTEGER
*           3                TYPE IS REAL
*           4                TYPE IS FILE
{{EJC{{{{{6392
*
*      EXPRESSION VARIABLE BLOCK (EVBLK)
*
*      IN THIS VERSION OF SPITBOL, AN EXPRESSION CAN BE USED IN
*      ANY POSITION WHICH WOULD NORMALLY EXPECT A NAME (FOR
*      EXAMPLE ON THE LEFT SIDE OF EQUALS OR AS THE RIGHT
*      ARGUMENT OF BINARY DOT). THIS CORRESPONDS TO THE CREATION
*      OF A PSEUDO-VARIABLE WHICH IS REPRESENTED BY A POINTER TO
*      AN EXPRESSION VARIABLE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                EVTYP               I
*           +------------------------------------+
*           I                EVEXP               I
*           +------------------------------------+
*           I                EVVAR               I
*           +------------------------------------+
*
{EVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$EVT{6411
{EVEXP{EQU{24,EVTYP+1{{{POINTER TO EXBLK FOR EXPRESSION{6412
{EVVAR{EQU{24,EVEXP+1{{{POINTER TO TRBEV DUMMY TRBLK{6413
{EVSI${EQU{24,EVVAR+1{{{SIZE OF EVBLK{6414
*
*      THE NAME OF AN EXPRESSION VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE EVBLK AND AN OFFSET OF EVVAR. THIS
*      VALUE APPEARS TO BE TRAPPED BY THE DUMMY TRBEV BLOCK.
*
*      NOTE THAT THERE IS NO NEED TO ALLOW FOR THE CASE OF AN
*      EXPRESSION VARIABLE WHICH REFERENCES AN SEBLK SINCE A
*      VARIABLE WHICH IS OF THE FORM *VAR IS EQUIVALENT TO VAR.
{{EJC{{{{{6423
*
*      EXPRESSION BLOCK (EXBLK)
*
*      AN EXPRESSION BLOCK IS BUILT FOR EACH EXPRESSION
*      REFERENCED IN A PROGRAM OR CREATED BY EVAL OR CONVERT
*      DURING EXECUTION OF A PROGRAM.
*
*           +------------------------------------+
*           I                EXTYP               I
*           +------------------------------------+
*           I                EXSTM               I
*           +------------------------------------+
*           I                EXSLN               I
*           +------------------------------------+
*           I                EXLEN               I
*           +------------------------------------+
*           I                EXFLC               I
*           +------------------------------------+
*           /                                    /
*           /                EXCOD               /
*           /                                    /
*           +------------------------------------+
*
{EXTYP{EQU{24,0{{{PTR TO ROUTINE B$EXL TO LOAD EXPR{6449
{EXSTM{EQU{24,CDSTM{{{STORES STMNT NO. DURING EVALUATION{6450
{EXSLN{EQU{24,EXSTM+1{{{STORES LINE NO. DURING EVALUATION{6452
{EXLEN{EQU{24,EXSLN+1{{{LENGTH OF EXBLK IN BYTES{6453
{EXFLC{EQU{24,EXLEN+1{{{FAILURE CODE (=O$FEX){6457
{EXCOD{EQU{24,EXFLC+1{{{PSEUDO-CODE FOR EXPRESSION{6458
{EXSI${EQU{24,EXCOD{{{NUMBER OF STANDARD FIELDS IN EXBLK{6459
*
*      THERE ARE TWO CASES FOR EXCOD DEPENDING ON WHETHER THE
*      EXPRESSION CAN BE EVALUATED BY NAME (SEE DESCRIPTION
*      OF CDBLK FOR DETAILS OF CODE FOR EXPRESSIONS).
*
*      IF THE EXPRESSION CAN BE EVALUATED BY NAME WE HAVE.
*
*                            (CODE FOR EXPR BY NAME)
*                            =O$RNM
*
*      IF THE EXPRESSION CAN ONLY BE EVALUATED BY VALUE.
*
*                            (CODE FOR EXPR BY VALUE)
*                            =O$RVL
{{EJC{{{{{6474
*
*      FIELD FUNCTION BLOCK (FFBLK)
*
*      A FIELD FUNCTION BLOCK IS USED TO CONTROL THE SELECTION
*      OF A FIELD FROM A PROGRAM DEFINED DATATYPE BLOCK.
*      A CALL TO DATA CREATES AN FFBLK FOR EACH FIELD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                FFDFP               I
*           +------------------------------------+
*           I                FFNXT               I
*           +------------------------------------+
*           I                FFOFS               I
*           +------------------------------------+
*
{FFDFP{EQU{24,FARGS+1{{{POINTER TO ASSOCIATED DFBLK{6494
{FFNXT{EQU{24,FFDFP+1{{{PTR TO NEXT FFBLK ON CHAIN OR ZERO{6495
{FFOFS{EQU{24,FFNXT+1{{{OFFSET (BYTES) TO FIELD IN PDBLK{6496
{FFSI${EQU{24,FFOFS+1{{{SIZE OF FFBLK IN WORDS{6497
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$FFC.
*
*      FARGS ALWAYS CONTAINS ONE.
*
*      FFDFP IS USED TO VERIFY THAT THE CORRECT PROGRAM DEFINED
*      DATATYPE IS BEING ACCESSED BY THIS CALL.
*      FFDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      FFOFS IS USED TO SELECT THE APPROPRIATE FIELD. NOTE THAT
*      IT IS AN ACTUAL OFFSET (NOT A FIELD NUMBER)
*
*      FFNXT IS USED TO POINT TO THE NEXT FFBLK OF THE SAME NAME
*      IN THE CASE WHERE THERE ARE SEVERAL FIELDS OF THE SAME
*      NAME FOR DIFFERENT DATATYPES. ZERO MARKS THE END OF CHAIN
{{EJC{{{{{6513
*
*      INTEGER CONSTANT BLOCK (ICBLK)
*
*      AN ICBLK IS CREATED FOR EVERY INTEGER REFERENCED OR
*      CREATED BY A PROGRAM. NOTE HOWEVER THAT CERTAIN INTERNAL
*      INTEGER VALUES ARE STORED AS ADDRESSES (E.G. THE LENGTH
*      FIELD IN A STRING CONSTANT BLOCK)
*
*           +------------------------------------+
*           I                ICGET               I
*           +------------------------------------+
*           *                ICVAL               *
*           +------------------------------------+
*
{ICGET{EQU{24,0{{{PTR TO ROUTINE B$ICL TO LOAD INT{6528
{ICVAL{EQU{24,ICGET+1{{{INTEGER VALUE{6529
{ICSI${EQU{24,ICVAL+CFP$I{{{SIZE OF ICBLK{6530
*
*      THE LENGTH OF THE ICVAL FIELD IS CFP$I.
{{EJC{{{{{6533
*
*      KEYWORD VARIABLE BLOCK (KVBLK)
*
*      A KVBLK IS USED TO REPRESENT A KEYWORD PSEUDO-VARIABLE.
*      A KVBLK IS BUILT FOR EACH KEYWORD REFERENCE (KWNAM).
*
*           +------------------------------------+
*           I                KVTYP               I
*           +------------------------------------+
*           I                KVVAR               I
*           +------------------------------------+
*           I                KVNUM               I
*           +------------------------------------+
*
{KVTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$KVT{6548
{KVVAR{EQU{24,KVTYP+1{{{POINTER TO DUMMY BLOCK TRBKV{6549
{KVNUM{EQU{24,KVVAR+1{{{KEYWORD NUMBER{6550
{KVSI${EQU{24,KVNUM+1{{{SIZE OF KVBLK{6551
*
*      THE NAME OF A KEYWORD VARIABLE IS REPRESENTED BY A
*      BASE POINTER TO THE KVBLK AND AN OFFSET OF KVVAR. THE
*      VALUE APPEARS TO BE TRAPPED BY THE POINTER TO TRBKV.
{{EJC{{{{{6556
*
*      NAME BLOCK (NMBLK)
*
*      A NAME BLOCK IS USED WHEREVER A NAME MUST BE STORED AS
*      A VALUE FOLLOWING USE OF THE UNARY DOT OPERATOR.
*
*           +------------------------------------+
*           I                NMTYP               I
*           +------------------------------------+
*           I                NMBAS               I
*           +------------------------------------+
*           I                NMOFS               I
*           +------------------------------------+
*
{NMTYP{EQU{24,0{{{PTR TO ROUTINE B$NML TO LOAD NAME{6571
{NMBAS{EQU{24,NMTYP+1{{{BASE POINTER FOR VARIABLE{6572
{NMOFS{EQU{24,NMBAS+1{{{OFFSET FOR VARIABLE{6573
{NMSI${EQU{24,NMOFS+1{{{SIZE OF NMBLK{6574
*
*      THE ACTUAL FIELD REPRESENTING THE CONTENTS OF THE NAME
*      IS FOUND NMOFS BYTES PAST THE ADDRESS IN NMBAS.
*
*      THE NAME IS SPLIT INTO BASE AND OFFSET FORM TO AVOID
*      CREATION OF A POINTER INTO THE MIDDLE OF A BLOCK WHICH
*      COULD NOT BE HANDLED PROPERLY BY THE GARBAGE COLLECTOR.
*
*      A NAME MAY BE BUILT FOR ANY VARIABLE (SEE SECTION ON
*      REPRESENTATIONS OF VARIABLES) THIS INCLUDES THE
*      CASES OF PSEUDO-VARIABLES.
{{EJC{{{{{6586
*
*      PATTERN BLOCK, NO PARAMETERS (P0BLK)
*
*      A P0BLK IS USED TO REPRESENT PATTERN NODES WHICH DO
*      NOT REQUIRE THE USE OF ANY PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*
{PCODE{EQU{24,0{{{PTR TO MATCH ROUTINE (P$XXX){6599
{PTHEN{EQU{24,PCODE+1{{{POINTER TO SUBSEQUENT NODE{6600
{PASI${EQU{24,PTHEN+1{{{SIZE OF P0BLK{6601
*
*      PTHEN POINTS TO THE PATTERN BLOCK FOR THE SUBSEQUENT
*      NODE TO BE MATCHED. THIS IS A POINTER TO THE PATTERN
*      BLOCK NDNTH IF THERE IS NO SUBSEQUENT (END OF PATTERN)
*
*      PCODE IS A POINTER TO THE MATCH ROUTINE FOR THE NODE.
{{EJC{{{{{6608
*
*      PATTERN BLOCK (ONE PARAMETER)
*
*      A P1BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE ONE PARAMETER VALUE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*
{PARM1{EQU{24,PTHEN+1{{{FIRST PARAMETER VALUE{6623
{PBSI${EQU{24,PARM1+1{{{SIZE OF P1BLK IN WORDS{6624
*
*      SEE P0BLK FOR DEFINITIONS OF PCODE, PTHEN
*
*      PARM1 CONTAINS A PARAMETER VALUE USED IN MATCHING THE
*      NODE. FOR EXAMPLE, IN A LEN PATTERN, IT IS THE INTEGER
*      ARGUMENT TO LEN. THE DETAILS OF THE USE OF THE PARAMETER
*      FIELD ARE INCLUDED IN THE DESCRIPTION OF THE INDIVIDUAL
*      MATCH ROUTINES. PARM1 IS ALWAYS AN ADDRESS POINTER WHICH
*      IS PROCESSED BY THE GARBAGE COLLECTOR.
{{EJC{{{{{6634
*
*      PATTERN BLOCK (TWO PARAMETERS)
*
*      A P2BLK IS USED TO REPRESENT PATTERN NODES WHICH
*      REQUIRE TWO PARAMETER VALUES.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
{PARM2{EQU{24,PARM1+1{{{SECOND PARAMETER VALUE{6651
{PCSI${EQU{24,PARM2+1{{{SIZE OF P2BLK IN WORDS{6652
*
*      SEE P1BLK FOR DEFINITIONS OF PCODE, PTHEN, PARM1
*
*      PARM2 IS A PARAMETER WHICH PERFORMS THE SAME SORT OF
*      FUNCTION AS PARM1 (SEE DESCRIPTION OF P1BLK).
*
*      PARM2 IS A NON-RELOCATABLE FIELD AND IS NOT
*      PROCESSED BY THE GARBAGE COLLECTOR. ACCORDINGLY, IT MAY
*      NOT CONTAIN A POINTER TO A BLOCK IN DYNAMIC MEMORY.
{{EJC{{{{{6662
*
*      PROGRAM-DEFINED DATATYPE BLOCK
*
*      A PDBLK REPRESENTS THE DATA ITEM FORMED BY A CALL TO A
*      DATATYPE FUNCTION AS DEFINED BY THE SYSTEM FUNCTION DATA.
*
*           +------------------------------------+
*           I                PDTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                PDDFP               I
*           +------------------------------------+
*           /                                    /
*           /                PDFLD               /
*           /                                    /
*           +------------------------------------+
*
{PDTYP{EQU{24,0{{{PTR TO DUMMY ROUTINE B$PDT{6681
{PDDFP{EQU{24,IDVAL+1{{{PTR TO ASSOCIATED DFBLK{6682
{PDFLD{EQU{24,PDDFP+1{{{START OF FIELD VALUE POINTERS{6683
{PDFOF{EQU{24,DFFLD-PDFLD{{{DIFFERENCE IN OFFSET TO FIELD PTRS{6684
{PDSI${EQU{24,PDFLD{{{SIZE OF STANDARD FIELDS IN PDBLK{6685
{PDDFS{EQU{24,DFSI$-PDSI${{{DIFFERENCE IN DFBLK, PDBLK SIZES{6686
*
*      THE PDDFP POINTER MAY BE USED TO DETERMINE THE DATATYPE
*      AND THE NAMES OF THE FIELDS IF REQUIRED. THE DFBLK ALSO
*      CONTAINS THE LENGTH OF THE PDBLK IN BYTES (FIELD DFPDL).
*      PDDFP IS NON-RELOC. BECAUSE DFBLK IS IN STATIC
*
*      PDFLD VALUES ARE STORED IN ORDER FROM LEFT TO RIGHT.
*      THEY CONTAIN VALUES OR POINTERS TO TRBLK CHAINS.
{{EJC{{{{{6695
*
*      PROGRAM DEFINED FUNCTION BLOCK (PFBLK)
*
*      A PFBLK IS CREATED FOR EACH CALL TO THE DEFINE FUNCTION
*      AND A POINTER TO THE PFBLK PLACED IN THE PROPER VRBLK.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                PFLEN               I
*           +------------------------------------+
*           I                PFVBL               I
*           +------------------------------------+
*           I                PFNLO               I
*           +------------------------------------+
*           I                PFCOD               I
*           +------------------------------------+
*           I                PFCTR               I
*           +------------------------------------+
*           I                PFRTR               I
*           +------------------------------------+
*           /                                    /
*           /                PFARG               /
*           /                                    /
*           +------------------------------------+
*
{PFLEN{EQU{24,FARGS+1{{{LENGTH OF PFBLK IN BYTES{6724
{PFVBL{EQU{24,PFLEN+1{{{POINTER TO VRBLK FOR FUNCTION NAME{6725
{PFNLO{EQU{24,PFVBL+1{{{NUMBER OF LOCALS{6726
{PFCOD{EQU{24,PFNLO+1{{{PTR TO VRBLK FOR ENTRY LABEL{6727
{PFCTR{EQU{24,PFCOD+1{{{TRBLK PTR IF CALL TRACED ELSE 0{6728
{PFRTR{EQU{24,PFCTR+1{{{TRBLK PTR IF RETURN TRACED ELSE 0{6729
{PFARG{EQU{24,PFRTR+1{{{VRBLK PTRS FOR ARGUMENTS AND LOCALS{6730
{PFAGB{EQU{24,PFARG-1{{{OFFSET BEHIND PFARG FOR ARG, LOCAL{6731
{PFSI${EQU{24,PFARG{{{NUMBER OF STANDARD FIELDS IN PFBLK{6732
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$PFC.
*
*      PFARG IS STORED IN THE FOLLOWING ORDER.
*
*           ARGUMENTS (LEFT TO RIGHT)
*           LOCALS (LEFT TO RIGHT)
{{EJC{{{{{6742
*
*      REAL CONSTANT BLOCK (RCBLK)
*
*      AN RCBLK IS CREATED FOR EVERY REAL REFERENCED OR
*      CREATED BY A PROGRAM.
*
*           +------------------------------------+
*           I                RCGET               I
*           +------------------------------------+
*           *                RCVAL               *
*           +------------------------------------+
*
{RCGET{EQU{24,0{{{PTR TO ROUTINE B$RCL TO LOAD REAL{6755
{RCVAL{EQU{24,RCGET+1{{{REAL VALUE{6756
{RCSI${EQU{24,RCVAL+CFP$R{{{SIZE OF RCBLK{6757
*
*      THE LENGTH OF THE RCVAL FIELD IS CFP$R.
{{EJC{{{{{6761
*
*      STRING CONSTANT BLOCK (SCBLK)
*
*      AN SCBLK IS BUILT FOR EVERY STRING REFERENCED OR CREATED
*      BY A PROGRAM.
*
*           +------------------------------------+
*           I                SCGET               I
*           +------------------------------------+
*           I                SCLEN               I
*           +------------------------------------+
*           /                                    /
*           /                SCHAR               /
*           /                                    /
*           +------------------------------------+
*
{SCGET{EQU{24,0{{{PTR TO ROUTINE B$SCL TO LOAD STRING{6778
{SCLEN{EQU{24,SCGET+1{{{LENGTH OF STRING IN CHARACTERS{6779
{SCHAR{EQU{24,SCLEN+1{{{CHARACTERS OF STRING{6780
{SCSI${EQU{24,SCHAR{{{SIZE OF STANDARD FIELDS IN SCBLK{6781
*
*      THE CHARACTERS OF THE STRING ARE STORED LEFT JUSTIFIED.
*      THE FINAL WORD IS PADDED ON THE RIGHT WITH ZEROS.
*      (I.E. THE CHARACTER WHOSE INTERNAL CODE IS ZERO).
*
*      THE VALUE OF SCLEN MAY NOT EXCEED MXLEN. THIS ENSURES
*      THAT CHARACTER OFFSETS (E.G. THE PATTERN MATCH CURSOR)
*      CAN BE CORRECTLY PROCESSED BY THE GARBAGE COLLECTOR.
*
*      NOTE THAT THE OFFSET TO THE CHARACTERS OF THE STRING
*      IS GIVEN IN BYTES BY CFP$F AND THAT THIS VALUE IS
*      AUTOMATICALLY ALLOWED FOR IN PLC, PSC.
*      NOTE THAT FOR A SPITBOL SCBLK, THE VALUE OF CFP$F
*      IS GIVEN BY CFP$B*SCHAR.
{{EJC{{{{{6796
*
*      SIMPLE EXPRESSION BLOCK (SEBLK)
*
*      AN SEBLK IS USED TO REPRESENT AN EXPRESSION OF THE FORM
*      *(NATURAL VARIABLE). ALL OTHER EXPRESSIONS ARE EXBLKS.
*
*           +------------------------------------+
*           I                SETYP               I
*           +------------------------------------+
*           I                SEVAR               I
*           +------------------------------------+
*
{SETYP{EQU{24,0{{{PTR TO ROUTINE B$SEL TO LOAD EXPR{6809
{SEVAR{EQU{24,SETYP+1{{{PTR TO VRBLK FOR VARIABLE{6810
{SESI${EQU{24,SEVAR+1{{{LENGTH OF SEBLK IN WORDS{6811
{{EJC{{{{{6812
*
*      STANDARD VARIABLE BLOCK (SVBLK)
*
*      AN SVBLK IS ASSEMBLED IN THE CONSTANT SECTION FOR EACH
*      VARIABLE WHICH SATISFIES ONE OF THE FOLLOWING CONDITIONS.
*
*      1)   IT IS THE NAME OF A SYSTEM FUNCTION
*      2)   IT HAS AN INITIAL VALUE
*      3)   IT HAS A KEYWORD ASSOCIATION
*      4)   IT HAS A STANDARD I/O ASSOCIATION
*      6)   IT HAS A STANDARD LABEL ASSOCIATION
*
*      IF VRBLKS ARE CONSTRUCTED FOR ANY OF THESE VARIABLES,
*      THEN THE VRSVP FIELD POINTS TO THE SVBLK (SEE VRBLK)
*
*           +------------------------------------+
*           I                SVBIT               I
*           +------------------------------------+
*           I                SVLEN               I
*           +------------------------------------+
*           I                SVCHS               I
*           +------------------------------------+
*           I                SVKNM               I
*           +------------------------------------+
*           I                SVFNC               I
*           +------------------------------------+
*           I                SVNAR               I
*           +------------------------------------+
*           I                SVLBL               I
*           +------------------------------------+
*           I                SVVAL               I
*           +------------------------------------+
{{EJC{{{{{6845
*
*      STANDARD VARIABLE BLOCK (CONTINUED)
*
{SVBIT{EQU{24,0{{{BIT STRING INDICATING ATTRIBUTES{6849
{SVLEN{EQU{24,1{{{(=SCLEN) LENGTH OF NAME IN CHARS{6850
{SVCHS{EQU{24,2{{{(=SCHAR) CHARACTERS OF NAME{6851
{SVSI${EQU{24,2{{{NUMBER OF STANDARD FIELDS IN SVBLK{6852
{SVPRE{EQU{24,1{{{SET IF PREEVALUATION PERMITTED{6853
{SVFFC{EQU{24,SVPRE+SVPRE{{{SET ON IF FAST CALL PERMITTED{6854
{SVCKW{EQU{24,SVFFC+SVFFC{{{SET ON IF KEYWORD VALUE CONSTANT{6855
{SVPRD{EQU{24,SVCKW+SVCKW{{{SET ON IF PREDICATE FUNCTION{6856
{SVNBT{EQU{24,4{{{NUMBER OF BITS TO RIGHT OF SVKNM{6857
{SVKNM{EQU{24,SVPRD+SVPRD{{{SET ON IF KEYWORD ASSOCIATION{6858
{SVFNC{EQU{24,SVKNM+SVKNM{{{SET ON IF SYSTEM FUNCTION{6859
{SVNAR{EQU{24,SVFNC+SVFNC{{{SET ON IF SYSTEM FUNCTION{6860
{SVLBL{EQU{24,SVNAR+SVNAR{{{SET ON IF SYSTEM LABEL{6861
{SVVAL{EQU{24,SVLBL+SVLBL{{{SET ON IF PREDEFINED VALUE{6862
*
*      NOTE THAT THE LAST FIVE BITS CORRESPOND IN ORDER
*      TO THE FIELDS WHICH ARE PRESENT (SEE PROCEDURE GTNVR).
*
*      THE FOLLOWING DEFINITIONS ARE USED IN THE SVBLK TABLE
*
{SVFNF{EQU{24,SVFNC+SVNAR{{{FUNCTION WITH NO FAST CALL{6869
{SVFNN{EQU{24,SVFNF+SVFFC{{{FUNCTION WITH FAST CALL, NO PREEVAL{6870
{SVFNP{EQU{24,SVFNN+SVPRE{{{FUNCTION ALLOWING PREEVALUATION{6871
{SVFPR{EQU{24,SVFNN+SVPRD{{{PREDICATE FUNCTION{6872
{SVFNK{EQU{24,SVFNN+SVKNM{{{NO PREEVAL FUNC + KEYWORD{6873
{SVKWV{EQU{24,SVKNM+SVVAL{{{KEYWORD + VALUE{6874
{SVKWC{EQU{24,SVCKW+SVKNM{{{KEYWORD WITH CONSTANT VALUE{6875
{SVKVC{EQU{24,SVKWV+SVCKW{{{CONSTANT KEYWORD + VALUE{6876
{SVKVL{EQU{24,SVKVC+SVLBL{{{CONSTANT KEYWORD + VALUE + LABEL{6877
{SVFPK{EQU{24,SVFNP+SVKVC{{{PREEVAL FCN + CONST KEYWD + VAL{6878
*
*      THE SVPRE BIT ALLOWS THE COMPILER TO PREEVALUATE A CALL
*      TO THE ASSOCIATED SYSTEM FUNCTION IF ALL THE ARGUMENTS
*      ARE THEMSELVES CONSTANTS. FUNCTIONS IN THIS CATEGORY
*      MUST HAVE NO SIDE EFFECTS AND MUST NEVER CAUSE FAILURE.
*      THE CALL MAY GENERATE AN ERROR CONDITION.
*
*      THE SVFFC BIT ALLOWS THE COMPILER TO GENERATE THE SPECIAL
*      FAST CALL AFTER ADJUSTING THE NUMBER OF ARGUMENTS. ONLY
*      THE ITEM AND APPLY FUNCTIONS FALL OUTSIDE THIS CATEGORY.
*
*      THE SVCKW BIT IS SET IF THE ASSOCIATED KEYWORD VALUE IS
*      A CONSTANT, THUS ALLOWING PREEVALUATION FOR A VALUE CALL.
*
*      THE SVPRD BIT IS SET ON FOR ALL PREDICATE FUNCTIONS TO
*      ENABLE THE SPECIAL CONCATENATION CODE OPTIMIZATION.
{{EJC{{{{{6895
*
*      SVBLK (CONTINUED)
*
*      SVKNM                 KEYWORD NUMBER
*
*           SVKNM IS PRESENT ONLY FOR A STANDARD KEYWORD ASSOC.
*           IT CONTAINS A KEYWORD NUMBER AS DEFINED BY THE
*           KEYWORD NUMBER TABLE GIVEN LATER ON.
*
*      SVFNC                 SYSTEM FUNCTION POINTER
*
*           SVFNC IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS A POINTER TO THE ACTUAL CODE FOR THE SYSTEM
*           FUNCTION. THE GENERATED CODE FOR A FAST CALL IS A
*           POINTER TO THE SVFNC FIELD OF THE SVBLK FOR THE
*           FUNCTION. THE VRFNC FIELD OF THE VRBLK POINTS TO
*           THIS SAME FIELD, IN WHICH CASE, IT SERVES AS THE
*           FCODE FIELD FOR THE FUNCTION CALL.
*
*      SVNAR                 NUMBER OF FUNCTION ARGUMENTS
*
*           SVNAR IS PRESENT ONLY FOR A SYSTEM FUNCTION ASSOC.
*           IT IS THE NUMBER OF ARGUMENTS REQUIRED FOR A CALL
*           TO THE SYSTEM FUNCTION. THE COMPILER USES THIS
*           VALUE TO ADJUST THE NUMBER OF ARGUMENTS IN A FAST
*           CALL AND IN THE CASE OF A FUNCTION CALLED THROUGH
*           THE VRFNC FIELD OF THE VRBLK, THE SVNAR FIELD
*           SERVES AS THE FARGS FIELD FOR O$FNC. A SPECIAL
*           CASE OCCURS IF THIS VALUE IS SET TO 999. THIS IS
*           USED TO INDICATE THAT THE FUNCTION HAS A VARIABLE
*           NUMBER OF ARGUMENTS AND CAUSES O$FNC TO PASS CONTROL
*           WITHOUT ADJUSTING THE ARGUMENT COUNT. THE ONLY
*           PREDEFINED FUNCTIONS USING THIS ARE APPLY AND ITEM.
*
*      SVLBL                 SYSTEM LABEL POINTER
*
*           SVLBL IS PRESENT ONLY FOR A STANDARD LABEL ASSOC.
*           IT IS A POINTER TO A SYSTEM LABEL ROUTINE (L$XXX).
*           THE VRLBL FIELD OF THE CORRESPONDING VRBLK POINTS TO
*           THE SVLBL FIELD OF THE SVBLK.
*
*      SVVAL                 SYSTEM VALUE POINTER
*
*           SVVAL IS PRESENT ONLY FOR A STANDARD VALUE.
*           IT IS A POINTER TO THE PATTERN NODE (NDXXX) WHICH
*           IS THE STANDARD INITIAL VALUE OF THE VARIABLE.
*           THIS VALUE IS COPIED TO THE VRVAL FIELD OF THE VRBLK
{{EJC{{{{{6943
*
*      SVBLK (CONTINUED)
*
*      KEYWORD NUMBER TABLE
*
*      THE FOLLOWING TABLE GIVES SYMBOLIC NAMES FOR KEYWORD
*      NUMBERS. THESE VALUES ARE STORED IN THE SVKNM FIELD OF
*      SVBLKS AND IN THE KVNUM FIELD OF KVBLKS. SEE ALSO
*      PROCEDURES ASIGN, ACESS AND KWNAM.
*
*      UNPROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K$ABE{EQU{24,0{{{ABEND{6956
{K$ANC{EQU{24,K$ABE+CFP$B{{{ANCHOR{6957
{K$CAS{EQU{24,K$ANC+CFP$B{{{CASE{6959
{K$COD{EQU{24,K$CAS+CFP$B{{{CODE{6960
{K$COM{EQU{24,K$COD+CFP$B{{{COMPARE{6965
{K$DMP{EQU{24,K$COM+CFP$B{{{DUMP{6966
{K$ERL{EQU{24,K$DMP+CFP$B{{{ERRLIMIT{6970
{K$ERT{EQU{24,K$ERL+CFP$B{{{ERRTYPE{6971
{K$FTR{EQU{24,K$ERT+CFP$B{{{FTRACE{6972
{K$FLS{EQU{24,K$FTR+CFP$B{{{FULLSCAN{6973
{K$INP{EQU{24,K$FLS+CFP$B{{{INPUT{6974
{K$MXL{EQU{24,K$INP+CFP$B{{{MAXLENGTH{6975
{K$OUP{EQU{24,K$MXL+CFP$B{{{OUTPUT{6976
{K$PFL{EQU{24,K$OUP+CFP$B{{{PROFILE{6980
{K$TRA{EQU{24,K$PFL+CFP$B{{{TRACE{6981
{K$TRM{EQU{24,K$TRA+CFP$B{{{TRIM{6983
*
*      PROTECTED KEYWORDS WITH ONE WORD INTEGER VALUES
*
{K$FNC{EQU{24,K$TRM+CFP$B{{{FNCLEVEL{6987
{K$LST{EQU{24,K$FNC+CFP$B{{{LASTNO{6988
{K$LLN{EQU{24,K$LST+CFP$B{{{LASTLINE{6990
{K$LIN{EQU{24,K$LLN+CFP$B{{{LINE{6991
{K$STN{EQU{24,K$LIN+CFP$B{{{STNO{6992
*
*      KEYWORDS WITH CONSTANT PATTERN VALUES
*
{K$ABO{EQU{24,K$STN+CFP$B{{{ABORT{6999
{K$ARB{EQU{24,K$ABO+PASI${{{ARB{7000
{K$BAL{EQU{24,K$ARB+PASI${{{BAL{7001
{K$FAL{EQU{24,K$BAL+PASI${{{FAIL{7002
{K$FEN{EQU{24,K$FAL+PASI${{{FENCE{7003
{K$REM{EQU{24,K$FEN+PASI${{{REM{7004
{K$SUC{EQU{24,K$REM+PASI${{{SUCCEED{7005
{{EJC{{{{{7006
*
*      KEYWORD NUMBER TABLE (CONTINUED)
*
*      SPECIAL KEYWORDS
*
{K$ALP{EQU{24,K$SUC+1{{{ALPHABET{7012
{K$RTN{EQU{24,K$ALP+1{{{RTNTYPE{7013
{K$STC{EQU{24,K$RTN+1{{{STCOUNT{7014
{K$ETX{EQU{24,K$STC+1{{{ERRTEXT{7015
{K$FIL{EQU{24,K$ETX+1{{{FILE{7017
{K$LFL{EQU{24,K$FIL+1{{{LASTFILE{7018
{K$STL{EQU{24,K$LFL+1{{{STLIMIT{7019
{K$LCS{EQU{24,K$STL+1{{{LCASE{7024
{K$UCS{EQU{24,K$LCS+1{{{UCASE{7025
*
*      RELATIVE OFFSETS OF SPECIAL KEYWORDS
*
{K$$AL{EQU{24,K$ALP-K$ALP{{{ALPHABET{7030
{K$$RT{EQU{24,K$RTN-K$ALP{{{RTNTYPE{7031
{K$$SC{EQU{24,K$STC-K$ALP{{{STCOUNT{7032
{K$$ET{EQU{24,K$ETX-K$ALP{{{ERRTEXT{7033
{K$$FL{EQU{24,K$FIL-K$ALP{{{FILE{7035
{K$$LF{EQU{24,K$LFL-K$ALP{{{LASTFILE{7036
{K$$SL{EQU{24,K$STL-K$ALP{{{STLIMIT{7038
{K$$LC{EQU{24,K$LCS-K$ALP{{{LCASE{7040
{K$$UC{EQU{24,K$UCS-K$ALP{{{UCASE{7041
{K$$N${EQU{24,K$$UC+1{{{NUMBER OF SPECIAL CASES{7042
*
*      SYMBOLS USED IN ASIGN AND ACESS PROCEDURES
*
{K$P$${EQU{24,K$FNC{{{FIRST PROTECTED KEYWORD{7049
{K$V$${EQU{24,K$ABO{{{FIRST KEYWORD WITH CONSTANT VALUE{7050
{K$S$${EQU{24,K$ALP{{{FIRST KEYWORD WITH SPECIAL ACESS{7051
{{EJC{{{{{7052
*
*      FORMAT OF A TABLE BLOCK (TBBLK)
*
*      A TABLE BLOCK IS USED TO REPRESENT A TABLE VALUE.
*      IT IS BUILT BY A CALL TO THE TABLE OR CONVERT FUNCTIONS.
*
*           +------------------------------------+
*           I                TBTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                TBLEN               I
*           +------------------------------------+
*           +------------------------------------+
*           I                TBINV               I
*           +------------------------------------+
*           /                                    /
*           /                TBBUK               /
*           /                                    /
*           +------------------------------------+
*
{TBTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TBT{7074
{TBLEN{EQU{24,OFFS2{{{LENGTH OF TBBLK IN BYTES{7075
{TBINV{EQU{24,OFFS3{{{DEFAULT INITIAL LOOKUP VALUE{7076
{TBBUK{EQU{24,TBINV+1{{{START OF HASH BUCKET POINTERS{7077
{TBSI${EQU{24,TBBUK{{{SIZE OF STANDARD FIELDS IN TBBLK{7078
{TBNBK{EQU{24,11{{{DEFAULT NO. OF BUCKETS{7079
*
*      THE TABLE BLOCK IS A HASH TABLE WHICH POINTS TO CHAINS
*      OF TABLE ELEMENT BLOCKS REPRESENTING THE ELEMENTS
*      IN THE TABLE WHICH HASH INTO THE SAME BUCKET.
*
*      TBBUK ENTRIES EITHER POINT TO THE FIRST TEBLK ON THE
*      CHAIN OR THEY POINT TO THE TBBLK ITSELF TO INDICATE THE
*      END OF THE CHAIN.
{{EJC{{{{{7088
*
*      TABLE ELEMENT BLOCK (TEBLK)
*
*      A TABLE ELEMENT IS USED TO REPRESENT A SINGLE ENTRY IN
*      A TABLE (SEE DESCRIPTION OF TBBLK FORMAT FOR HASH TABLE)
*
*           +------------------------------------+
*           I                TETYP               I
*           +------------------------------------+
*           I                TESUB               I
*           +------------------------------------+
*           I                TEVAL               I
*           +------------------------------------+
*           I                TENXT               I
*           +------------------------------------+
*
{TETYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TET{7105
{TESUB{EQU{24,TETYP+1{{{SUBSCRIPT VALUE{7106
{TEVAL{EQU{24,TESUB+1{{{(=VRVAL) TABLE ELEMENT VALUE{7107
{TENXT{EQU{24,TEVAL+1{{{LINK TO NEXT TEBLK{7108
*      SEE S$CNV WHERE RELATION IS ASSUMED WITH TENXT AND TBBUK
{TESI${EQU{24,TENXT+1{{{SIZE OF TEBLK IN WORDS{7110
*
*      TENXT POINTS TO THE NEXT TEBLK ON THE HASH CHAIN FROM THE
*      TBBUK CHAIN FOR THIS HASH INDEX. AT THE END OF THE CHAIN,
*      TENXT POINTS BACK TO THE START OF THE TBBLK.
*
*      TEVAL CONTAINS A DATA POINTER OR A TRBLK POINTER.
*
*      TESUB CONTAINS A DATA POINTER.
{{EJC{{{{{7119
*
*      TRAP BLOCK (TRBLK)
*
*      A TRAP BLOCK IS USED TO REPRESENT A TRACE OR INPUT OR
*      OUTPUT ASSOCIATION IN RESPONSE TO A CALL TO THE TRACE
*      INPUT OR OUTPUT SYSTEM FUNCTIONS. SEE BELOW FOR DETAILS
*
*           +------------------------------------+
*           I                TRIDN               I
*           +------------------------------------+
*           I                TRTYP               I
*           +------------------------------------+
*           I  TRVAL OR TRLBL OR TRNXT OR TRKVR  I
*           +------------------------------------+
*           I       TRTAG OR TRTER OR TRTRF      I
*           +------------------------------------+
*           I            TRFNC OR TRFPT          I
*           +------------------------------------+
*
{TRIDN{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$TRT{7139
{TRTYP{EQU{24,TRIDN+1{{{TRAP TYPE CODE{7140
{TRVAL{EQU{24,TRTYP+1{{{VALUE OF TRAPPED VARIABLE (=VRVAL){7141
{TRNXT{EQU{24,TRVAL{{{PTR TO NEXT TRBLK ON TRBLK CHAIN{7142
{TRLBL{EQU{24,TRVAL{{{PTR TO ACTUAL LABEL (TRACED LABEL){7143
{TRKVR{EQU{24,TRVAL{{{VRBLK POINTER FOR KEYWORD TRACE{7144
{TRTAG{EQU{24,TRVAL+1{{{TRACE TAG{7145
{TRTER{EQU{24,TRTAG{{{PTR TO TERMINAL VRBLK OR NULL{7146
{TRTRF{EQU{24,TRTAG{{{PTR TO TRBLK HOLDING FCBLK PTR{7147
{TRFNC{EQU{24,TRTAG+1{{{TRACE FUNCTION VRBLK (ZERO IF NONE){7148
{TRFPT{EQU{24,TRFNC{{{FCBLK PTR FOR SYSIO{7149
{TRSI${EQU{24,TRFNC+1{{{NUMBER OF WORDS IN TRBLK{7150
*
{TRTIN{EQU{24,0{{{TRACE TYPE FOR INPUT ASSOCIATION{7152
{TRTAC{EQU{24,TRTIN+1{{{TRACE TYPE FOR ACCESS TRACE{7153
{TRTVL{EQU{24,TRTAC+1{{{TRACE TYPE FOR VALUE TRACE{7154
{TRTOU{EQU{24,TRTVL+1{{{TRACE TYPE FOR OUTPUT ASSOCIATION{7155
{TRTFC{EQU{24,TRTOU+1{{{TRACE TYPE FOR FCBLK IDENTIFICATION{7156
{{EJC{{{{{7157
*
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE INPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR INPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      VARIABLE ACCESS TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTAC
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      VARIABLE VALUE TRACE ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTVL
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{7199
*      TRAP BLOCK (CONTINUED)
*
*      VARIABLE OUTPUT ASSOCIATION
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE
*           OF A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTOU
*           TRNXT POINTS TO NEXT TRBLK OR TRVAL HAS VARIABLE VAL
*           TRTER IS A POINTER TO SVBLK IF ASSOCIATION IS
*           FOR OUTPUT, TERMINAL, ELSE IT IS NULL.
*           TRTRF POINTS TO THE TRAP BLOCK WHICH IN TURN POINTS
*           TO AN FCBLK USED FOR I/O ASSOCIATION.
*           TRFPT IS THE FCBLK PTR RETURNED BY SYSIO.
*
*      FUNCTION CALL TRACE
*
*           THE PFCTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK.
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      FUNCTION RETURN TRACE
*
*           THE PFRTR FIELD OF THE CORRESPONDING PFBLK IS SET
*           TO POINT TO A TRBLK
*
*           TRTYP IS SET TO TRTIN
*           TRNXT IS ZERO
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      LABEL TRACE
*
*           THE VRLBL OF THE VRBLK FOR THE LABEL IS
*           CHANGED TO POINT TO A TRBLK AND THE VRTRA FIELD IS
*           SET TO B$VRT TO ACTIVATE THE CHECK.
*
*           TRTYP IS SET TO TRTIN
*           TRLBL POINTS TO THE ACTUAL LABEL (CDBLK) VALUE
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
{{EJC{{{{{7247
*
*      TRAP BLOCK (CONTINUED)
*
*      KEYWORD TRACE
*
*           KEYWORDS WHICH CAN BE TRACED POSSESS A UNIQUE
*           LOCATION WHICH IS ZERO IF THERE IS NO TRACE AND
*           POINTS TO A TRBLK IF THERE IS A TRACE. THE LOCATIONS
*           ARE AS FOLLOWS.
*
*           R$ERT            ERRTYPE
*           R$FNC            FNCLEVEL
*           R$STC            STCOUNT
*
*           THE FORMAT OF THE TRBLK IS AS FOLLOWS.
*
*           TRTYP IS SET TO TRTIN
*           TRKVR IS A POINTER TO THE VRBLK FOR THE KEYWORD
*           TRTAG IS THE TRACE TAG (0 IF NONE)
*           TRFNC IS THE TRACE FUNCTION VRBLK PTR (0 IF NONE)
*
*      INPUT/OUTPUT FILE ARG1 TRAP BLOCK
*
*           THE VALUE FIELD OF THE VARIABLE POINTS TO A TRBLK
*           INSTEAD OF CONTAINING THE DATA VALUE. IN THE CASE OF
*           A NATURAL VARIABLE, THE VRGET AND VRSTO FIELDS
*           CONTAIN =B$VRA AND =B$VRV. THIS TRAP BLOCK IS USED
*           TO HOLD A POINTER TO THE FCBLK WHICH AN
*           IMPLEMENTATION MAY REQUEST TO HOLD INFORMATION
*           ABOUT A FILE.
*
*           TRTYP IS SET TO TRTFC
*           TRNEXT POINTS TO NEXT TRBLK OR TRVAL IS VARIABLE VAL
*           TRFNM IS 0
*           TRFPT IS THE FCBLK POINTER.
*
*      NOTE THAT WHEN MULTIPLE TRAPS ARE SET ON A VARIABLE
*      THE ORDER IS IN ASCENDING VALUE OF TRTYP FIELD.
*
*      INPUT ASSOCIATION (IF PRESENT)
*      ACCESS TRACE (IF PRESENT)
*      VALUE TRACE (IF PRESENT)
*      OUTPUT ASSOCIATION (IF PRESENT)
*
*      THE ACTUAL VALUE OF THE VARIABLE IS STORED IN THE TRVAL
*      FIELD OF THE LAST TRBLK ON THE CHAIN.
*
*      THIS IMPLEMENTATION DOES NOT PERMIT TRACE OR I/O
*      ASSOCIATIONS TO ANY OF THE PSEUDO-VARIABLES.
{{EJC{{{{{7297
*
*      VECTOR BLOCK (VCBLK)
*
*      A VCBLK IS USED TO REPRESENT AN ARRAY VALUE WHICH HAS
*      ONE DIMENSION WHOSE LOWER BOUND IS ONE. ALL OTHER ARRAYS
*      ARE REPRESENTED BY ARBLKS. A VCBLK IS CREATED BY THE
*      SYSTEM FUNCTION ARRAY (S$ARR) WHEN PASSED AN INTEGER ARG.
*
*           +------------------------------------+
*           I                VCTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                VCLEN               I
*           +------------------------------------+
*           I                VCVLS               I
*           +------------------------------------+
*
{VCTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$VCT{7316
{VCLEN{EQU{24,OFFS2{{{LENGTH OF VCBLK IN BYTES{7317
{VCVLS{EQU{24,OFFS3{{{START OF VECTOR VALUES{7318
{VCSI${EQU{24,VCVLS{{{SIZE OF STANDARD FIELDS IN VCBLK{7319
{VCVLB{EQU{24,VCVLS-1{{{OFFSET ONE WORD BEHIND VCVLS{7320
{VCTBD{EQU{24,TBSI$-VCSI${{{DIFFERENCE IN SIZES - SEE PRTVL{7321
*
*      VCVLS ARE EITHER DATA POINTERS OR TRBLK POINTERS
*
*      THE DIMENSION CAN BE DEDUCED FROM VCLEN.
{{EJC{{{{{7326
*
*      VARIABLE BLOCK (VRBLK)
*
*      A VARIABLE BLOCK IS BUILT IN THE STATIC MEMORY AREA
*      FOR EVERY VARIABLE REFERENCED OR CREATED BY A PROGRAM.
*
*      NOTE THAT SINCE THESE BLOCKS ONLY OCCUR IN THE STATIC
*      REGION, IT IS PERMISSIBLE TO POINT TO ANY WORD IN
*      THE BLOCK AND THIS IS USED TO PROVIDE THREE DISTINCT
*      ACCESS POINTS FROM THE GENERATED CODE AS FOLLOWS.
*
*      1)   POINT TO VRGET (FIRST WORD OF VRBLK) TO LOAD THE
*           VALUE OF THE VARIABLE ONTO THE MAIN STACK.
*
*      2)   POINT TO VRSTO (SECOND WORD OF VRBLK) TO STORE THE
*           TOP STACK ELEMENT AS THE VALUE OF THE VARIABLE.
*
*      3)   POINT TO VRTRA (FOURTH WORD OF VRBLK) TO JUMP TO
*           THE LABEL ASSOCIATED WITH THE VARIABLE NAME.
*
*           +------------------------------------+
*           I                VRGET               I
*           +------------------------------------+
*           I                VRSTO               I
*           +------------------------------------+
*           I                VRVAL               I
*           +------------------------------------+
*           I                VRTRA               I
*           +------------------------------------+
*           I                VRLBL               I
*           +------------------------------------+
*           I                VRFNC               I
*           +------------------------------------+
*           I                VRNXT               I
*           +------------------------------------+
*           I                VRLEN               I
*           +------------------------------------+
*           /                                    /
*           /            VRCHS = VRSVP           /
*           /                                    /
*           +------------------------------------+
{{EJC{{{{{7368
*
*      VARIABLE BLOCK (CONTINUED)
*
{VRGET{EQU{24,0{{{POINTER TO ROUTINE TO LOAD VALUE{7372
{VRSTO{EQU{24,VRGET+1{{{POINTER TO ROUTINE TO STORE VALUE{7373
{VRVAL{EQU{24,VRSTO+1{{{VARIABLE VALUE{7374
{VRVLO{EQU{24,VRVAL-VRSTO{{{OFFSET TO VALUE FROM STORE FIELD{7375
{VRTRA{EQU{24,VRVAL+1{{{POINTER TO ROUTINE TO JUMP TO LABEL{7376
{VRLBL{EQU{24,VRTRA+1{{{POINTER TO CODE FOR LABEL{7377
{VRLBO{EQU{24,VRLBL-VRTRA{{{OFFSET TO LABEL FROM TRANSFER FIELD{7378
{VRFNC{EQU{24,VRLBL+1{{{POINTER TO FUNCTION BLOCK{7379
{VRNXT{EQU{24,VRFNC+1{{{POINTER TO NEXT VRBLK ON HASH CHAIN{7380
{VRLEN{EQU{24,VRNXT+1{{{LENGTH OF NAME (OR ZERO){7381
{VRCHS{EQU{24,VRLEN+1{{{CHARACTERS OF NAME (VRLEN GT 0){7382
{VRSVP{EQU{24,VRLEN+1{{{PTR TO SVBLK (VRLEN EQ 0){7383
{VRSI${EQU{24,VRCHS+1{{{NUMBER OF STANDARD FIELDS IN VRBLK{7384
{VRSOF{EQU{24,VRLEN-SCLEN{{{OFFSET TO DUMMY SCBLK FOR NAME{7385
{VRSVO{EQU{24,VRSVP-VRSOF{{{PSEUDO-OFFSET TO VRSVP FIELD{7386
*
*      VRGET = B$VRL IF NOT INPUT ASSOCIATED OR ACCESS TRACED
*      VRGET = B$VRA IF INPUT ASSOCIATED OR ACCESS TRACED
*
*      VRSTO = B$VRS IF NOT OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B$VRV IF OUTPUT ASSOCIATED OR VALUE TRACED
*      VRSTO = B$VRE IF VALUE IS PROTECTED PATTERN VALUE
*
*      VRVAL POINTS TO THE APPROPRIATE VALUE UNLESS THE
*      VARIABLE IS I/O/TRACE ASSOCIATED IN WHICH CASE, VRVAL
*      POINTS TO AN APPROPRIATE TRBLK (TRAP BLOCK) CHAIN.
*
*      VRTRA = B$VRG IF THE LABEL IS NOT TRACED
*      VRTRA = B$VRT IF THE LABEL IS TRACED
*
*      VRLBL POINTS TO A CDBLK IF THERE IS A LABEL
*      VRLBL POINTS TO THE SVBLK SVLBL FIELD FOR A SYSTEM LABEL
*      VRLBL POINTS TO STNDL FOR AN UNDEFINED LABEL
*      VRLBL POINTS TO A TRBLK IF THE LABEL IS TRACED
*
*      VRFNC POINTS TO A FFBLK FOR A FIELD FUNCTION
*      VRFNC POINTS TO A DFBLK FOR A DATATYPE FUNCTION
*      VRFNC POINTS TO A PFBLK FOR A PROGRAM DEFINED FUNCTION
*      VRFNC POINTS TO A EFBLK FOR AN EXTERNAL LOADED FUNCTION
*      VRFNC POINTS TO SVFNC (SVBLK) FOR A SYSTEM FUNCTION
*      VRFNC POINTS TO STNDF IF THE FUNCTION IS UNDEFINED
*
*      VRNXT POINTS TO THE NEXT VRBLK ON THIS CHAIN UNLESS
*      THIS IS THE END OF THE CHAIN IN WHICH CASE IT IS ZERO.
*
*      VRLEN IS THE NAME LENGTH FOR A NON-SYSTEM VARIABLE.
*      VRLEN IS ZERO FOR A SYSTEM VARIABLE.
*
*      VRCHS IS THE NAME (LJRZ) IF VRLEN IS NON-ZERO.
*      VRSVP IS A PTR TO THE SVBLK IF VRLEN IS ZERO.
{{EJC{{{{{7422
*
*      FORMAT OF A NON-RELOCATABLE EXTERNAL BLOCK (XNBLK)
*
*      AN XNBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE BLOCK CONTAINS NO POINTERS TO OTHER
*      RELOCATABLE BLOCKS. AN XNBLK IS USED BY EXTERNAL FUNCTION
*      PROCESSING OR POSSIBLY FOR SYSTEM I/O ROUTINES ETC.
*      THE MACRO-SYSTEM ITSELF DOES NOT USE XNBLKS.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XNTYP               I
*           +------------------------------------+
*           I                XNLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XNDTA               /
*           /                                    /
*           +------------------------------------+
*
{XNTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$XNT{7444
{XNLEN{EQU{24,XNTYP+1{{{LENGTH OF XNBLK IN BYTES{7445
{XNDTA{EQU{24,XNLEN+1{{{DATA WORDS{7446
{XNSI${EQU{24,XNDTA{{{SIZE OF STANDARD FIELDS IN XNBLK{7447
*
*      NOTE THAT THE TERM NON-RELOCATABLE REFERS TO THE CONTENTS
*      AND NOT THE BLOCK ITSELF. AN XNBLK CAN BE MOVED AROUND IF
*      IT IS BUILT IN THE DYNAMIC MEMORY AREA.
{{EJC{{{{{7452
*
*      RELOCATABLE EXTERNAL BLOCK (XRBLK)
*
*      AN XRBLK IS A BLOCK REPRESENTING AN UNKNOWN (EXTERNAL)
*      DATA VALUE. THE DATA AREA IN THIS BLOCK CONSISTS ONLY
*      OF ADDRESS VALUES AND ANY ADDRESSES POINTING INTO THE
*      DYNAMIC MEMORY AREA MUST POINT TO THE START OF OTHER
*      DATA BLOCKS. SEE ALSO DESCRIPTION OF XNBLK.
*      THIS TYPE OF BLOCK MAY BE USED AS A FILE CONTROL BLOCK.
*      SEE SYSFC,SYSIN,SYSOU,S$INP,S$OUP FOR DETAILS.
*
*           +------------------------------------+
*           I                XRTYP               I
*           +------------------------------------+
*           I                XRLEN               I
*           +------------------------------------+
*           /                                    /
*           /                XRPTR               /
*           /                                    /
*           +------------------------------------+
*
{XRTYP{EQU{24,0{{{POINTER TO DUMMY ROUTINE B$XRT{7474
{XRLEN{EQU{24,XRTYP+1{{{LENGTH OF XRBLK IN BYTES{7475
{XRPTR{EQU{24,XRLEN+1{{{START OF ADDRESS POINTERS{7476
{XRSI${EQU{24,XRPTR{{{SIZE OF STANDARD FIELDS IN XRBLK{7477
{{EJC{{{{{7478
*
*      S$CNV (CONVERT) FUNCTION SWITCH CONSTANTS.  THE VALUES
*      ARE TIED TO THE ORDER OF THE ENTRIES IN THE SVCTB TABLE
*      AND HENCE TO THE BRANCH TABLE IN S$CNV.
*
{CNVST{EQU{24,8{{{MAX STANDARD TYPE CODE FOR CONVERT{7484
{CNVRT{EQU{24,CNVST+1{{{CONVERT CODE FOR REALS{7488
{CNVBT{EQU{24,CNVRT{{{NO BUFFERS - SAME AS REAL CODE{7491
{CNVTT{EQU{24,CNVBT+1{{{BSW CODE FOR CONVERT{7495
*
*      INPUT IMAGE LENGTH
*
{INILN{EQU{24,1024{{{DEFAULT IMAGE LENGTH FOR COMPILER{7499
{INILS{EQU{24,1024{{{IMAGE LENGTH IF -SEQU IN EFFECT{7500
*
{IONMB{EQU{24,2{{{NAME BASE USED FOR IOCHN IN SYSIO{7502
{IONMO{EQU{24,4{{{NAME OFFSET USED FOR IOCHN IN SYSIO{7503
*
*      MINIMUM VALUE FOR KEYWORD MAXLNGTH
*      SHOULD BE LARGER THAN INILN
*
{MNLEN{EQU{24,1024{{{MIN VALUE ALLOWED KEYWORD MAXLNGTH{7508
{MXERN{EQU{24,329{{{ERR NUM INADEQUATE STARTUP MEMORY{7509
*
*      IN GENERAL, MEANINGFUL MNEMONICS SHOULD BE USED FOR
*      OFFSETS. HOWEVER FOR SMALL INTEGERS USED OFTEN IN
*      LITERALS THE FOLLOWING GENERAL DEFINITIONS ARE PROVIDED.
*
{NUM01{EQU{24,1{{{{7515
{NUM02{EQU{24,2{{{{7516
{NUM03{EQU{24,3{{{{7517
{NUM04{EQU{24,4{{{{7518
{NUM05{EQU{24,5{{{{7519
{NUM06{EQU{24,6{{{{7520
{NUM07{EQU{24,7{{{{7521
{NUM08{EQU{24,8{{{{7522
{NUM09{EQU{24,9{{{{7523
{NUM10{EQU{24,10{{{{7524
{NM320{EQU{24,320{{{{7525
{NM321{EQU{24,321{{{{7526
{NINI8{EQU{24,998{{{{7527
{NINI9{EQU{24,999{{{{7528
{THSND{EQU{24,1000{{{{7529
{{EJC{{{{{7530
*
*      NUMBERS OF UNDEFINED SPITBOL OPERATORS
*
{OPBUN{EQU{24,5{{{NO. OF BINARY UNDEFINED OPS{7534
{OPUUN{EQU{24,6{{{NO OF UNARY UNDEFINED OPS{7535
*
*      OFFSETS USED IN PRTSN, PRTMI AND ACESS
*
{PRSNF{EQU{24,13{{{OFFSET USED IN PRTSN{7539
{PRTMF{EQU{24,21{{{OFFSET TO COL 21 (PRTMI){7540
{RILEN{EQU{24,1024{{{BUFFER LENGTH FOR SYSRI{7541
*
*      CODES FOR STAGES OF PROCESSING
*
{STGIC{EQU{24,0{{{INITIAL COMPILE{7545
{STGXC{EQU{24,STGIC+1{{{EXECUTION COMPILE (CODE){7546
{STGEV{EQU{24,STGXC+1{{{EXPRESSION EVAL DURING EXECUTION{7547
{STGXT{EQU{24,STGEV+1{{{EXECUTION TIME{7548
{STGCE{EQU{24,STGXT+1{{{INITIAL COMPILE AFTER END LINE{7549
{STGXE{EQU{24,STGCE+1{{{EXEC. COMPILE AFTER END LINE{7550
{STGND{EQU{24,STGCE-STGIC{{{DIFFERENCE IN STAGE AFTER END{7551
{STGEE{EQU{24,STGXE+1{{{EVAL EVALUATING EXPRESSION{7552
{STGNO{EQU{24,STGEE+1{{{NUMBER OF CODES{7553
{{EJC{{{{{7554
*
*
*      STATEMENT NUMBER PAD COUNT FOR LISTR
*
{STNPD{EQU{24,5{{{STATEMENT NO. PAD COUNT{7566
*
*      SYNTAX TYPE CODES
*
*      THESE CODES ARE RETURNED FROM THE SCANE PROCEDURE.
*
*      THEY ARE SPACED 3 APART FOR THE BENEFIT OF EXPAN.
*
{T$UOP{EQU{24,0{{{UNARY OPERATOR{7575
{T$LPR{EQU{24,T$UOP+3{{{LEFT PAREN{7576
{T$LBR{EQU{24,T$LPR+3{{{LEFT BRACKET{7577
{T$CMA{EQU{24,T$LBR+3{{{COMMA{7578
{T$FNC{EQU{24,T$CMA+3{{{FUNCTION CALL{7579
{T$VAR{EQU{24,T$FNC+3{{{VARIABLE{7580
{T$CON{EQU{24,T$VAR+3{{{CONSTANT{7581
{T$BOP{EQU{24,T$CON+3{{{BINARY OPERATOR{7582
{T$RPR{EQU{24,T$BOP+3{{{RIGHT PAREN{7583
{T$RBR{EQU{24,T$RPR+3{{{RIGHT BRACKET{7584
{T$COL{EQU{24,T$RBR+3{{{COLON{7585
{T$SMC{EQU{24,T$COL+3{{{SEMI-COLON{7586
*
*      THE FOLLOWING DEFINITIONS ARE USED ONLY IN THE GOTO FIELD
*
{T$FGO{EQU{24,T$SMC+1{{{FAILURE GOTO{7590
{T$SGO{EQU{24,T$FGO+1{{{SUCCESS GOTO{7591
*
*      THE ABOVE CODES ARE GROUPED SO THAT CODES FOR ELEMENTS
*      WHICH CAN LEGITIMATELY IMMEDIATELY PRECEDE A UNARY
*      OPERATOR COME FIRST TO FACILITATE OPERATOR SYNTAX CHECK.
*
{T$UOK{EQU{24,T$FNC{{{LAST CODE OK BEFORE UNARY OPERATOR{7597
{{EJC{{{{{7598
*
*      DEFINITIONS OF VALUES FOR EXPAN JUMP TABLE
*
{T$UO0{EQU{24,T$UOP+0{{{UNARY OPERATOR, STATE ZERO{7602
{T$UO1{EQU{24,T$UOP+1{{{UNARY OPERATOR, STATE ONE{7603
{T$UO2{EQU{24,T$UOP+2{{{UNARY OPERATOR, STATE TWO{7604
{T$LP0{EQU{24,T$LPR+0{{{LEFT PAREN, STATE ZERO{7605
{T$LP1{EQU{24,T$LPR+1{{{LEFT PAREN, STATE ONE{7606
{T$LP2{EQU{24,T$LPR+2{{{LEFT PAREN, STATE TWO{7607
{T$LB0{EQU{24,T$LBR+0{{{LEFT BRACKET, STATE ZERO{7608
{T$LB1{EQU{24,T$LBR+1{{{LEFT BRACKET, STATE ONE{7609
{T$LB2{EQU{24,T$LBR+2{{{LEFT BRACKET, STATE TWO{7610
{T$CM0{EQU{24,T$CMA+0{{{COMMA, STATE ZERO{7611
{T$CM1{EQU{24,T$CMA+1{{{COMMA, STATE ONE{7612
{T$CM2{EQU{24,T$CMA+2{{{COMMA, STATE TWO{7613
{T$FN0{EQU{24,T$FNC+0{{{FUNCTION CALL, STATE ZERO{7614
{T$FN1{EQU{24,T$FNC+1{{{FUNCTION CALL, STATE ONE{7615
{T$FN2{EQU{24,T$FNC+2{{{FUNCTION CALL, STATE TWO{7616
{T$VA0{EQU{24,T$VAR+0{{{VARIABLE, STATE ZERO{7617
{T$VA1{EQU{24,T$VAR+1{{{VARIABLE, STATE ONE{7618
{T$VA2{EQU{24,T$VAR+2{{{VARIABLE, STATE TWO{7619
{T$CO0{EQU{24,T$CON+0{{{CONSTANT, STATE ZERO{7620
{T$CO1{EQU{24,T$CON+1{{{CONSTANT, STATE ONE{7621
{T$CO2{EQU{24,T$CON+2{{{CONSTANT, STATE TWO{7622
{T$BO0{EQU{24,T$BOP+0{{{BINARY OPERATOR, STATE ZERO{7623
{T$BO1{EQU{24,T$BOP+1{{{BINARY OPERATOR, STATE ONE{7624
{T$BO2{EQU{24,T$BOP+2{{{BINARY OPERATOR, STATE TWO{7625
{T$RP0{EQU{24,T$RPR+0{{{RIGHT PAREN, STATE ZERO{7626
{T$RP1{EQU{24,T$RPR+1{{{RIGHT PAREN, STATE ONE{7627
{T$RP2{EQU{24,T$RPR+2{{{RIGHT PAREN, STATE TWO{7628
{T$RB0{EQU{24,T$RBR+0{{{RIGHT BRACKET, STATE ZERO{7629
{T$RB1{EQU{24,T$RBR+1{{{RIGHT BRACKET, STATE ONE{7630
{T$RB2{EQU{24,T$RBR+2{{{RIGHT BRACKET, STATE TWO{7631
{T$CL0{EQU{24,T$COL+0{{{COLON, STATE ZERO{7632
{T$CL1{EQU{24,T$COL+1{{{COLON, STATE ONE{7633
{T$CL2{EQU{24,T$COL+2{{{COLON, STATE TWO{7634
{T$SM0{EQU{24,T$SMC+0{{{SEMICOLON, STATE ZERO{7635
{T$SM1{EQU{24,T$SMC+1{{{SEMICOLON, STATE ONE{7636
{T$SM2{EQU{24,T$SMC+2{{{SEMICOLON, STATE TWO{7637
*
{T$NES{EQU{24,T$SM2+1{{{NUMBER OF ENTRIES IN BRANCH TABLE{7639
{{EJC{{{{{7640
*
*       DEFINITION OF OFFSETS USED IN CONTROL CARD PROCESSING
*
{CC$CA{EQU{24,0{{{-CASE{7645
{CC$DO{EQU{24,CC$CA+1{{{-DOUBLE{7646
{CC$CO{EQU{24,CC$DO+1{{{-COMPARE{7651
{CC$DU{EQU{24,CC$CO+1{{{-DUMP{7652
{CC$CP{EQU{24,CC$DU+1{{{-COPY{7657
{CC$EJ{EQU{24,CC$CP+1{{{-EJECT{7658
{CC$ER{EQU{24,CC$EJ+1{{{-ERRORS{7662
{CC$EX{EQU{24,CC$ER+1{{{-EXECUTE{7663
{CC$FA{EQU{24,CC$EX+1{{{-FAIL{7664
{CC$IN{EQU{24,CC$FA+1{{{-INCLUDE{7666
{CC$LN{EQU{24,CC$IN+1{{{-LINE{7668
{CC$LI{EQU{24,CC$LN+1{{{-LIST{7669
{CC$NR{EQU{24,CC$LI+1{{{-NOERRORS{7681
{CC$NX{EQU{24,CC$NR+1{{{-NOEXECUTE{7682
{CC$NF{EQU{24,CC$NX+1{{{-NOFAIL{7683
{CC$NL{EQU{24,CC$NF+1{{{-NOLIST{7684
{CC$NO{EQU{24,CC$NL+1{{{-NOOPT{7685
{CC$NP{EQU{24,CC$NO+1{{{-NOPRINT{7686
{CC$OP{EQU{24,CC$NP+1{{{-OPTIMISE{7687
{CC$PR{EQU{24,CC$OP+1{{{-PRINT{7688
{CC$SI{EQU{24,CC$PR+1{{{-SINGLE{7689
{CC$SP{EQU{24,CC$SI+1{{{-SPACE{7690
{CC$ST{EQU{24,CC$SP+1{{{-STITL{7691
{CC$TI{EQU{24,CC$ST+1{{{-TITLE{7692
{CC$TR{EQU{24,CC$TI+1{{{-TRACE{7693
{CC$NC{EQU{24,CC$TR+1{{{NUMBER OF CONTROL CARDS{7694
{CCNOC{EQU{24,4{{{NO. OF CHARS INCLUDED IN MATCH{7695
{CCOFS{EQU{24,7{{{OFFSET TO START OF TITLE/SUBTITLE{7696
{CCINM{EQU{24,9{{{MAX DEPTH OF INCLUDE FILE NESTING{7698
{{EJC{{{{{7700
*
*      DEFINITIONS OF STACK OFFSETS USED IN CMPIL PROCEDURE
*
*      SEE DESCRIPTION AT START OF CMPIL PROCEDURE FOR DETAILS
*      OF USE OF THESE LOCATIONS ON THE STACK.
*
{CMSTM{EQU{24,0{{{TREE FOR STATEMENT BODY{7707
{CMSGO{EQU{24,CMSTM+1{{{TREE FOR SUCCESS GOTO{7708
{CMFGO{EQU{24,CMSGO+1{{{TREE FOR FAIL GOTO{7709
{CMCGO{EQU{24,CMFGO+1{{{CONDITIONAL GOTO FLAG{7710
{CMPCD{EQU{24,CMCGO+1{{{PREVIOUS CDBLK POINTER{7711
{CMFFP{EQU{24,CMPCD+1{{{FAILURE FILL IN FLAG FOR PREVIOUS{7712
{CMFFC{EQU{24,CMFFP+1{{{FAILURE FILL IN FLAG FOR CURRENT{7713
{CMSOP{EQU{24,CMFFC+1{{{SUCCESS FILL IN OFFSET FOR PREVIOUS{7714
{CMSOC{EQU{24,CMSOP+1{{{SUCCESS FILL IN OFFSET FOR CURRENT{7715
{CMLBL{EQU{24,CMSOC+1{{{PTR TO VRBLK FOR CURRENT LABEL{7716
{CMTRA{EQU{24,CMLBL+1{{{PTR TO ENTRY CDBLK{7717
*
{CMNEN{EQU{24,CMTRA+1{{{COUNT OF STACK ENTRIES FOR CMPIL{7719
*
*      A FEW CONSTANTS USED BY THE PROFILER
{PFPD1{EQU{24,8{{{PAD POSITIONS ...{7724
{PFPD2{EQU{24,20{{{... FOR PROFILE ...{7725
{PFPD3{EQU{24,32{{{... PRINTOUT{7726
{PF$I2{EQU{24,CFP$I+CFP$I{{{SIZE OF TABLE ENTRY (2 INTS){7727
*
{{TTL{27,S P I T B O L -- CONSTANT SECTION{{{{7796
*
*      THIS SECTION CONSISTS ENTIRELY OF ASSEMBLED CONSTANTS.
*
*      ALL LABEL NAMES ARE FIVE LETTERS. THE ORDER IS
*      APPROXIMATELY ALPHABETICAL, BUT IN SOME CASES (ALWAYS
*      DOCUMENTED), CONSTANTS MUST BE PLACED IN SOME SPECIAL
*      ORDER WHICH MUST NOT BE DISTURBED.
*
*      IT MUST ALSO BE REMEMBERED THAT THERE IS A REQUIREMENT
*      FOR NO FORWARD REFERENCES WHICH ALSO DISTURBS THE
*      ALPHABETICAL ORDER IN SOME CASES.
*
{{SEC{{{{START OF CONSTANT SECTION{7809
*
*      START OF CONSTANT SECTION
*
{C$AAA{DAC{1,0{{{FIRST LOCATION OF CONSTANT SECTION{7813
*
*      FREE STORE PERCENTAGE (USED BY ALLOC)
*
{ALFSP{DAC{2,E$FSP{{{FREE STORE PERCENTAGE{7817
*
*      BIT CONSTANTS FOR GENERAL USE
*
{BITS0{DBC{1,0{{{ALL ZERO BITS{7821
{BITS1{DBC{1,1{{{ONE BIT IN LOW ORDER POSITION{7822
{BITS2{DBC{1,2{{{BIT IN POSITION 2{7823
{BITS3{DBC{1,4{{{BIT IN POSITION 3{7824
{BITS4{DBC{1,8{{{BIT IN POSITION 4{7825
{BITS5{DBC{1,16{{{BIT IN POSITION 5{7826
{BITS6{DBC{1,32{{{BIT IN POSITION 6{7827
{BITS7{DBC{1,64{{{BIT IN POSITION 7{7828
{BITS8{DBC{1,128{{{BIT IN POSITION 8{7829
{BITS9{DBC{1,256{{{BIT IN POSITION 9{7830
{BIT10{DBC{1,512{{{BIT IN POSITION 10{7831
{BIT11{DBC{1,1024{{{BIT IN POSITION 11{7832
{BIT12{DBC{1,2048{{{BIT IN POSITION 12{7833
{BITSM{DBC{2,CFP$M{{{MASK FOR MAX INTEGER{7834
*
*      BIT CONSTANTS FOR SVBLK (SVBIT FIELD) TESTS
*
{BTFNC{DBC{2,SVFNC{{{BIT TO TEST FOR FUNCTION{7838
{BTKNM{DBC{2,SVKNM{{{BIT TO TEST FOR KEYWORD NUMBER{7839
{BTLBL{DBC{2,SVLBL{{{BIT TO TEST FOR LABEL{7840
{BTFFC{DBC{2,SVFFC{{{BIT TO TEST FOR FAST CALL{7841
{BTCKW{DBC{2,SVCKW{{{BIT TO TEST FOR CONSTANT KEYWORD{7842
{BTKWV{DBC{2,SVKWV{{{BITS TO TEST FOR KEWORD WITH VALUE{7843
{BTPRD{DBC{2,SVPRD{{{BIT TO TEST FOR PREDICATE FUNCTION{7844
{BTPRE{DBC{2,SVPRE{{{BIT TO TEST FOR PREEVALUATION{7845
{BTVAL{DBC{2,SVVAL{{{BIT TO TEST FOR VALUE{7846
{{EJC{{{{{7847
*
*      LIST OF NAMES USED FOR CONTROL CARD PROCESSING
*
{CCNMS{DTC{27,/CASE/{{{{7852
{{DTC{27,/DOUB/{{{{7853
{{DTC{27,/COMP/{{{{7858
{{DTC{27,/DUMP/{{{{7860
{{DTC{27,/COPY/{{{{7862
{{DTC{27,/EJEC/{{{{7864
{{DTC{27,/ERRO/{{{{7865
{{DTC{27,/EXEC/{{{{7866
{{DTC{27,/FAIL/{{{{7867
{{DTC{27,/INCL/{{{{7869
{{DTC{27,/LINE/{{{{7872
{{DTC{27,/LIST/{{{{7874
{{DTC{27,/NOER/{{{{7875
{{DTC{27,/NOEX/{{{{7876
{{DTC{27,/NOFA/{{{{7877
{{DTC{27,/NOLI/{{{{7878
{{DTC{27,/NOOP/{{{{7879
{{DTC{27,/NOPR/{{{{7880
{{DTC{27,/OPTI/{{{{7881
{{DTC{27,/PRIN/{{{{7882
{{DTC{27,/SING/{{{{7883
{{DTC{27,/SPAC/{{{{7884
{{DTC{27,/STIT/{{{{7885
{{DTC{27,/TITL/{{{{7886
{{DTC{27,/TRAC/{{{{7887
*
*      HEADER MESSAGES FOR DUMPR PROCEDURE (SCBLK FORMAT)
*
{DMHDK{DAC{6,B$SCL{{{DUMP OF KEYWORD VALUES{7891
{{DAC{1,22{{{{7892
{{DTC{27,/Dump of Keyword Values/{{{{7893
*
{DMHDV{DAC{6,B$SCL{{{DUMP OF NATURAL VARIABLES{7895
{{DAC{1,25{{{{7896
{{DTC{27,/Dump of Natural Variables/{{{{7897
{{EJC{{{{{7898
*
*      MESSAGE TEXT FOR COMPILATION STATISTICS
*
{ENCM1{DAC{6,B$SCL{{{{7902
{{DAC{1,19{{{{7911
{{DTC{27,/Memory used (words)/{{{{7912
*
{ENCM2{DAC{6,B$SCL{{{{7914
{{DAC{1,19{{{{7915
{{DTC{27,/Memory left (words)/{{{{7916
*
{ENCM3{DAC{6,B$SCL{{{{7919
{{DAC{1,11{{{{7920
{{DTC{27,/Comp errors/{{{{7921
*
{ENCM4{DAC{6,B$SCL{{{{7923
{{DAC{1,20{{{{7928
{{DTC{27,/Comp time (millisec)/{{{{7929
*
{ENCM5{DAC{6,B$SCL{{{EXECUTION SUPPRESSED{7932
{{DAC{1,20{{{{7933
{{DTC{27,/Execution suppressed/{{{{7934
*
*      STRING CONSTANT FOR ABNORMAL END
*
{ENDAB{DAC{6,B$SCL{{{{7938
{{DAC{1,12{{{{7939
{{DTC{27,/Abnormal End/{{{{7940
{{EJC{{{{{7941
*
*      MEMORY OVERFLOW DURING INITIALISATION
*
{ENDMO{DAC{6,B$SCL{{{{7945
{ENDML{DAC{1,15{{{{7946
{{DTC{27,/Memory Overflow/{{{{7947
*
*      STRING CONSTANT FOR MESSAGE ISSUED BY L$END
*
{ENDMS{DAC{6,B$SCL{{{{7951
{{DAC{1,10{{{{7952
{{DTC{27,/Normal end/{{{{7953
*
*      FAIL MESSAGE FOR STACK FAIL SECTION
*
{ENDSO{DAC{6,B$SCL{{{STACK OVERFLOW IN GARBAGE COLLECTOR{7957
{{DAC{1,36{{{{7958
{{DTC{27,/Stack overflow in garbage collection/{{{{7959
*
*      STRING CONSTANT FOR TIME UP
*
{ENDTU{DAC{6,B$SCL{{{{7963
{{DAC{1,15{{{{7964
{{DTC{27,/Error - Time Up/{{{{7965
{{EJC{{{{{7966
*
*      STRING CONSTANT FOR ERROR MESSAGE (ERROR SECTION)
*
{ERMMS{DAC{6,B$SCL{{{ERROR{7970
{{DAC{1,5{{{{7971
{{DTC{27,/Error/{{{{7972
*
{ERMNS{DAC{6,B$SCL{{{STRING / -- /{7974
{{DAC{1,4{{{{7975
{{DTC{27,/ -- /{{{{7976
*
*      STRING CONSTANT FOR PAGE NUMBERING
*
{LSTMS{DAC{6,B$SCL{{{PAGE{7980
{{DAC{1,5{{{{7981
{{DTC{27,/Page /{{{{7982
*
*      LISTING HEADER MESSAGE
*
{HEADR{DAC{6,B$SCL{{{{7986
{{DAC{1,25{{{{7987
{{DTC{27,/Macro SPITBOL Version 3.7/{{{{7988
*
{HEADV{DAC{6,B$SCL{{{FOR EXIT() VERSION NO. CHECK{7990
{{DAC{1,3{{{{7991
{{DTC{27,/3.7/{{{{7992
*
*      INTEGER CONSTANTS FOR GENERAL USE
*      ICBLD OPTIMISATION USES THE FIRST THREE.
*
{INT$R{DAC{6,B$ICL{{{{8002
{INTV0{DIC{16,+0{{{0{8003
{INTON{DAC{6,B$ICL{{{{8004
{INTV1{DIC{16,+1{{{1{8005
{INTTW{DAC{6,B$ICL{{{{8006
{INTV2{DIC{16,+2{{{2{8007
{INTVT{DIC{16,+10{{{10{8008
{INTVH{DIC{16,+100{{{100{8009
{INTTH{DIC{16,+1000{{{1000{8010
*
*      TABLE USED IN ICBLD OPTIMISATION
*
{INTAB{DAC{4,INT$R{{{POINTER TO 0{8014
{{DAC{4,INTON{{{POINTER TO 1{8015
{{DAC{4,INTTW{{{POINTER TO 2{8016
{{EJC{{{{{8017
*
*      SPECIAL PATTERN NODES. THE FOLLOWING PATTERN NODES
*      CONSIST SIMPLY OF A PCODE POINTER, SEE MATCH ROUTINES
*      (P$XXX) FOR FULL DETAILS OF THEIR USE AND FORMAT).
*
{NDABB{DAC{6,P$ABB{{{ARBNO{8023
{NDABD{DAC{6,P$ABD{{{ARBNO{8024
{NDARC{DAC{6,P$ARC{{{ARB{8025
{NDEXB{DAC{6,P$EXB{{{EXPRESSION{8026
{NDFNB{DAC{6,P$FNB{{{FENCE(){8027
{NDFND{DAC{6,P$FND{{{FENCE(){8028
{NDEXC{DAC{6,P$EXC{{{EXPRESSION{8029
{NDIMB{DAC{6,P$IMB{{{IMMEDIATE ASSIGNMENT{8030
{NDIMD{DAC{6,P$IMD{{{IMMEDIATE ASSIGNMENT{8031
{NDNTH{DAC{6,P$NTH{{{PATTERN END (NULL PATTERN){8032
{NDPAB{DAC{6,P$PAB{{{PATTERN ASSIGNMENT{8033
{NDPAD{DAC{6,P$PAD{{{PATTERN ASSIGNMENT{8034
{NDUNA{DAC{6,P$UNA{{{ANCHOR POINT MOVEMENT{8035
*
*      KEYWORD CONSTANT PATTERN NODES. THE FOLLOWING NODES ARE
*      USED AS THE VALUES OF PATTERN KEYWORDS AND THE INITIAL
*      VALUES OF THE CORRESPONDING NATURAL VARIABLES. ALL
*      NODES ARE IN P0BLK FORMAT AND THE ORDER IS TIED TO THE
*      DEFINITIONS OF CORRESPONDING K$XXX SYMBOLS.
*
{NDABO{DAC{6,P$ABO{{{ABORT{8043
{{DAC{4,NDNTH{{{{8044
{NDARB{DAC{6,P$ARB{{{ARB{8045
{{DAC{4,NDNTH{{{{8046
{NDBAL{DAC{6,P$BAL{{{BAL{8047
{{DAC{4,NDNTH{{{{8048
{NDFAL{DAC{6,P$FAL{{{FAIL{8049
{{DAC{4,NDNTH{{{{8050
{NDFEN{DAC{6,P$FEN{{{FENCE{8051
{{DAC{4,NDNTH{{{{8052
{NDREM{DAC{6,P$REM{{{REM{8053
{{DAC{4,NDNTH{{{{8054
{NDSUC{DAC{6,P$SUC{{{SUCCEED{8055
{{DAC{4,NDNTH{{{{8056
*
*      NULL STRING. ALL NULL VALUES POINT TO THIS STRING. THE
*      SVCHS FIELD CONTAINS A BLANK TO PROVIDE FOR EASY DEFAULT
*      PROCESSING IN TRACE, STOPTR, LPAD AND RPAD.
*      NULLW CONTAINS 10 BLANKS WHICH ENSURES AN ALL BLANK WORD
*      BUT FOR VERY EXCEPTIONAL MACHINES.
*
{NULLS{DAC{6,B$SCL{{{NULL STRING VALUE{8064
{{DAC{1,0{{{SCLEN = 0{8065
{NULLW{DTC{27,/          /{{{{8066
*
*
*      CONSTANT STRINGS FOR LCASE AND UCASE KEYWORDS
*
{LCASE{DAC{6,B$SCL{{{{8072
{{DAC{1,26{{{{8073
{{DTC{27,/abcdefghijklmnopqrstuvwxyz/{{{{8074
*
{UCASE{DAC{6,B$SCL{{{{8076
{{DAC{1,26{{{{8077
{{DTC{27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/{{{{8078
{{EJC{{{{{8080
*
*      OPERATOR DOPE VECTORS (SEE DVBLK FORMAT)
*
{OPDVC{DAC{6,O$CNC{{{CONCATENATION{8084
{{DAC{2,C$CNC{{{{8085
{{DAC{2,LLCNC{{{{8086
{{DAC{2,RRCNC{{{{8087
*
*      OPDVS IS USED WHEN SCANNING BELOW THE TOP LEVEL TO
*      INSURE THAT THE CONCATENATION WILL NOT BE LATER
*      MISTAKEN FOR PATTERN MATCHING
*
{OPDVP{DAC{6,O$CNC{{{CONCATENATION - NOT PATTERN MATCH{8093
{{DAC{2,C$CNP{{{{8094
{{DAC{2,LLCNC{{{{8095
{{DAC{2,RRCNC{{{{8096
*
*      NOTE THAT THE ORDER OF THE REMAINING ENTRIES IS TIED TO
*      THE ORDER OF THE CODING IN THE SCANE PROCEDURE.
*
{OPDVS{DAC{6,O$ASS{{{ASSIGNMENT{8101
{{DAC{2,C$ASS{{{{8102
{{DAC{2,LLASS{{{{8103
{{DAC{2,RRASS{{{{8104
*
{{DAC{1,6{{{UNARY EQUAL{8106
{{DAC{2,C$UUO{{{{8107
{{DAC{2,LLUNO{{{{8108
*
{{DAC{6,O$PMV{{{PATTERN MATCH{8110
{{DAC{2,C$PMT{{{{8111
{{DAC{2,LLPMT{{{{8112
{{DAC{2,RRPMT{{{{8113
*
{{DAC{6,O$INT{{{INTERROGATION{8115
{{DAC{2,C$UVL{{{{8116
{{DAC{2,LLUNO{{{{8117
*
{{DAC{1,1{{{BINARY AMPERSAND{8119
{{DAC{2,C$UBO{{{{8120
{{DAC{2,LLAMP{{{{8121
{{DAC{2,RRAMP{{{{8122
*
{{DAC{6,O$KWV{{{KEYWORD REFERENCE{8124
{{DAC{2,C$KEY{{{{8125
{{DAC{2,LLUNO{{{{8126
*
{{DAC{6,O$ALT{{{ALTERNATION{8128
{{DAC{2,C$ALT{{{{8129
{{DAC{2,LLALT{{{{8130
{{DAC{2,RRALT{{{{8131
{{EJC{{{{{8132
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,5{{{UNARY VERTICAL BAR{8136
{{DAC{2,C$UUO{{{{8137
{{DAC{2,LLUNO{{{{8138
*
{{DAC{1,0{{{BINARY AT{8140
{{DAC{2,C$UBO{{{{8141
{{DAC{2,LLATS{{{{8142
{{DAC{2,RRATS{{{{8143
*
{{DAC{6,O$CAS{{{CURSOR ASSIGNMENT{8145
{{DAC{2,C$UNM{{{{8146
{{DAC{2,LLUNO{{{{8147
*
{{DAC{1,2{{{BINARY NUMBER SIGN{8149
{{DAC{2,C$UBO{{{{8150
{{DAC{2,LLNUM{{{{8151
{{DAC{2,RRNUM{{{{8152
*
{{DAC{1,7{{{UNARY NUMBER SIGN{8154
{{DAC{2,C$UUO{{{{8155
{{DAC{2,LLUNO{{{{8156
*
{{DAC{6,O$DVD{{{DIVISION{8158
{{DAC{2,C$BVL{{{{8159
{{DAC{2,LLDVD{{{{8160
{{DAC{2,RRDVD{{{{8161
*
{{DAC{1,9{{{UNARY SLASH{8163
{{DAC{2,C$UUO{{{{8164
{{DAC{2,LLUNO{{{{8165
*
{{DAC{6,O$MLT{{{MULTIPLICATION{8167
{{DAC{2,C$BVL{{{{8168
{{DAC{2,LLMLT{{{{8169
{{DAC{2,RRMLT{{{{8170
{{EJC{{{{{8171
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{1,0{{{DEFERRED EXPRESSION{8175
{{DAC{2,C$DEF{{{{8176
{{DAC{2,LLUNO{{{{8177
*
{{DAC{1,3{{{BINARY PERCENT{8179
{{DAC{2,C$UBO{{{{8180
{{DAC{2,LLPCT{{{{8181
{{DAC{2,RRPCT{{{{8182
*
{{DAC{1,8{{{UNARY PERCENT{8184
{{DAC{2,C$UUO{{{{8185
{{DAC{2,LLUNO{{{{8186
*
{{DAC{6,O$EXP{{{EXPONENTIATION{8188
{{DAC{2,C$BVL{{{{8189
{{DAC{2,LLEXP{{{{8190
{{DAC{2,RREXP{{{{8191
*
{{DAC{1,10{{{UNARY EXCLAMATION{8193
{{DAC{2,C$UUO{{{{8194
{{DAC{2,LLUNO{{{{8195
*
{{DAC{6,O$IMA{{{IMMEDIATE ASSIGNMENT{8197
{{DAC{2,C$BVN{{{{8198
{{DAC{2,LLDLD{{{{8199
{{DAC{2,RRDLD{{{{8200
*
{{DAC{6,O$INV{{{INDIRECTION{8202
{{DAC{2,C$IND{{{{8203
{{DAC{2,LLUNO{{{{8204
*
{{DAC{1,4{{{BINARY NOT{8206
{{DAC{2,C$UBO{{{{8207
{{DAC{2,LLNOT{{{{8208
{{DAC{2,RRNOT{{{{8209
*
{{DAC{1,0{{{NEGATION{8211
{{DAC{2,C$NEG{{{{8212
{{DAC{2,LLUNO{{{{8213
{{EJC{{{{{8214
*
*      OPERATOR DOPE VECTORS (CONTINUED)
*
{{DAC{6,O$SUB{{{SUBTRACTION{8218
{{DAC{2,C$BVL{{{{8219
{{DAC{2,LLPLM{{{{8220
{{DAC{2,RRPLM{{{{8221
*
{{DAC{6,O$COM{{{COMPLEMENTATION{8223
{{DAC{2,C$UVL{{{{8224
{{DAC{2,LLUNO{{{{8225
*
{{DAC{6,O$ADD{{{ADDITION{8227
{{DAC{2,C$BVL{{{{8228
{{DAC{2,LLPLM{{{{8229
{{DAC{2,RRPLM{{{{8230
*
{{DAC{6,O$AFF{{{AFFIRMATION{8232
{{DAC{2,C$UVL{{{{8233
{{DAC{2,LLUNO{{{{8234
*
{{DAC{6,O$PAS{{{PATTERN ASSIGNMENT{8236
{{DAC{2,C$BVN{{{{8237
{{DAC{2,LLDLD{{{{8238
{{DAC{2,RRDLD{{{{8239
*
{{DAC{6,O$NAM{{{NAME REFERENCE{8241
{{DAC{2,C$UNM{{{{8242
{{DAC{2,LLUNO{{{{8243
*
*      SPECIAL DVS FOR GOTO OPERATORS (SEE PROCEDURE SCNGF)
*
{OPDVD{DAC{6,O$GOD{{{DIRECT GOTO{8247
{{DAC{2,C$UVL{{{{8248
{{DAC{2,LLUNO{{{{8249
*
{OPDVN{DAC{6,O$GOC{{{COMPLEX NORMAL GOTO{8251
{{DAC{2,C$UNM{{{{8252
{{DAC{2,LLUNO{{{{8253
{{EJC{{{{{8254
*
*      OPERATOR ENTRY ADDRESS POINTERS, USED IN CODE
*
{OAMN${DAC{6,O$AMN{{{ARRAY REF (MULTI-SUBS BY VALUE){8258
{OAMV${DAC{6,O$AMV{{{ARRAY REF (MULTI-SUBS BY VALUE){8259
{OAON${DAC{6,O$AON{{{ARRAY REF (ONE SUB BY NAME){8260
{OAOV${DAC{6,O$AOV{{{ARRAY REF (ONE SUB BY VALUE){8261
{OCER${DAC{6,O$CER{{{COMPILATION ERROR{8262
{OFEX${DAC{6,O$FEX{{{FAILURE IN EXPRESSION EVALUATION{8263
{OFIF${DAC{6,O$FIF{{{FAILURE DURING GOTO EVALUATION{8264
{OFNC${DAC{6,O$FNC{{{FUNCTION CALL (MORE THAN ONE ARG){8265
{OFNE${DAC{6,O$FNE{{{FUNCTION NAME ERROR{8266
{OFNS${DAC{6,O$FNS{{{FUNCTION CALL (SINGLE ARGUMENT){8267
{OGOF${DAC{6,O$GOF{{{SET GOTO FAILURE TRAP{8268
{OINN${DAC{6,O$INN{{{INDIRECTION BY NAME{8269
{OKWN${DAC{6,O$KWN{{{KEYWORD REFERENCE BY NAME{8270
{OLEX${DAC{6,O$LEX{{{LOAD EXPRESSION BY NAME{8271
{OLPT${DAC{6,O$LPT{{{LOAD PATTERN{8272
{OLVN${DAC{6,O$LVN{{{LOAD VARIABLE NAME{8273
{ONTA${DAC{6,O$NTA{{{NEGATION, FIRST ENTRY{8274
{ONTB${DAC{6,O$NTB{{{NEGATION, SECOND ENTRY{8275
{ONTC${DAC{6,O$NTC{{{NEGATION, THIRD ENTRY{8276
{OPMN${DAC{6,O$PMN{{{PATTERN MATCH BY NAME{8277
{OPMS${DAC{6,O$PMS{{{PATTERN MATCH (STATEMENT){8278
{OPOP${DAC{6,O$POP{{{POP TOP STACK ITEM{8279
{ORNM${DAC{6,O$RNM{{{RETURN NAME FROM EXPRESSION{8280
{ORPL${DAC{6,O$RPL{{{PATTERN REPLACEMENT{8281
{ORVL${DAC{6,O$RVL{{{RETURN VALUE FROM EXPRESSION{8282
{OSLA${DAC{6,O$SLA{{{SELECTION, FIRST ENTRY{8283
{OSLB${DAC{6,O$SLB{{{SELECTION, SECOND ENTRY{8284
{OSLC${DAC{6,O$SLC{{{SELECTION, THIRD ENTRY{8285
{OSLD${DAC{6,O$SLD{{{SELECTION, FOURTH ENTRY{8286
{OSTP${DAC{6,O$STP{{{STOP EXECUTION{8287
{OUNF${DAC{6,O$UNF{{{UNEXPECTED FAILURE{8288
{{EJC{{{{{8289
*
*      TABLE OF NAMES OF UNDEFINED BINARY OPERATORS FOR OPSYN
*
{OPSNB{DAC{2,CH$AT{{{AT{8293
{{DAC{2,CH$AM{{{AMPERSAND{8294
{{DAC{2,CH$NM{{{NUMBER{8295
{{DAC{2,CH$PC{{{PERCENT{8296
{{DAC{2,CH$NT{{{NOT{8297
*
*      TABLE OF NAMES OF UNDEFINED UNARY OPERATORS FOR OPSYN
*
{OPNSU{DAC{2,CH$BR{{{VERTICAL BAR{8301
{{DAC{2,CH$EQ{{{EQUAL{8302
{{DAC{2,CH$NM{{{NUMBER{8303
{{DAC{2,CH$PC{{{PERCENT{8304
{{DAC{2,CH$SL{{{SLASH{8305
{{DAC{2,CH$EX{{{EXCLAMATION{8306
*
*      ADDRESS CONST CONTAINING PROFILE TABLE ENTRY SIZE
*
{PFI2A{DAC{2,PF$I2{{{{8312
*
*      PROFILER MESSAGE STRINGS
*
{PFMS1{DAC{6,B$SCL{{{{8316
{{DAC{1,15{{{{8317
{{DTC{27,/Program Profile/{{{{8318
{PFMS2{DAC{6,B$SCL{{{{8319
{{DAC{1,42{{{{8320
{{DTC{27,/STMT    Number Of     -- Execution Time --/{{{{8321
{PFMS3{DAC{6,B$SCL{{{{8322
{{DAC{1,47{{{{8323
{{DTC{27,/Number  Executions  Total(MSec) per Excn(MCSec)/{{{{8324
*
*
*      REAL CONSTANTS FOR GENERAL USE. NOTE THAT THE CONSTANTS
*      STARTING AT REAV1 FORM A POWERS OF TEN TABLE (USED IN
*      GTNUM AND GTSTG)
*
{REAV0{DRC{17,+0.0{{{0.0{8334
{REAV1{DRC{17,+1.0{{{10**0{8340
{REAVT{DRC{17,+1.0E+1{{{10**1{8341
{{DRC{17,+1.0E+2{{{10**2{8342
{{DRC{17,+1.0E+3{{{10**3{8343
{{DRC{17,+1.0E+4{{{10**4{8344
{{DRC{17,+1.0E+5{{{10**5{8345
{{DRC{17,+1.0E+6{{{10**6{8346
{{DRC{17,+1.0E+7{{{10**7{8347
{{DRC{17,+1.0E+8{{{10**8{8348
{{DRC{17,+1.0E+9{{{10**9{8349
{REATT{DRC{17,+1.0E+10{{{10**10{8350
{{EJC{{{{{8352
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR DTYPE PROCEDURE
*
{SCARR{DAC{6,B$SCL{{{ARRAY{8356
{{DAC{1,5{{{{8357
{{DTC{27,/ARRAY/{{{{8358
*
{SCCOD{DAC{6,B$SCL{{{CODE{8367
{{DAC{1,4{{{{8368
{{DTC{27,/CODE/{{{{8369
*
{SCEXP{DAC{6,B$SCL{{{EXPRESSION{8371
{{DAC{1,10{{{{8372
{{DTC{27,/EXPRESSION/{{{{8373
*
{SCEXT{DAC{6,B$SCL{{{EXTERNAL{8375
{{DAC{1,8{{{{8376
{{DTC{27,/EXTERNAL/{{{{8377
*
{SCINT{DAC{6,B$SCL{{{INTEGER{8379
{{DAC{1,7{{{{8380
{{DTC{27,/INTEGER/{{{{8381
*
{SCNAM{DAC{6,B$SCL{{{NAME{8383
{{DAC{1,4{{{{8384
{{DTC{27,/NAME/{{{{8385
*
{SCNUM{DAC{6,B$SCL{{{NUMERIC{8387
{{DAC{1,7{{{{8388
{{DTC{27,/NUMERIC/{{{{8389
*
{SCPAT{DAC{6,B$SCL{{{PATTERN{8391
{{DAC{1,7{{{{8392
{{DTC{27,/PATTERN/{{{{8393
*
{SCREA{DAC{6,B$SCL{{{REAL{8397
{{DAC{1,4{{{{8398
{{DTC{27,/REAL/{{{{8399
*
{SCSTR{DAC{6,B$SCL{{{STRING{8402
{{DAC{1,6{{{{8403
{{DTC{27,/STRING/{{{{8404
*
{SCTAB{DAC{6,B$SCL{{{TABLE{8406
{{DAC{1,5{{{{8407
{{DTC{27,/TABLE/{{{{8408
{SCFIL{DAC{6,B$SCL{{{FILE (FOR EXTENDED LOAD ARGUMENTS){8410
{{DAC{1,4{{{{8411
{{DTC{27,/FILE/{{{{8412
{{EJC{{{{{8414
*
*      STRING CONSTANTS (SCBLK FORMAT) FOR KVRTN (SEE RETRN)
*
{SCFRT{DAC{6,B$SCL{{{FRETURN{8418
{{DAC{1,7{{{{8419
{{DTC{27,/FRETURN/{{{{8420
*
{SCNRT{DAC{6,B$SCL{{{NRETURN{8422
{{DAC{1,7{{{{8423
{{DTC{27,/NRETURN/{{{{8424
*
{SCRTN{DAC{6,B$SCL{{{RETURN{8426
{{DAC{1,6{{{{8427
{{DTC{27,/RETURN/{{{{8428
*
*      DATATYPE NAME TABLE FOR DTYPE PROCEDURE. THE ORDER OF
*      THESE ENTRIES IS TIED TO THE B$XXX DEFINITIONS FOR BLOCKS
*
*      NOTE THAT SLOTS FOR BUFFER AND REAL DATA TYPES ARE FILLED
*      EVEN IF THESE DATA TYPES ARE CONDITIONALIZED OUT OF THE
*      IMPLEMENTATION.  THIS IS DONE SO THAT THE BLOCK NUMBERING
*      AT BL$AR ETC. REMAINS CONSTANT IN ALL VERSIONS.
*
{SCNMT{DAC{4,SCARR{{{ARBLK     ARRAY{8438
{{DAC{4,SCCOD{{{CDBLK     CODE{8439
{{DAC{4,SCEXP{{{EXBLK     EXPRESSION{8440
{{DAC{4,SCINT{{{ICBLK     INTEGER{8441
{{DAC{4,SCNAM{{{NMBLK     NAME{8442
{{DAC{4,SCPAT{{{P0BLK     PATTERN{8443
{{DAC{4,SCPAT{{{P1BLK     PATTERN{8444
{{DAC{4,SCPAT{{{P2BLK     PATTERN{8445
{{DAC{4,SCREA{{{RCBLK     REAL{8450
{{DAC{4,SCSTR{{{SCBLK     STRING{8452
{{DAC{4,SCEXP{{{SEBLK     EXPRESSION{8453
{{DAC{4,SCTAB{{{TBBLK     TABLE{8454
{{DAC{4,SCARR{{{VCBLK     ARRAY{8455
{{DAC{4,SCEXT{{{XNBLK     EXTERNAL{8456
{{DAC{4,SCEXT{{{XRBLK     EXTERNAL{8457
{{DAC{4,NULLS{{{BFBLK     NO BUFFER IN THIS VERSION{8459
*
*      STRING CONSTANT FOR REAL ZERO
*
{SCRE0{DAC{6,B$SCL{{{{8468
{{DAC{1,2{{{{8469
{{DTC{27,/0./{{{{8470
{{EJC{{{{{8472
*
*      USED TO RE-INITIALISE KVSTL
*
{STLIM{DIC{16,+2147483647{{{DEFAULT STATEMENT LIMIT{8480
*
*      DUMMY FUNCTION BLOCK USED FOR UNDEFINED FUNCTIONS
*
{STNDF{DAC{6,O$FUN{{{PTR TO UNDEFINED FUNCTION ERR CALL{8488
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{8489
*
*      DUMMY CODE BLOCK USED FOR UNDEFINED LABELS
*
{STNDL{DAC{6,L$UND{{{CODE PTR POINTS TO UNDEFINED LBL{8493
*
*      DUMMY OPERATOR BLOCK USED FOR UNDEFINED OPERATORS
*
{STNDO{DAC{6,O$OUN{{{PTR TO UNDEFINED OPERATOR ERR CALL{8497
{{DAC{1,0{{{DUMMY FARGS COUNT FOR CALL CIRCUIT{8498
*
*      STANDARD VARIABLE BLOCK. THIS BLOCK IS USED TO INITIALIZE
*      THE FIRST SEVEN FIELDS OF A NEWLY CONSTRUCTED VRBLK.
*      ITS FORMAT IS TIED TO THE VRBLK DEFINITIONS (SEE GTNVR).
*
{STNVR{DAC{6,B$VRL{{{VRGET{8504
{{DAC{6,B$VRS{{{VRSTO{8505
{{DAC{4,NULLS{{{VRVAL{8506
{{DAC{6,B$VRG{{{VRTRA{8507
{{DAC{4,STNDL{{{VRLBL{8508
{{DAC{4,STNDF{{{VRFNC{8509
{{DAC{1,0{{{VRNXT{8510
{{EJC{{{{{8511
*
*      MESSAGES USED IN END OF RUN PROCESSING (STOPR)
*
{STPM1{DAC{6,B$SCL{{{IN STATEMENT{8515
{{DAC{1,12{{{{8516
{{DTC{27,/In statement/{{{{8517
*
{STPM2{DAC{6,B$SCL{{{{8519
{{DAC{1,14{{{{8520
{{DTC{27,/Stmts executed/{{{{8521
*
{STPM3{DAC{6,B$SCL{{{{8523
{{DAC{1,19{{{{8528
{{DTC{27,/Run time (millisec)/{{{{8529
*
{STPM4{DAC{6,B$SCL{{{{8532
{{DAC{1,12{{{{8533
{{DTC{27,$MCSec / Stmt${{{{8534
*
{STPM5{DAC{6,B$SCL{{{{8536
{{DAC{1,13{{{{8537
{{DTC{27,/Regenerations/{{{{8538
*
{STPM6{DAC{6,B$SCL{{{IN LINE{8541
{{DAC{1,7{{{{8542
{{DTC{27,/In line/{{{{8543
*
{STPM7{DAC{6,B$SCL{{{IN FILE{8547
{{DAC{1,7{{{{8548
{{DTC{27,/In file/{{{{8549
*
*      CHARS FOR /TU/ ENDING CODE
*
{STRTU{DTC{27,/TU/{{{{8554
*
*      TABLE USED BY CONVERT FUNCTION TO CHECK DATATYPE NAME
*      THE ENTRIES ARE ORDERED TO CORRESPOND TO BRANCH TABLE
*      IN S$CNV
*
{SVCTB{DAC{4,SCSTR{{{STRING{8560
{{DAC{4,SCINT{{{INTEGER{8561
{{DAC{4,SCNAM{{{NAME{8562
{{DAC{4,SCPAT{{{PATTERN{8563
{{DAC{4,SCARR{{{ARRAY{8564
{{DAC{4,SCTAB{{{TABLE{8565
{{DAC{4,SCEXP{{{EXPRESSION{8566
{{DAC{4,SCCOD{{{CODE{8567
{{DAC{4,SCNUM{{{NUMERIC{8568
{{DAC{4,SCREA{{{REAL{8571
{{DAC{1,0{{{ZERO MARKS END OF LIST{8577
{{EJC{{{{{8578
*
*      MESSAGES (SCBLK FORMAT) USED BY TRACE PROCEDURES
*
*
{TMASB{DAC{6,B$SCL{{{ASTERISKS FOR TRACE STATEMENT NO{8583
{{DAC{1,13{{{{8584
{{DTC{27,/************ /{{{{8585
*
{TMBEB{DAC{6,B$SCL{{{BLANK-EQUAL-BLANK{8588
{{DAC{1,3{{{{8589
{{DTC{27,/ = /{{{{8590
*
*      DUMMY TRBLK FOR EXPRESSION VARIABLE
*
{TRBEV{DAC{6,B$TRT{{{DUMMY TRBLK{8594
*
*      DUMMY TRBLK FOR KEYWORD VARIABLE
*
{TRBKV{DAC{6,B$TRT{{{DUMMY TRBLK{8598
*
*      DUMMY CODE BLOCK TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{TRXDR{DAC{6,O$TXR{{{BLOCK POINTS TO RETURN ROUTINE{8602
{TRXDC{DAC{4,TRXDR{{{POINTER TO BLOCK{8603
{{EJC{{{{{8604
*
*      STANDARD VARIABLE BLOCKS
*
*      SEE SVBLK FORMAT FOR FULL DETAILS OF THE FORMAT. THE
*      VRBLKS ARE ORDERED BY LENGTH AND WITHIN EACH LENGTH THE
*      ORDER IS ALPHABETICAL BY NAME OF THE VARIABLE.
*
{V$EQF{DBC{2,SVFPR{{{EQ{8612
{{DAC{1,2{{{{8613
{{DTC{27,/EQ/{{{{8614
{{DAC{6,S$EQF{{{{8615
{{DAC{1,2{{{{8616
*
{V$GEF{DBC{2,SVFPR{{{GE{8618
{{DAC{1,2{{{{8619
{{DTC{27,/GE/{{{{8620
{{DAC{6,S$GEF{{{{8621
{{DAC{1,2{{{{8622
*
{V$GTF{DBC{2,SVFPR{{{GT{8624
{{DAC{1,2{{{{8625
{{DTC{27,/GT/{{{{8626
{{DAC{6,S$GTF{{{{8627
{{DAC{1,2{{{{8628
*
{V$LEF{DBC{2,SVFPR{{{LE{8630
{{DAC{1,2{{{{8631
{{DTC{27,/LE/{{{{8632
{{DAC{6,S$LEF{{{{8633
{{DAC{1,2{{{{8634
*
{V$LNF{DBC{2,SVFNP{{{LN{8637
{{DAC{1,2{{{{8638
{{DTC{27,/LN/{{{{8639
{{DAC{6,S$LNF{{{{8640
{{DAC{1,1{{{{8641
*
{V$LTF{DBC{2,SVFPR{{{LT{8644
{{DAC{1,2{{{{8645
{{DTC{27,/LT/{{{{8646
{{DAC{6,S$LTF{{{{8647
{{DAC{1,2{{{{8648
*
{V$NEF{DBC{2,SVFPR{{{NE{8650
{{DAC{1,2{{{{8651
{{DTC{27,/NE/{{{{8652
{{DAC{6,S$NEF{{{{8653
{{DAC{1,2{{{{8654
*
{V$ANY{DBC{2,SVFNP{{{ANY{8680
{{DAC{1,3{{{{8681
{{DTC{27,/ANY/{{{{8682
{{DAC{6,S$ANY{{{{8683
{{DAC{1,1{{{{8684
*
{V$ARB{DBC{2,SVKVC{{{ARB{8686
{{DAC{1,3{{{{8687
{{DTC{27,/ARB/{{{{8688
{{DAC{2,K$ARB{{{{8689
{{DAC{4,NDARB{{{{8690
{{EJC{{{{{8691
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$ARG{DBC{2,SVFNN{{{ARG{8695
{{DAC{1,3{{{{8696
{{DTC{27,/ARG/{{{{8697
{{DAC{6,S$ARG{{{{8698
{{DAC{1,2{{{{8699
*
{V$BAL{DBC{2,SVKVC{{{BAL{8701
{{DAC{1,3{{{{8702
{{DTC{27,/BAL/{{{{8703
{{DAC{2,K$BAL{{{{8704
{{DAC{4,NDBAL{{{{8705
*
{V$COS{DBC{2,SVFNP{{{COS{8708
{{DAC{1,3{{{{8709
{{DTC{27,/COS/{{{{8710
{{DAC{6,S$COS{{{{8711
{{DAC{1,1{{{{8712
*
{V$END{DBC{2,SVLBL{{{END{8715
{{DAC{1,3{{{{8716
{{DTC{27,/END/{{{{8717
{{DAC{6,L$END{{{{8718
*
{V$EXP{DBC{2,SVFNP{{{EXP{8721
{{DAC{1,3{{{{8722
{{DTC{27,/EXP/{{{{8723
{{DAC{6,S$EXP{{{{8724
{{DAC{1,1{{{{8725
*
{V$LEN{DBC{2,SVFNP{{{LEN{8728
{{DAC{1,3{{{{8729
{{DTC{27,/LEN/{{{{8730
{{DAC{6,S$LEN{{{{8731
{{DAC{1,1{{{{8732
*
{V$LEQ{DBC{2,SVFPR{{{LEQ{8734
{{DAC{1,3{{{{8735
{{DTC{27,/LEQ/{{{{8736
{{DAC{6,S$LEQ{{{{8737
{{DAC{1,2{{{{8738
*
{V$LGE{DBC{2,SVFPR{{{LGE{8740
{{DAC{1,3{{{{8741
{{DTC{27,/LGE/{{{{8742
{{DAC{6,S$LGE{{{{8743
{{DAC{1,2{{{{8744
*
{V$LGT{DBC{2,SVFPR{{{LGT{8746
{{DAC{1,3{{{{8747
{{DTC{27,/LGT/{{{{8748
{{DAC{6,S$LGT{{{{8749
{{DAC{1,2{{{{8750
*
{V$LLE{DBC{2,SVFPR{{{LLE{8752
{{DAC{1,3{{{{8753
{{DTC{27,/LLE/{{{{8754
{{DAC{6,S$LLE{{{{8755
{{DAC{1,2{{{{8756
{{EJC{{{{{8757
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$LLT{DBC{2,SVFPR{{{LLT{8761
{{DAC{1,3{{{{8762
{{DTC{27,/LLT/{{{{8763
{{DAC{6,S$LLT{{{{8764
{{DAC{1,2{{{{8765
*
{V$LNE{DBC{2,SVFPR{{{LNE{8767
{{DAC{1,3{{{{8768
{{DTC{27,/LNE/{{{{8769
{{DAC{6,S$LNE{{{{8770
{{DAC{1,2{{{{8771
*
{V$POS{DBC{2,SVFNP{{{POS{8773
{{DAC{1,3{{{{8774
{{DTC{27,/POS/{{{{8775
{{DAC{6,S$POS{{{{8776
{{DAC{1,1{{{{8777
*
{V$REM{DBC{2,SVKVC{{{REM{8779
{{DAC{1,3{{{{8780
{{DTC{27,/REM/{{{{8781
{{DAC{2,K$REM{{{{8782
{{DAC{4,NDREM{{{{8783
*
{V$SET{DBC{2,SVFNN{{{SET{8786
{{DAC{1,3{{{{8787
{{DTC{27,/SET/{{{{8788
{{DAC{6,S$SET{{{{8789
{{DAC{1,3{{{{8790
*
{V$SIN{DBC{2,SVFNP{{{SIN{8794
{{DAC{1,3{{{{8795
{{DTC{27,/SIN/{{{{8796
{{DAC{6,S$SIN{{{{8797
{{DAC{1,1{{{{8798
*
{V$TAB{DBC{2,SVFNP{{{TAB{8801
{{DAC{1,3{{{{8802
{{DTC{27,/TAB/{{{{8803
{{DAC{6,S$TAB{{{{8804
{{DAC{1,1{{{{8805
*
{V$TAN{DBC{2,SVFNP{{{TAN{8808
{{DAC{1,3{{{{8809
{{DTC{27,/TAN/{{{{8810
{{DAC{6,S$TAN{{{{8811
{{DAC{1,1{{{{8812
*
{V$ATN{DBC{2,SVFNP{{{ATAN{8824
{{DAC{1,4{{{{8825
{{DTC{27,/ATAN/{{{{8826
{{DAC{6,S$ATN{{{{8827
{{DAC{1,1{{{{8828
*
{V$CAS{DBC{2,SVKNM{{{CASE{8832
{{DAC{1,4{{{{8833
{{DTC{27,/CASE/{{{{8834
{{DAC{2,K$CAS{{{{8835
*
{V$CHR{DBC{2,SVFNP{{{CHAR{8838
{{DAC{1,4{{{{8839
{{DTC{27,/CHAR/{{{{8840
{{DAC{6,S$CHR{{{{8841
{{DAC{1,1{{{{8842
*
*
{V$CHP{DBC{2,SVFNP{{{CHOP{8846
{{DAC{1,4{{{{8847
{{DTC{27,/CHOP/{{{{8848
{{DAC{6,S$CHP{{{{8849
{{DAC{1,1{{{{8850
{V$COD{DBC{2,SVFNK{{{CODE{8852
{{DAC{1,4{{{{8853
{{DTC{27,/CODE/{{{{8854
{{DAC{2,K$COD{{{{8855
{{DAC{6,S$COD{{{{8856
{{DAC{1,1{{{{8857
*
{V$COP{DBC{2,SVFNN{{{COPY{8859
{{DAC{1,4{{{{8860
{{DTC{27,/COPY/{{{{8861
{{DAC{6,S$COP{{{{8862
{{DAC{1,1{{{{8863
{{EJC{{{{{8864
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DAT{DBC{2,SVFNN{{{DATA{8868
{{DAC{1,4{{{{8869
{{DTC{27,/DATA/{{{{8870
{{DAC{6,S$DAT{{{{8871
{{DAC{1,1{{{{8872
*
{V$DTE{DBC{2,SVFNN{{{DATE{8874
{{DAC{1,4{{{{8875
{{DTC{27,/DATE/{{{{8876
{{DAC{6,S$DTE{{{{8877
{{DAC{1,1{{{{8878
*
{V$DMP{DBC{2,SVFNK{{{DUMP{8880
{{DAC{1,4{{{{8881
{{DTC{27,/DUMP/{{{{8882
{{DAC{2,K$DMP{{{{8883
{{DAC{6,S$DMP{{{{8884
{{DAC{1,1{{{{8885
*
{V$DUP{DBC{2,SVFNN{{{DUPL{8887
{{DAC{1,4{{{{8888
{{DTC{27,/DUPL/{{{{8889
{{DAC{6,S$DUP{{{{8890
{{DAC{1,2{{{{8891
*
{V$EVL{DBC{2,SVFNN{{{EVAL{8893
{{DAC{1,4{{{{8894
{{DTC{27,/EVAL/{{{{8895
{{DAC{6,S$EVL{{{{8896
{{DAC{1,1{{{{8897
*
{V$EXT{DBC{2,SVFNN{{{EXIT{8901
{{DAC{1,4{{{{8902
{{DTC{27,/EXIT/{{{{8903
{{DAC{6,S$EXT{{{{8904
{{DAC{1,2{{{{8905
*
{V$FAL{DBC{2,SVKVC{{{FAIL{8908
{{DAC{1,4{{{{8909
{{DTC{27,/FAIL/{{{{8910
{{DAC{2,K$FAL{{{{8911
{{DAC{4,NDFAL{{{{8912
*
{V$FIL{DBC{2,SVKNM{{{FILE{8915
{{DAC{1,4{{{{8916
{{DTC{27,/FILE/{{{{8917
{{DAC{2,K$FIL{{{{8918
*
{V$HST{DBC{2,SVFNN{{{HOST{8921
{{DAC{1,4{{{{8922
{{DTC{27,/HOST/{{{{8923
{{DAC{6,S$HST{{{{8924
{{DAC{1,5{{{{8925
{{EJC{{{{{8926
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$ITM{DBC{2,SVFNF{{{ITEM{8930
{{DAC{1,4{{{{8931
{{DTC{27,/ITEM/{{{{8932
{{DAC{6,S$ITM{{{{8933
{{DAC{1,999{{{{8934
*
{V$LIN{DBC{2,SVKNM{{{LINE{8937
{{DAC{1,4{{{{8938
{{DTC{27,/LINE/{{{{8939
{{DAC{2,K$LIN{{{{8940
*
{V$LOD{DBC{2,SVFNN{{{LOAD{8945
{{DAC{1,4{{{{8946
{{DTC{27,/LOAD/{{{{8947
{{DAC{6,S$LOD{{{{8948
{{DAC{1,2{{{{8949
*
{V$LPD{DBC{2,SVFNP{{{LPAD{8952
{{DAC{1,4{{{{8953
{{DTC{27,/LPAD/{{{{8954
{{DAC{6,S$LPD{{{{8955
{{DAC{1,3{{{{8956
*
{V$RPD{DBC{2,SVFNP{{{RPAD{8958
{{DAC{1,4{{{{8959
{{DTC{27,/RPAD/{{{{8960
{{DAC{6,S$RPD{{{{8961
{{DAC{1,3{{{{8962
*
{V$RPS{DBC{2,SVFNP{{{RPOS{8964
{{DAC{1,4{{{{8965
{{DTC{27,/RPOS/{{{{8966
{{DAC{6,S$RPS{{{{8967
{{DAC{1,1{{{{8968
*
{V$RTB{DBC{2,SVFNP{{{RTAB{8970
{{DAC{1,4{{{{8971
{{DTC{27,/RTAB/{{{{8972
{{DAC{6,S$RTB{{{{8973
{{DAC{1,1{{{{8974
*
{V$SI${DBC{2,SVFNP{{{SIZE{8976
{{DAC{1,4{{{{8977
{{DTC{27,/SIZE/{{{{8978
{{DAC{6,S$SI${{{{8979
{{DAC{1,1{{{{8980
*
*
{V$SRT{DBC{2,SVFNN{{{SORT{8985
{{DAC{1,4{{{{8986
{{DTC{27,/SORT/{{{{8987
{{DAC{6,S$SRT{{{{8988
{{DAC{1,2{{{{8989
{V$SPN{DBC{2,SVFNP{{{SPAN{8991
{{DAC{1,4{{{{8992
{{DTC{27,/SPAN/{{{{8993
{{DAC{6,S$SPN{{{{8994
{{DAC{1,1{{{{8995
{{EJC{{{{{8996
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V$SQR{DBC{2,SVFNP{{{SQRT{9002
{{DAC{1,4{{{{9003
{{DTC{27,/SQRT/{{{{9004
{{DAC{6,S$SQR{{{{9005
{{DAC{1,1{{{{9006
{V$STN{DBC{2,SVKNM{{{STNO{9008
{{DAC{1,4{{{{9009
{{DTC{27,/STNO/{{{{9010
{{DAC{2,K$STN{{{{9011
*
{V$TIM{DBC{2,SVFNN{{{TIME{9013
{{DAC{1,4{{{{9014
{{DTC{27,/TIME/{{{{9015
{{DAC{6,S$TIM{{{{9016
{{DAC{1,0{{{{9017
*
{V$TRM{DBC{2,SVFNK{{{TRIM{9019
{{DAC{1,4{{{{9020
{{DTC{27,/TRIM/{{{{9021
{{DAC{2,K$TRM{{{{9022
{{DAC{6,S$TRM{{{{9023
{{DAC{1,1{{{{9024
*
{V$ABE{DBC{2,SVKNM{{{ABEND{9026
{{DAC{1,5{{{{9027
{{DTC{27,/ABEND/{{{{9028
{{DAC{2,K$ABE{{{{9029
*
{V$ABO{DBC{2,SVKVL{{{ABORT{9031
{{DAC{1,5{{{{9032
{{DTC{27,/ABORT/{{{{9033
{{DAC{2,K$ABO{{{{9034
{{DAC{6,L$ABO{{{{9035
{{DAC{4,NDABO{{{{9036
*
{V$APP{DBC{2,SVFNF{{{APPLY{9038
{{DAC{1,5{{{{9039
{{DTC{27,/APPLY/{{{{9040
{{DAC{6,S$APP{{{{9041
{{DAC{1,999{{{{9042
*
{V$ABN{DBC{2,SVFNP{{{ARBNO{9044
{{DAC{1,5{{{{9045
{{DTC{27,/ARBNO/{{{{9046
{{DAC{6,S$ABN{{{{9047
{{DAC{1,1{{{{9048
*
{V$ARR{DBC{2,SVFNN{{{ARRAY{9050
{{DAC{1,5{{{{9051
{{DTC{27,/ARRAY/{{{{9052
{{DAC{6,S$ARR{{{{9053
{{DAC{1,2{{{{9054
{{EJC{{{{{9055
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$BRK{DBC{2,SVFNP{{{BREAK{9059
{{DAC{1,5{{{{9060
{{DTC{27,/BREAK/{{{{9061
{{DAC{6,S$BRK{{{{9062
{{DAC{1,1{{{{9063
*
{V$CLR{DBC{2,SVFNN{{{CLEAR{9065
{{DAC{1,5{{{{9066
{{DTC{27,/CLEAR/{{{{9067
{{DAC{6,S$CLR{{{{9068
{{DAC{1,1{{{{9069
*
{V$EJC{DBC{2,SVFNN{{{EJECT{9079
{{DAC{1,5{{{{9080
{{DTC{27,/EJECT/{{{{9081
{{DAC{6,S$EJC{{{{9082
{{DAC{1,1{{{{9083
*
{V$FEN{DBC{2,SVFPK{{{FENCE{9085
{{DAC{1,5{{{{9086
{{DTC{27,/FENCE/{{{{9087
{{DAC{2,K$FEN{{{{9088
{{DAC{6,S$FNC{{{{9089
{{DAC{1,1{{{{9090
{{DAC{4,NDFEN{{{{9091
*
{V$FLD{DBC{2,SVFNN{{{FIELD{9093
{{DAC{1,5{{{{9094
{{DTC{27,/FIELD/{{{{9095
{{DAC{6,S$FLD{{{{9096
{{DAC{1,2{{{{9097
*
{V$IDN{DBC{2,SVFPR{{{IDENT{9099
{{DAC{1,5{{{{9100
{{DTC{27,/IDENT/{{{{9101
{{DAC{6,S$IDN{{{{9102
{{DAC{1,2{{{{9103
*
{V$INP{DBC{2,SVFNK{{{INPUT{9105
{{DAC{1,5{{{{9106
{{DTC{27,/INPUT/{{{{9107
{{DAC{2,K$INP{{{{9108
{{DAC{6,S$INP{{{{9109
{{DAC{1,3{{{{9110
*
{V$LCS{DBC{2,SVKWC{{{LCASE{9113
{{DAC{1,5{{{{9114
{{DTC{27,/LCASE/{{{{9115
{{DAC{2,K$LCS{{{{9116
*
{V$LOC{DBC{2,SVFNN{{{LOCAL{9119
{{DAC{1,5{{{{9120
{{DTC{27,/LOCAL/{{{{9121
{{DAC{6,S$LOC{{{{9122
{{DAC{1,2{{{{9123
{{EJC{{{{{9124
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$OPS{DBC{2,SVFNN{{{OPSYN{9128
{{DAC{1,5{{{{9129
{{DTC{27,/OPSYN/{{{{9130
{{DAC{6,S$OPS{{{{9131
{{DAC{1,3{{{{9132
*
{V$RMD{DBC{2,SVFNP{{{REMDR{9134
{{DAC{1,5{{{{9135
{{DTC{27,/REMDR/{{{{9136
{{DAC{6,S$RMD{{{{9137
{{DAC{1,2{{{{9138
*
{V$RSR{DBC{2,SVFNN{{{RSORT{9142
{{DAC{1,5{{{{9143
{{DTC{27,/RSORT/{{{{9144
{{DAC{6,S$RSR{{{{9145
{{DAC{1,2{{{{9146
*
{V$TBL{DBC{2,SVFNN{{{TABLE{9149
{{DAC{1,5{{{{9150
{{DTC{27,/TABLE/{{{{9151
{{DAC{6,S$TBL{{{{9152
{{DAC{1,3{{{{9153
*
{V$TRA{DBC{2,SVFNK{{{TRACE{9155
{{DAC{1,5{{{{9156
{{DTC{27,/TRACE/{{{{9157
{{DAC{2,K$TRA{{{{9158
{{DAC{6,S$TRA{{{{9159
{{DAC{1,4{{{{9160
*
{V$UCS{DBC{2,SVKWC{{{UCASE{9163
{{DAC{1,5{{{{9164
{{DTC{27,/UCASE/{{{{9165
{{DAC{2,K$UCS{{{{9166
*
{V$ANC{DBC{2,SVKNM{{{ANCHOR{9169
{{DAC{1,6{{{{9170
{{DTC{27,/ANCHOR/{{{{9171
{{DAC{2,K$ANC{{{{9172
*
{V$BKX{DBC{2,SVFNP{{{BREAKX{9183
{{DAC{1,6{{{{9184
{{DTC{27,/BREAKX/{{{{9185
{{DAC{6,S$BKX{{{{9186
{{DAC{1,1{{{{9187
*
*
{V$DEF{DBC{2,SVFNN{{{DEFINE{9198
{{DAC{1,6{{{{9199
{{DTC{27,/DEFINE/{{{{9200
{{DAC{6,S$DEF{{{{9201
{{DAC{1,2{{{{9202
*
{V$DET{DBC{2,SVFNN{{{DETACH{9204
{{DAC{1,6{{{{9205
{{DTC{27,/DETACH/{{{{9206
{{DAC{6,S$DET{{{{9207
{{DAC{1,1{{{{9208
{{EJC{{{{{9209
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DIF{DBC{2,SVFPR{{{DIFFER{9213
{{DAC{1,6{{{{9214
{{DTC{27,/DIFFER/{{{{9215
{{DAC{6,S$DIF{{{{9216
{{DAC{1,2{{{{9217
*
{V$FTR{DBC{2,SVKNM{{{FTRACE{9219
{{DAC{1,6{{{{9220
{{DTC{27,/FTRACE/{{{{9221
{{DAC{2,K$FTR{{{{9222
*
{V$LST{DBC{2,SVKNM{{{LASTNO{9233
{{DAC{1,6{{{{9234
{{DTC{27,/LASTNO/{{{{9235
{{DAC{2,K$LST{{{{9236
*
{V$NAY{DBC{2,SVFNP{{{NOTANY{9238
{{DAC{1,6{{{{9239
{{DTC{27,/NOTANY/{{{{9240
{{DAC{6,S$NAY{{{{9241
{{DAC{1,1{{{{9242
*
{V$OUP{DBC{2,SVFNK{{{OUTPUT{9244
{{DAC{1,6{{{{9245
{{DTC{27,/OUTPUT/{{{{9246
{{DAC{2,K$OUP{{{{9247
{{DAC{6,S$OUP{{{{9248
{{DAC{1,3{{{{9249
*
{V$RET{DBC{2,SVLBL{{{RETURN{9251
{{DAC{1,6{{{{9252
{{DTC{27,/RETURN/{{{{9253
{{DAC{6,L$RTN{{{{9254
*
{V$REW{DBC{2,SVFNN{{{REWIND{9256
{{DAC{1,6{{{{9257
{{DTC{27,/REWIND/{{{{9258
{{DAC{6,S$REW{{{{9259
{{DAC{1,1{{{{9260
*
{V$STT{DBC{2,SVFNN{{{STOPTR{9262
{{DAC{1,6{{{{9263
{{DTC{27,/STOPTR/{{{{9264
{{DAC{6,S$STT{{{{9265
{{DAC{1,2{{{{9266
{{EJC{{{{{9267
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$SUB{DBC{2,SVFNN{{{SUBSTR{9271
{{DAC{1,6{{{{9272
{{DTC{27,/SUBSTR/{{{{9273
{{DAC{6,S$SUB{{{{9274
{{DAC{1,3{{{{9275
*
{V$UNL{DBC{2,SVFNN{{{UNLOAD{9277
{{DAC{1,6{{{{9278
{{DTC{27,/UNLOAD/{{{{9279
{{DAC{6,S$UNL{{{{9280
{{DAC{1,1{{{{9281
*
{V$COL{DBC{2,SVFNN{{{COLLECT{9283
{{DAC{1,7{{{{9284
{{DTC{27,/COLLECT/{{{{9285
{{DAC{6,S$COL{{{{9286
{{DAC{1,1{{{{9287
*
{V$COM{DBC{2,SVKNM{{{COMPARE{9290
{{DAC{1,7{{{{9291
{{DTC{27,/COMPARE/{{{{9292
{{DAC{2,K$COM{{{{9293
*
{V$CNV{DBC{2,SVFNN{{{CONVERT{9296
{{DAC{1,7{{{{9297
{{DTC{27,/CONVERT/{{{{9298
{{DAC{6,S$CNV{{{{9299
{{DAC{1,2{{{{9300
*
{V$ENF{DBC{2,SVFNN{{{ENDFILE{9302
{{DAC{1,7{{{{9303
{{DTC{27,/ENDFILE/{{{{9304
{{DAC{6,S$ENF{{{{9305
{{DAC{1,1{{{{9306
*
{V$ETX{DBC{2,SVKNM{{{ERRTEXT{9308
{{DAC{1,7{{{{9309
{{DTC{27,/ERRTEXT/{{{{9310
{{DAC{2,K$ETX{{{{9311
*
{V$ERT{DBC{2,SVKNM{{{ERRTYPE{9313
{{DAC{1,7{{{{9314
{{DTC{27,/ERRTYPE/{{{{9315
{{DAC{2,K$ERT{{{{9316
*
{V$FRT{DBC{2,SVLBL{{{FRETURN{9318
{{DAC{1,7{{{{9319
{{DTC{27,/FRETURN/{{{{9320
{{DAC{6,L$FRT{{{{9321
*
{V$INT{DBC{2,SVFPR{{{INTEGER{9323
{{DAC{1,7{{{{9324
{{DTC{27,/INTEGER/{{{{9325
{{DAC{6,S$INT{{{{9326
{{DAC{1,1{{{{9327
*
{V$NRT{DBC{2,SVLBL{{{NRETURN{9329
{{DAC{1,7{{{{9330
{{DTC{27,/NRETURN/{{{{9331
{{DAC{6,L$NRT{{{{9332
{{EJC{{{{{9333
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
*
{V$PFL{DBC{2,SVKNM{{{PROFILE{9340
{{DAC{1,7{{{{9341
{{DTC{27,/PROFILE/{{{{9342
{{DAC{2,K$PFL{{{{9343
*
{V$RPL{DBC{2,SVFNP{{{REPLACE{9346
{{DAC{1,7{{{{9347
{{DTC{27,/REPLACE/{{{{9348
{{DAC{6,S$RPL{{{{9349
{{DAC{1,3{{{{9350
*
{V$RVS{DBC{2,SVFNP{{{REVERSE{9352
{{DAC{1,7{{{{9353
{{DTC{27,/REVERSE/{{{{9354
{{DAC{6,S$RVS{{{{9355
{{DAC{1,1{{{{9356
*
{V$RTN{DBC{2,SVKNM{{{RTNTYPE{9358
{{DAC{1,7{{{{9359
{{DTC{27,/RTNTYPE/{{{{9360
{{DAC{2,K$RTN{{{{9361
*
{V$STX{DBC{2,SVFNN{{{SETEXIT{9363
{{DAC{1,7{{{{9364
{{DTC{27,/SETEXIT/{{{{9365
{{DAC{6,S$STX{{{{9366
{{DAC{1,1{{{{9367
*
{V$STC{DBC{2,SVKNM{{{STCOUNT{9369
{{DAC{1,7{{{{9370
{{DTC{27,/STCOUNT/{{{{9371
{{DAC{2,K$STC{{{{9372
*
{V$STL{DBC{2,SVKNM{{{STLIMIT{9374
{{DAC{1,7{{{{9375
{{DTC{27,/STLIMIT/{{{{9376
{{DAC{2,K$STL{{{{9377
*
{V$SUC{DBC{2,SVKVC{{{SUCCEED{9379
{{DAC{1,7{{{{9380
{{DTC{27,/SUCCEED/{{{{9381
{{DAC{2,K$SUC{{{{9382
{{DAC{4,NDSUC{{{{9383
*
{V$ALP{DBC{2,SVKWC{{{ALPHABET{9385
{{DAC{1,8{{{{9386
{{DTC{27,/ALPHABET/{{{{9387
{{DAC{2,K$ALP{{{{9388
*
{V$CNT{DBC{2,SVLBL{{{CONTINUE{9390
{{DAC{1,8{{{{9391
{{DTC{27,/CONTINUE/{{{{9392
{{DAC{6,L$CNT{{{{9393
{{EJC{{{{{9394
*
*      STANDARD VARIABLE BLOCKS (CONTINUED)
*
{V$DTP{DBC{2,SVFNP{{{DATATYPE{9398
{{DAC{1,8{{{{9399
{{DTC{27,/DATATYPE/{{{{9400
{{DAC{6,S$DTP{{{{9401
{{DAC{1,1{{{{9402
*
{V$ERL{DBC{2,SVKNM{{{ERRLIMIT{9404
{{DAC{1,8{{{{9405
{{DTC{27,/ERRLIMIT/{{{{9406
{{DAC{2,K$ERL{{{{9407
*
{V$FNC{DBC{2,SVKNM{{{FNCLEVEL{9409
{{DAC{1,8{{{{9410
{{DTC{27,/FNCLEVEL/{{{{9411
{{DAC{2,K$FNC{{{{9412
*
{V$FLS{DBC{2,SVKNM{{{FULLSCAN{9414
{{DAC{1,8{{{{9415
{{DTC{27,/FULLSCAN/{{{{9416
{{DAC{2,K$FLS{{{{9417
*
{V$LFL{DBC{2,SVKNM{{{LASTFILE{9420
{{DAC{1,8{{{{9421
{{DTC{27,/LASTFILE/{{{{9422
{{DAC{2,K$LFL{{{{9423
*
{V$LLN{DBC{2,SVKNM{{{LASTLINE{9427
{{DAC{1,8{{{{9428
{{DTC{27,/LASTLINE/{{{{9429
{{DAC{2,K$LLN{{{{9430
*
{V$MXL{DBC{2,SVKNM{{{MAXLNGTH{9433
{{DAC{1,8{{{{9434
{{DTC{27,/MAXLNGTH/{{{{9435
{{DAC{2,K$MXL{{{{9436
*
{V$TER{DBC{1,0{{{TERMINAL{9438
{{DAC{1,8{{{{9439
{{DTC{27,/TERMINAL/{{{{9440
{{DAC{1,0{{{{9441
*
{V$BSP{DBC{2,SVFNN{{{BACKSPACE{9444
{{DAC{1,9{{{{9445
{{DTC{27,/BACKSPACE/{{{{9446
{{DAC{6,S$BSP{{{{9447
{{DAC{1,1{{{{9448
*
{V$PRO{DBC{2,SVFNN{{{PROTOTYPE{9451
{{DAC{1,9{{{{9452
{{DTC{27,/PROTOTYPE/{{{{9453
{{DAC{6,S$PRO{{{{9454
{{DAC{1,1{{{{9455
*
{V$SCN{DBC{2,SVLBL{{{SCONTINUE{9457
{{DAC{1,9{{{{9458
{{DTC{27,/SCONTINUE/{{{{9459
{{DAC{6,L$SCN{{{{9460
*
{{DBC{1,0{{{DUMMY ENTRY TO END LIST{9462
{{DAC{1,10{{{LENGTH GT 9 (SCONTINUE){9463
{{EJC{{{{{9464
*
*      LIST OF SVBLK POINTERS FOR KEYWORDS TO BE DUMPED. THE
*      LIST IS IN THE ORDER WHICH APPEARS ON THE DUMP OUTPUT.
*
{VDMKW{DAC{4,V$ANC{{{ANCHOR{9469
{{DAC{4,V$CAS{{{CCASE{9471
{{DAC{4,V$COD{{{CODE{9473
{{DAC{1,1{{{COMPARE NOT PRINTED{9478
{{DAC{4,V$DMP{{{DUMP{9481
{{DAC{4,V$ERL{{{ERRLIMIT{9482
{{DAC{4,V$ETX{{{ERRTEXT{9483
{{DAC{4,V$ERT{{{ERRTYPE{9484
{{DAC{4,V$FIL{{{FILE{9486
{{DAC{4,V$FNC{{{FNCLEVEL{9488
{{DAC{4,V$FTR{{{FTRACE{9489
{{DAC{4,V$FLS{{{FULLSCAN{9490
{{DAC{4,V$INP{{{INPUT{9491
{{DAC{4,V$LFL{{{LASTFILE{9493
{{DAC{4,V$LLN{{{LASTLINE{9496
{{DAC{4,V$LST{{{LASTNO{9498
{{DAC{4,V$LIN{{{LINE{9500
{{DAC{4,V$MXL{{{MAXLENGTH{9502
{{DAC{4,V$OUP{{{OUTPUT{9503
{{DAC{4,V$PFL{{{PROFILE{9506
{{DAC{4,V$RTN{{{RTNTYPE{9508
{{DAC{4,V$STC{{{STCOUNT{9509
{{DAC{4,V$STL{{{STLIMIT{9510
{{DAC{4,V$STN{{{STNO{9511
{{DAC{4,V$TRA{{{TRACE{9512
{{DAC{4,V$TRM{{{TRIM{9513
{{DAC{1,0{{{END OF LIST{9514
*
*      TABLE USED BY GTNVR TO SEARCH SVBLK LISTS
*
{VSRCH{DAC{1,0{{{DUMMY ENTRY TO GET PROPER INDEXING{9518
{{DAC{4,V$EQF{{{START OF 1 CHAR VARIABLES (NONE){9519
{{DAC{4,V$EQF{{{START OF 2 CHAR VARIABLES{9520
{{DAC{4,V$ANY{{{START OF 3 CHAR VARIABLES{9521
{{DAC{4,V$ATN{{{START OF 4 CHAR VARIABLES{9523
{{DAC{4,V$ABE{{{START OF 5 CHAR VARIABLES{9531
{{DAC{4,V$ANC{{{START OF 6 CHAR VARIABLES{9532
{{DAC{4,V$COL{{{START OF 7 CHAR VARIABLES{9533
{{DAC{4,V$ALP{{{START OF 8 CHAR VARIABLES{9534
{{DAC{4,V$BSP{{{START OF 9 CHAR VARIABLES{9536
*
*      LAST LOCATION IN CONSTANT SECTION
*
{C$YYY{DAC{1,0{{{LAST LOCATION IN CONSTANT SECTION{9543
{{TTL{27,S P I T B O L -- WORKING STORAGE SECTION{{{{9544
*
*      THE WORKING STORAGE SECTION CONTAINS AREAS WHICH ARE
*      CHANGED DURING EXECUTION OF THE PROGRAM. THE VALUE
*      ASSEMBLED IS THE INITIAL VALUE BEFORE EXECUTION STARTS.
*
*      ALL THESE AREAS ARE FIXED LENGTH AREAS. VARIABLE LENGTH
*      DATA IS STORED IN THE STATIC OR DYNAMIC REGIONS OF THE
*      ALLOCATED DATA AREAS.
*
*      THE VALUES IN THIS AREA ARE DESCRIBED EITHER AS WORK
*      AREAS OR AS GLOBAL VALUES. A WORK AREA IS USED IN AN
*      EPHEMERAL MANNER AND THE VALUE IS NOT SAVED FROM ONE
*      ENTRY INTO A ROUTINE TO ANOTHER. A GLOBAL VALUE IS A
*      LESS TEMPORARY LOCATION WHOSE VALUE IS SAVED FROM ONE
*      CALL TO ANOTHER.
*
*      W$AAA MARKS THE START OF THE WORKING SECTION WHILST
*      W$YYY MARKS ITS END.  G$AAA MARKS THE DIVISION BETWEEN
*      TEMPORARY AND GLOBAL VALUES.
*
*      GLOBAL VALUES ARE FURTHER SUBDIVIDED TO FACILITATE
*      PROCESSING BY THE GARBAGE COLLECTOR. R$AAA THROUGH
*      R$YYY ARE GLOBAL VALUES THAT MAY POINT INTO DYNAMIC
*      STORAGE AND HENCE MUST BE RELOCATED AFTER EACH GARBAGE
*      COLLECTION.  THEY ALSO SERVE AS ROOT POINTERS TO ALL
*      ALLOCATED DATA THAT MUST BE PRESERVED.  POINTERS BETWEEN
*      A$AAA AND R$AAA MAY POINT INTO CODE, STATIC STORAGE,
*      OR MARK THE LIMITS OF DYNAMIC MEMORY.  THESE POINTERS
*      MUST BE ADJUSTED WHEN THE WORKING SECTION IS SAVED TO A
*      FILE AND SUBSEQUENTLY RELOADED AT A DIFFERENT ADDRESS.
*
*      A GENERAL PART OF THE APPROACH IN THIS PROGRAM IS NOT
*      TO OVERLAP WORK AREAS BETWEEN PROCEDURES EVEN THOUGH A
*      SMALL AMOUNT OF SPACE COULD BE SAVED. SUCH OVERLAP IS
*      CONSIDERED A SOURCE OF PROGRAM ERRORS AND DECREASES THE
*      INFORMATION LEFT BEHIND AFTER A SYSTEM CRASH OF ANY KIND.
*
*      THE NAMES OF THESE LOCATIONS ARE LABELS WITH FIVE LETTER
*      (A-Y,$) NAMES. AS FAR AS POSSIBLE THE ORDER IS KEPT
*      ALPHABETICAL BY THESE NAMES BUT IN SOME CASES THERE
*      ARE SLIGHT DEPARTURES CAUSED BY OTHER ORDER REQUIREMENTS.
*
*      UNLESS OTHERWISE DOCUMENTED, THE ORDER OF WORK AREAS
*      DOES NOT AFFECT THE EXECUTION OF THE SPITBOL PROGRAM.
*
{{SEC{{{{START OF WORKING STORAGE SECTION{9590
{{EJC{{{{{9591
*
*      THIS AREA IS NOT CLEARED BY INITIAL CODE
*
{CMLAB{DAC{6,B$SCL{{{STRING USED TO CHECK LABEL LEGALITY{9595
{{DAC{1,2{{{{9596
{{DTC{27,/  /{{{{9597
*
*      LABEL TO MARK START OF WORK AREA
*
{W$AAA{DAC{1,0{{{{9601
*
*      WORK AREAS FOR ACESS PROCEDURE
*
{ACTRM{DAC{1,0{{{TRIM INDICATOR{9605
*
*      WORK AREAS FOR ALLOC PROCEDURE
*
{ALDYN{DAC{1,0{{{AMOUNT OF DYNAMIC STORE{9609
{ALLIA{DIC{16,+0{{{DUMP IA{9610
{ALLSV{DAC{1,0{{{SAVE WB IN ALLOC{9611
*
*      WORK AREAS FOR ALOST PROCEDURE
*
{ALSTA{DAC{1,0{{{SAVE WA IN ALOST{9615
*
*      WORK AREAS FOR ARRAY FUNCTION (S$ARR)
*
{ARCDM{DAC{1,0{{{COUNT DIMENSIONS{9619
{ARNEL{DIC{16,+0{{{COUNT ELEMENTS{9620
{ARPTR{DAC{1,0{{{OFFSET PTR INTO ARBLK{9621
{ARSVL{DIC{16,+0{{{SAVE INTEGER LOW BOUND{9622
{{EJC{{{{{9623
*
*      WORK AREAS FOR ARREF ROUTINE
*
{ARFSI{DIC{16,+0{{{SAVE CURRENT EVOLVING SUBSCRIPT{9627
{ARFXS{DAC{1,0{{{SAVE BASE STACK POINTER{9628
*
*      WORK AREAS FOR B$EFC BLOCK ROUTINE
*
{BEFOF{DAC{1,0{{{SAVE OFFSET PTR INTO EFBLK{9632
*
*      WORK AREAS FOR B$PFC BLOCK ROUTINE
*
{BPFPF{DAC{1,0{{{SAVE PFBLK POINTER{9636
{BPFSV{DAC{1,0{{{SAVE OLD FUNCTION VALUE{9637
{BPFXT{DAC{1,0{{{POINTER TO STACKED ARGUMENTS{9638
*
*      WORK AREA FOR COLLECT FUNCTION (S$COL)
*
{CLSVI{DIC{16,+0{{{SAVE INTEGER ARGUMENT{9642
*
*      WORK AREAS VALUE FOR CNCRD
*
{CNSCC{DAC{1,0{{{POINTER TO CONTROL CARD STRING{9646
{CNSWC{DAC{1,0{{{WORD COUNT{9647
{CNR$T{DAC{1,0{{{POINTER TO R$TTL OR R$STL{9648
*
*      WORK AREAS FOR CONVERT FUNCTION (S$CNV)
*
{CNVTP{DAC{1,0{{{SAVE PTR INTO SCVTB{9652
*
*      WORK AREAS FOR DATA FUNCTION (S$DAT)
*
{DATDV{DAC{1,0{{{SAVE VRBLK PTR FOR DATATYPE NAME{9656
{DATXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{9657
*
*      WORK AREAS FOR DEFINE FUNCTION (S$DEF)
*
{DEFLB{DAC{1,0{{{SAVE VRBLK PTR FOR LABEL{9661
{DEFNA{DAC{1,0{{{COUNT FUNCTION ARGUMENTS{9662
{DEFVR{DAC{1,0{{{SAVE VRBLK PTR FOR FUNCTION NAME{9663
{DEFXS{DAC{1,0{{{SAVE INITIAL STACK POINTER{9664
*
*      WORK AREAS FOR DUMPR PROCEDURE
*
{DMARG{DAC{1,0{{{DUMP ARGUMENT{9668
{DMPSA{DAC{1,0{{{PRESERVE WA OVER PRTVL CALL{9669
{DMPSB{DAC{1,0{{{PRESERVE WB OVER SYSCM CALL{9671
{DMPSV{DAC{1,0{{{GENERAL SCRATCH SAVE{9673
{DMVCH{DAC{1,0{{{CHAIN POINTER FOR VARIABLE BLOCKS{9674
{DMPCH{DAC{1,0{{{SAVE SORTED VRBLK CHAIN POINTER{9675
{DMPKB{DAC{1,0{{{DUMMY KVBLK FOR USE IN DUMPR{9676
{DMPKT{DAC{1,0{{{KVVAR TRBLK PTR (MUST FOLLOW DMPKB){9677
{DMPKN{DAC{1,0{{{KEYWORD NUMBER (MUST FOLLOW DMPKT){9678
*
*      WORK AREA FOR DTACH
*
{DTCNB{DAC{1,0{{{NAME BASE{9682
{DTCNM{DAC{1,0{{{NAME PTR{9683
*
*      WORK AREAS FOR DUPL FUNCTION (S$DUP)
*
{DUPSI{DIC{16,+0{{{STORE INTEGER STRING LENGTH{9687
*
*      WORK AREA FOR ENDFILE (S$ENF)
*
{ENFCH{DAC{1,0{{{FOR IOCHN CHAIN HEAD{9691
{{EJC{{{{{9692
*
*      WORK AREAS FOR ERTEX
*
{ERTWA{DAC{1,0{{{SAVE WA{9696
{ERTWB{DAC{1,0{{{SAVE WB{9697
*
*      WORK AREAS FOR EVALI
*
{EVLIN{DAC{1,0{{{DUMMY PATTERN BLOCK PCODE{9701
{EVLIS{DAC{1,0{{{THEN NODE (MUST FOLLOW EVLIN){9702
{EVLIV{DAC{1,0{{{VALUE OF PARM1 (MUST FOLLOW EVLIS){9703
{EVLIO{DAC{1,0{{{PTR TO ORIGINAL NODE{9704
{EVLIF{DAC{1,0{{{FLAG FOR SIMPLE/COMPLEX ARGUMENT{9705
*
*      WORK AREA FOR EXPAN
*
{EXPSV{DAC{1,0{{{SAVE OP DOPE VECTOR POINTER{9709
*
*      WORK AREAS FOR GBCOL PROCEDURE
*
{GBCFL{DAC{1,0{{{GARBAGE COLLECTOR ACTIVE FLAG{9713
{GBCLM{DAC{1,0{{{POINTER TO LAST MOVE BLOCK (PASS 3){9714
{GBCNM{DAC{1,0{{{DUMMY FIRST MOVE BLOCK{9715
{GBCNS{DAC{1,0{{{REST OF DUMMY BLOCK (FOLLOWS GBCNM){9716
{GBSVA{DAC{1,0{{{SAVE WA{9726
{GBSVB{DAC{1,0{{{SAVE WB{9727
{GBSVC{DAC{1,0{{{SAVE WC{9728
*
*      WORK AREAS FOR GTNVR PROCEDURE
*
{GNVHE{DAC{1,0{{{PTR TO END OF HASH CHAIN{9732
{GNVNW{DAC{1,0{{{NUMBER OF WORDS IN STRING NAME{9733
{GNVSA{DAC{1,0{{{SAVE WA{9734
{GNVSB{DAC{1,0{{{SAVE WB{9735
{GNVSP{DAC{1,0{{{POINTER INTO VSRCH TABLE{9736
{GNVST{DAC{1,0{{{POINTER TO CHARS OF STRING{9737
*
*      WORK AREAS FOR GTARR
*
{GTAWA{DAC{1,0{{{SAVE WA{9741
*
*      WORK AREAS FOR GTINT
*
{GTINA{DAC{1,0{{{SAVE WA{9745
{GTINB{DAC{1,0{{{SAVE WB{9746
{{EJC{{{{{9747
*
*      WORK AREAS FOR GTNUM PROCEDURE
*
{GTNNF{DAC{1,0{{{ZERO/NONZERO FOR RESULT +/-{9751
{GTNSI{DIC{16,+0{{{GENERAL INTEGER SAVE{9752
{GTNDF{DAC{1,0{{{0/1 FOR DEC POINT SO FAR NO/YES{9755
{GTNES{DAC{1,0{{{ZERO/NONZERO EXPONENT +/-{9756
{GTNEX{DIC{16,+0{{{REAL EXPONENT{9757
{GTNSC{DAC{1,0{{{SCALE (PLACES AFTER POINT){9758
{GTNSR{DRC{17,+0.0{{{GENERAL REAL SAVE{9759
{GTNRD{DAC{1,0{{{FLAG FOR OK REAL NUMBER{9760
*
*      WORK AREAS FOR GTPAT PROCEDURE
*
{GTPSB{DAC{1,0{{{SAVE WB{9765
*
*      WORK AREAS FOR GTSTG PROCEDURE
*
{GTSSF{DAC{1,0{{{0/1 FOR RESULT +/-{9769
{GTSVC{DAC{1,0{{{SAVE WC{9770
{GTSVB{DAC{1,0{{{SAVE WB{9771
*
*      WORK AREAS FOR GTVAR PROCEDURE
*
{GTVRC{DAC{1,0{{{SAVE WC{9783
*
*      WORK AREAS FOR IOPUT
*
{IOPTT{DAC{1,0{{{TYPE OF ASSOCIATION{9798
*
*      WORK AREAS FOR LOAD FUNCTION
*
{LODFN{DAC{1,0{{{POINTER TO VRBLK FOR FUNC NAME{9804
{LODNA{DAC{1,0{{{COUNT NUMBER OF ARGUMENTS{9805
*
*      WORK AREA FOR PROFILER
*
{PFSVW{DAC{1,0{{{TO SAVE A W-REG{9812
*
*      WORK AREAS FOR PRTNM PROCEDURE
*
{PRNSI{DIC{16,+0{{{SCRATCH INTEGER LOC{9817
*
*      WORK AREAS FOR PRTSN PROCEDURE
*
{PRSNA{DAC{1,0{{{SAVE WA{9821
*
*      WORK AREAS FOR PRTST PROCEDURE
*
{PRSVA{DAC{1,0{{{SAVE WA{9825
{PRSVB{DAC{1,0{{{SAVE WB{9826
{PRSVC{DAC{1,0{{{SAVE CHAR COUNTER{9827
*
*      WORK AREA FOR PRTNL
*
{PRTSA{DAC{1,0{{{SAVE WA{9831
{PRTSB{DAC{1,0{{{SAVE WB{9832
*
*      WORK AREA FOR PRTVL
*
{PRVSI{DAC{1,0{{{SAVE IDVAL{9836
*
*      WORK AREAS FOR PATTERN MATCH ROUTINES
*
{PSAVE{DAC{1,0{{{TEMPORARY SAVE FOR CURRENT NODE PTR{9840
{PSAVC{DAC{1,0{{{SAVE CURSOR IN P$SPN, P$STR{9841
*
*      WORK AREAS FOR RETRN ROUTINE
*
{RTNBP{DAC{1,0{{{TO SAVE A BLOCK POINTER{9857
{RTNFV{DAC{1,0{{{NEW FUNCTION VALUE (RESULT){9858
{RTNSV{DAC{1,0{{{OLD FUNCTION VALUE (SAVED VALUE){9859
*
*      WORK AREAS FOR SUBSTR FUNCTION (S$SUB)
*
{SBSSV{DAC{1,0{{{SAVE THIRD ARGUMENT{9863
*
*      WORK AREAS FOR SCAN PROCEDURE
*
{SCNSA{DAC{1,0{{{SAVE WA{9867
{SCNSB{DAC{1,0{{{SAVE WB{9868
{SCNSC{DAC{1,0{{{SAVE WC{9869
{SCNOF{DAC{1,0{{{SAVE OFFSET{9870
{{EJC{{{{{9873
*
*      WORK AREA USED BY SORTA, SORTC, SORTF, SORTH
*
{SRTDF{DAC{1,0{{{DATATYPE FIELD NAME{9877
{SRTFD{DAC{1,0{{{FOUND DFBLK ADDRESS{9878
{SRTFF{DAC{1,0{{{FOUND FIELD NAME{9879
{SRTFO{DAC{1,0{{{OFFSET TO FIELD NAME{9880
{SRTNR{DAC{1,0{{{NUMBER OF ROWS{9881
{SRTOF{DAC{1,0{{{OFFSET WITHIN ROW TO SORT KEY{9882
{SRTRT{DAC{1,0{{{ROOT OFFSET{9883
{SRTS1{DAC{1,0{{{SAVE OFFSET 1{9884
{SRTS2{DAC{1,0{{{SAVE OFFSET 2{9885
{SRTSC{DAC{1,0{{{SAVE WC{9886
{SRTSF{DAC{1,0{{{SORT ARRAY FIRST ROW OFFSET{9887
{SRTSN{DAC{1,0{{{SAVE N{9888
{SRTSO{DAC{1,0{{{OFFSET TO A(0){9889
{SRTSR{DAC{1,0{{{0, NON-ZERO FOR SORT, RSORT{9890
{SRTST{DAC{1,0{{{STRIDE FROM ONE ROW TO NEXT{9891
{SRTWC{DAC{1,0{{{DUMP WC{9892
*
*      WORK AREAS FOR STOPR ROUTINE
*
{STPSI{DIC{16,+0{{{SAVE VALUE OF STCOUNT{9897
{STPTI{DIC{16,+0{{{SAVE TIME ELAPSED{9898
*
*      WORK AREAS FOR TFIND PROCEDURE
*
{TFNSI{DIC{16,+0{{{NUMBER OF HEADERS{9902
*
*      WORK AREAS FOR XSCAN PROCEDURE
*
{XSCRT{DAC{1,0{{{SAVE RETURN CODE{9906
{XSCWB{DAC{1,0{{{SAVE REGISTER WB{9907
*
*      START OF GLOBAL VALUES IN WORKING SECTION
*
{G$AAA{DAC{1,0{{{{9911
*
*      GLOBAL VALUE FOR ALLOC PROCEDURE
*
{ALFSF{DIC{16,+0{{{FACTOR IN FREE STORE PCNTAGE CHECK{9915
*
*      GLOBAL VALUES FOR CMPIL PROCEDURE
*
{CMERC{DAC{1,0{{{COUNT OF INITIAL COMPILE ERRORS{9919
{CMPLN{DAC{1,0{{{LINE NUMBER OF FIRST LINE OF STMT{9920
{CMPXS{DAC{1,0{{{SAVE STACK PTR IN CASE OF ERRORS{9921
{CMPSN{DAC{1,1{{{NUMBER OF NEXT STATEMENT TO COMPILE{9922
*
*      GLOBAL VALUES FOR CNCRD
*
{CNSIL{DAC{1,0{{{SAVE SCNIL DURING INCLUDE PROCESS.{9927
{CNIND{DAC{1,0{{{CURRENT INCLUDE FILE NEST LEVEL{9928
{CNSPT{DAC{1,0{{{SAVE SCNPT DURING INCLUDE PROCESS.{9929
{CNTTL{DAC{1,0{{{FLAG FOR -TITLE, -STITL{9931
*
*      GLOBAL FLAG FOR SUPPRESSION OF COMPILATION STATISTICS.
*
{CPSTS{DAC{1,0{{{SUPPRESS COMP. STATS IF NON ZERO{9935
*
*      GLOBAL VALUES FOR CONTROL CARD SWITCHES
*
{CSWDB{DAC{1,0{{{0/1 FOR -SINGLE/-DOUBLE{9939
{CSWER{DAC{1,0{{{0/1 FOR -ERRORS/-NOERRORS{9940
{CSWEX{DAC{1,0{{{0/1 FOR -EXECUTE/-NOEXECUTE{9941
{CSWFL{DAC{1,1{{{0/1 FOR -NOFAIL/-FAIL{9942
{CSWIN{DAC{2,INILN{{{XXX FOR -INXXX{9943
{CSWLS{DAC{1,1{{{0/1 FOR -NOLIST/-LIST{9944
{CSWNO{DAC{1,0{{{0/1 FOR -OPTIMISE/-NOOPT{9945
{CSWPR{DAC{1,0{{{0/1 FOR -NOPRINT/-PRINT{9946
*
*      GLOBAL LOCATION USED BY PATST PROCEDURE
*
{CTMSK{DBC{1,0{{{LAST BIT POSITION USED IN R$CTP{9950
{CURID{DAC{1,0{{{CURRENT ID VALUE{9951
{{EJC{{{{{9952
*
*      GLOBAL VALUE FOR CDWRD PROCEDURE
*
{CWCOF{DAC{1,0{{{NEXT WORD OFFSET IN CURRENT CCBLK{9956
*
*      GLOBAL AREA FOR ERROR PROCESSING.
*
{ERICH{DAC{1,0{{{COPY ERROR REPORTS TO INT.CHAN IF 1{9966
{ERLST{DAC{1,0{{{FOR LISTR WHEN ERRORS GO TO INT.CH.{9967
{ERRFT{DAC{1,0{{{FATAL ERROR FLAG{9968
{ERRSP{DAC{1,0{{{ERROR SUPPRESSION FLAG{9969
*
*      GLOBAL FLAG FOR SUPPRESSION OF EXECUTION STATS
*
{EXSTS{DAC{1,0{{{SUPPRESS EXEC STATS IF SET{9973
*
*      GLOBAL VALUES FOR EXFAL AND RETURN
*
{FLPRT{DAC{1,0{{{LOCATION OF FAIL OFFSET FOR RETURN{9977
{FLPTR{DAC{1,0{{{LOCATION OF FAILURE OFFSET ON STACK{9978
*
*      GLOBAL LOCATION TO COUNT GARBAGE COLLECTIONS (GBCOL)
*
{GBCNT{DAC{1,0{{{COUNT OF GARBAGE COLLECTIONS{9985
*
*      GLOBAL VALUE FOR GTCOD AND GTEXP
*
{GTCEF{DAC{1,0{{{SAVE FAIL PTR IN CASE OF ERROR{9989
*
*      GLOBAL LOCATIONS FOR GTSTG PROCEDURE
*
{GTSWK{DAC{1,0{{{PTR TO WORK AREA FOR GTSTG{10001
*
*      GLOBAL FLAG FOR HEADER PRINTING
*
{HEADP{DAC{1,0{{{HEADER PRINTED FLAG{10005
*
*      GLOBAL VALUES FOR VARIABLE HASH TABLE
*
{HSHNB{DIC{16,+0{{{NUMBER OF HASH BUCKETS{10009
*
*      GLOBAL AREAS FOR INIT
*
{INITR{DAC{1,0{{{SAVE TERMINAL FLAG{10013
{{EJC{{{{{10014
*
*      GLOBAL VALUES FOR KEYWORD VALUES WHICH ARE STORED AS ONE
*      WORD INTEGERS. THESE VALUES MUST BE ASSEMBLED IN THE
*      FOLLOWING ORDER (AS DICTATED BY K$XXX DEFINITION VALUES).
*
{KVABE{DAC{1,0{{{ABEND{10020
{KVANC{DAC{1,0{{{ANCHOR{10021
{KVCAS{DAC{1,0{{{CASE{10023
{KVCOD{DAC{1,0{{{CODE{10025
{KVCOM{DAC{1,0{{{COMPARE{10027
{KVDMP{DAC{1,0{{{DUMP{10029
{KVERL{DAC{1,0{{{ERRLIMIT{10030
{KVERT{DAC{1,0{{{ERRTYPE{10031
{KVFTR{DAC{1,0{{{FTRACE{10032
{KVFLS{DAC{1,1{{{FULLSCAN{10033
{KVINP{DAC{1,1{{{INPUT{10034
{KVMXL{DAC{1,5000{{{MAXLENGTH{10035
{KVOUP{DAC{1,1{{{OUTPUT{10036
{KVPFL{DAC{1,0{{{PROFILE{10039
{KVTRA{DAC{1,0{{{TRACE{10041
{KVTRM{DAC{1,0{{{TRIM{10042
{KVFNC{DAC{1,0{{{FNCLEVEL{10043
{KVLST{DAC{1,0{{{LASTNO{10044
{KVLLN{DAC{1,0{{{LASTLINE{10046
{KVLIN{DAC{1,0{{{LINE{10047
{KVSTN{DAC{1,0{{{STNO{10049
*
*      GLOBAL VALUES FOR OTHER KEYWORDS
*
{KVALP{DAC{1,0{{{ALPHABET{10053
{KVRTN{DAC{4,NULLS{{{RTNTYPE (SCBLK POINTER){10054
{KVSTL{DIC{16,+2147483647{{{STLIMIT{10060
{KVSTC{DIC{16,+2147483647{{{STCOUNT (COUNTS DOWN FROM STLIMIT){10061
*
*      GLOBAL VALUES FOR LISTR PROCEDURE
*
{LSTID{DAC{1,0{{{INCLUDE DEPTH OF CURRENT IMAGE{10071
{LSTLC{DAC{1,0{{{COUNT LINES ON SOURCE LIST PAGE{10073
{LSTNP{DAC{1,0{{{MAX NUMBER OF LINES ON PAGE{10074
{LSTPF{DAC{1,1{{{SET NONZERO IF CURRENT IMAGE LISTED{10075
{LSTPG{DAC{1,0{{{CURRENT SOURCE LIST PAGE NUMBER{10076
{LSTPO{DAC{1,0{{{OFFSET TO   PAGE NNN   MESSAGE{10077
{LSTSN{DAC{1,0{{{REMEMBER LAST STMNUM LISTED{10078
*
*      GLOBAL MAXIMUM SIZE OF SPITBOL OBJECTS
*
{MXLEN{DAC{1,0{{{INITIALISED BY SYSMX CALL{10082
*
*      GLOBAL EXECUTION CONTROL VARIABLE
*
{NOXEQ{DAC{1,0{{{SET NON-ZERO TO INHIBIT EXECUTION{10086
*
*      GLOBAL PROFILER VALUES LOCATIONS
*
{PFDMP{DAC{1,0{{{SET NON-0 IF &PROFILE SET NON-0{10092
{PFFNC{DAC{1,0{{{SET NON-0 IF FUNCT JUST ENTERED{10093
{PFSTM{DIC{16,+0{{{TO STORE STARTING TIME OF STMT{10094
{PFETM{DIC{16,+0{{{TO STORE ENDING TIME OF STMT{10095
{PFNTE{DAC{1,0{{{NR OF TABLE ENTRIES{10096
{PFSTE{DIC{16,+0{{{GETS INT REP OF TABLE ENTRY SIZE{10097
*
{{EJC{{{{{10100
*
*      GLOBAL VALUES USED IN PATTERN MATCH ROUTINES
*
{PMDFL{DAC{1,0{{{PATTERN ASSIGNMENT FLAG{10104
{PMHBS{DAC{1,0{{{HISTORY STACK BASE POINTER{10105
{PMSSL{DAC{1,0{{{LENGTH OF SUBJECT STRING IN CHARS{10106
*
*      GLOBAL VALUES FOR INTERFACE POLLING (SYSPL)
*
{POLCS{DAC{1,1{{{POLL INTERVAL START VALUE{10111
{POLCT{DAC{1,1{{{POLL INTERVAL COUNTER{10112
*
*      GLOBAL FLAGS USED FOR STANDARD FILE LISTING OPTIONS
*
{PRICH{DAC{1,0{{{PRINTER ON INTERACTIVE CHANNEL{10117
{PRSTD{DAC{1,0{{{TESTED BY PRTPG{10118
{PRSTO{DAC{1,0{{{STANDARD LISTING OPTION FLAG{10119
*
*      GLOBAL VALUES FOR PRINT PROCEDURES
*
{PRBUF{DAC{1,0{{{PTR TO PRINT BFR IN STATIC{10123
{PRECL{DAC{1,0{{{EXTENDED/COMPACT LISTING FLAG{10124
{PRLEN{DAC{1,0{{{LENGTH OF PRINT BUFFER IN CHARS{10125
{PRLNW{DAC{1,0{{{LENGTH OF PRINT BUFFER IN WORDS{10126
{PROFS{DAC{1,0{{{OFFSET TO NEXT LOCATION IN PRBUF{10127
{PRTEF{DAC{1,0{{{ENDFILE FLAG{10128
{{EJC{{{{{10129
*
*      GLOBAL AREA FOR READR
*
{RDCLN{DAC{1,0{{{CURRENT STATEMENT LINE NUMBER{10133
{RDNLN{DAC{1,0{{{NEXT STATEMENT LINE NUMBER{10134
*
*      GLOBAL AMOUNT OF MEMORY RESERVED FOR END OF EXECUTION
*
{RSMEM{DAC{1,0{{{RESERVE MEMORY{10138
*
*      GLOBAL AREA FOR STMGO COUNTERS
*
{STMCS{DAC{1,1{{{COUNTER STARTUP VALUE{10142
{STMCT{DAC{1,1{{{COUNTER ACTIVE VALUE{10143
*
*      ADJUSTABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO THE
*      DYNAMIC OR THE STATIC REGION.
*      WHEN A SAVE FILE IS RELOADED, THESE POINTERS MUST
*      BE ADJUSTED IF STATIC OR DYNAMIC MEMORY IS NOW
*      AT A DIFFERENT ADDRESS.  SEE ROUTINE RELOC FOR
*      ADDITIONAL INFORMATION.
*
*      SOME VALUES CANNOT BE MOVE HERE BECAUSE OF ADJACENCY
*      CONSTRAINTS.  THEY ARE HANDLED SPECIALLY BY RELOC ET AL.
*      THESE VALUES ARE KVRTN,
*
*      VALUES GTSWK, KVALP, AND PRBUF ARE REINITIALIZED BY
*      PROCEDURE INSTA, AND DO NOT NEED TO APPEAR HERE.
*
*      VALUES FLPRT, FLPTR, GTCEF, AND STBAS POINT INTO THE
*      STACK AND ARE EXPLICITLY ADJUSTED BY OSINT'S RESTART
*      PROCEDURE.
*
{A$AAA{DAC{1,0{{{START OF ADJUSTABLE VALUES{10165
{CMPSS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{10166
{DNAMB{DAC{1,0{{{START OF DYNAMIC AREA{10167
{DNAMP{DAC{1,0{{{NEXT AVAILABLE LOC IN DYNAMIC AREA{10168
{DNAME{DAC{1,0{{{END OF AVAILABLE DYNAMIC AREA{10169
{HSHTB{DAC{1,0{{{POINTER TO START OF VRBLK HASH TABL{10170
{HSHTE{DAC{1,0{{{POINTER PAST END OF VRBLK HASH TABL{10171
{INISS{DAC{1,0{{{SAVE SUBROUTINE STACK PTR{10172
{PFTBL{DAC{1,0{{{GETS ADRS OF (IMAG) TABLE BASE{10173
{PRNMV{DAC{1,0{{{VRBLK PTR FROM LAST NAME SEARCH{10174
{STATB{DAC{1,0{{{START OF STATIC AREA{10175
{STATE{DAC{1,0{{{END OF STATIC AREA{10176
{STXVR{DAC{4,NULLS{{{VRBLK POINTER OR NULL{10177
*
*      RELOCATABLE GLOBAL VALUES
*
*      ALL THE POINTERS IN THIS SECTION CAN POINT TO BLOCKS IN
*      THE DYNAMIC STORAGE AREA AND MUST BE RELOCATED BY THE
*      GARBAGE COLLECTOR. THEY ARE IDENTIFIED BY R$XXX NAMES.
*
{R$AAA{DAC{1,0{{{START OF RELOCATABLE VALUES{10186
{R$ARF{DAC{1,0{{{ARRAY BLOCK POINTER FOR ARREF{10187
{R$CCB{DAC{1,0{{{PTR TO CCBLK BEING BUILT (CDWRD){10188
{R$CIM{DAC{1,0{{{PTR TO CURRENT COMPILER INPUT STR{10189
{R$CMP{DAC{1,0{{{COPY OF R$CIM USED IN CMPIL{10190
{R$CNI{DAC{1,0{{{PTR TO NEXT COMPILER INPUT STRING{10191
{R$CNT{DAC{1,0{{{CDBLK POINTER FOR SETEXIT CONTINUE{10192
{R$COD{DAC{1,0{{{POINTER TO CURRENT CDBLK OR EXBLK{10193
{R$CTP{DAC{1,0{{{PTR TO CURRENT CTBLK FOR PATST{10194
{R$CTS{DAC{1,0{{{PTR TO LAST STRING SCANNED BY PATST{10195
{R$ERT{DAC{1,0{{{TRBLK POINTER FOR ERRTYPE TRACE{10196
{R$ETX{DAC{4,NULLS{{{POINTER TO ERRTEXT STRING{10197
{R$EXS{DAC{1,0{{{= SAVE XL IN EXPDM{10198
{R$FCB{DAC{1,0{{{FCBLK CHAIN HEAD{10199
{R$FNC{DAC{1,0{{{TRBLK POINTER FOR FNCLEVEL TRACE{10200
{R$GTC{DAC{1,0{{{KEEP CODE PTR FOR GTCOD,GTEXP{10201
{R$ICI{DAC{1,0{{{SAVED R$CIM DURING INCLUDE PROCESS.{10203
{R$IFA{DAC{1,0{{{ARRAY OF FILE NAMES BY INCL. DEPTH{10205
{R$IFL{DAC{1,0{{{ARRAY OF LINE NUMS BY INCLUDE DEPTH{10206
{R$IFN{DAC{1,0{{{LAST INCLUDE FILE NAME{10208
{R$INC{DAC{1,0{{{TABLE OF INCLUDE FILE NAMES SEEN{10209
{R$IO1{DAC{1,0{{{FILE ARG1 FOR IOPUT{10211
{R$IO2{DAC{1,0{{{FILE ARG2 FOR IOPUT{10212
{R$IOF{DAC{1,0{{{FCBLK PTR OR 0{10213
{R$ION{DAC{1,0{{{NAME BASE PTR{10214
{R$IOP{DAC{1,0{{{PREDECESSOR BLOCK PTR FOR IOPUT{10215
{R$IOT{DAC{1,0{{{TRBLK PTR FOR IOPUT{10216
{R$PMS{DAC{1,0{{{SUBJECT STRING PTR IN PATTERN MATCH{10221
{R$RA2{DAC{1,0{{{REPLACE SECOND ARGUMENT LAST TIME{10222
{R$RA3{DAC{1,0{{{REPLACE THIRD ARGUMENT LAST TIME{10223
{R$RPT{DAC{1,0{{{PTR TO CTBLK REPLACE TABLE LAST USD{10224
{R$SCP{DAC{1,0{{{SAVE POINTER FROM LAST SCANE CALL{10225
{R$SFC{DAC{4,NULLS{{{CURRENT SOURCE FILE NAME{10227
{R$SFN{DAC{1,0{{{PTR TO SOURCE FILE NAME TABLE{10228
{R$SXL{DAC{1,0{{{PRESERVE XL IN SORTC{10230
{R$SXR{DAC{1,0{{{PRESERVE XR IN SORTA/SORTC{10231
{R$STC{DAC{1,0{{{TRBLK POINTER FOR STCOUNT TRACE{10232
{R$STL{DAC{1,0{{{SOURCE LISTING SUB-TITLE{10233
{R$SXC{DAC{1,0{{{CODE (CDBLK) PTR FOR SETEXIT TRAP{10234
{R$TTL{DAC{4,NULLS{{{SOURCE LISTING TITLE{10235
{R$XSC{DAC{1,0{{{STRING POINTER FOR XSCAN{10236
{{EJC{{{{{10237
*
*      THE REMAINING POINTERS IN THIS LIST ARE USED TO POINT
*      TO FUNCTION BLOCKS FOR NORMALLY UNDEFINED OPERATORS.
*
{R$UBA{DAC{4,STNDO{{{BINARY AT{10242
{R$UBM{DAC{4,STNDO{{{BINARY AMPERSAND{10243
{R$UBN{DAC{4,STNDO{{{BINARY NUMBER SIGN{10244
{R$UBP{DAC{4,STNDO{{{BINARY PERCENT{10245
{R$UBT{DAC{4,STNDO{{{BINARY NOT{10246
{R$UUB{DAC{4,STNDO{{{UNARY VERTICAL BAR{10247
{R$UUE{DAC{4,STNDO{{{UNARY EQUAL{10248
{R$UUN{DAC{4,STNDO{{{UNARY NUMBER SIGN{10249
{R$UUP{DAC{4,STNDO{{{UNARY PERCENT{10250
{R$UUS{DAC{4,STNDO{{{UNARY SLASH{10251
{R$UUX{DAC{4,STNDO{{{UNARY EXCLAMATION{10252
{R$YYY{DAC{1,0{{{LAST RELOCATABLE LOCATION{10253
*
*      GLOBAL LOCATIONS USED IN SCAN PROCEDURE
*
{SCNBL{DAC{1,0{{{SET NON-ZERO IF SCANNED PAST BLANKS{10257
{SCNCC{DAC{1,0{{{NON-ZERO TO SCAN CONTROL CARD NAME{10258
{SCNGO{DAC{1,0{{{SET NON-ZERO TO SCAN GOTO FIELD{10259
{SCNIL{DAC{1,0{{{LENGTH OF CURRENT INPUT IMAGE{10260
{SCNPT{DAC{1,0{{{POINTER TO NEXT LOCATION IN R$CIM{10261
{SCNRS{DAC{1,0{{{SET NON-ZERO TO SIGNAL RESCAN{10262
{SCNSE{DAC{1,0{{{START OF CURRENT ELEMENT{10263
{SCNTP{DAC{1,0{{{SAVE SYNTAX TYPE FROM LAST CALL{10264
*
*      GLOBAL VALUE FOR INDICATING STAGE (SEE ERROR SECTION)
*
{STAGE{DAC{1,0{{{INITIAL VALUE = INITIAL COMPILE{10268
{{EJC{{{{{10269
*
*      GLOBAL STACK POINTER
*
{STBAS{DAC{1,0{{{POINTER PAST STACK BASE{10273
*
*      GLOBAL VALUES FOR SETEXIT FUNCTION (S$STX)
*
{STXOC{DAC{1,0{{{CODE POINTER OFFSET{10277
{STXOF{DAC{1,0{{{FAILURE OFFSET{10278
*
*      GLOBAL VALUE FOR TIME KEEPING
*
{TIMSX{DIC{16,+0{{{TIME AT START OF EXECUTION{10282
{TIMUP{DAC{1,0{{{SET WHEN TIME UP OCCURS{10283
*
*      GLOBAL VALUES FOR XSCAN AND XSCNI PROCEDURES
*
{XSOFS{DAC{1,0{{{OFFSET TO CURRENT LOCATION IN R$XSC{10287
*
*      LABEL TO MARK END OF WORKING SECTION
*
{W$YYY{DAC{1,0{{{{10291
{{TTL{27,S P I T B O L -- MINIMAL CODE{{{{10292
{{SEC{{{{START OF PROGRAM SECTION{10293
{S$AAA{ENT{2,BL$$I{{{MARK START OF CODE{10294
{{TTL{27,S P I T B O L -- INITIALIZATION{{{{10766
*
*      INITIALISATION
*      THE FOLLOWING SECTION RECEIVES CONTROL FROM THE SYSTEM
*      AT THE START OF A RUN WITH THE REGISTERS SET AS FOLLOWS.
*
*      (WA)                  INITIAL STACK POINTER
*      (XR)                  POINTS TO FIRST WORD OF DATA AREA
*      (XL)                  POINTS TO LAST WORD OF DATA AREA
*
{START{PRC{25,E{1,0{{ENTRY POINT{10776
{{MOV{8,WA{7,XS{{DISCARD RETURN{10777
{{JSR{6,SYSTM{{{INITIALISE TIMER{10778
{{STI{3,TIMSX{{{STORE TIME{10780
{{MOV{7,XR{3,STATB{{START ADDRESS OF STATIC{10781
{{MOV{19,*E$SRS{3,RSMEM{{RESERVE MEMORY{10833
{{MOV{7,XS{3,STBAS{{STORE STACK BASE{10834
{{SSS{3,INISS{{{SAVE S-R STACK PTR{10835
*
*      NOW CONVERT FREE STORE PERCENTAGE TO A SUITABLE FACTOR
*      FOR EASY TESTING IN ALLOC ROUTINE.
*
{{LDI{4,INTVH{{{GET 100{10840
{{DVI{4,ALFSP{{{FORM 100 / ALFSP{10841
{{STI{3,ALFSF{{{STORE THE FACTOR{10842
{{ZER{8,WC{{{SET TO READ PARAMETERS{10872
{{JSR{6,PRPAR{{{READ THEM{10873
{{EJC{{{{{10874
*
*      NOW COMPUTE STARTING ADDRESS FOR DYNAMIC STORE AND IF
*      NECESSARY REQUEST MORE MEMORY.
*
{{SUB{19,*E$SRS{7,XL{{ALLOW FOR RESERVE MEMORY{10879
{{MOV{3,PRLEN{8,WA{{GET PRINT BUFFER LENGTH{10880
{{ADD{18,=CFP$A{8,WA{{ADD NO. OF CHARS IN ALPHABET{10881
{{ADD{18,=NSTMX{8,WA{{ADD CHARS FOR GTSTG BFR{10882
{{CTB{8,WA{1,8{{CONVERT TO BYTES, ALLOWING A MARGIN{10883
{{MOV{3,STATB{7,XR{{POINT TO STATIC BASE{10884
{{ADD{8,WA{7,XR{{INCREMENT FOR ABOVE BUFFERS{10885
{{ADD{19,*E$HNB{7,XR{{INCREMENT FOR HASH TABLE{10886
{{ADD{19,*E$STS{7,XR{{BUMP FOR INITIAL STATIC BLOCK{10887
{{JSR{6,SYSMX{{{GET MXLEN{10888
{{MOV{8,WA{3,KVMXL{{PROVISIONALLY STORE AS MAXLNGTH{10889
{{MOV{8,WA{3,MXLEN{{AND AS MXLEN{10890
{{BGT{7,XR{8,WA{6,INI06{SKIP IF STATIC HI EXCEEDS MXLEN{10891
{{CTB{8,WA{1,1{{ROUND UP AND MAKE BIGGER THAN MXLEN{10892
{{MOV{8,WA{7,XR{{USE IT INSTEAD{10893
*
*      HERE TO STORE VALUES WHICH MARK INITIAL DIVISION
*      OF DATA AREA INTO STATIC AND DYNAMIC
*
{INI06{MOV{7,XR{3,DNAMB{{DYNAMIC BASE ADRS{10898
{{MOV{7,XR{3,DNAMP{{DYNAMIC PTR{10899
{{BNZ{8,WA{6,INI07{{SKIP IF NON-ZERO MXLEN{10900
{{DCA{7,XR{{{POINT A WORD IN FRONT{10901
{{MOV{7,XR{3,KVMXL{{USE AS MAXLNGTH{10902
{{MOV{7,XR{3,MXLEN{{AND AS MXLEN{10903
{{EJC{{{{{10904
*
*      LOOP HERE IF NECESSARY TILL ENOUGH MEMORY OBTAINED
*      SO THAT DNAME IS ABOVE DNAMB
*
{INI07{MOV{7,XL{3,DNAME{{STORE DYNAMIC END ADDRESS{10909
{{BLT{3,DNAMB{7,XL{6,INI09{SKIP IF HIGH ENOUGH{10910
{{JSR{6,SYSMM{{{REQUEST MORE MEMORY{10911
{{WTB{7,XR{{{GET AS BAUS (SGD05){10912
{{ADD{7,XR{7,XL{{BUMP BY AMOUNT OBTAINED{10913
{{BNZ{7,XR{6,INI07{{TRY AGAIN{10914
{{MOV{18,=MXERN{8,WA{{INSUFFICIENT MEMORY FOR MAXLENGTH{10916
{{ZER{8,WB{{{NO COLUMN NUMBER INFO{10917
{{ZER{8,WC{{{NO LINE NUMBER INFO{10918
{{MOV{18,=STGIC{7,XR{{INITIAL COMPILE STAGE{10919
{{MOV{21,=NULLS{7,XL{{NO FILE NAME{10921
{{JSR{6,SYSEA{{{ADVISE OF ERROR{10923
{{PPM{6,INI08{{{CANT USE ERROR LOGIC YET{10924
{{BRN{6,INI08{{{FORCE TERMINATION{10925
*
*      INSERT TEXT FOR ERROR 329 IN ERROR MESSAGE TABLE
*
{{ERB{1,329{26,Requested MAXLNGTH too large{{{10929
{INI08{MOV{21,=ENDMO{7,XR{{POINT TO FAILURE MESSAGE{10931
{{MOV{4,ENDML{8,WA{{MESSAGE LENGTH{10932
{{JSR{6,SYSPR{{{PRINT IT (PRTST NOT YET USABLE){10933
{{PPM{{{{SHOULD NOT FAIL{10934
{{ZER{7,XL{{{NO FCB CHAIN YET{10935
{{MOV{18,=NUM10{8,WB{{SET SPECIAL CODE VALUE{10936
{{JSR{6,SYSEJ{{{PACK UP (STOPR NOT YET USABLE){10937
*
*      INITIALISE STRUCTURES AT START OF STATIC REGION
*
{INI09{MOV{3,STATB{7,XR{{POINT TO STATIC AGAIN{10941
{{JSR{6,INSTA{{{INITIALIZE STATIC{10942
*
*      INITIALIZE NUMBER OF HASH HEADERS
*
{{MOV{18,=E$HNB{8,WA{{GET NUMBER OF HASH HEADERS{10946
{{MTI{8,WA{{{CONVERT TO INTEGER{10947
{{STI{3,HSHNB{{{STORE FOR USE BY GTNVR PROCEDURE{10948
{{LCT{8,WA{8,WA{{COUNTER FOR CLEARING HASH TABLE{10949
{{MOV{7,XR{3,HSHTB{{POINTER TO HASH TABLE{10950
*
*      LOOP TO CLEAR HASH TABLE
*
{INI11{ZER{10,(XR)+{{{BLANK A WORD{10954
{{BCT{8,WA{6,INI11{{LOOP{10955
{{MOV{7,XR{3,HSHTE{{END OF HASH TABLE ADRS IS KEPT{10956
{{MOV{7,XR{3,STATE{{STORE STATIC END ADDRESS{10957
*
*      INIT TABLE TO MAP STATEMENT NUMBERS TO SOURCE FILE NAMES
*
{{MOV{18,=NUM01{8,WC{{TABLE WILL HAVE ONLY ONE BUCKET{10962
{{MOV{21,=NULLS{7,XL{{DEFAULT TABLE VALUE{10963
{{MOV{7,XL{3,R$SFC{{CURRENT SOURCE FILE NAME{10964
{{JSR{6,TMAKE{{{CREATE TABLE{10965
{{MOV{7,XR{3,R$SFN{{SAVE PTR TO TABLE{10966
*
*      INITIALIZE TABLE TO DETECT DUPLICATE INCLUDE FILE NAMES
*
{{MOV{18,=NUM01{8,WC{{TABLE WILL HAVE ONLY ONE BUCKET{10972
{{MOV{21,=NULLS{7,XL{{DEFAULT TABLE VALUE{10973
{{JSR{6,TMAKE{{{CREATE TABLE{10974
{{MOV{7,XR{3,R$INC{{SAVE PTR TO TABLE{10975
*
*      INITIALIZE ARRAY TO HOLD NAMES OF NESTED INCLUDE FILES
*
{{MOV{18,=CCINM{8,WA{{MAXIMUM NESTING LEVEL{10980
{{MOV{21,=NULLS{7,XL{{NULL STRING DEFAULT VALUE{10981
{{JSR{6,VMAKE{{{CREATE ARRAY{10982
{{PPM{{{{{10983
{{MOV{7,XR{3,R$IFA{{SAVE PTR TO ARRAY{10984
*
*      INIT ARRAY TO HOLD LINE NUMBERS OF NESTED INCLUDE FILES
*
{{MOV{18,=CCINM{8,WA{{MAXIMUM NESTING LEVEL{10988
{{MOV{21,=INTON{7,XL{{INTEGER ONE DEFAULT VALUE{10989
{{JSR{6,VMAKE{{{CREATE ARRAY{10990
{{PPM{{{{{10991
{{MOV{7,XR{3,R$IFL{{SAVE PTR TO ARRAY{10992
*
*      INITIALIZE VARIABLE BLOCKS FOR INPUT AND OUTPUT
*
{{MOV{21,=V$INP{7,XL{{POINT TO STRING /INPUT/{10998
{{MOV{18,=TRTIN{8,WB{{TRBLK TYPE FOR INPUT{10999
{{JSR{6,INOUT{{{PERFORM INPUT ASSOCIATION{11000
{{MOV{21,=V$OUP{7,XL{{POINT TO STRING /OUTPUT/{11001
{{MOV{18,=TRTOU{8,WB{{TRBLK TYPE FOR OUTPUT{11002
{{JSR{6,INOUT{{{PERFORM OUTPUT ASSOCIATION{11003
{{MOV{3,INITR{8,WC{{TERMINAL FLAG{11004
{{BZE{8,WC{6,INI13{{SKIP IF NO TERMINAL{11005
{{JSR{6,PRPAR{{{ASSOCIATE TERMINAL{11006
{{EJC{{{{{11007
*
*      CHECK FOR EXPIRY DATE
*
{INI13{JSR{6,SYSDC{{{CALL DATE CHECK{11011
{{MOV{7,XS{3,FLPTR{{IN CASE STACK OVERFLOWS IN COMPILER{11012
*
*      NOW COMPILE SOURCE INPUT CODE
*
{{JSR{6,CMPIL{{{CALL COMPILER{11016
{{MOV{7,XR{3,R$COD{{SET PTR TO FIRST CODE BLOCK{11017
{{MOV{21,=NULLS{3,R$TTL{{FORGET TITLE{11018
{{MOV{21,=NULLS{3,R$STL{{FORGET SUB-TITLE{11019
{{ZER{3,R$CIM{{{FORGET COMPILER INPUT IMAGE{11020
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{11021
{{ZER{3,CNIND{{{IN CASE END OCCURRED WITH INCLUDE{11023
{{ZER{3,LSTID{{{LISTING INCLUDE DEPTH{11024
{{ZER{7,XL{{{CLEAR DUD VALUE{11026
{{ZER{8,WB{{{DONT SHIFT DYNAMIC STORE UP{11027
{{JSR{6,GBCOL{{{CLEAR GARBAGE LEFT FROM COMPILE{11033
{{BNZ{3,CPSTS{6,INIX0{{SKIP IF NO LISTING OF COMP STATS{11035
{{JSR{6,PRTPG{{{EJECT PAGE{11036
*
*      PRINT COMPILE STATISTICS
*
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{11040
{{MTI{3,CMERC{{{GET COUNT OF ERRORS AS INTEGER{11041
{{MOV{21,=ENCM3{7,XR{{POINT TO /COMPILE ERRORS/{11042
{{JSR{6,PRTMI{{{PRINT IT{11043
{{MTI{3,GBCNT{{{GARBAGE COLLECTION COUNT{11044
{{SBI{4,INTV1{{{ADJUST FOR UNAVOIDABLE COLLECT{11045
{{MOV{21,=STPM5{7,XR{{POINT TO /STORAGE REGENERATIONS/{11046
{{JSR{6,PRTMI{{{PRINT GBCOL COUNT{11047
{{JSR{6,SYSTM{{{GET TIME{11048
{{SBI{3,TIMSX{{{GET COMPILATION TIME{11049
{{MOV{21,=ENCM4{7,XR{{POINT TO COMPILATION TIME (MSEC)/{11050
{{JSR{6,PRTMI{{{PRINT MESSAGE{11051
{{ADD{18,=NUM05{3,LSTLC{{BUMP LINE COUNT{11052
{{BZE{3,HEADP{6,INIX0{{NO EJECT IF NOTHING PRINTED{11054
{{JSR{6,PRTPG{{{EJECT PRINTER{11055
{{EJC{{{{{11057
*
*      PREPARE NOW TO START EXECUTION
*
*      SET DEFAULT INPUT RECORD LENGTH
*
{INIX0{BGT{3,CSWIN{18,=INILN{6,INIX1{SKIP IF NOT DEFAULT -IN72 USED{11063
{{MOV{18,=INILS{3,CSWIN{{ELSE USE DEFAULT RECORD LENGTH{11064
*
*      RESET TIMER
*
{INIX1{JSR{6,SYSTM{{{GET TIME AGAIN{11068
{{STI{3,TIMSX{{{STORE FOR END RUN PROCESSING{11069
{{ZER{3,GBCNT{{{INITIALISE COLLECT COUNT{11070
{{JSR{6,SYSBX{{{CALL BEFORE STARTING EXECUTION{11071
{{ADD{3,CSWEX{3,NOXEQ{{ADD -NOEXECUTE FLAG{11072
{{BNZ{3,NOXEQ{6,INIX2{{JUMP IF EXECUTION SUPPRESSED{11073
*
*      MERGE WHEN LISTING FILE SET FOR EXECUTION.  ALSO
*      MERGE HERE WHEN RESTARTING A SAVE FILE OR LOAD MODULE.
*
{INIY0{MNZ{3,HEADP{{{MARK HEADERS OUT REGARDLESS{11083
{{ZER{11,-(XS){{{SET FAILURE LOCATION ON STACK{11084
{{MOV{7,XS{3,FLPTR{{SAVE PTR TO FAILURE OFFSET WORD{11085
{{MOV{3,R$COD{7,XR{{LOAD PTR TO ENTRY CODE BLOCK{11086
{{MOV{18,=STGXT{3,STAGE{{SET STAGE FOR EXECUTE TIME{11087
{{MOV{18,=NUM01{3,POLCS{{RESET INTERFACE POLLING INTERVAL{11089
{{MOV{18,=NUM01{3,POLCT{{RESET INTERFACE POLLING INTERVAL{11090
{{MOV{3,CMPSN{3,PFNTE{{COPY STMTS COMPILED COUNT IN CASE{11094
{{MOV{3,KVPFL{3,PFDMP{{START PROFILING IF &PROFILE SET{11095
{{JSR{6,SYSTM{{{TIME YET AGAIN{11096
{{STI{3,PFSTM{{{{11097
{{JSR{6,STGCC{{{COMPUTE STMGO COUNTDOWN COUNTERS{11099
{{BRI{9,(XR){{{START XEQ WITH FIRST STATEMENT{11100
*
*      HERE IF EXECUTION IS SUPPRESSED
*
{INIX2{ZER{8,WA{{{SET ABEND VALUE TO ZERO{11105
{{MOV{18,=NINI9{8,WB{{SET SPECIAL CODE VALUE{11113
{{ZER{7,XL{{{NO FCB CHAIN{11114
{{JSR{6,SYSEJ{{{END OF JOB, EXIT TO SYSTEM{11115
{{ENP{{{{END PROCEDURE START{11116
*
*      HERE FROM OSINT TO RESTART A SAVE FILE OR LOAD MODULE.
*
{RSTRT{PRC{25,E{1,0{{ENTRY POINT{11120
{{MOV{3,STBAS{7,XS{{DISCARD RETURN{11121
{{ZER{7,XL{{{CLEAR XL{11122
{{BRN{6,INIY0{{{RESUME EXECUTION{11123
{{ENP{{{{END PROCEDURE RSTRT{11124
{{TTL{27,S P I T B O L -- SNOBOL4 OPERATOR ROUTINES{{{{11126
*
*      THIS SECTION INCLUDES ALL ROUTINES WHICH CAN BE ACCESSED
*      DIRECTLY FROM THE GENERATED CODE EXCEPT SYSTEM FUNCTIONS.
*
*      ALL ROUTINES IN THIS SECTION START WITH A LABEL OF THE
*      FORM O$XXX WHERE XXX IS THREE LETTERS. THE GENERATED CODE
*      CONTAINS A POINTER TO THE APPROPRIATE ENTRY LABEL.
*
*      SINCE THE GENERAL FORM OF THE GENERATED CODE CONSISTS OF
*      POINTERS TO BLOCKS WHOSE FIRST WORD IS THE ADDRESS OF THE
*      ACTUAL ENTRY POINT LABEL (O$XXX).
*
*      THESE ROUTINES ARE IN ALPHABETICAL ORDER BY THEIR
*      ENTRY LABEL NAMES (I.E. BY THE XXX OF THE O$XXX NAME)
*
*      THESE ROUTINES RECEIVE CONTROL AS FOLLOWS
*
*      (CP)                  POINTER TO NEXT CODE WORD
*      (XS)                  CURRENT STACK POINTER
{{EJC{{{{{11146
*
*      BINARY PLUS (ADDITION)
*
{O$ADD{ENT{{{{ENTRY POINT{11150
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11151
{{ERR{1,001{26,Addition left operand is not numeric{{{11152
{{ERR{1,002{26,Addition right operand is not numeric{{{11153
{{PPM{6,OADD1{{{JUMP IF REAL OPERANDS{11156
*
*      HERE TO ADD TWO INTEGERS
*
{{ADI{13,ICVAL(XL){{{ADD RIGHT OPERAND TO LEFT{11161
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11162
{{ERB{1,003{26,Addition caused integer overflow{{{11163
*
*      HERE TO ADD TWO REALS
*
{OADD1{ADR{13,RCVAL(XL){{{ADD RIGHT OPERAND TO LEFT{11169
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11170
{{ERB{1,261{26,Addition caused real overflow{{{11171
{{EJC{{{{{11173
*
*      UNARY PLUS (AFFIRMATION)
*
{O$AFF{ENT{{{{ENTRY POINT{11177
{{MOV{10,(XS)+{7,XR{{LOAD OPERAND{11178
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{11179
{{ERR{1,004{26,Affirmation operand is not numeric{{{11180
{{MOV{7,XR{11,-(XS){{RESULT IF CONVERTED TO NUMERIC{11181
{{LCW{7,XR{{{GET NEXT CODE WORD{11182
{{BRI{9,(XR){{{EXECUTE IT{11183
{{EJC{{{{{11184
*
*      BINARY BAR (ALTERNATION)
*
{O$ALT{ENT{{{{ENTRY POINT{11188
{{MOV{10,(XS)+{7,XR{{LOAD RIGHT OPERAND{11189
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11190
{{ERR{1,005{26,Alternation right operand is not pattern{{{11191
*
*      MERGE HERE FROM SPECIAL (LEFT ALTERNATION) CASE
*
{OALT1{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATIVE NODE{11195
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{11196
{{MOV{7,XR{7,XL{{SAVE ADDRESS OF ALTERNATIVE NODE{11197
{{MOV{10,(XS)+{7,XR{{LOAD LEFT OPERAND{11198
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11199
{{ERR{1,006{26,Alternation left operand is not pattern{{{11200
{{BEQ{7,XR{22,=P$ALT{6,OALT2{JUMP IF LEFT ARG IS ALTERNATION{11201
{{MOV{7,XR{13,PTHEN(XL){{SET LEFT OPERAND AS SUCCESSOR{11202
{{MOV{7,XL{11,-(XS){{STACK RESULT{11203
{{LCW{7,XR{{{GET NEXT CODE WORD{11204
{{BRI{9,(XR){{{EXECUTE IT{11205
*
*      COME HERE IF LEFT ARGUMENT IS ITSELF AN ALTERNATION
*
*      THE RESULT IS MORE EFFICIENT IF WE MAKE THE REPLACEMENT
*
*      (A / B) / C = A / (B / C)
*
{OALT2{MOV{13,PARM1(XR){13,PTHEN(XL){{BUILD THE (B / C) NODE{11213
{{MOV{13,PTHEN(XR){11,-(XS){{SET A AS NEW LEFT ARG{11214
{{MOV{7,XL{7,XR{{SET (B / C) AS NEW RIGHT ARG{11215
{{BRN{6,OALT1{{{MERGE BACK TO BUILD A / (B / C){11216
{{EJC{{{{{11217
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY NAME)
*
{O$AMN{ENT{{{{ENTRY POINT{11221
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{11222
{{MOV{7,XR{8,WB{{SET FLAG FOR BY NAME{11223
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11224
{{EJC{{{{{11225
*
*      ARRAY REFERENCE (MULTIPLE SUBSCRIPTS, BY VALUE)
*
{O$AMV{ENT{{{{ENTRY POINT{11229
{{LCW{7,XR{{{LOAD NUMBER OF SUBSCRIPTS{11230
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{11231
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11232
{{EJC{{{{{11233
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY NAME)
*
{O$AON{ENT{{{{ENTRY POINT{11237
{{MOV{9,(XS){7,XR{{LOAD SUBSCRIPT VALUE{11238
{{MOV{12,1(XS){7,XL{{LOAD ARRAY VALUE{11239
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF ARRAY OPERAND{11240
{{BEQ{8,WA{22,=B$VCT{6,OAON2{JUMP IF VECTOR REFERENCE{11241
{{BEQ{8,WA{22,=B$TBT{6,OAON3{JUMP IF TABLE REFERENCE{11242
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAON1{MOV{18,=NUM01{7,XR{{SET NUMBER OF SUBSCRIPTS TO ONE{11246
{{MOV{7,XR{8,WB{{SET FLAG FOR BY NAME{11247
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11248
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAON2{BNE{9,(XR){22,=B$ICL{6,OAON1{USE LONG ROUTINE IF NOT INTEGER{11252
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{11253
{{MFI{8,WA{6,EXFAL{{COPY AS ADDRESS INT, FAIL IF OVFLO{11254
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{11255
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{11256
{{WTB{8,WA{{{CONVERT TO BYTES{11257
{{MOV{8,WA{9,(XS){{COMPLETE NAME ON STACK{11258
{{BLT{8,WA{13,VCLEN(XL){6,OAON4{EXIT IF SUBSCRIPT NOT TOO LARGE{11259
{{BRN{6,EXFAL{{{ELSE FAIL{11260
*
*      HERE FOR TABLE REFERENCE
*
{OAON3{MNZ{8,WB{{{SET FLAG FOR NAME REFERENCE{11264
{{JSR{6,TFIND{{{LOCATE/CREATE TABLE ELEMENT{11265
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11266
{{MOV{7,XL{12,1(XS){{STORE NAME BASE ON STACK{11267
{{MOV{8,WA{9,(XS){{STORE NAME OFFSET ON STACK{11268
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{OAON4{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11272
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11273
{{EJC{{{{{11274
*
*      ARRAY REFERENCE (ONE SUBSCRIPT, BY VALUE)
*
{O$AOV{ENT{{{{ENTRY POINT{11278
{{MOV{10,(XS)+{7,XR{{LOAD SUBSCRIPT VALUE{11279
{{MOV{10,(XS)+{7,XL{{LOAD ARRAY VALUE{11280
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF ARRAY OPERAND{11281
{{BEQ{8,WA{22,=B$VCT{6,OAOV2{JUMP IF VECTOR REFERENCE{11282
{{BEQ{8,WA{22,=B$TBT{6,OAOV3{JUMP IF TABLE REFERENCE{11283
*
*      HERE TO USE CENTRAL ARRAY REFERENCE ROUTINE
*
{OAOV1{MOV{7,XL{11,-(XS){{RESTACK ARRAY VALUE{11287
{{MOV{7,XR{11,-(XS){{RESTACK SUBSCRIPT{11288
{{MOV{18,=NUM01{7,XR{{SET NUMBER OF SUBSCRIPTS TO ONE{11289
{{ZER{8,WB{{{SET FLAG FOR VALUE CALL{11290
{{BRN{6,ARREF{{{JUMP TO ARRAY REFERENCE ROUTINE{11291
*
*      HERE IF WE HAVE A VECTOR REFERENCE
*
{OAOV2{BNE{9,(XR){22,=B$ICL{6,OAOV1{USE LONG ROUTINE IF NOT INTEGER{11295
{{LDI{13,ICVAL(XR){{{LOAD INTEGER SUBSCRIPT VALUE{11296
{{MFI{8,WA{6,EXFAL{{MOVE AS ONE WORD INT, FAIL IF OVFLO{11297
{{BZE{8,WA{6,EXFAL{{FAIL IF ZERO{11298
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{11299
{{WTB{8,WA{{{CONVERT TO BYTES{11300
{{BGE{8,WA{13,VCLEN(XL){6,EXFAL{FAIL IF SUBSCRIPT TOO LARGE{11301
{{JSR{6,ACESS{{{ACCESS VALUE{11302
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11303
{{MOV{7,XR{11,-(XS){{STACK RESULT{11304
{{LCW{7,XR{{{GET NEXT CODE WORD{11305
{{BRI{9,(XR){{{EXECUTE IT{11306
*
*      HERE FOR TABLE REFERENCE BY VALUE
*
{OAOV3{ZER{8,WB{{{SET FLAG FOR VALUE REFERENCE{11310
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{11311
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{11312
{{MOV{7,XR{11,-(XS){{STACK RESULT{11313
{{LCW{7,XR{{{GET NEXT CODE WORD{11314
{{BRI{9,(XR){{{EXECUTE IT{11315
{{EJC{{{{{11316
*
*      ASSIGNMENT
*
{O$ASS{ENT{{{{ENTRY POINT{11320
*
*      O$RPL (PATTERN REPLACEMENT) MERGES HERE
*
{OASS0{MOV{10,(XS)+{8,WB{{LOAD VALUE TO BE ASSIGNED{11324
{{MOV{10,(XS)+{8,WA{{LOAD NAME OFFSET{11325
{{MOV{9,(XS){7,XL{{LOAD NAME BASE{11326
{{MOV{8,WB{9,(XS){{STORE ASSIGNED VALUE AS RESULT{11327
{{JSR{6,ASIGN{{{PERFORM ASSIGNMENT{11328
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{11329
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11330
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11331
{{EJC{{{{{11332
*
*      COMPILATION ERROR
*
{O$CER{ENT{{{{ENTRY POINT{11336
{{ERB{1,007{26,Compilation error encountered during execution{{{11337
{{EJC{{{{{11338
*
*      UNARY AT (CURSOR ASSIGNMENT)
*
{O$CAS{ENT{{{{ENTRY POINT{11342
{{MOV{10,(XS)+{8,WC{{LOAD NAME OFFSET (PARM2){11343
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE (PARM1){11344
{{MOV{22,=P$CAS{8,WB{{SET PCODE FOR CURSOR ASSIGNMENT{11345
{{JSR{6,PBILD{{{BUILD NODE{11346
{{MOV{7,XR{11,-(XS){{STACK RESULT{11347
{{LCW{7,XR{{{GET NEXT CODE WORD{11348
{{BRI{9,(XR){{{EXECUTE IT{11349
{{EJC{{{{{11350
*
*      CONCATENATION
*
{O$CNC{ENT{{{{ENTRY POINT{11354
{{MOV{9,(XS){7,XR{{LOAD RIGHT ARGUMENT{11355
{{BEQ{7,XR{21,=NULLS{6,OCNC3{JUMP IF RIGHT ARG IS NULL{11356
{{MOV{12,1(XS){7,XL{{LOAD LEFT ARGUMENT{11357
{{BEQ{7,XL{21,=NULLS{6,OCNC4{JUMP IF LEFT ARGUMENT IS NULL{11358
{{MOV{22,=B$SCL{8,WA{{GET CONSTANT TO TEST FOR STRING{11359
{{BNE{8,WA{9,(XL){6,OCNC2{JUMP IF LEFT ARG NOT A STRING{11360
{{BNE{8,WA{9,(XR){6,OCNC2{JUMP IF RIGHT ARG NOT A STRING{11361
*
*      MERGE HERE TO CONCATENATE TWO STRINGS
*
{OCNC1{MOV{13,SCLEN(XL){8,WA{{LOAD LEFT ARGUMENT LENGTH{11365
{{ADD{13,SCLEN(XR){8,WA{{COMPUTE RESULT LENGTH{11366
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{11367
{{MOV{7,XR{12,1(XS){{STORE RESULT PTR OVER LEFT ARGUMENT{11368
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{11369
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARS IN LEFT ARG{11370
{{PLC{7,XL{{{PREPARE TO LOAD LEFT ARG CHARS{11371
{{MVC{{{{MOVE CHARACTERS OF LEFT ARGUMENT{11372
{{MOV{10,(XS)+{7,XL{{LOAD RIGHT ARG POINTER, POP STACK{11373
{{MOV{13,SCLEN(XL){8,WA{{LOAD NUMBER OF CHARS IN RIGHT ARG{11374
{{PLC{7,XL{{{PREPARE TO LOAD RIGHT ARG CHARS{11375
{{MVC{{{{MOVE CHARACTERS OF RIGHT ARGUMENT{11376
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{11377
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11378
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11379
*
*      COME HERE IF ARGUMENTS ARE NOT BOTH STRINGS
*
{OCNC2{JSR{6,GTSTG{{{CONVERT RIGHT ARG TO STRING{11383
{{PPM{6,OCNC5{{{JUMP IF RIGHT ARG IS NOT STRING{11384
{{MOV{7,XR{7,XL{{SAVE RIGHT ARG PTR{11385
{{JSR{6,GTSTG{{{CONVERT LEFT ARG TO STRING{11386
{{PPM{6,OCNC6{{{JUMP IF LEFT ARG IS NOT A STRING{11387
{{MOV{7,XR{11,-(XS){{STACK LEFT ARGUMENT{11388
{{MOV{7,XL{11,-(XS){{STACK RIGHT ARGUMENT{11389
{{MOV{7,XR{7,XL{{MOVE LEFT ARG TO PROPER REG{11390
{{MOV{9,(XS){7,XR{{MOVE RIGHT ARG TO PROPER REG{11391
{{BRN{6,OCNC1{{{MERGE BACK TO CONCATENATE STRINGS{11392
{{EJC{{{{{11393
*
*      CONCATENATION (CONTINUED)
*
*      COME HERE FOR NULL RIGHT ARGUMENT
*
{OCNC3{ICA{7,XS{{{REMOVE RIGHT ARG FROM STACK{11399
{{LCW{7,XR{{{LEFT ARGUMENT ON STACK{11400
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11401
*
*      HERE FOR NULL LEFT ARGUMENT
*
{OCNC4{ICA{7,XS{{{UNSTACK ONE ARGUMENT{11405
{{MOV{7,XR{9,(XS){{STORE RIGHT ARGUMENT{11406
{{LCW{7,XR{{{RESULT ON STACK, GET CODE WORD{11407
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11408
*
*      HERE IF RIGHT ARGUMENT IS NOT A STRING
*
{OCNC5{MOV{7,XR{7,XL{{MOVE RIGHT ARGUMENT PTR{11412
{{MOV{10,(XS)+{7,XR{{LOAD LEFT ARG POINTER{11413
*
*      MERGE HERE WHEN LEFT ARGUMENT IS NOT A STRING
*
{OCNC6{JSR{6,GTPAT{{{CONVERT LEFT ARG TO PATTERN{11417
{{ERR{1,008{26,Concatenation left operand is not a string or pattern{{{11418
{{MOV{7,XR{11,-(XS){{SAVE RESULT ON STACK{11419
{{MOV{7,XL{7,XR{{POINT TO RIGHT OPERAND{11420
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11421
{{ERR{1,009{26,Concatenation right operand is not a string or pattern{{{11422
{{MOV{7,XR{7,XL{{MOVE FOR PCONC{11423
{{MOV{10,(XS)+{7,XR{{RELOAD LEFT OPERAND PTR{11424
{{JSR{6,PCONC{{{CONCATENATE PATTERNS{11425
{{MOV{7,XR{11,-(XS){{STACK RESULT{11426
{{LCW{7,XR{{{GET NEXT CODE WORD{11427
{{BRI{9,(XR){{{EXECUTE IT{11428
{{EJC{{{{{11429
*
*      COMPLEMENTATION
*
{O$COM{ENT{{{{ENTRY POINT{11433
{{MOV{10,(XS)+{7,XR{{LOAD OPERAND{11434
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{11435
*
*      MERGE BACK HERE AFTER CONVERSION
*
{OCOM1{BEQ{8,WA{22,=B$ICL{6,OCOM2{JUMP IF INTEGER{11439
{{BEQ{8,WA{22,=B$RCL{6,OCOM3{JUMP IF REAL{11442
{{JSR{6,GTNUM{{{ELSE CONVERT TO NUMERIC{11444
{{ERR{1,010{26,Negation operand is not numeric{{{11445
{{BRN{6,OCOM1{{{BACK TO CHECK CASES{11446
*
*      HERE TO COMPLEMENT INTEGER
*
{OCOM2{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{11450
{{NGI{{{{NEGATE{11451
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11452
{{ERB{1,011{26,Negation caused integer overflow{{{11453
*
*      HERE TO COMPLEMENT REAL
*
{OCOM3{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{11459
{{NGR{{{{NEGATE{11460
{{BRN{6,EXREA{{{RETURN REAL RESULT{11461
{{EJC{{{{{11463
*
*      BINARY SLASH (DIVISION)
*
{O$DVD{ENT{{{{ENTRY POINT{11467
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11468
{{ERR{1,012{26,Division left operand is not numeric{{{11469
{{ERR{1,013{26,Division right operand is not numeric{{{11470
{{PPM{6,ODVD2{{{JUMP IF REAL OPERANDS{11473
*
*      HERE TO DIVIDE TWO INTEGERS
*
{{DVI{13,ICVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{11478
{{INO{6,EXINT{{{RESULT OK IF NO OVERFLOW{11479
{{ERB{1,014{26,Division caused integer overflow{{{11480
*
*      HERE TO DIVIDE TWO REALS
*
{ODVD2{DVR{13,RCVAL(XL){{{DIVIDE LEFT OPERAND BY RIGHT{11486
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11487
{{ERB{1,262{26,Division caused real overflow{{{11488
{{EJC{{{{{11490
*
*      EXPONENTIATION
*
{O$EXP{ENT{{{{ENTRY POINT{11494
{{MOV{10,(XS)+{7,XR{{LOAD EXPONENT{11495
{{JSR{6,GTNUM{{{CONVERT TO NUMBER{11496
{{ERR{1,015{26,Exponentiation right operand is not numeric{{{11497
{{MOV{7,XR{7,XL{{MOVE EXPONENT TO XL{11498
{{MOV{10,(XS)+{7,XR{{LOAD BASE{11499
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{11500
{{ERR{1,016{26,Exponentiation left operand is not numeric{{{11501
{{BEQ{9,(XL){22,=B$RCL{6,OEXP7{JUMP IF REAL EXPONENT{11504
{{LDI{13,ICVAL(XL){{{LOAD EXPONENT{11506
{{ILT{6,OEX12{{{JUMP IF NEGATIVE EXPONENT{11507
{{BEQ{8,WA{22,=B$RCL{6,OEXP3{JUMP IF BASE IS REAL{11510
*
*      HERE TO EXPONENTIATE AN INTEGER BASE AND INTEGER EXPONENT
*
{{MFI{8,WA{6,OEXP2{{CONVERT EXPONENT TO 1 WORD INTEGER{11515
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{11516
{{LDI{13,ICVAL(XR){{{LOAD BASE AS INITIAL VALUE{11517
{{BNZ{8,WA{6,OEXP1{{JUMP INTO LOOP IF NON-ZERO EXPONENT{11518
{{IEQ{6,OEXP4{{{ERROR IF 0**0{11519
{{LDI{4,INTV1{{{NONZERO**0{11520
{{BRN{6,EXINT{{{GIVE ONE AS RESULT FOR NONZERO**0{11521
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX13{MLI{13,ICVAL(XR){{{MULTIPLY BY BASE{11525
{{IOV{6,OEXP2{{{JUMP IF OVERFLOW{11526
{OEXP1{BCT{8,WA{6,OEX13{{LOOP IF MORE TO GO{11527
{{BRN{6,EXINT{{{ELSE RETURN INTEGER RESULT{11528
*
*      HERE IF INTEGER OVERFLOW
*
{OEXP2{ERB{1,017{26,Exponentiation caused integer overflow{{{11532
{{EJC{{{{{11533
*
*      EXPONENTIATION (CONTINUED)
*
*      HERE TO EXPONENTIATE A REAL TO AN INTEGER POWER
*
{OEXP3{MFI{8,WA{6,OEXP6{{CONVERT EXPONENT TO ONE WORD{11541
{{LCT{8,WA{8,WA{{SET LOOP COUNTER{11542
{{LDR{13,RCVAL(XR){{{LOAD BASE AS INITIAL VALUE{11543
{{BNZ{8,WA{6,OEXP5{{JUMP INTO LOOP IF NON-ZERO EXPONENT{11544
{{REQ{6,OEXP4{{{ERROR IF 0.0**0{11545
{{LDR{4,REAV1{{{NONZERO**0{11546
{{BRN{6,EXREA{{{RETURN 1.0 IF NONZERO**ZERO{11547
*
*      HERE FOR ERROR OF 0**0 OR 0.0**0
*
{OEXP4{ERB{1,018{26,Exponentiation result is undefined{{{11552
*
*      LOOP TO PERFORM EXPONENTIATION
*
{OEX14{MLR{13,RCVAL(XR){{{MULTIPLY BY BASE{11558
{{ROV{6,OEXP6{{{JUMP IF OVERFLOW{11559
{OEXP5{BCT{8,WA{6,OEX14{{LOOP TILL COMPUTATION COMPLETE{11560
{{BRN{6,EXREA{{{THEN RETURN REAL RESULT{11561
*
*      HERE IF REAL OVERFLOW
*
{OEXP6{ERB{1,266{26,Exponentiation caused real overflow{{{11565
*
*      HERE WITH REAL EXPONENT IN (XL), NUMERIC BASE IN (XR)
*
{OEXP7{BEQ{9,(XR){22,=B$RCL{6,OEXP8{JUMP IF BASE REAL{11570
{{LDI{13,ICVAL(XR){{{LOAD INTEGER BASE{11571
{{ITR{{{{CONVERT TO REAL{11572
{{JSR{6,RCBLD{{{CREATE REAL IN (XR){11573
*
*      HERE WITH REAL EXPONENT IN (XL)
*      NUMERIC BASE IN (XR) AND RA
*
{OEXP8{ZER{8,WB{{{SET POSITIVE RESULT FLAG{11578
{{LDR{13,RCVAL(XR){{{LOAD BASE TO RA{11579
{{RNE{6,OEXP9{{{JUMP IF BASE NON-ZERO{11580
{{LDR{13,RCVAL(XL){{{BASE IS ZERO.  CHECK EXPONENT{11581
{{REQ{6,OEXP4{{{JUMP IF 0.0 ** 0.0{11582
{{LDR{4,REAV0{{{0.0 TO NON-ZERO EXPONENT YIELDS 0.0{11583
{{BRN{6,EXREA{{{RETURN ZERO RESULT{11584
*
*      HERE WITH NON-ZERO BASE IN (XR) AND RA, EXPONENT IN (XL)
*
*      A NEGATIVE BASE IS ALLOWED IF THE EXPONENT IS INTEGRAL.
*
{OEXP9{RGT{6,OEX10{{{JUMP IF BASE GT 0.0{11590
{{NGR{{{{MAKE BASE POSITIVE{11591
{{JSR{6,RCBLD{{{CREATE POSITIVE BASE IN (XR){11592
{{LDR{13,RCVAL(XL){{{EXAMINE EXPONENT{11593
{{CHP{{{{CHOP TO INTEGRAL VALUE{11594
{{RTI{6,OEXP6{{{CONVERT TO INTEGER, BR IF TOO LARGE{11595
{{SBR{13,RCVAL(XL){{{CHOP(EXPONENT) - EXPONENT{11596
{{RNE{6,OEX11{{{NON-INTEGRAL POWER WITH NEG BASE{11597
{{MFI{8,WB{{{RECORD EVEN/ODD EXPONENT{11598
{{ANB{4,BITS1{8,WB{{ODD EXPONENT YIELDS NEGATIVE RESULT{11599
{{LDR{13,RCVAL(XR){{{RESTORE BASE TO RA{11600
*
*      HERE WITH POSITIVE BASE IN RA AND (XR), EXPONENT IN (XL)
*
{OEX10{LNF{{{{LOG OF BASE{11604
{{ROV{6,OEXP6{{{TOO LARGE{11605
{{MLR{13,RCVAL(XL){{{TIMES EXPONENT{11606
{{ROV{6,OEXP6{{{TOO LARGE{11607
{{ETX{{{{E ** (EXPONENT * LN(BASE)){11608
{{ROV{6,OEXP6{{{TOO LARGE{11609
{{BZE{8,WB{6,EXREA{{IF NO SIGN FIXUP REQUIRED{11610
{{NGR{{{{NEGATIVE RESULT NEEDED{11611
{{BRN{6,EXREA{{{{11612
*
*      HERE FOR NON-INTEGRAL EXPONENT WITH NEGATIVE BASE
*
{OEX11{ERB{1,311{26,Exponentiation of negative base to non-integral power{{{11616
*
*      HERE WITH NEGATIVE INTEGER EXPONENT IN IA
*
{OEX12{MOV{7,XR{11,-(XS){{STACK BASE{11625
{{ITR{{{{CONVERT TO REAL EXPONENT{11626
{{JSR{6,RCBLD{{{REAL NEGATIVE EXPONENT IN (XR){11627
{{MOV{7,XR{7,XL{{PUT EXPONENT IN XL{11628
{{MOV{10,(XS)+{7,XR{{RESTORE BASE VALUE{11629
{{BRN{6,OEXP7{{{PROCESS REAL EXPONENT{11630
{{EJC{{{{{11634
*
*      FAILURE IN EXPRESSION EVALUATION
*
*      THIS ENTRY POINT IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, FAILS.
*      CONTROL IS RETURNED TO AN APPROPRIATE POINT IN EVALX.
*
{O$FEX{ENT{{{{ENTRY POINT{11642
{{BRN{6,EVLX6{{{JUMP TO FAILURE LOC IN EVALX{11643
{{EJC{{{{{11644
*
*      FAILURE DURING EVALUATION OF A COMPLEX OR DIRECT GOTO
*
{O$FIF{ENT{{{{ENTRY POINT{11648
{{ERB{1,020{26,Goto evaluation failure{{{11649
{{EJC{{{{{11650
*
*      FUNCTION CALL (MORE THAN ONE ARGUMENT)
*
{O$FNC{ENT{{{{ENTRY POINT{11654
{{LCW{8,WA{{{LOAD NUMBER OF ARGUMENTS{11655
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{11656
{{MOV{13,VRFNC(XR){7,XL{{LOAD FUNCTION POINTER{11657
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{11658
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{11659
{{EJC{{{{{11660
*
*      FUNCTION NAME ERROR
*
{O$FNE{ENT{{{{ENTRY POINT{11664
{{LCW{8,WA{{{GET NEXT CODE WORD{11665
{{BNE{8,WA{21,=ORNM${6,OFNE1{FAIL IF NOT EVALUATING EXPRESSION{11666
{{BZE{12,2(XS){6,EVLX3{{OK IF EXPR. WAS WANTED BY VALUE{11667
*
*      HERE FOR ERROR
*
{OFNE1{ERB{1,021{26,Function called by name returned a value{{{11671
{{EJC{{{{{11672
*
*      FUNCTION CALL (SINGLE ARGUMENT)
*
{O$FNS{ENT{{{{ENTRY POINT{11676
{{LCW{7,XR{{{LOAD FUNCTION VRBLK POINTER{11677
{{MOV{18,=NUM01{8,WA{{SET NUMBER OF ARGUMENTS TO ONE{11678
{{MOV{13,VRFNC(XR){7,XL{{LOAD FUNCTION POINTER{11679
{{BNE{8,WA{13,FARGS(XL){6,CFUNC{USE CENTRAL ROUTINE IF WRONG NUM{11680
{{BRI{9,(XL){{{JUMP TO FUNCTION IF ARG COUNT OK{11681
{{EJC{{{{{11682
*      CALL TO UNDEFINED FUNCTION
*
{O$FUN{ENT{{{{ENTRY POINT{11685
{{ERB{1,022{26,Undefined function called{{{11686
{{EJC{{{{{11687
*
*      EXECUTE COMPLEX GOTO
*
{O$GOC{ENT{{{{ENTRY POINT{11691
{{MOV{12,1(XS){7,XR{{LOAD NAME BASE POINTER{11692
{{BHI{7,XR{3,STATE{6,OGOC1{JUMP IF NOT NATURAL VARIABLE{11693
{{ADD{19,*VRTRA{7,XR{{ELSE POINT TO VRTRA FIELD{11694
{{BRI{9,(XR){{{AND JUMP THROUGH IT{11695
*
*      HERE IF GOTO OPERAND IS NOT NATURAL VARIABLE
*
{OGOC1{ERB{1,023{26,Goto operand is not a natural variable{{{11699
{{EJC{{{{{11700
*
*      EXECUTE DIRECT GOTO
*
{O$GOD{ENT{{{{ENTRY POINT{11704
{{MOV{9,(XS){7,XR{{LOAD OPERAND{11705
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD{11706
{{BEQ{8,WA{22,=B$CDS{6,BCDS0{JUMP IF CODE BLOCK TO CODE ROUTINE{11707
{{BEQ{8,WA{22,=B$CDC{6,BCDC0{JUMP IF CODE BLOCK TO CODE ROUTINE{11708
{{ERB{1,024{26,Goto operand in direct goto is not code{{{11709
{{EJC{{{{{11710
*
*      SET GOTO FAILURE TRAP
*
*      THIS ROUTINE IS EXECUTED AT THE START OF A COMPLEX OR
*      DIRECT FAILURE GOTO TO TRAP A SUBSEQUENT FAIL (SEE EXFAL)
*
{O$GOF{ENT{{{{ENTRY POINT{11717
{{MOV{3,FLPTR{7,XR{{POINT TO FAIL OFFSET ON STACK{11718
{{ICA{9,(XR){{{POINT FAILURE TO O$FIF WORD{11719
{{ICP{{{{POINT TO NEXT CODE WORD{11720
{{LCW{7,XR{{{FETCH NEXT CODE WORD{11721
{{BRI{9,(XR){{{EXECUTE IT{11722
{{EJC{{{{{11723
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOLLAR IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O$IMA{ENT{{{{ENTRY POINT{11731
{{MOV{22,=P$IMC{8,WB{{SET PCODE FOR LAST NODE{11732
{{MOV{10,(XS)+{8,WC{{POP NAME OFFSET (PARM2){11733
{{MOV{10,(XS)+{7,XR{{POP NAME BASE (PARM1){11734
{{JSR{6,PBILD{{{BUILD P$IMC NODE{11735
{{MOV{7,XR{7,XL{{SAVE PTR TO NODE{11736
{{MOV{9,(XS){7,XR{{LOAD LEFT ARGUMENT{11737
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11738
{{ERR{1,025{26,Immediate assignment left operand is not pattern{{{11739
{{MOV{7,XR{9,(XS){{SAVE PTR TO LEFT OPERAND PATTERN{11740
{{MOV{22,=P$IMA{8,WB{{SET PCODE FOR FIRST NODE{11741
{{JSR{6,PBILD{{{BUILD P$IMA NODE{11742
{{MOV{10,(XS)+{13,PTHEN(XR){{SET LEFT OPERAND AS P$IMA SUCCESSOR{11743
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{11744
{{MOV{7,XR{11,-(XS){{STACK RESULT{11745
{{LCW{7,XR{{{GET NEXT CODE WORD{11746
{{BRI{9,(XR){{{EXECUTE IT{11747
{{EJC{{{{{11748
*
*      INDIRECTION (BY NAME)
*
{O$INN{ENT{{{{ENTRY POINT{11752
{{MNZ{8,WB{{{SET FLAG FOR RESULT BY NAME{11753
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{11754
{{EJC{{{{{11755
*
*      INTERROGATION
*
{O$INT{ENT{{{{ENTRY POINT{11759
{{MOV{21,=NULLS{9,(XS){{REPLACE OPERAND WITH NULL{11760
{{LCW{7,XR{{{GET NEXT CODE WORD{11761
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11762
{{EJC{{{{{11763
*
*      INDIRECTION (BY VALUE)
*
{O$INV{ENT{{{{ENTRY POINT{11767
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{11768
{{BRN{6,INDIR{{{JUMP TO COMMON ROUTINE{11769
{{EJC{{{{{11770
*
*      KEYWORD REFERENCE (BY NAME)
*
{O$KWN{ENT{{{{ENTRY POINT{11774
{{JSR{6,KWNAM{{{GET KEYWORD NAME{11775
{{BRN{6,EXNAM{{{EXIT WITH RESULT NAME{11776
{{EJC{{{{{11777
*
*      KEYWORD REFERENCE (BY VALUE)
*
{O$KWV{ENT{{{{ENTRY POINT{11781
{{JSR{6,KWNAM{{{GET KEYWORD NAME{11782
{{MOV{7,XR{3,DNAMP{{DELETE KVBLK{11783
{{JSR{6,ACESS{{{ACCESS VALUE{11784
{{PPM{6,EXNUL{{{DUMMY (UNUSED) FAILURE RETURN{11785
{{MOV{7,XR{11,-(XS){{STACK RESULT{11786
{{LCW{7,XR{{{GET NEXT CODE WORD{11787
{{BRI{9,(XR){{{EXECUTE IT{11788
{{EJC{{{{{11789
*
*      LOAD EXPRESSION BY NAME
*
{O$LEX{ENT{{{{ENTRY POINT{11793
{{MOV{19,*EVSI${8,WA{{SET SIZE OF EVBLK{11794
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EVBLK{11795
{{MOV{22,=B$EVT{9,(XR){{SET TYPE WORD{11796
{{MOV{21,=TRBEV{13,EVVAR(XR){{SET DUMMY TRBLK POINTER{11797
{{LCW{8,WA{{{LOAD EXBLK POINTER{11798
{{MOV{8,WA{13,EVEXP(XR){{SET EXBLK POINTER{11799
{{MOV{7,XR{7,XL{{MOVE NAME BASE TO PROPER REG{11800
{{MOV{19,*EVVAR{8,WA{{SET NAME OFFSET = ZERO{11801
{{BRN{6,EXNAM{{{EXIT WITH NAME IN (XL,WA){11802
{{EJC{{{{{11803
*
*      LOAD PATTERN VALUE
*
{O$LPT{ENT{{{{ENTRY POINT{11807
{{LCW{7,XR{{{LOAD PATTERN POINTER{11808
{{MOV{7,XR{11,-(XS){{STACK RESULT{11809
{{LCW{7,XR{{{GET NEXT CODE WORD{11810
{{BRI{9,(XR){{{EXECUTE IT{11811
{{EJC{{{{{11812
*
*      LOAD VARIABLE NAME
*
{O$LVN{ENT{{{{ENTRY POINT{11816
{{LCW{8,WA{{{LOAD VRBLK POINTER{11817
{{MOV{8,WA{11,-(XS){{STACK VRBLK PTR (NAME BASE){11818
{{MOV{19,*VRVAL{11,-(XS){{STACK NAME OFFSET{11819
{{LCW{7,XR{{{GET NEXT CODE WORD{11820
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11821
{{EJC{{{{{11822
*
*      BINARY ASTERISK (MULTIPLICATION)
*
{O$MLT{ENT{{{{ENTRY POINT{11826
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{11827
{{ERR{1,026{26,Multiplication left operand is not numeric{{{11828
{{ERR{1,027{26,Multiplication right operand is not numeric{{{11829
{{PPM{6,OMLT1{{{JUMP IF REAL OPERANDS{11832
*
*      HERE TO MULTIPLY TWO INTEGERS
*
{{MLI{13,ICVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{11837
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{11838
{{ERB{1,028{26,Multiplication caused integer overflow{{{11839
*
*      HERE TO MULTIPLY TWO REALS
*
{OMLT1{MLR{13,RCVAL(XL){{{MULTIPLY LEFT OPERAND BY RIGHT{11845
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{11846
{{ERB{1,263{26,Multiplication caused real overflow{{{11847
{{EJC{{{{{11849
*
*      NAME REFERENCE
*
{O$NAM{ENT{{{{ENTRY POINT{11853
{{MOV{19,*NMSI${8,WA{{SET LENGTH OF NMBLK{11854
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{11855
{{MOV{22,=B$NML{9,(XR){{SET NAME BLOCK CODE{11856
{{MOV{10,(XS)+{13,NMOFS(XR){{SET NAME OFFSET FROM OPERAND{11857
{{MOV{10,(XS)+{13,NMBAS(XR){{SET NAME BASE FROM OPERAND{11858
{{MOV{7,XR{11,-(XS){{STACK RESULT{11859
{{LCW{7,XR{{{GET NEXT CODE WORD{11860
{{BRI{9,(XR){{{EXECUTE IT{11861
{{EJC{{{{{11862
*
*      NEGATION
*
*      INITIAL ENTRY
*
{O$NTA{ENT{{{{ENTRY POINT{11868
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{11869
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{11870
{{MOV{8,WA{11,-(XS){{STACK NEW FAILURE OFFSET{11871
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{11872
{{LCW{7,XR{{{GET NEXT CODE WORD{11873
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11874
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF OPERAND
*
{O$NTB{ENT{{{{ENTRY POINT{11878
{{MOV{12,2(XS){3,FLPTR{{RESTORE OLD FAILURE POINTER{11879
{{BRN{6,EXFAL{{{AND FAIL{11880
*
*      ENTRY FOR FAILURE DURING OPERAND EVALUATION
*
{O$NTC{ENT{{{{ENTRY POINT{11884
{{ICA{7,XS{{{POP FAILURE OFFSET{11885
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{11886
{{BRN{6,EXNUL{{{EXIT GIVING NULL RESULT{11887
{{EJC{{{{{11888
*
*      USE OF UNDEFINED OPERATOR
*
{O$OUN{ENT{{{{ENTRY POINT{11892
{{ERB{1,029{26,Undefined operator referenced{{{11893
{{EJC{{{{{11894
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*
*      THE PATTERN BUILT BY BINARY DOT IS A COMPOUND PATTERN.
*      SEE DESCRIPTION AT START OF PATTERN MATCH SECTION FOR
*      DETAILS OF THE STRUCTURE WHICH IS CONSTRUCTED.
*
{O$PAS{ENT{{{{ENTRY POINT{11902
{{MOV{22,=P$PAC{8,WB{{LOAD PCODE FOR P$PAC NODE{11903
{{MOV{10,(XS)+{8,WC{{LOAD NAME OFFSET (PARM2){11904
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE (PARM1){11905
{{JSR{6,PBILD{{{BUILD P$PAC NODE{11906
{{MOV{7,XR{7,XL{{SAVE PTR TO NODE{11907
{{MOV{9,(XS){7,XR{{LOAD LEFT OPERAND{11908
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{11909
{{ERR{1,030{26,Pattern assignment left operand is not pattern{{{11910
{{MOV{7,XR{9,(XS){{SAVE PTR TO LEFT OPERAND PATTERN{11911
{{MOV{22,=P$PAA{8,WB{{SET PCODE FOR P$PAA NODE{11912
{{JSR{6,PBILD{{{BUILD P$PAA NODE{11913
{{MOV{10,(XS)+{13,PTHEN(XR){{SET LEFT OPERAND AS P$PAA SUCCESSOR{11914
{{JSR{6,PCONC{{{CONCATENATE TO FORM FINAL PATTERN{11915
{{MOV{7,XR{11,-(XS){{STACK RESULT{11916
{{LCW{7,XR{{{GET NEXT CODE WORD{11917
{{BRI{9,(XR){{{EXECUTE IT{11918
{{EJC{{{{{11919
*
*      PATTERN MATCH (BY NAME, FOR REPLACEMENT)
*
{O$PMN{ENT{{{{ENTRY POINT{11923
{{ZER{8,WB{{{SET TYPE CODE FOR MATCH BY NAME{11924
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11925
{{EJC{{{{{11926
*
*      PATTERN MATCH (STATEMENT)
*
*      O$PMS IS USED IN PLACE OF O$PMV WHEN THE PATTERN MATCH
*      OCCURS AT THE OUTER (STATEMENT) LEVEL SINCE IN THIS
*      CASE THE SUBSTRING VALUE NEED NOT BE CONSTRUCTED.
*
{O$PMS{ENT{{{{ENTRY POINT{11934
{{MOV{18,=NUM02{8,WB{{SET FLAG FOR STATEMENT TO MATCH{11935
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11936
{{EJC{{{{{11937
*
*      PATTERN MATCH (BY VALUE)
*
{O$PMV{ENT{{{{ENTRY POINT{11941
{{MOV{18,=NUM01{8,WB{{SET TYPE CODE FOR VALUE MATCH{11942
{{BRN{6,MATCH{{{JUMP TO ROUTINE TO START MATCH{11943
{{EJC{{{{{11944
*
*      POP TOP ITEM ON STACK
*
{O$POP{ENT{{{{ENTRY POINT{11948
{{ICA{7,XS{{{POP TOP STACK ENTRY{11949
{{LCW{7,XR{{{GET NEXT CODE WORD{11950
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{11951
{{EJC{{{{{11952
*
*      TERMINATE EXECUTION (CODE COMPILED FOR END STATEMENT)
*
{O$STP{ENT{{{{ENTRY POINT{11956
{{BRN{6,LEND0{{{JUMP TO END CIRCUIT{11957
{{EJC{{{{{11958
*
*      RETURN NAME FROM EXPRESSION
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A NAME. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX.
*
{O$RNM{ENT{{{{ENTRY POINT{11965
{{BRN{6,EVLX4{{{RETURN TO EVALX PROCEDURE{11966
{{EJC{{{{{11967
*
*      PATTERN REPLACEMENT
*
*      WHEN THIS ROUTINE GETS CONTROL, THE FOLLOWING STACK
*      ENTRIES HAVE BEEN MADE (SEE END OF MATCH ROUTINE P$NTH)
*
*                            SUBJECT NAME BASE
*                            SUBJECT NAME OFFSET
*                            INITIAL CURSOR VALUE
*                            FINAL CURSOR VALUE
*                            SUBJECT POINTER
*      (XS) ---------------- REPLACEMENT VALUE
*
{O$RPL{ENT{{{{ENTRY POINT{11981
{{JSR{6,GTSTG{{{CONVERT REPLACEMENT VAL TO STRING{11982
{{ERR{1,031{26,Pattern replacement right operand is not a string{{{11983
*
*      GET RESULT LENGTH AND ALLOCATE RESULT SCBLK
*
{{MOV{9,(XS){7,XL{{LOAD SUBJECT STRING POINTER{11987
{{ADD{13,SCLEN(XL){8,WA{{ADD SUBJECT STRING LENGTH{11992
{{ADD{12,2(XS){8,WA{{ADD STARTING CURSOR{11993
{{SUB{12,1(XS){8,WA{{MINUS FINAL CURSOR = TOTAL LENGTH{11994
{{BZE{8,WA{6,ORPL3{{JUMP IF RESULT IS NULL{11995
{{MOV{7,XR{11,-(XS){{RESTACK REPLACEMENT STRING{11996
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR RESULT{11997
{{MOV{12,3(XS){8,WA{{GET INITIAL CURSOR (PART 1 LEN){11998
{{MOV{7,XR{12,3(XS){{STACK RESULT POINTER{11999
{{PSC{7,XR{{{POINT TO CHARACTERS OF RESULT{12000
*
*      MOVE PART 1 (START OF SUBJECT) TO RESULT
*
{{BZE{8,WA{6,ORPL1{{JUMP IF FIRST PART IS NULL{12004
{{MOV{12,1(XS){7,XL{{ELSE POINT TO SUBJECT STRING{12005
{{PLC{7,XL{{{POINT TO SUBJECT STRING CHARS{12006
{{MVC{{{{MOVE FIRST PART TO RESULT{12007
{{EJC{{{{{12008
*      PATTERN REPLACEMENT (CONTINUED)
*
*      NOW MOVE IN REPLACEMENT VALUE
*
{ORPL1{MOV{10,(XS)+{7,XL{{LOAD REPLACEMENT STRING, POP{12013
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH{12014
{{BZE{8,WA{6,ORPL2{{JUMP IF NULL REPLACEMENT{12015
{{PLC{7,XL{{{ELSE POINT TO CHARS OF REPLACEMENT{12016
{{MVC{{{{MOVE IN CHARS (PART 2){12017
*
*      NOW MOVE IN REMAINDER OF STRING (PART 3)
*
{ORPL2{MOV{10,(XS)+{7,XL{{LOAD SUBJECT STRING POINTER, POP{12021
{{MOV{10,(XS)+{8,WC{{LOAD FINAL CURSOR, POP{12022
{{MOV{13,SCLEN(XL){8,WA{{LOAD SUBJECT STRING LENGTH{12023
{{SUB{8,WC{8,WA{{MINUS FINAL CURSOR = PART 3 LENGTH{12024
{{BZE{8,WA{6,OASS0{{JUMP TO ASSIGN IF PART 3 IS NULL{12025
{{PLC{7,XL{8,WC{{ELSE POINT TO LAST PART OF STRING{12026
{{MVC{{{{MOVE PART 3 TO RESULT{12027
{{BRN{6,OASS0{{{JUMP TO PERFORM ASSIGNMENT{12028
*
*      HERE IF RESULT IS NULL
*
{ORPL3{ADD{19,*NUM02{7,XS{{POP SUBJECT STR PTR, FINAL CURSOR{12032
{{MOV{21,=NULLS{9,(XS){{SET NULL RESULT{12033
{{BRN{6,OASS0{{{JUMP TO ASSIGN NULL VALUE{12034
{{EJC{{{{{12053
*
*      RETURN VALUE FROM EXPRESSION
*
*      THIS ENTRY POINTS IS USED IF THE EVALUATION OF AN
*      EXPRESSION, INITIATED BY THE EVALX PROCEDURE, RETURNS
*      A VALUE. CONTROL IS RETURNED TO THE PROPER POINT IN EVALX
*
{O$RVL{ENT{{{{ENTRY POINT{12061
{{BRN{6,EVLX3{{{RETURN TO EVALX PROCEDURE{12062
{{EJC{{{{{12063
*
*      SELECTION
*
*      INITIAL ENTRY
*
{O$SLA{ENT{{{{ENTRY POINT{12069
{{LCW{8,WA{{{LOAD NEW FAILURE OFFSET{12070
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{12071
{{MOV{8,WA{11,-(XS){{STACK NEW FAILURE OFFSET{12072
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{12073
{{LCW{7,XR{{{GET NEXT CODE WORD{12074
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12075
*
*      ENTRY AFTER SUCCESSFUL EVALUATION OF ALTERNATIVE
*
{O$SLB{ENT{{{{ENTRY POINT{12079
{{MOV{10,(XS)+{7,XR{{LOAD RESULT{12080
{{ICA{7,XS{{{POP FAIL OFFSET{12081
{{MOV{9,(XS){3,FLPTR{{RESTORE OLD FAILURE POINTER{12082
{{MOV{7,XR{9,(XS){{RESTACK RESULT{12083
{{LCW{8,WA{{{LOAD NEW CODE OFFSET{12084
{{ADD{3,R$COD{8,WA{{POINT TO ABSOLUTE CODE LOCATION{12085
{{LCP{8,WA{{{SET NEW CODE POINTER{12086
{{LCW{7,XR{{{GET NEXT CODE WORD{12087
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12088
*
*      ENTRY AT START OF SUBSEQUENT ALTERNATIVES
*
{O$SLC{ENT{{{{ENTRY POINT{12092
{{LCW{8,WA{{{LOAD NEW FAIL OFFSET{12093
{{MOV{8,WA{9,(XS){{STORE NEW FAIL OFFSET{12094
{{LCW{7,XR{{{GET NEXT CODE WORD{12095
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12096
*
*      ENTRY AT START OF LAST ALTERNATIVE
*
{O$SLD{ENT{{{{ENTRY POINT{12100
{{ICA{7,XS{{{POP FAILURE OFFSET{12101
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{12102
{{LCW{7,XR{{{GET NEXT CODE WORD{12103
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12104
{{EJC{{{{{12105
*
*      BINARY MINUS (SUBTRACTION)
*
{O$SUB{ENT{{{{ENTRY POINT{12109
{{JSR{6,ARITH{{{FETCH ARITHMETIC OPERANDS{12110
{{ERR{1,032{26,Subtraction left operand is not numeric{{{12111
{{ERR{1,033{26,Subtraction right operand is not numeric{{{12112
{{PPM{6,OSUB1{{{JUMP IF REAL OPERANDS{12115
*
*      HERE TO SUBTRACT TWO INTEGERS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{12120
{{INO{6,EXINT{{{RETURN INTEGER IF NO OVERFLOW{12121
{{ERB{1,034{26,Subtraction caused integer overflow{{{12122
*
*      HERE TO SUBTRACT TWO REALS
*
{OSUB1{SBR{13,RCVAL(XL){{{SUBTRACT RIGHT OPERAND FROM LEFT{12128
{{RNO{6,EXREA{{{RETURN REAL IF NO OVERFLOW{12129
{{ERB{1,264{26,Subtraction caused real overflow{{{12130
{{EJC{{{{{12132
*
*      DUMMY OPERATOR TO RETURN CONTROL TO TRXEQ PROCEDURE
*
{O$TXR{ENT{{{{ENTRY POINT{12136
{{BRN{6,TRXQ1{{{JUMP INTO TRXEQ PROCEDURE{12137
{{EJC{{{{{12138
*
*      UNEXPECTED FAILURE
*
*      NOTE THAT IF A SETEXIT TRAP IS OPERATING THEN
*      TRANSFER TO SYSTEM LABEL CONTINUE
*      WILL RESULT IN LOOPING HERE.  DIFFICULT TO AVOID EXCEPT
*      WITH A CONSIDERABLE OVERHEAD WHICH IS NOT WORTHWHILE OR
*      ELSE BY A TECHNIQUE SUCH AS SETTING KVERL TO ZERO.
*
{O$UNF{ENT{{{{ENTRY POINT{12148
{{ERB{1,035{26,Unexpected failure in -NOFAIL mode{{{12149
{{TTL{27,S P I T B O L -- BLOCK ACTION ROUTINES{{{{12150
*
*      THE FIRST WORD OF EVERY BLOCK IN DYNAMIC STORAGE AND THE
*      VRGET, VRSTO AND VRTRA FIELDS OF A VRBLK CONTAIN A
*      POINTER TO AN ENTRY POINT IN THE PROGRAM. ALL SUCH ENTRY
*      POINTS ARE IN THE FOLLOWING SECTION EXCEPT THOSE FOR
*      PATTERN BLOCKS WHICH ARE IN THE PATTERN MATCHING SEGMENT
*      LATER ON (LABELS OF THE FORM P$XXX).
*
*      THE ENTRY POINTS IN THIS SECTION HAVE LABELS OF THE
*      FORM B$XXY WHERE XX IS THE TWO CHARACTER BLOCK TYPE FOR
*      THE CORRESPONDING BLOCK AND Y IS ANY LETTER.
*
*      IN SOME CASES, THE POINTERS SERVE NO OTHER PURPOSE THAN
*      TO IDENTIFY THE BLOCK TYPE. IN THIS CASE THE ROUTINE
*      IS NEVER EXECUTED AND THUS NO CODE IS ASSEMBLED.
*
*      FOR EACH OF THESE ENTRY POINTS CORRESPONDING TO A BLOCK
*      AN ENTRY POINT IDENTIFICATION IS ASSEMBLED (BL$XX).
*
*      THE EXACT ENTRY CONDITIONS DEPEND ON THE MANNER IN
*      WHICH THE ROUTINE IS ACCESSED AND ARE DOCUMENTED WITH
*      THE INDIVIDUAL ROUTINES AS REQUIRED.
*
*      THE ORDER OF THESE ROUTINES IS ALPHABETICAL WITH THE
*      FOLLOWING EXCEPTIONS.
*
*      THE ROUTINES FOR SEBLK AND EXBLK ENTRIES OCCUR FIRST SO
*      THAT EXPRESSIONS CAN BE QUICKLY IDENTIFIED FROM THE FACT
*      THAT THEIR ROUTINES LIE BEFORE THE SYMBOL B$E$$.
*
*      THESE ARE IMMEDIATELY FOLLOWED BY THE ROUTINE FOR A TRBLK
*      SO THAT THE TEST AGAINST THE SYMBOL B$T$$ CHECKS FOR
*      TRAPPED VALUES OR EXPRESSION VALUES (SEE PROCEDURE EVALP)
*
*      THE PATTERN ROUTINES LIE AFTER THIS SECTION SO THAT
*      PATTERNS ARE IDENTIFIED WITH ROUTINES STARTING AT OR
*      AFTER THE INITIAL INSTRUCTION IN THESE ROUTINES (P$AAA).
*
*      THE SYMBOL B$AAA DEFINES THE FIRST LOCATION FOR BLOCK
*      ROUTINES AND THE SYMBOL P$YYY (AT THE END OF THE PATTERN
*      MATCH ROUTINES SECTION) DEFINES THE LAST SUCH ENTRY POINT
*
{B$AAA{ENT{2,BL$$I{{{ENTRY POINT OF FIRST BLOCK ROUTINE{12193
{{EJC{{{{{12194
*
*      EXBLK
*
*      THE ROUTINE FOR AN EXBLK LOADS THE EXPRESSION ONTO
*      THE STACK AS A VALUE.
*
*      (XR)                  POINTER TO EXBLK
*
{B$EXL{ENT{2,BL$EX{{{ENTRY POINT (EXBLK){12203
{{MOV{7,XR{11,-(XS){{STACK RESULT{12204
{{LCW{7,XR{{{GET NEXT CODE WORD{12205
{{BRI{9,(XR){{{EXECUTE IT{12206
{{EJC{{{{{12207
*
*      SEBLK
*
*      THE ROUTINE FOR SEBLK IS ACCESSED FROM THE GENERATED
*      CODE TO LOAD THE EXPRESSION VALUE ONTO THE STACK.
*
{B$SEL{ENT{2,BL$SE{{{ENTRY POINT (SEBLK){12214
{{MOV{7,XR{11,-(XS){{STACK RESULT{12215
{{LCW{7,XR{{{GET NEXT CODE WORD{12216
{{BRI{9,(XR){{{EXECUTE IT{12217
*
*      DEFINE SYMBOL WHICH MARKS END OF ENTRIES FOR EXPRESSIONS
*
{B$E$${ENT{2,BL$$I{{{ENTRY POINT{12221
{{EJC{{{{{12222
*
*      TRBLK
*
*      THE ROUTINE FOR A TRBLK IS NEVER EXECUTED
*
{B$TRT{ENT{2,BL$TR{{{ENTRY POINT (TRBLK){12228
*
*      DEFINE SYMBOL MARKING END OF TRAP AND EXPRESSION BLOCKS
*
{B$T$${ENT{2,BL$$I{{{END OF TRBLK,SEBLK,EXBLK ENTRIES{12232
{{EJC{{{{{12233
*
*      ARBLK
*
*      THE ROUTINE FOR ARBLK IS NEVER EXECUTED
*
{B$ART{ENT{2,BL$AR{{{ENTRY POINT (ARBLK){12239
{{EJC{{{{{12240
*
*      BCBLK
*
*      THE ROUTINE FOR A BCBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BCBLK
*
{B$BCT{ENT{2,BL$BC{{{ENTRY POINT (BCBLK){12248
{{EJC{{{{{12249
*
*      BFBLK
*
*      THE ROUTINE FOR A BFBLK IS NEVER EXECUTED
*
*      (XR)                  POINTER TO BFBLK
*
{B$BFT{ENT{2,BL$BF{{{ENTRY POINT (BFBLK){12257
{{EJC{{{{{12258
*
*      CCBLK
*
*      THE ROUTINE FOR CCBLK IS NEVER ENTERED
*
{B$CCT{ENT{2,BL$CC{{{ENTRY POINT (CCBLK){12264
{{EJC{{{{{12265
*
*      CDBLK
*
*      THE CDBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE TWO CASES DEPENDING ON THE FORM OF CDFAL.
*
*      ENTRY FOR COMPLEX FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B$CDC{ENT{2,BL$CD{{{ENTRY POINT (CDBLK){12276
{BCDC0{MOV{3,FLPTR{7,XS{{POP GARBAGE OFF STACK{12277
{{MOV{13,CDFAL(XR){9,(XS){{SET FAILURE OFFSET{12278
{{BRN{6,STMGO{{{ENTER STMT{12279
{{EJC{{{{{12280
*
*      CDBLK (CONTINUED)
*
*      ENTRY FOR SIMPLE FAILURE CODE AT CDFAL
*
*      (XR)                  POINTER TO CDBLK
*
{B$CDS{ENT{2,BL$CD{{{ENTRY POINT (CDBLK){12288
{BCDS0{MOV{3,FLPTR{7,XS{{POP GARBAGE OFF STACK{12289
{{MOV{19,*CDFAL{9,(XS){{SET FAILURE OFFSET{12290
{{BRN{6,STMGO{{{ENTER STMT{12291
{{EJC{{{{{12292
*
*      CMBLK
*
*      THE ROUTINE FOR A CMBLK IS NEVER EXECUTED
*
{B$CMT{ENT{2,BL$CM{{{ENTRY POINT (CMBLK){12298
{{EJC{{{{{12299
*
*      CTBLK
*
*      THE ROUTINE FOR A CTBLK IS NEVER EXECUTED
*
{B$CTT{ENT{2,BL$CT{{{ENTRY POINT (CTBLK){12305
{{EJC{{{{{12306
*
*      DFBLK
*
*      THE ROUTINE FOR A DFBLK IS ACCESSED FROM THE O$FNC ENTRY
*      TO CALL A DATATYPE FUNCTION AND BUILD A PDBLK.
*
*      (XL)                  POINTER TO DFBLK
*
{B$DFC{ENT{2,BL$DF{{{ENTRY POINT{12315
{{MOV{13,DFPDL(XL){8,WA{{LOAD LENGTH OF PDBLK{12316
{{JSR{6,ALLOC{{{ALLOCATE PDBLK{12317
{{MOV{22,=B$PDT{9,(XR){{STORE TYPE WORD{12318
{{MOV{7,XL{13,PDDFP(XR){{STORE DFBLK POINTER{12319
{{MOV{7,XR{8,WC{{SAVE POINTER TO PDBLK{12320
{{ADD{8,WA{7,XR{{POINT PAST PDBLK{12321
{{LCT{8,WA{13,FARGS(XL){{SET TO COUNT FIELDS{12322
*
*      LOOP TO ACQUIRE FIELD VALUES FROM STACK
*
{BDFC1{MOV{10,(XS)+{11,-(XR){{MOVE A FIELD VALUE{12326
{{BCT{8,WA{6,BDFC1{{LOOP TILL ALL MOVED{12327
{{MOV{8,WC{7,XR{{RECALL POINTER TO PDBLK{12328
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{12329
{{EJC{{{{{12330
*
*      EFBLK
*
*      THE ROUTINE FOR AN EFBLK IS PASSED CONTROL FORM THE O$FNC
*      ENTRY TO CALL AN EXTERNAL FUNCTION.
*
*      (XL)                  POINTER TO EFBLK
*
{B$EFC{ENT{2,BL$EF{{{ENTRY POINT (EFBLK){12339
{{MOV{13,FARGS(XL){8,WC{{LOAD NUMBER OF ARGUMENTS{12342
{{WTB{8,WC{{{CONVERT TO OFFSET{12343
{{MOV{7,XL{11,-(XS){{SAVE POINTER TO EFBLK{12344
{{MOV{7,XS{7,XT{{COPY POINTER TO ARGUMENTS{12345
*
*      LOOP TO CONVERT ARGUMENTS
*
{BEFC1{ICA{7,XT{{{POINT TO NEXT ENTRY{12349
{{MOV{9,(XS){7,XR{{LOAD POINTER TO EFBLK{12350
{{DCA{8,WC{{{DECREMENT EFTAR OFFSET{12351
{{ADD{8,WC{7,XR{{POINT TO NEXT EFTAR ENTRY{12352
{{MOV{13,EFTAR(XR){7,XR{{LOAD EFTAR ENTRY{12353
{{BSW{7,XR{1,5{{SWITCH ON TYPE{12362
{{IFF{1,0{6,BEFC7{{NO CONVERSION NEEDED{12380
{{IFF{1,1{6,BEFC2{{STRING{12380
{{IFF{1,2{6,BEFC3{{INTEGER{12380
{{IFF{1,3{6,BEFC4{{REAL{12380
{{IFF{1,4{6,BEFF1{{FILE{12380
{{ESW{{{{END OF SWITCH ON TYPE{12380
*
*      HERE TO CONVERT TO FILE
*
{BEFF1{MOV{7,XT{11,-(XS){{SAVE ENTRY POINTER{12385
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12386
{{MOV{9,(XT){11,-(XS){{STACK ARG POINTER{12387
{{JSR{6,IOFCB{{{CONVERT TO FCB{12388
{{ERR{1,298{26,External function argument is not file{{{12389
{{ERR{1,298{26,External function argument is not file{{{12390
{{ERR{1,298{26,External function argument is not file{{{12391
{{MOV{8,WA{7,XR{{POINT TO FCB{12392
{{MOV{10,(XS)+{7,XT{{RELOAD ENTRY POINTER{12393
{{BRN{6,BEFC5{{{JUMP TO MERGE{12394
*
*      HERE TO CONVERT TO STRING
*
{BEFC2{MOV{9,(XT){11,-(XS){{STACK ARG PTR{12399
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{12400
{{ERR{1,039{26,External function argument is not a string{{{12401
{{BRN{6,BEFC6{{{JUMP TO MERGE{12402
{{EJC{{{{{12403
*
*      EFBLK (CONTINUED)
*
*      HERE TO CONVERT AN INTEGER
*
{BEFC3{MOV{9,(XT){7,XR{{LOAD NEXT ARGUMENT{12409
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12410
{{JSR{6,GTINT{{{CONVERT TO INTEGER{12411
{{ERR{1,040{26,External function argument is not integer{{{12412
{{BRN{6,BEFC5{{{MERGE WITH REAL CASE{12415
*
*      HERE TO CONVERT A REAL
*
{BEFC4{MOV{9,(XT){7,XR{{LOAD NEXT ARGUMENT{12419
{{MOV{8,WC{3,BEFOF{{SAVE OFFSET{12420
{{JSR{6,GTREA{{{CONVERT TO REAL{12421
{{ERR{1,265{26,External function argument is not real{{{12422
*
*      INTEGER CASE MERGES HERE
*
{BEFC5{MOV{3,BEFOF{8,WC{{RESTORE OFFSET{12427
*
*      STRING MERGES HERE
*
{BEFC6{MOV{7,XR{9,(XT){{STORE CONVERTED RESULT{12431
*
*      NO CONVERSION MERGES HERE
*
{BEFC7{BNZ{8,WC{6,BEFC1{{LOOP BACK IF MORE TO GO{12435
*
*      HERE AFTER CONVERTING ALL THE ARGUMENTS
*
{{MOV{10,(XS)+{7,XL{{RESTORE EFBLK POINTER{12439
{{MOV{13,FARGS(XL){8,WA{{GET NUMBER OF ARGS{12440
{{JSR{6,SYSEX{{{CALL ROUTINE TO CALL EXTERNAL FNC{12441
{{PPM{6,EXFAL{{{FAIL IF FAILURE{12442
{{ERR{1,327{26,Calling external function - not found{{{12443
{{ERR{1,326{26,Calling external function - bad argument type{{{12444
{{WTB{8,WA{{{CONVERT NUMBER OF ARGS TO BYTES{12446
{{ADD{8,WA{7,XS{{REMOVE ARGUMENTS FROM STACK{12447
{{EJC{{{{{12449
*
*      EFBLK (CONTINUED)
*
*      RETURN HERE WITH RESULT IN XR
*
*      FIRST DEFEND AGAINST NON-STANDARD NULL STRING RETURNED
*
{{MOV{13,EFRSL(XL){8,WB{{GET RESULT TYPE ID{12457
{{BNZ{8,WB{6,BEFA8{{BRANCH IF NOT UNCONVERTED{12458
{{BNE{9,(XR){22,=B$SCL{6,BEFC8{JUMP IF NOT A STRING{12459
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{12460
*
*      HERE IF CONVERTED RESULT TO CHECK FOR NULL STRING
*
{BEFA8{BNE{8,WB{18,=NUM01{6,BEFC8{JUMP IF NOT A STRING{12464
{{BZE{13,SCLEN(XR){6,EXNUL{{RETURN NULL IF NULL{12465
*
*      RETURN IF RESULT IS IN DYNAMIC STORAGE
*
{BEFC8{BLT{7,XR{3,DNAMB{6,BEFC9{JUMP IF NOT IN DYNAMIC STORAGE{12469
{{BLE{7,XR{3,DNAMP{6,EXIXR{RETURN RESULT IF ALREADY DYNAMIC{12470
*
*      HERE WE COPY A RESULT INTO THE DYNAMIC REGION
*
{BEFC9{MOV{9,(XR){8,WA{{GET POSSIBLE TYPE WORD{12474
{{BZE{8,WB{6,BEF11{{JUMP IF UNCONVERTED RESULT{12475
{{MOV{22,=B$SCL{8,WA{{STRING{12476
{{BEQ{8,WB{18,=NUM01{6,BEF10{YES JUMP{12477
{{MOV{22,=B$ICL{8,WA{{INTEGER{12478
{{BEQ{8,WB{18,=NUM02{6,BEF10{YES JUMP{12479
{{MOV{22,=B$RCL{8,WA{{REAL{12482
*
*      STORE TYPE WORD IN RESULT
*
{BEF10{MOV{8,WA{9,(XR){{STORED BEFORE COPYING TO DYNAMIC{12487
*
*      MERGE FOR UNCONVERTED RESULT
*
{BEF11{BEQ{9,(XR){22,=B$SCL{6,BEF12{BRANCH IF STRING RESULT{12491
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{12492
{{MOV{7,XR{7,XL{{COPY ADDRESS OF OLD BLOCK{12493
{{JSR{6,ALLOC{{{ALLOCATE DYNAMIC BLOCK SAME SIZE{12494
{{MOV{7,XR{11,-(XS){{SET POINTER TO NEW BLOCK AS RESULT{12495
{{MVW{{{{COPY OLD BLOCK TO DYNAMIC BLOCK{12496
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12497
{{LCW{7,XR{{{GET NEXT CODE WORD{12498
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12499
*
*      HERE TO RETURN A STRING RESULT THAT WAS NOT IN DYNAMIC.
*      CANNOT USE THE SIMPLE WORD COPY ABOVE BECAUSE IT WILL NOT
*      GUARANTEE ZERO PADDING IN THE LAST WORD.
*
{BEF12{MOV{7,XR{7,XL{{SAVE SOURCE STRING POINTER{12505
{{MOV{13,SCLEN(XR){8,WA{{FETCH STRING LENGTH{12506
{{BZE{8,WA{6,EXNUL{{RETURN NULL STRING IF LENGTH ZERO{12507
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{12508
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT POINTER{12509
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{12510
{{PLC{7,XL{{{POINT TO CHARS IN SOURCE STRING{12511
{{MOV{8,WC{8,WA{{NUMBER OF CHARACTERS TO COPY{12512
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{12513
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{12514
{{LCW{7,XR{{{GET NEXT CODE WORD{12515
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12516
{{EJC{{{{{12518
*
*      EVBLK
*
*      THE ROUTINE FOR AN EVBLK IS NEVER EXECUTED
*
{B$EVT{ENT{2,BL$EV{{{ENTRY POINT (EVBLK){12524
{{EJC{{{{{12525
*
*      FFBLK
*
*      THE ROUTINE FOR AN FFBLK IS EXECUTED FROM THE O$FNC ENTRY
*      TO CALL A FIELD FUNCTION AND EXTRACT A FIELD VALUE/NAME.
*
*      (XL)                  POINTER TO FFBLK
*
{B$FFC{ENT{2,BL$FF{{{ENTRY POINT (FFBLK){12534
{{MOV{7,XL{7,XR{{COPY FFBLK POINTER{12535
{{LCW{8,WC{{{LOAD NEXT CODE WORD{12536
{{MOV{9,(XS){7,XL{{LOAD PDBLK POINTER{12537
{{BNE{9,(XL){22,=B$PDT{6,BFFC2{JUMP IF NOT PDBLK AT ALL{12538
{{MOV{13,PDDFP(XL){8,WA{{LOAD DFBLK POINTER FROM PDBLK{12539
*
*      LOOP TO FIND CORRECT FFBLK FOR THIS PDBLK
*
{BFFC1{BEQ{8,WA{13,FFDFP(XR){6,BFFC3{JUMP IF THIS IS THE CORRECT FFBLK{12543
{{MOV{13,FFNXT(XR){7,XR{{ELSE LINK TO NEXT FFBLK ON CHAIN{12544
{{BNZ{7,XR{6,BFFC1{{LOOP BACK IF ANOTHER ENTRY TO CHECK{12545
*
*      HERE FOR BAD ARGUMENT
*
{BFFC2{ERB{1,041{26,FIELD function argument is wrong datatype{{{12549
{{EJC{{{{{12550
*
*      FFBLK (CONTINUED)
*
*      HERE AFTER LOCATING CORRECT FFBLK
*
{BFFC3{MOV{13,FFOFS(XR){8,WA{{LOAD FIELD OFFSET{12556
{{BEQ{8,WC{21,=OFNE${6,BFFC5{JUMP IF CALLED BY NAME{12557
{{ADD{8,WA{7,XL{{ELSE POINT TO VALUE FIELD{12558
{{MOV{9,(XL){7,XR{{LOAD VALUE{12559
{{BNE{9,(XR){22,=B$TRT{6,BFFC4{JUMP IF NOT TRAPPED{12560
{{SUB{8,WA{7,XL{{ELSE RESTORE NAME BASE,OFFSET{12561
{{MOV{8,WC{9,(XS){{SAVE NEXT CODE WORD OVER PDBLK PTR{12562
{{JSR{6,ACESS{{{ACCESS VALUE{12563
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{12564
{{MOV{9,(XS){8,WC{{RESTORE NEXT CODE WORD{12565
*
*      HERE AFTER GETTING VALUE IN (XR), XL IS GARBAGE
*
{BFFC4{MOV{7,XR{9,(XS){{STORE VALUE ON STACK (OVER PDBLK){12569
{{MOV{8,WC{7,XR{{COPY NEXT CODE WORD{12570
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{12571
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{12572
*
*      HERE IF CALLED BY NAME
*
{BFFC5{MOV{8,WA{11,-(XS){{STORE NAME OFFSET (BASE IS SET){12576
{{LCW{7,XR{{{GET NEXT CODE WORD{12577
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12578
{{EJC{{{{{12579
*
*      ICBLK
*
*      THE ROUTINE FOR ICBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD AN INTEGER VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO ICBLK
*
{B$ICL{ENT{2,BL$IC{{{ENTRY POINT (ICBLK){12588
{{MOV{7,XR{11,-(XS){{STACK RESULT{12589
{{LCW{7,XR{{{GET NEXT CODE WORD{12590
{{BRI{9,(XR){{{EXECUTE IT{12591
{{EJC{{{{{12592
*
*      KVBLK
*
*      THE ROUTINE FOR A KVBLK IS NEVER EXECUTED.
*
{B$KVT{ENT{2,BL$KV{{{ENTRY POINT (KVBLK){12598
{{EJC{{{{{12599
*
*      NMBLK
*
*      THE ROUTINE FOR A NMBLK IS EXECUTED FROM THE GENERATED
*      CODE FOR THE CASE OF LOADING A NAME ONTO THE STACK
*      WHERE THE NAME IS THAT OF A NATURAL VARIABLE WHICH CAN
*      BE PREEVALUATED AT COMPILE TIME.
*
*      (XR)                  POINTER TO NMBLK
*
{B$NML{ENT{2,BL$NM{{{ENTRY POINT (NMBLK){12610
{{MOV{7,XR{11,-(XS){{STACK RESULT{12611
{{LCW{7,XR{{{GET NEXT CODE WORD{12612
{{BRI{9,(XR){{{EXECUTE IT{12613
{{EJC{{{{{12614
*
*      PDBLK
*
*      THE ROUTINE FOR A PDBLK IS NEVER EXECUTED
*
{B$PDT{ENT{2,BL$PD{{{ENTRY POINT (PDBLK){12620
{{EJC{{{{{12621
*
*      PFBLK
*
*      THE ROUTINE FOR A PFBLK IS EXECUTED FROM THE ENTRY O$FNC
*      TO CALL A PROGRAM DEFINED FUNCTION.
*
*      (XL)                  POINTER TO PFBLK
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE PROGRAM DEFINED FUNCTION.
*
*                            SAVED VALUE OF FIRST ARGUMENT
*                            .
*                            SAVED VALUE OF LAST ARGUMENT
*                            SAVED VALUE OF FIRST LOCAL
*                            .
*                            SAVED VALUE OF LAST LOCAL
*                            SAVED VALUE OF FUNCTION NAME
*                            SAVED CODE BLOCK PTR (R$COD)
*                            SAVED CODE POINTER (-R$COD)
*                            SAVED VALUE OF FLPRT
*                            SAVED VALUE OF FLPTR
*                            POINTER TO PFBLK
*      FLPTR --------------- ZERO (TO BE OVERWRITTEN WITH OFFS)
*
{B$PFC{ENT{2,BL$PF{{{ENTRY POINT (PFBLK){12647
{{MOV{7,XL{3,BPFPF{{SAVE PFBLK PTR (NEED NOT BE RELOC){12648
{{MOV{7,XL{7,XR{{COPY FOR THE MOMENT{12649
{{MOV{13,PFVBL(XR){7,XL{{POINT TO VRBLK FOR FUNCTION{12650
*
*      LOOP TO FIND OLD VALUE OF FUNCTION
*
{BPF01{MOV{7,XL{8,WB{{SAVE POINTER{12654
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{12655
{{BEQ{9,(XL){22,=B$TRT{6,BPF01{LOOP IF TRBLK{12656
*
*      SET VALUE TO NULL AND SAVE OLD FUNCTION VALUE
*
{{MOV{7,XL{3,BPFSV{{SAVE OLD VALUE{12660
{{MOV{8,WB{7,XL{{POINT BACK TO BLOCK WITH VALUE{12661
{{MOV{21,=NULLS{13,VRVAL(XL){{SET VALUE TO NULL{12662
{{MOV{13,FARGS(XR){8,WA{{LOAD NUMBER OF ARGUMENTS{12663
{{ADD{19,*PFARG{7,XR{{POINT TO PFARG ENTRIES{12664
{{BZE{8,WA{6,BPF04{{JUMP IF NO ARGUMENTS{12665
{{MOV{7,XS{7,XT{{PTR TO LAST ARG{12666
{{WTB{8,WA{{{CONVERT NO. OF ARGS TO BYTES OFFSET{12667
{{ADD{8,WA{7,XT{{POINT BEFORE FIRST ARG{12668
{{MOV{7,XT{3,BPFXT{{REMEMBER ARG POINTER{12669
{{EJC{{{{{12670
*
*      PFBLK (CONTINUED)
*
*      LOOP TO SAVE OLD ARGUMENT VALUES AND SET NEW ONES
*
{BPF02{MOV{10,(XR)+{7,XL{{LOAD VRBLK PTR FOR NEXT ARGUMENT{12676
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF03{MOV{7,XL{8,WC{{SAVE POINTER{12680
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE{12681
{{BEQ{9,(XL){22,=B$TRT{6,BPF03{LOOP BACK IF TRBLK{12682
*
*      SAVE OLD VALUE AND GET NEW VALUE
*
{{MOV{7,XL{8,WA{{KEEP OLD VALUE{12686
{{MOV{3,BPFXT{7,XT{{POINT BEFORE NEXT STACKED ARG{12687
{{MOV{11,-(XT){8,WB{{LOAD ARGUMENT (NEW VALUE){12688
{{MOV{8,WA{9,(XT){{SAVE OLD VALUE{12689
{{MOV{7,XT{3,BPFXT{{KEEP ARG PTR FOR NEXT TIME{12690
{{MOV{8,WC{7,XL{{POINT BACK TO BLOCK WITH VALUE{12691
{{MOV{8,WB{13,VRVAL(XL){{SET NEW VALUE{12692
{{BNE{7,XS{3,BPFXT{6,BPF02{LOOP IF NOT ALL DONE{12693
*
*      NOW PROCESS LOCALS
*
{BPF04{MOV{3,BPFPF{7,XL{{RESTORE PFBLK POINTER{12697
{{MOV{13,PFNLO(XL){8,WA{{LOAD NUMBER OF LOCALS{12698
{{BZE{8,WA{6,BPF07{{JUMP IF NO LOCALS{12699
{{MOV{21,=NULLS{8,WB{{GET NULL CONSTANT{12700
{{LCT{8,WA{8,WA{{SET LOCAL COUNTER{12701
*
*      LOOP TO PROCESS LOCALS
*
{BPF05{MOV{10,(XR)+{7,XL{{LOAD VRBLK PTR FOR NEXT LOCAL{12705
*
*      LOOP THROUGH POSSIBLE TRBLK CHAIN TO FIND VALUE
*
{BPF06{MOV{7,XL{8,WC{{SAVE POINTER{12709
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE{12710
{{BEQ{9,(XL){22,=B$TRT{6,BPF06{LOOP BACK IF TRBLK{12711
*
*      SAVE OLD VALUE AND SET NULL AS NEW VALUE
*
{{MOV{7,XL{11,-(XS){{STACK OLD VALUE{12715
{{MOV{8,WC{7,XL{{POINT BACK TO BLOCK WITH VALUE{12716
{{MOV{8,WB{13,VRVAL(XL){{SET NULL AS NEW VALUE{12717
{{BCT{8,WA{6,BPF05{{LOOP TILL ALL LOCALS PROCESSED{12718
{{EJC{{{{{12719
*
*      PFBLK (CONTINUED)
*
*      HERE AFTER PROCESSING ARGUMENTS AND LOCALS
*
{BPF07{ZER{7,XR{{{ZERO REG XR IN CASE{12728
{{BZE{3,KVPFL{6,BPF7C{{SKIP IF PROFILING IS OFF{12729
{{BEQ{3,KVPFL{18,=NUM02{6,BPF7A{BRANCH ON TYPE OF PROFILE{12730
*
*      HERE IF &PROFILE = 1
*
{{JSR{6,SYSTM{{{GET CURRENT TIME{12734
{{STI{3,PFETM{{{SAVE FOR A SEC{12735
{{SBI{3,PFSTM{{{FIND TIME USED BY CALLER{12736
{{JSR{6,ICBLD{{{BUILD INTO AN ICBLK{12737
{{LDI{3,PFETM{{{RELOAD CURRENT TIME{12738
{{BRN{6,BPF7B{{{MERGE{12739
*
*       HERE IF &PROFILE = 2
*
{BPF7A{LDI{3,PFSTM{{{GET START TIME OF CALLING STMT{12743
{{JSR{6,ICBLD{{{ASSEMBLE AN ICBLK ROUND IT{12744
{{JSR{6,SYSTM{{{GET NOW TIME{12745
*
*      BOTH TYPES OF PROFILE MERGE HERE
*
{BPF7B{STI{3,PFSTM{{{SET START TIME OF 1ST FUNC STMT{12749
{{MNZ{3,PFFNC{{{FLAG FUNCTION ENTRY{12750
*
*      NO PROFILING MERGES HERE
*
{BPF7C{MOV{7,XR{11,-(XS){{STACK ICBLK PTR (OR ZERO){12754
{{MOV{3,R$COD{8,WA{{LOAD OLD CODE BLOCK POINTER{12755
{{SCP{8,WB{{{GET CODE POINTER{12757
{{SUB{8,WA{8,WB{{MAKE CODE POINTER INTO OFFSET{12758
{{MOV{3,BPFPF{7,XL{{RECALL PFBLK POINTER{12759
{{MOV{3,BPFSV{11,-(XS){{STACK OLD VALUE OF FUNCTION NAME{12760
{{MOV{8,WA{11,-(XS){{STACK CODE BLOCK POINTER{12761
{{MOV{8,WB{11,-(XS){{STACK CODE OFFSET{12762
{{MOV{3,FLPRT{11,-(XS){{STACK OLD FLPRT{12763
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{12764
{{MOV{7,XL{11,-(XS){{STACK POINTER TO PFBLK{12765
{{ZER{11,-(XS){{{DUMMY ZERO ENTRY FOR FAIL RETURN{12766
{{CHK{{{{CHECK FOR STACK OVERFLOW{12767
{{MOV{7,XS{3,FLPTR{{SET NEW FAIL RETURN VALUE{12768
{{MOV{7,XS{3,FLPRT{{SET NEW FLPRT{12769
{{MOV{3,KVTRA{8,WA{{LOAD TRACE VALUE{12770
{{ADD{3,KVFTR{8,WA{{ADD FTRACE VALUE{12771
{{BNZ{8,WA{6,BPF09{{JUMP IF TRACING POSSIBLE{12772
{{ICV{3,KVFNC{{{ELSE BUMP FNCLEVEL{12773
*
*      HERE TO ACTUALLY JUMP TO FUNCTION
*
{BPF08{MOV{13,PFCOD(XL){7,XR{{POINT TO VRBLK OF ENTRY LABEL{12777
{{MOV{13,VRLBL(XR){7,XR{{POINT TO TARGET CODE{12778
{{BEQ{7,XR{21,=STNDL{6,BPF17{TEST FOR UNDEFINED LABEL{12779
{{BNE{9,(XR){22,=B$TRT{6,BPF8A{JUMP IF NOT TRAPPED{12780
{{MOV{13,TRLBL(XR){7,XR{{ELSE LOAD PTR TO REAL LABEL CODE{12781
{BPF8A{BRI{9,(XR){{{OFF TO EXECUTE FUNCTION{12782
*
*      HERE IF TRACING IS POSSIBLE
*
{BPF09{MOV{13,PFCTR(XL){7,XR{{LOAD POSSIBLE CALL TRACE TRBLK{12786
{{MOV{13,PFVBL(XL){7,XL{{LOAD VRBLK POINTER FOR FUNCTION{12787
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET FOR VARIABLE{12788
{{BZE{3,KVTRA{6,BPF10{{JUMP IF TRACE MODE IS OFF{12789
{{BZE{7,XR{6,BPF10{{OR IF THERE IS NO CALL TRACE{12790
*
*      HERE IF CALL TRACED
*
{{DCV{3,KVTRA{{{DECREMENT TRACE COUNT{12794
{{BZE{13,TRFNC(XR){6,BPF11{{JUMP IF PRINT TRACE{12795
{{JSR{6,TRXEQ{{{EXECUTE FUNCTION TYPE TRACE{12796
{{EJC{{{{{12797
*
*      PFBLK (CONTINUED)
*
*      HERE TO TEST FOR FTRACE TRACE
*
{BPF10{BZE{3,KVFTR{6,BPF16{{JUMP IF FTRACE IS OFF{12803
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{12804
*
*      HERE FOR PRINT TRACE
*
{BPF11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{12808
{{JSR{6,PRTNM{{{PRINT FUNCTION NAME{12809
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{12810
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{12811
{{MOV{12,1(XS){7,XL{{RECOVER PFBLK POINTER{12812
{{BZE{13,FARGS(XL){6,BPF15{{SKIP IF NO ARGUMENTS{12813
{{ZER{8,WB{{{ELSE SET ARGUMENT COUNTER{12814
{{BRN{6,BPF13{{{JUMP INTO LOOP{12815
*
*      LOOP TO PRINT ARGUMENT VALUES
*
{BPF12{MOV{18,=CH$CM{8,WA{{LOAD COMMA{12819
{{JSR{6,PRTCH{{{PRINT TO SEPARATE FROM LAST ARG{12820
*
*      MERGE HERE FIRST TIME (NO COMMA REQUIRED)
*
{BPF13{MOV{8,WB{9,(XS){{SAVE ARG CTR (OVER FAILOFFS IS OK){12824
{{WTB{8,WB{{{CONVERT TO BYTE OFFSET{12825
{{ADD{8,WB{7,XL{{POINT TO NEXT ARGUMENT POINTER{12826
{{MOV{13,PFARG(XL){7,XR{{LOAD NEXT ARGUMENT VRBLK PTR{12827
{{SUB{8,WB{7,XL{{RESTORE PFBLK POINTER{12828
{{MOV{13,VRVAL(XR){7,XR{{LOAD NEXT VALUE{12829
{{JSR{6,PRTVL{{{PRINT ARGUMENT VALUE{12830
{{EJC{{{{{12831
*
*      HERE AFTER DEALING WITH ONE ARGUMENT
*
{{MOV{9,(XS){8,WB{{RESTORE ARGUMENT COUNTER{12835
{{ICV{8,WB{{{INCREMENT ARGUMENT COUNTER{12836
{{BLT{8,WB{13,FARGS(XL){6,BPF12{LOOP IF MORE TO PRINT{12837
*
*      MERGE HERE IN NO ARGS CASE TO PRINT PAREN
*
{BPF15{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN{12841
{{JSR{6,PRTCH{{{PRINT TO TERMINATE OUTPUT{12842
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{12843
*
*      MERGE HERE TO EXIT WITH TEST FOR FNCLEVEL TRACE
*
{BPF16{ICV{3,KVFNC{{{INCREMENT FNCLEVEL{12847
{{MOV{3,R$FNC{7,XL{{LOAD PTR TO POSSIBLE TRBLK{12848
{{JSR{6,KTREX{{{CALL KEYWORD TRACE ROUTINE{12849
*
*      CALL FUNCTION AFTER TRACE TESTS COMPLETE
*
{{MOV{12,1(XS){7,XL{{RESTORE PFBLK POINTER{12853
{{BRN{6,BPF08{{{JUMP BACK TO EXECUTE FUNCTION{12854
*
*      HERE IF CALLING A FUNCTION WHOSE ENTRY LABEL IS UNDEFINED
*
{BPF17{MOV{12,2(XS){3,FLPTR{{RESET SO EXFAL CAN RETURN TO EVALX{12858
{{ERB{1,286{26,Function call to undefined entry label{{{12859
{{EJC{{{{{12862
*
*      RCBLK
*
*      THE ROUTINE FOR AN RCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A REAL VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO RCBLK
*
{B$RCL{ENT{2,BL$RC{{{ENTRY POINT (RCBLK){12871
{{MOV{7,XR{11,-(XS){{STACK RESULT{12872
{{LCW{7,XR{{{GET NEXT CODE WORD{12873
{{BRI{9,(XR){{{EXECUTE IT{12874
{{EJC{{{{{12876
*
*      SCBLK
*
*      THE ROUTINE FOR AN SCBLK IS EXECUTED FROM THE GENERATED
*      CODE TO LOAD A STRING VALUE ONTO THE STACK.
*
*      (XR)                  POINTER TO SCBLK
*
{B$SCL{ENT{2,BL$SC{{{ENTRY POINT (SCBLK){12885
{{MOV{7,XR{11,-(XS){{STACK RESULT{12886
{{LCW{7,XR{{{GET NEXT CODE WORD{12887
{{BRI{9,(XR){{{EXECUTE IT{12888
{{EJC{{{{{12889
*
*      TBBLK
*
*      THE ROUTINE FOR A TBBLK IS NEVER EXECUTED
*
{B$TBT{ENT{2,BL$TB{{{ENTRY POINT (TBBLK){12895
{{EJC{{{{{12896
*
*      TEBLK
*
*      THE ROUTINE FOR A TEBLK IS NEVER EXECUTED
*
{B$TET{ENT{2,BL$TE{{{ENTRY POINT (TEBLK){12902
{{EJC{{{{{12903
*
*      VCBLK
*
*      THE ROUTINE FOR A VCBLK IS NEVER EXECUTED
*
{B$VCT{ENT{2,BL$VC{{{ENTRY POINT (VCBLK){12909
{{EJC{{{{{12910
*
*      VRBLK
*
*      THE VRBLK ROUTINES ARE EXECUTED FROM THE GENERATED CODE.
*      THERE ARE SIX ENTRIES FOR VRBLK COVERING VARIOUS CASES
*
{B$VR${ENT{2,BL$$I{{{MARK START OF VRBLK ENTRY POINTS{12917
*
*      ENTRY FOR VRGET (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*      THIS ENTRY POINT IS USED IF AN ACCESS TRACE OR INPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRGET FIELD OF VRBLK
*
{B$VRA{ENT{2,BL$$I{{{ENTRY POINT{12926
{{MOV{7,XR{7,XL{{COPY NAME BASE (VRGET = 0){12927
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{12928
{{JSR{6,ACESS{{{ACCESS VALUE{12929
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{12930
{{MOV{7,XR{11,-(XS){{STACK RESULT{12931
{{LCW{7,XR{{{GET NEXT CODE WORD{12932
{{BRI{9,(XR){{{EXECUTE IT{12933
{{EJC{{{{{12934
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (ERROR CASE. THIS ROUTINE IS CALLED FROM
*      THE EXECUTED CODE FOR AN ATTEMPT TO MODIFY THE VALUE
*      OF A PROTECTED (PATTERN VALUED) NATURAL VARIABLE.
*
{B$VRE{ENT{{{{ENTRY POINT{12942
{{ERB{1,042{26,Attempt to change value of protected variable{{{12943
{{EJC{{{{{12944
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRTRA (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE EXECUTED CODE TO TRANSFER TO A LABEL.
*
*      (XR)                  POINTER TO VRTRA FIELD OF VRBLK
*
{B$VRG{ENT{{{{ENTRY POINT{12953
{{MOV{13,VRLBO(XR){7,XR{{LOAD CODE POINTER{12954
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{12955
{{BRI{7,XL{{{JUMP TO ROUTINE FOR NEXT CODE WORD{12956
{{EJC{{{{{12957
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRGET (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO LOAD THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTS TO VRGET FIELD OF VRBLK
*
{B$VRL{ENT{{{{ENTRY POINT{12966
{{MOV{13,VRVAL(XR){11,-(XS){{LOAD VALUE ONTO STACK (VRGET = 0){12967
{{LCW{7,XR{{{GET NEXT CODE WORD{12968
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12969
{{EJC{{{{{12970
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (UNTRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B$VRS{ENT{{{{ENTRY POINT{12979
{{MOV{9,(XS){13,VRVLO(XR){{STORE VALUE, LEAVE ON STACK{12980
{{LCW{7,XR{{{GET NEXT CODE WORD{12981
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{12982
{{EJC{{{{{12983
*
*      VRBLK (CONTINUED)
*
*      VRTRA (TRAPPED CASE). THIS ROUTINE IS CALLED FROM THE
*      GENERATED CODE TO TRANSFER TO A LABEL WHEN A LABEL
*      TRACE IS CURRENTLY ACTIVE.
*
{B$VRT{ENT{{{{ENTRY POINT{12991
{{SUB{19,*VRTRA{7,XR{{POINT BACK TO START OF VRBLK{12992
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{12993
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{12994
{{MOV{13,VRLBL(XL){7,XR{{LOAD POINTER TO TRBLK{12995
{{BZE{3,KVTRA{6,BVRT2{{JUMP IF TRACE IS OFF{12996
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{12997
{{BZE{13,TRFNC(XR){6,BVRT1{{JUMP IF PRINT TRACE CASE{12998
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{12999
{{BRN{6,BVRT2{{{MERGE TO JUMP TO LABEL{13000
*
*      HERE FOR PRINT TRACE -- PRINT COLON ( LABEL NAME )
*
{BVRT1{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{13004
{{MOV{7,XL{7,XR{{COPY VRBLK POINTER{13005
{{MOV{18,=CH$CL{8,WA{{COLON{13006
{{JSR{6,PRTCH{{{PRINT IT{13007
{{MOV{18,=CH$PP{8,WA{{LEFT PAREN{13008
{{JSR{6,PRTCH{{{PRINT IT{13009
{{JSR{6,PRTVN{{{PRINT LABEL NAME{13010
{{MOV{18,=CH$RP{8,WA{{RIGHT PAREN{13011
{{JSR{6,PRTCH{{{PRINT IT{13012
{{JSR{6,PRTNL{{{TERMINATE LINE{13013
{{MOV{13,VRLBL(XL){7,XR{{POINT BACK TO TRBLK{13014
*
*      MERGE HERE TO JUMP TO LABEL
*
{BVRT2{MOV{13,TRLBL(XR){7,XR{{LOAD POINTER TO ACTUAL CODE{13018
{{BRI{9,(XR){{{EXECUTE STATEMENT AT LABEL{13019
{{EJC{{{{{13020
*
*      VRBLK (CONTINUED)
*
*      ENTRY FOR VRSTO (TRAPPED CASE). THIS ROUTINE IS CALLED
*      FROM THE GENERATED CODE TO STORE THE VALUE OF A VARIABLE.
*      THIS ENTRY IS USED WHEN A VALUE TRACE OR OUTPUT
*      ASSOCIATION IS CURRENTLY ACTIVE.
*
*      (XR)                  POINTER TO VRSTO FIELD OF VRBLK
*
{B$VRV{ENT{{{{ENTRY POINT{13031
{{MOV{9,(XS){8,WB{{LOAD VALUE (LEAVE COPY ON STACK){13032
{{SUB{19,*VRSTO{7,XR{{POINT TO VRBLK{13033
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{13034
{{MOV{19,*VRVAL{8,WA{{SET OFFSET{13035
{{JSR{6,ASIGN{{{CALL ASSIGNMENT ROUTINE{13036
{{PPM{6,EXFAL{{{FAIL IF ASSIGNMENT FAILS{13037
{{LCW{7,XR{{{ELSE GET NEXT CODE WORD{13038
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{13039
{{EJC{{{{{13040
*
*      XNBLK
*
*      THE ROUTINE FOR AN XNBLK IS NEVER EXECUTED
*
{B$XNT{ENT{2,BL$XN{{{ENTRY POINT (XNBLK){13046
{{EJC{{{{{13047
*
*      XRBLK
*
*      THE ROUTINE FOR AN XRBLK IS NEVER EXECUTED
*
{B$XRT{ENT{2,BL$XR{{{ENTRY POINT (XRBLK){13053
*
*      MARK ENTRY ADDRESS PAST LAST BLOCK ACTION ROUTINE
*
{B$YYY{ENT{2,BL$$I{{{LAST BLOCK ROUTINE ENTRY POINT{13057
{{TTL{27,S P I T B O L -- PATTERN MATCHING ROUTINES{{{{13058
*
*      THE FOLLOWING SECTION CONSISTS OF THE PATTERN MATCHING
*      ROUTINES. ALL PATTERN NODES CONTAIN A POINTER (PCODE)
*      TO ONE OF THE ROUTINES IN THIS SECTION (P$XXX).
*
*      NOTE THAT THIS SECTION FOLLOWS THE B$XXX ROUTINES TO
*      ENABLE A FAST TEST FOR THE PATTERN DATATYPE.
*
{P$AAA{ENT{2,BL$$I{{{ENTRY TO MARK FIRST PATTERN{13067
*
*
*      THE ENTRY CONDITIONS TO THE MATCH ROUTINE ARE AS FOLLOWS
*      (SEE O$PMN, O$PMV, O$PMS AND PROCEDURE MATCH).
*
*      STACK CONTENTS.
*
*                            NAME BASE (O$PMN ONLY)
*                            NAME OFFSET (O$PMN ONLY)
*                            TYPE (0-O$PMN, 1-O$PMV, 2-O$PMS)
*      PMHBS --------------- INITIAL CURSOR (ZERO)
*                            INITIAL NODE POINTER
*      XS ------------------ =NDABO (ANCHORED), =NDUNA (UNANCH)
*
*      REGISTER VALUES.
*
*           (XS)             SET AS SHOWN IN STACK DIAGRAM
*           (XR)             POINTER TO INITIAL PATTERN NODE
*           (WB)             INITIAL CURSOR (ZERO)
*
*      GLOBAL PATTERN VALUES
*
*           R$PMS            POINTER TO SUBJECT STRING SCBLK
*           PMSSL            LENGTH OF SUBJECT STRING IN CHARS
*           PMDFL            DOT FLAG, INITIALLY ZERO
*           PMHBS            SET AS SHOWN IN STACK DIAGRAM
*
*      CONTROL IS PASSED BY BRANCHING THROUGH THE PCODE
*      FIELD OF THE INITIAL PATTERN NODE (BRI (XR)).
{{EJC{{{{{13097
*
*      DESCRIPTION OF ALGORITHM
*
*      A PATTERN STRUCTURE IS REPRESENTED AS A LINKED GRAPH
*      OF NODES WITH THE FOLLOWING STRUCTURE.
*
*           +------------------------------------+
*           I                PCODE               I
*           +------------------------------------+
*           I                PTHEN               I
*           +------------------------------------+
*           I                PARM1               I
*           +------------------------------------+
*           I                PARM2               I
*           +------------------------------------+
*
*      PCODE IS A POINTER TO THE ROUTINE WHICH WILL PERFORM
*      THE MATCH OF THIS PARTICULAR NODE TYPE.
*
*      PTHEN IS A POINTER TO THE SUCCESSOR NODE. I.E. THE NODE
*      TO BE MATCHED IF THE ATTEMPT TO MATCH THIS NODE SUCCEEDS.
*      IF THIS IS THE LAST NODE OF THE PATTERN PTHEN POINTS
*      TO THE DUMMY NODE NDNTH WHICH INITIATES PATTERN EXIT.
*
*      PARM1, PARM2 ARE PARAMETERS WHOSE USE VARIES WITH THE
*      PARTICULAR NODE. THEY ARE ONLY PRESENT IF REQUIRED.
*
*      ALTERNATIVES ARE HANDLED WITH THE SPECIAL ALTERNATIVE
*      NODE WHOSE PARAMETER POINTS TO THE NODE TO BE MATCHED
*      IF THERE IS A FAILURE ON THE SUCCESSOR PATH.
*
*      THE FOLLOWING EXAMPLE ILLUSTRATES THE MANNER IN WHICH
*      THE STRUCTURE IS BUILT UP. THE PATTERN IS
*
*      (A / B / C) (D / E)   WHERE / IS ALTERNATION
*
*      IN THE DIAGRAM, THE NODE MARKED + REPRESENTS AN
*      ALTERNATIVE NODE AND THE DOTTED LINE FROM A + NODE
*      REPRESENTS THE PARAMETER POINTER TO THE ALTERNATIVE.
*
*      +---+     +---+     +---+     +---+
*      I + I-----I A I-----I + I-----I D I-----
*      +---+     +---+  I  +---+     +---+
*        .              I    .
*        .              I    .
*      +---+     +---+  I  +---+
*      I + I-----I B I--I  I E I-----
*      +---+     +---+  I  +---+
*        .              I
*        .              I
*      +---+            I
*      I C I------------I
*      +---+
{{EJC{{{{{13151
*
*      DURING THE MATCH, THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  POINTS TO THE CURRENT NODE
*      (XL)                  SCRATCH
*      (XS)                  MAIN STACK POINTER
*      (WB)                  CURSOR (NUMBER OF CHARS MATCHED)
*      (WA,WC)               SCRATCH
*
*      TO KEEP TRACK OF ALTERNATIVES, THE MAIN STACK IS USED AS
*      A HISTORY STACK AND CONTAINS TWO WORD ENTRIES.
*
*      WORD 1                SAVED CURSOR VALUE
*      WORD 2                NODE TO MATCH ON FAILURE
*
*      WHEN A FAILURE OCCURS, THE MOST RECENT ENTRY ON THIS
*      STACK IS POPPED OFF TO RESTORE THE CURSOR AND POINT
*      TO THE NODE TO BE MATCHED AS AN ALTERNATIVE. THE ENTRY
*      AT THE BOTTOM OF THE STACK POINTS TO THE FOLLOWING
*      SPECIAL NODES DEPENDING ON THE SCAN MODE.
*
*      ANCHORED MODE         THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDABO WHICH CAUSES AN
*                            ABORT. THE CURSOR VALUE STORED
*                            WITH THIS ENTRY IS ALWAYS ZERO.
*
*      UNANCHORED MODE       THE BOTTOM ENTRY POINTS TO THE
*                            SPECIAL NODE NDUNA WHICH MOVES THE
*                            ANCHOR POINT AND RESTARTS THE MATCH
*                            THE CURSOR SAVED WITH THIS ENTRY
*                            IS THE NUMBER OF CHARACTERS WHICH
*                            LIE BEFORE THE INITIAL ANCHOR POINT
*                            (I.E. THE NUMBER OF ANCHOR MOVES).
*                            THIS ENTRY IS THREE WORDS LONG AND
*                            ALSO CONTAINS THE INITIAL PATTERN.
*
*      ENTRIES ARE MADE ON THIS HISTORY STACK BY ALTERNATIVE
*      NODES AND BY SOME SPECIAL COMPOUND PATTERNS AS DESCRIBED
*      LATER ON. THE FOLLOWING GLOBAL LOCATIONS ARE USED DURING
*      PATTERN MATCHING.
*
*      R$PMS                 POINTER TO SUBJECT STRING
*      PMSSL                 LENGTH OF SUBJECT STRING
*      PMDFL                 FLAG SET NON-ZERO FOR DOT PATTERNS
*      PMHBS                 BASE PTR FOR CURRENT HISTORY STACK
*
*      THE FOLLOWING EXIT POINTS ARE AVAILABLE TO MATCH ROUTINES
*
*      SUCCP                 SUCCESS IN MATCHING CURRENT NODE
*      FAILP                 FAILURE IN MATCHING CURRENT NODE
{{EJC{{{{{13202
*
*      COMPOUND PATTERNS
*
*      SOME PATTERNS HAVE IMPLICIT ALTERNATIVES AND THEIR
*      REPRESENTATION IN THE PATTERN STRUCTURE CONSISTS OF A
*      LINKED SET OF NODES AS INDICATED BY THESE DIAGRAMS.
*
*      AS BEFORE, THE + REPRESENTS AN ALTERNATIVE NODE AND
*      THE DOTTED LINE FROM A + NODE IS THE PARAMETER POINTER
*      TO THE ALTERNATIVE PATTERN.
*
*      ARB
*      ---
*
*           +---+            THIS NODE (P$ARB) MATCHES NULL
*           I B I-----       AND STACKS CURSOR, SUCCESSOR PTR,
*           +---+            CURSOR (COPY) AND A PTR TO NDARC.
*
*
*
*
*      BAL
*      ---
*
*           +---+            THE P$BAL NODE SCANS A BALANCED
*           I B I-----       STRING AND THEN STACKS A POINTER
*           +---+            TO ITSELF ON THE HISTORY STACK.
{{EJC{{{{{13230
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*
*      ARBNO
*      -----
*
*           +---+            THIS ALTERNATIVE NODE MATCHES NULL
*      +----I + I-----       THE FIRST TIME AND STACKS A POINTER
*      I    +---+            TO THE ARGUMENT PATTERN X.
*      I      .
*      I      .
*      I    +---+            NODE (P$ABA) TO STACK CURSOR
*      I    I A I            AND HISTORY STACK BASE PTR.
*      I    +---+
*      I      I
*      I      I
*      I    +---+            THIS IS THE ARGUMENT PATTERN. AS
*      I    I X I            INDICATED, THE SUCCESSOR OF THE
*      I    +---+            PATTERN IS THE P$ABC NODE
*      I      I
*      I      I
*      I    +---+            THIS NODE (P$ABC) POPS PMHBS,
*      +----I C I            STACKS OLD PMHBS AND PTR TO NDABD
*           +---+            (UNLESS OPTIMISATION HAS OCCURRED)
*
*      STRUCTURE AND EXECUTION OF THIS PATTERN RESEMBLE THOSE OF
*      RECURSIVE PATTERN MATCHING AND IMMEDIATE ASSIGNMENT.
*      THE ALTERNATIVE NODE AT THE HEAD OF THE STRUCTURE MATCHES
*      NULL INITIALLY BUT ON SUBSEQUENT FAILURE ENSURES ATTEMPT
*      TO MATCH THE ARGUMENT.  BEFORE THE ARGUMENT IS MATCHED
*      P$ABA STACKS THE CURSOR, PMHBS AND A PTR TO P$ABB.  IF
*      THE ARGUMENT CANT BE MATCHED , P$ABB REMOVES THIS SPECIAL
*      STACK ENTRY AND FAILS.
*      IF ARGUMENT IS MATCHED , P$ABC RESTORES THE OUTER PMHBS
*      VALUE (SAVED BY P$ABA) .  THEN IF THE ARGUMENT HAS LEFT
*      ALTERNATIVES ON STACK IT STACKS THE INNER VALUE OF PMHBS
*      AND A PTR TO NDABD. IF ARGUMENT LEFT NOTHING ON THE STACK
*      IT OPTIMISES BY REMOVING ITEMS STACKED BY P$ABA.  FINALLY
*      A CHECK IS MADE THAT ARGUMENT MATCHED MORE THAN THE NULL
*      STRING (CHECK IS INTENDED TO PREVENT USELESS LOOPING).
*      IF SO THE SUCCESSOR IS AGAIN THE ALTERNATIVE NODE AT THE
*      HEAD OF THE STRUCTURE , ENSURING A POSSIBLE EXTRA ATTEMPT
*      TO MATCH THE ARG IF NECESSARY.  IF NOT , THE SUCCESSOR TO
*      ALTERNATIVE IS TAKEN SO AS TO TERMINATE THE LOOP.  P$ABD
*      RESTORES INNER PMHBS PTR AND FAILS , THUS TRYING TO MATCH
*      ALTERNATIVES LEFT BY THE ARBNO ARGUMENT.
{{EJC{{{{{13278
*
*      COMPOUND PATTERN STRUCTURES (CONTINUED)
*
*      BREAKX
*      ------
*
*           +---+            THIS NODE IS A BREAK NODE FOR
*      +----I B I            THE ARGUMENT TO BREAKX, IDENTICAL
*      I    +---+            TO AN ORDINARY BREAK NODE.
*      I      I
*      I      I
*      I    +---+            THIS ALTERNATIVE NODE STACKS A
*      I    I + I-----       POINTER TO THE BREAKX NODE TO
*      I    +---+            ALLOW FOR SUBSEQUENT FAILURE
*      I      .
*      I      .
*      I    +---+            THIS IS THE BREAKX NODE ITSELF. IT
*      +----I X I            MATCHES ONE CHARACTER AND THEN
*           +---+            PROCEEDS BACK TO THE BREAK NODE.
*
*
*
*
*      FENCE
*      -----
*
*           +---+            THE FENCE NODE MATCHES NULL AND
*           I F I-----       STACKS A POINTER TO NODE NDABO TO
*           +---+            ABORT ON A SUBSEQUENT REMATCH
*
*
*
*
*      SUCCEED
*      -------
*
*           +---+            THE NODE FOR SUCCEED MATCHES NULL
*           I S I-----       AND STACKS A POINTER TO ITSELF
*           +---+            TO REPEAT THE MATCH ON A FAILURE.
{{EJC{{{{{13318
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOT (PATTERN ASSIGNMENT)
*      -------------------------------
*
*           +---+            THIS NODE (P$PAA) SAVES THE CURRENT
*           I A I            CURSOR AND A POINTER TO THE
*           +---+            SPECIAL NODE NDPAB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            PATTERN ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P$PAC) SAVES THE CURSOR,
*           I C I-----       A PTR TO ITSELF, THE CURSOR (COPY)
*           +---+            AND A PTR TO NDPAD ON THE STACK.
*
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAB (P$PAB)
*      IS SIMPLY TO UNSTACK ITSELF AND FAIL BACK ONTO THE STACK.
*
*      THE MATCH ROUTINE FOR P$PAC ALSO SETS THE GLOBAL PATTERN
*      FLAG PMDFL NON-ZERO TO INDICATE THAT PATTERN ASSIGNMENTS
*      MAY HAVE OCCURED IN THE PATTERN MATCH
*
*      IF PMDFL IS SET AT THE END OF THE MATCH (SEE P$NTH), THE
*      HISTORY STACK IS SCANNED FOR MATCHING NDPAB-NDPAD PAIRS
*      AND THE CORRESPONDING PATTERN ASSIGNMENTS ARE EXECUTED.
*
*      THE FUNCTION OF THE MATCH ROUTINE FOR NDPAD (P$PAD)
*      IS SIMPLY TO REMOVE ITS ENTRY FROM THE STACK AND FAIL.
*      THIS INCLUDES REMOVING THE SPECIAL NODE POINTER STORED
*      IN ADDITION TO THE STANDARD TWO ENTRIES ON THE STACK.
{{EJC{{{{{13355
*
*      COMPOUNT PATTERN STRUCTURES (CONTINUED)
*
*      FENCE (FUNCTION)
*      ----------------
*
*           +---+            THIS NODE (P$FNA) SAVES THE
*           I A I            CURRENT HISTORY STACK AND A
*           +---+            POINTER TO NDFNB ON THE STACK.
*             I
*             I
*           +---+            THIS IS THE PATTERN STRUCTURE
*           I X I            GIVEN AS THE ARGUMENT TO THE
*           +---+            FENCE FUNCTION.
*             I
*             I
*           +---+            THIS NODE P$FNC RESTORES THE OUTER
*           I C I            HISTORY STACK PTR SAVED IN P$FNA,
*           +---+            AND STACKS THE INNER STACK BASE
*                            PTR AND A POINTER TO NDFND ON THE
*                            STACK.
*
*      NDFNB (F$FNB) SIMPLY IS THE FAILURE EXIT FOR PATTERN
*      ARGUMENT FAILURE, AND IT POPS ITSELF AND FAILS ONTO THE
*      STACK.
*
*      THE MATCH ROUTINE P$FNC ALLOWS FOR AN OPTIMIZATION WHEN
*      THE FENCE PATTERN LEAVES NO ALTERNATIVES.  IN THIS CASE,
*      THE NDFNB ENTRY IS POPPED, AND THE MATCH CONTINUES.
*
*      NDFND (P$FND) IS ENTERED WHEN THE PATTERN FAILS AFTER
*      GOING THROUGH A NON-OPTIMIZED P$FNC, AND IT POPS THE
*      STACK BACK PAST THE INNTER STACK BASE CREATED BY P$FNA
{{EJC{{{{{13389
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      EXPRESSION PATTERNS (RECURSIVE PATTERN MATCHES)
*      -----------------------------------------------
*
*      INITIAL ENTRY FOR A PATTERN NODE IS TO THE ROUTINE P$EXA.
*      IF THE EVALUATED RESULT OF THE EXPRESSION IS ITSELF A
*      PATTERN, THEN THE FOLLOWING STEPS ARE TAKEN TO ARRANGE
*      FOR PROPER RECURSIVE PROCESSING.
*
*      1)   A POINTER TO THE CURRENT NODE (THE P$EXA NODE) IS
*           STORED ON THE HISTORY STACK WITH A DUMMY CURSOR.
*
*      2)   A SPECIAL HISTORY STACK ENTRY IS MADE IN WHICH THE
*           NODE POINTER POINTS TO NDEXB, AND THE CURSOR VALUE
*           IS THE SAVED VALUE OF PMHBS ON ENTRY TO THIS NODE.
*           THE MATCH ROUTINE FOR NDEXB (P$EXB) RESTORES PMHBS
*           FROM THIS CURSOR ENTRY, POPS OFF THE P$EXA NODE
*           POINTER AND FAILS.
*
*      3)   THE RESULTING HISTORY STACK POINTER IS SAVED IN
*           PMHBS TO ESTABLISH A NEW LEVEL OF HISTORY STACK.
*
*      AFTER MATCHING A PATTERN, THE END OF MATCH ROUTINE GETS
*      CONTROL (P$NTH). THIS ROUTINE PROCEEDS AS FOLLOWS.
*
*      1)   LOAD THE CURRENT VALUE OF PMHBS AND RECOGNIZE THE
*           OUTER LEVEL CASE BY THE FACT THAT THE ASSOCIATED
*           CURSOR IN THIS CASE IS THE PATTERN MATCH TYPE CODE
*           WHICH IS LESS THAN 3. TERMINATE THE MATCH IN THIS
*           CASE AND CONTINUE EXECUTION OF THE PROGRAM.
*
*      2)   OTHERWISE MAKE A SPECIAL HISTORY STACK ENTRY IN
*           WHICH THE NODE POINTER POINTS TO THE SPECIAL NODE
*           NDEXC AND THE CURSOR IS THE CURRENT VALUE OF PMHBS.
*           THE MATCH ROUTINE FOR NDEXC (P$EXC) RESETS PMHBS TO
*           THIS (INNER) VALUE AND AND THEN FAILS.
*
*      3)   USING THE HISTORY STACK ENTRY MADE ON STARTING THE
*           EXPRESSION (ACCESSIBLE WITH THE CURRENT VALUE OF
*           PMHBS), RESTORE THE P$EXA NODE POINTER AND THE OLD
*           PMHBS SETTING. TAKE THE SUCCESSOR AND CONTINUE.
*
*      AN OPTIMIZATION IS POSSIBLE IF THE EXPRESSION PATTERN
*      MAKES NO ENTRIES ON THE HISTORY STACK. IN THIS CASE,
*      INSTEAD OF BUILDING THE P$EXC NODE IN STEP 2, IT IS MORE
*      EFFICIENT TO SIMPLY POP OFF THE P$EXB ENTRY AND ITS
*      ASSOCIATED NODE POINTER. THE EFFECT IS THE SAME.
{{EJC{{{{{13439
*
*      COMPOUND PATTERNS (CONTINUED)
*
*      BINARY DOLLAR (IMMEDIATE ASSIGNMENT)
*      ------------------------------------
*
*           +---+            THIS NODE (P$IMA) STACKS THE CURSOR
*           I A I            PMHBS AND A PTR TO NDIMB AND RESETS
*           +---+            THE STACK PTR PMHBS.
*             I
*             I
*           +---+            THIS IS THE LEFT STRUCTURE FOR THE
*           I X I            PATTERN LEFT ARGUMENT OF THE
*           +---+            IMMEDIATE ASSIGNMENT CALL.
*             I
*             I
*           +---+            THIS NODE (P$IMC) PERFORMS THE
*           I C I-----       ASSIGNMENT, POPS PMHBS AND STACKS
*           +---+            THE OLD PMHBS AND A PTR TO NDIMD.
*
*
*      THE STRUCTURE AND EXECUTION OF THIS PATTERN ARE SIMILAR
*      TO THOSE OF THE RECURSIVE EXPRESSION PATTERN MATCHING.
*
*      THE MATCH ROUTINE FOR NDIMB (P$IMB) RESTORES THE OUTER
*      LEVEL VALUE OF PMHBS, UNSTACKS THE SAVED CURSOR AND FAILS
*
*      THE MATCH ROUTINE P$IMC USES THE CURRENT VALUE OF PMHBS
*      TO LOCATE THE P$IMB ENTRY. THIS ENTRY IS USED TO MAKE
*      THE ASSIGNMENT AND RESTORE THE OUTER LEVEL VALUE OF
*      PMHBS. FINALLY, THE INNER LEVEL VALUE OF PMHBS AND A
*      POINTER TO THE SPECIAL NODE NDIMD ARE STACKED.
*
*      THE MATCH ROUTINE FOR NDIMD (P$IMD) RESTORES THE INNER
*      LEVEL VALUE OF PMHBS AND FAILS BACK INTO THE STACK.
*
*      AN OPTIMIZATION OCCURS IF THE INNER PATTERN MAKES NO
*      ENTRIES ON THE HISTORY STACK. IN THIS CASE, P$IMC POPS
*      THE P$IMB ENTRY INSTEAD OF MAKING A P$IMD ENTRY.
{{EJC{{{{{13479
*
*      ARBNO
*
*      SEE COMPOUND PATTERNS SECTION FOR STUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$ABA{ENT{2,BL$P0{{{P0BLK{13488
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13489
{{MOV{7,XR{11,-(XS){{STACK DUMMY NODE PTR{13490
{{MOV{3,PMHBS{11,-(XS){{STACK OLD STACK BASE PTR{13491
{{MOV{21,=NDABB{11,-(XS){{STACK PTR TO NODE NDABB{13492
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE PTR{13493
{{BRN{6,SUCCP{{{SUCCEED{13494
{{EJC{{{{{13495
*
*      ARBNO (REMOVE P$ABA SPECIAL STACK ENTRY)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABB{ENT{{{{ENTRY POINT{13501
{{MOV{8,WB{3,PMHBS{{RESTORE HISTORY STACK BASE PTR{13502
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{13503
{{EJC{{{{{13504
*
*      ARBNO (CHECK IF ARG MATCHED NULL STRING)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABC{ENT{2,BL$P0{{{P0BLK{13510
{{MOV{3,PMHBS{7,XT{{KEEP P$ABB STACK BASE{13511
{{MOV{12,3(XT){8,WA{{LOAD INITIAL CURSOR{13512
{{MOV{12,1(XT){3,PMHBS{{RESTORE OUTER STACK BASE PTR{13513
{{BEQ{7,XT{7,XS{6,PABC1{JUMP IF NO HISTORY STACK ENTRIES{13514
{{MOV{7,XT{11,-(XS){{ELSE SAVE INNER PMHBS ENTRY{13515
{{MOV{21,=NDABD{11,-(XS){{STACK PTR TO SPECIAL NODE NDABD{13516
{{BRN{6,PABC2{{{MERGE{13517
*
*      OPTIMISE CASE OF NO EXTRA ENTRIES ON STACK FROM ARBNO ARG
*
{PABC1{ADD{19,*NUM04{7,XS{{REMOVE NDABB ENTRY AND CURSOR{13521
*
*      MERGE TO CHECK FOR MATCHING OF NULL STRING
*
{PABC2{BNE{8,WA{8,WB{6,SUCCP{ALLOW FURTHER ATTEMPT IF NON-NULL{13525
{{MOV{13,PTHEN(XR){7,XR{{BYPASS ALTERNATIVE NODE SO AS TO ...{13526
{{BRN{6,SUCCP{{{... REFUSE FURTHER MATCH ATTEMPTS{13527
{{EJC{{{{{13528
*
*      ARBNO (TRY FOR ALTERNATIVES IN ARBNO ARGUMENT)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ABD{ENT{{{{ENTRY POINT{13534
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE PTR{13535
{{BRN{6,FAILP{{{AND FAIL{13536
{{EJC{{{{{13537
*
*      ABORT
*
*      NO PARAMETERS
*
{P$ABO{ENT{2,BL$P0{{{P0BLK{13543
{{BRN{6,EXFAL{{{SIGNAL STATEMENT FAILURE{13544
{{EJC{{{{{13545
*
*      ALTERNATION
*
*      PARM1                 ALTERNATIVE NODE
*
{P$ALT{ENT{2,BL$P1{{{P1BLK{13551
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13552
{{MOV{13,PARM1(XR){11,-(XS){{STACK POINTER TO ALTERNATIVE{13553
{{CHK{{{{CHECK FOR STACK OVERFLOW{13554
{{BRN{6,SUCCP{{{IF ALL OK, THEN SUCCEED{13555
{{EJC{{{{{13556
*
*      ANY (ONE CHARACTER ARGUMENT) (1-CHAR STRING ALSO)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$ANS{ENT{2,BL$P1{{{P1BLK{13562
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{13563
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13564
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13565
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{13566
{{BNE{8,WA{13,PARM1(XR){6,FAILP{FAIL IF NO MATCH{13567
{{ICV{8,WB{{{ELSE BUMP CURSOR{13568
{{BRN{6,SUCCP{{{AND SUCCEED{13569
{{EJC{{{{{13570
*
*      ANY (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT IN CTBLK
*
{P$ANY{ENT{2,BL$P2{{{P2BLK{13577
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PANY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{13581
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13582
{{PLC{7,XL{8,WB{{GET CHAR PTR TO CURRENT CHARACTER{13583
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{13584
{{MOV{13,PARM1(XR){7,XL{{POINT TO CTBLK{13585
{{WTB{8,WA{{{CHANGE TO BYTE OFFSET{13586
{{ADD{8,WA{7,XL{{POINT TO ENTRY IN CTBLK{13587
{{MOV{13,CTCHS(XL){8,WA{{LOAD WORD FROM CTBLK{13588
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{13589
{{ZRB{8,WA{6,FAILP{{FAIL IF NO MATCH{13590
{{ICV{8,WB{{{ELSE BUMP CURSOR{13591
{{BRN{6,SUCCP{{{AND SUCCEED{13592
{{EJC{{{{{13593
*
*      ANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$AYD{ENT{2,BL$P1{{{P1BLK{13599
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{13600
{{ERR{1,043{26,ANY evaluated argument is not a string{{{13601
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILURE{13602
{{PPM{6,PANY1{{{MERGE MULTI-CHAR CASE IF OK{13603
{{EJC{{{{{13604
*
*      P$ARB                 INITIAL ARB MATCH
*
*      NO PARAMETERS
*
*      THE P$ARB NODE IS PART OF A COMPOUND PATTERN STRUCTURE
*      FOR AN ARB PATTERN (SEE DESCRIPTION OF COMPOUND PATTERNS)
*
{P$ARB{ENT{2,BL$P0{{{P0BLK{13613
{{MOV{13,PTHEN(XR){7,XR{{LOAD SUCCESSOR POINTER{13614
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13615
{{MOV{7,XR{11,-(XS){{STACK SUCCESSOR POINTER{13616
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13617
{{MOV{21,=NDARC{11,-(XS){{STACK PTR TO SPECIAL NODE NDARC{13618
{{BRI{9,(XR){{{EXECUTE NEXT NODE MATCHING NULL{13619
{{EJC{{{{{13620
*
*      P$ARC                 EXTEND ARB MATCH
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$ARC{ENT{{{{ENTRY POINT{13626
{{BEQ{8,WB{3,PMSSL{6,FLPOP{FAIL AND POP STACK TO SUCCESSOR{13627
{{ICV{8,WB{{{ELSE BUMP CURSOR{13628
{{MOV{8,WB{11,-(XS){{STACK UPDATED CURSOR{13629
{{MOV{7,XR{11,-(XS){{RESTACK POINTER TO NDARC NODE{13630
{{MOV{12,2(XS){7,XR{{LOAD SUCCESSOR POINTER{13631
{{BRI{9,(XR){{{OFF TO REEXECUTE SUCCESSOR NODE{13632
{{EJC{{{{{13633
*
*      BAL
*
*      NO PARAMETERS
*
*      THE P$BAL NODE IS PART OF THE COMPOUND STRUCTURE BUILT
*      FOR BAL (SEE SECTION ON COMPOUND PATTERNS).
*
{P$BAL{ENT{2,BL$P0{{{P0BLK{13642
{{ZER{8,WC{{{ZERO PARENTHESES LEVEL COUNTER{13643
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13644
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13645
{{BRN{6,PBAL2{{{JUMP INTO SCAN LOOP{13646
*
*      LOOP TO SCAN OUT CHARACTERS
*
{PBAL1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{13650
{{ICV{8,WB{{{PUSH CURSOR FOR CHARACTER{13651
{{BEQ{8,WA{18,=CH$PP{6,PBAL3{JUMP IF LEFT PAREN{13652
{{BEQ{8,WA{18,=CH$RP{6,PBAL4{JUMP IF RIGHT PAREN{13653
{{BZE{8,WC{6,PBAL5{{ELSE SUCCEED IF AT OUTER LEVEL{13654
*
*      HERE AFTER PROCESSING ONE CHARACTER
*
{PBAL2{BNE{8,WB{3,PMSSL{6,PBAL1{LOOP BACK UNLESS END OF STRING{13658
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{13659
*
*      HERE ON LEFT PAREN
*
{PBAL3{ICV{8,WC{{{BUMP PAREN LEVEL{13663
{{BRN{6,PBAL2{{{LOOP BACK TO CHECK END OF STRING{13664
*
*      HERE FOR RIGHT PAREN
*
{PBAL4{BZE{8,WC{6,FAILP{{FAIL IF NO MATCHING LEFT PAREN{13668
{{DCV{8,WC{{{ELSE DECREMENT LEVEL COUNTER{13669
{{BNZ{8,WC{6,PBAL2{{LOOP BACK IF NOT AT OUTER LEVEL{13670
*
*      HERE AFTER SUCCESSFULLY SCANNING A BALANCED STRING
*
{PBAL5{MOV{8,WB{11,-(XS){{STACK CURSOR{13674
{{MOV{7,XR{11,-(XS){{STACK PTR TO BAL NODE FOR EXTEND{13675
{{BRN{6,SUCCP{{{AND SUCCEED{13676
{{EJC{{{{{13677
*
*      BREAK (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$BKD{ENT{2,BL$P1{{{P1BLK{13683
{{JSR{6,EVALS{{{EVALUATE STRING EXPRESSION{13684
{{ERR{1,044{26,BREAK evaluated argument is not a string{{{13685
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13686
{{PPM{6,PBRK1{{{MERGE WITH MULTI-CHAR CASE IF OK{13687
{{EJC{{{{{13688
*
*      BREAK (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$BKS{ENT{2,BL$P1{{{P1BLK{13694
{{MOV{3,PMSSL{8,WC{{GET SUBJECT STRING LENGTH{13695
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS LEFT{13696
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{13697
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{13698
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13699
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13700
*
*      LOOP TO SCAN TILL BREAK CHARACTER FOUND
*
{PBKS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{13704
{{BEQ{8,WA{13,PARM1(XR){6,SUCCP{SUCCEED IF BREAK CHARACTER FOUND{13705
{{ICV{8,WB{{{ELSE PUSH CURSOR{13706
{{BCT{8,WC{6,PBKS1{{LOOP BACK IF MORE TO GO{13707
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{13708
{{EJC{{{{{13709
*
*      BREAK (MULTI-CHARACTER ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$BRK{ENT{2,BL$P2{{{P2BLK{13716
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PBRK1{MOV{3,PMSSL{8,WC{{LOAD SUBJECT STRING LENGTH{13720
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS LEFT{13721
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{13722
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{13723
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{13724
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{13725
{{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{13726
*
*      LOOP TO SEARCH FOR BREAK CHARACTER
*
{PBRK2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHAR, BUMP POINTER{13730
{{MOV{13,PARM1(XR){7,XR{{LOAD POINTER TO CTBLK{13731
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{13732
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{13733
{{MOV{13,CTCHS(XR){8,WA{{LOAD CTBLK WORD{13734
{{MOV{3,PSAVE{7,XR{{RESTORE NODE POINTER{13735
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{13736
{{NZB{8,WA{6,SUCCP{{SUCCEED IF BREAK CHARACTER FOUND{13737
{{ICV{8,WB{{{ELSE PUSH CURSOR{13738
{{BCT{8,WC{6,PBRK2{{LOOP BACK UNLESS END OF STRING{13739
{{BRN{6,FAILP{{{FAIL IF END OF STRING, NO BREAK CHR{13740
{{EJC{{{{{13741
*
*      BREAKX (EXTENSION)
*
*      THIS IS THE ENTRY WHICH CAUSES AN EXTENSION OF A BREAKX
*      MATCH WHEN FAILURE OCCURS. SEE SECTION ON COMPOUND
*      PATTERNS FOR FULL DETAILS OF BREAKX MATCHING.
*
*      NO PARAMETERS
*
{P$BKX{ENT{2,BL$P0{{{P0BLK{13751
{{ICV{8,WB{{{STEP CURSOR PAST PREVIOUS BREAK CHR{13752
{{BRN{6,SUCCP{{{SUCCEED TO REMATCH BREAK{13753
{{EJC{{{{{13754
*
*      BREAKX (EXPRESSION ARGUMENT)
*
*      SEE SECTION ON COMPOUND PATTERNS FOR FULL STRUCTURE OF
*      BREAKX PATTERN. THE ACTUAL CHARACTER MATCHING USES A
*      BREAK NODE. HOWEVER, THE ENTRY FOR THE EXPRESSION
*      ARGUMENT CASE IS SEPARATED TO GET PROPER ERROR MESSAGES.
*
*      PARM1                 EXPRESSION POINTER
*
{P$BXD{ENT{2,BL$P1{{{P1BLK{13765
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{13766
{{ERR{1,045{26,BREAKX evaluated argument is not a string{{{13767
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13768
{{PPM{6,PBRK1{{{MERGE WITH BREAK IF ALL OK{13769
{{EJC{{{{{13770
*
*      CURSOR ASSIGNMENT
*
*      PARM1                 NAME BASE
*      PARM2                 NAME OFFSET
*
{P$CAS{ENT{2,BL$P2{{{P2BLK{13777
{{MOV{7,XR{11,-(XS){{SAVE NODE POINTER{13778
{{MOV{8,WB{11,-(XS){{SAVE CURSOR{13779
{{MOV{13,PARM1(XR){7,XL{{LOAD NAME BASE{13780
{{MTI{8,WB{{{LOAD CURSOR AS INTEGER{13781
{{MOV{13,PARM2(XR){8,WB{{LOAD NAME OFFSET{13782
{{JSR{6,ICBLD{{{GET ICBLK FOR CURSOR VALUE{13783
{{MOV{8,WB{8,WA{{MOVE NAME OFFSET{13784
{{MOV{7,XR{8,WB{{MOVE VALUE TO ASSIGN{13785
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{13786
{{PPM{6,FLPOP{{{FAIL ON ASSIGNMENT FAILURE{13787
{{MOV{10,(XS)+{8,WB{{ELSE RESTORE CURSOR{13788
{{MOV{10,(XS)+{7,XR{{RESTORE NODE POINTER{13789
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{13790
{{EJC{{{{{13791
*
*      EXPRESSION NODE (P$EXA, INITIAL ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      PARM1                 EXPRESSION POINTER
*
{P$EXA{ENT{2,BL$P1{{{P1BLK{13800
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{13801
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{13802
{{BLO{8,WA{22,=P$AAA{6,PEXA1{JUMP IF RESULT IS NOT A PATTERN{13803
*
*      HERE IF RESULT OF EXPRESSION IS A PATTERN
*
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13807
{{MOV{7,XR{11,-(XS){{STACK PTR TO P$EXA NODE{13808
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE PTR{13809
{{MOV{21,=NDEXB{11,-(XS){{STACK PTR TO SPECIAL NODE NDEXB{13810
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE POINTER{13811
{{MOV{7,XL{7,XR{{COPY NODE POINTER{13812
{{BRI{9,(XR){{{MATCH FIRST NODE IN EXPRESSION PAT{13813
*
*      HERE IF RESULT OF EXPRESSION IS NOT A PATTERN
*
{PEXA1{BEQ{8,WA{22,=B$SCL{6,PEXA2{JUMP IF IT IS ALREADY A STRING{13817
{{MOV{7,XL{11,-(XS){{ELSE STACK RESULT{13818
{{MOV{7,XR{7,XL{{SAVE NODE POINTER{13819
{{JSR{6,GTSTG{{{CONVERT RESULT TO STRING{13820
{{ERR{1,046{26,Expression does not evaluate to pattern{{{13821
{{MOV{7,XR{8,WC{{COPY STRING POINTER{13822
{{MOV{7,XL{7,XR{{RESTORE NODE POINTER{13823
{{MOV{8,WC{7,XL{{COPY STRING POINTER AGAIN{13824
*
*      MERGE HERE WITH STRING POINTER IN XL
*
{PEXA2{BZE{13,SCLEN(XL){6,SUCCP{{JUST SUCCEED IF NULL STRING{13828
{{BRN{6,PSTR1{{{ELSE MERGE WITH STRING CIRCUIT{13829
{{EJC{{{{{13830
*
*      EXPRESSION NODE (P$EXB, REMOVE NDEXB ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$EXB{ENT{{{{ENTRY POINT{13839
{{MOV{8,WB{3,PMHBS{{RESTORE OUTER LEVEL STACK POINTER{13840
{{BRN{6,FLPOP{{{FAIL AND POP P$EXA NODE PTR{13841
{{EJC{{{{{13842
*
*      EXPRESSION NODE (P$EXC, REMOVE NDEXC ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR HANDLING EXPRESSION NODES.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$EXC{ENT{{{{ENTRY POINT{13851
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE POINTER{13852
{{BRN{6,FAILP{{{AND FAIL INTO EXPR PATTERN ALTERNVS{13853
{{EJC{{{{{13854
*
*      FAIL
*
*      NO PARAMETERS
*
{P$FAL{ENT{2,BL$P0{{{P0BLK{13860
{{BRN{6,FAILP{{{JUST SIGNAL FAILURE{13861
{{EJC{{{{{13862
*
*      FENCE
*
*      SEE COMPOUND PATTERNS SECTION FOR THE STRUCTURE AND
*      ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$FEN{ENT{2,BL$P0{{{P0BLK{13871
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR{13872
{{MOV{21,=NDABO{11,-(XS){{STACK PTR TO ABORT NODE{13873
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{13874
{{EJC{{{{{13875
*
*      FENCE (FUNCTION)
*
*      SEE COMPOUND PATTERNS COMMENTS AT START OF THIS SECTION
*      FOR DETAILS OF SCHEME
*
*      NO PARAMETERS
*
{P$FNA{ENT{2,BL$P0{{{P0BLK{13884
{{MOV{3,PMHBS{11,-(XS){{STACK CURRENT HISTORY STACK BASE{13885
{{MOV{21,=NDFNB{11,-(XS){{STACK INDIR PTR TO P$FNB (FAILURE){13886
{{MOV{7,XS{3,PMHBS{{BEGIN NEW HISTORY STACK{13887
{{BRN{6,SUCCP{{{SUCCEED{13888
{{EJC{{{{{13889
*
*      FENCE (FUNCTION) (RESET HISTORY STACK AND FAIL)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FNB{ENT{2,BL$P0{{{P0BLK{13895
{{MOV{8,WB{3,PMHBS{{RESTORE OUTER PMHBS STACK BASE{13896
{{BRN{6,FAILP{{{...AND FAIL{13897
{{EJC{{{{{13898
*
*      FENCE (FUNCTION) (MAKE FENCE TRAP ENTRY ON STACK)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FNC{ENT{2,BL$P0{{{P0BLK{13904
{{MOV{3,PMHBS{7,XT{{GET INNER STACK BASE PTR{13905
{{MOV{13,NUM01(XT){3,PMHBS{{RESTORE OUTER STACK BASE{13906
{{BEQ{7,XT{7,XS{6,PFNC1{OPTIMIZE IF NO ALTERNATIVES{13907
{{MOV{7,XT{11,-(XS){{ELSE STACK INNER STACK BASE{13908
{{MOV{21,=NDFND{11,-(XS){{STACK PTR TO NDFND{13909
{{BRN{6,SUCCP{{{SUCCEED{13910
*
*      HERE WHEN FENCE FUNCTION LEFT NOTHING ON THE STACK
*
{PFNC1{ADD{19,*NUM02{7,XS{{POP OFF P$FNB ENTRY{13914
{{BRN{6,SUCCP{{{SUCCEED{13915
{{EJC{{{{{13916
*
*      FENCE (FUNCTION) (SKIP PAST ALTERNATIVES ON FAILURE)
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$FND{ENT{2,BL$P0{{{P0BLK{13922
{{MOV{8,WB{7,XS{{POP STACK TO FENCE() HISTORY BASE{13923
{{BRN{6,FLPOP{{{POP BASE ENTRY AND FAIL{13924
{{EJC{{{{{13925
*
*      IMMEDIATE ASSIGNMENT (INITIAL ENTRY, SAVE CURRENT CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHM FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$IMA{ENT{2,BL$P0{{{P0BLK{13934
{{MOV{8,WB{11,-(XS){{STACK CURSOR{13935
{{MOV{7,XR{11,-(XS){{STACK DUMMY NODE POINTER{13936
{{MOV{3,PMHBS{11,-(XS){{STACK OLD STACK BASE POINTER{13937
{{MOV{21,=NDIMB{11,-(XS){{STACK PTR TO SPECIAL NODE NDIMB{13938
{{MOV{7,XS{3,PMHBS{{STORE NEW STACK BASE POINTER{13939
{{BRN{6,SUCCP{{{AND SUCCEED{13940
{{EJC{{{{{13941
*
*      IMMEDIATE ASSIGNMENT (REMOVE CURSOR MARK ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$IMB{ENT{{{{ENTRY POINT{13950
{{MOV{8,WB{3,PMHBS{{RESTORE HISTORY STACK BASE PTR{13951
{{BRN{6,FLPOP{{{FAIL AND POP DUMMY NODE PTR{13952
{{EJC{{{{{13953
*
*      IMMEDIATE ASSIGNMENT (PERFORM ACTUAL ASSIGNMENT)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P$IMC{ENT{2,BL$P2{{{P2BLK{13963
{{MOV{3,PMHBS{7,XT{{LOAD POINTER TO P$IMB ENTRY{13964
{{MOV{8,WB{8,WA{{COPY FINAL CURSOR{13965
{{MOV{12,3(XT){8,WB{{LOAD INITIAL CURSOR{13966
{{MOV{12,1(XT){3,PMHBS{{RESTORE OUTER STACK BASE POINTER{13967
{{BEQ{7,XT{7,XS{6,PIMC1{JUMP IF NO HISTORY STACK ENTRIES{13968
{{MOV{7,XT{11,-(XS){{ELSE SAVE INNER PMHBS POINTER{13969
{{MOV{21,=NDIMD{11,-(XS){{AND A PTR TO SPECIAL NODE NDIMD{13970
{{BRN{6,PIMC2{{{MERGE{13971
*
*      HERE IF NO ENTRIES MADE ON HISTORY STACK
*
{PIMC1{ADD{19,*NUM04{7,XS{{REMOVE NDIMB ENTRY AND CURSOR{13975
*
*      MERGE HERE TO PERFORM ASSIGNMENT
*
{PIMC2{MOV{8,WA{11,-(XS){{SAVE CURRENT (FINAL) CURSOR{13979
{{MOV{7,XR{11,-(XS){{SAVE CURRENT NODE POINTER{13980
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{13981
{{SUB{8,WB{8,WA{{COMPUTE SUBSTRING LENGTH{13982
{{JSR{6,SBSTR{{{BUILD SUBSTRING{13983
{{MOV{7,XR{8,WB{{MOVE RESULT{13984
{{MOV{9,(XS){7,XR{{RELOAD NODE POINTER{13985
{{MOV{13,PARM1(XR){7,XL{{LOAD NAME BASE{13986
{{MOV{13,PARM2(XR){8,WA{{LOAD NAME OFFSET{13987
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{13988
{{PPM{6,FLPOP{{{FAIL IF ASSIGNMENT FAILS{13989
{{MOV{10,(XS)+{7,XR{{ELSE RESTORE NODE POINTER{13990
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{13991
{{BRN{6,SUCCP{{{AND SUCCEED{13992
{{EJC{{{{{13993
*
*      IMMEDIATE ASSIGNMENT (REMOVE NDIMD ENTRY ON FAILURE)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$IMD{ENT{{{{ENTRY POINT{14002
{{MOV{8,WB{3,PMHBS{{RESTORE INNER STACK BASE POINTER{14003
{{BRN{6,FAILP{{{AND FAIL{14004
{{EJC{{{{{14005
*
*      LEN (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$LEN{ENT{2,BL$P1{{{P1BLK{14011
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PLEN1{ADD{13,PARM1(XR){8,WB{{PUSH CURSOR INDICATED AMOUNT{14015
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{14016
{{BRN{6,FAILP{{{ELSE FAIL{14017
{{EJC{{{{{14018
*
*      LEN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$LND{ENT{2,BL$P1{{{P1BLK{14024
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14025
{{ERR{1,047{26,LEN evaluated argument is not integer{{{14026
{{ERR{1,048{26,LEN evaluated argument is negative or too large{{{14027
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14028
{{PPM{6,PLEN1{{{MERGE WITH NORMAL CIRCUIT IF OK{14029
{{EJC{{{{{14030
*
*      NOTANY (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$NAD{ENT{2,BL$P1{{{P1BLK{14036
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{14037
{{ERR{1,049{26,NOTANY evaluated argument is not a string{{{14038
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14039
{{PPM{6,PNAY1{{{MERGE WITH MULTI-CHAR CASE IF OK{14040
{{EJC{{{{{14041
*
*      NOTANY (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$NAS{ENT{2,BL$P1{{{ENTRY POINT{14047
{{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARS LEFT{14048
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14049
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER IN STRIN{14050
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{14051
{{BEQ{8,WA{13,PARM1(XR){6,FAILP{FAIL IF MATCH{14052
{{ICV{8,WB{{{ELSE BUMP CURSOR{14053
{{BRN{6,SUCCP{{{AND SUCCEED{14054
{{EJC{{{{{14055
*
*      NOTANY (MULTI-CHARACTER STRING ARGUMENT)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$NAY{ENT{2,BL$P2{{{P2BLK{14062
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PNAY1{BEQ{8,WB{3,PMSSL{6,FAILP{FAIL IF NO CHARACTERS LEFT{14066
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14067
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14068
{{LCH{8,WA{9,(XL){{LOAD CURRENT CHARACTER{14069
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{14070
{{MOV{13,PARM1(XR){7,XL{{LOAD POINTER TO CTBLK{14071
{{ADD{8,WA{7,XL{{POINT TO ENTRY IN CTBLK{14072
{{MOV{13,CTCHS(XL){8,WA{{LOAD ENTRY FROM CTBLK{14073
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{14074
{{NZB{8,WA{6,FAILP{{FAIL IF CHARACTER IS MATCHED{14075
{{ICV{8,WB{{{ELSE BUMP CURSOR{14076
{{BRN{6,SUCCP{{{AND SUCCEED{14077
{{EJC{{{{{14078
*
*      END OF PATTERN MATCH
*
*      THIS ROUTINE IS ENTERED ON SUCCESSFUL COMPLETION.
*      SEE DESCRIPTION OF EXPRESSION PATTERNS IN COMPOUND
*      PATTERN SECTION FOR HANDLING OF RECURSION IN MATCHING.
*
*      THIS PATTERN ALSO RESULTS FROM AN ATTEMPT TO CONVERT THE
*      NULL STRING TO A PATTERN VIA CONVERT()
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$NTH{ENT{2,BL$P0{{{P0BLK (DUMMY){14091
{{MOV{3,PMHBS{7,XT{{LOAD POINTER TO BASE OF STACK{14092
{{MOV{12,1(XT){8,WA{{LOAD SAVED PMHBS (OR PATTERN TYPE){14093
{{BLE{8,WA{18,=NUM02{6,PNTH2{JUMP IF OUTER LEVEL (PATTERN TYPE){14094
*
*      HERE WE ARE AT THE END OF MATCHING AN EXPRESSION PATTERN
*
{{MOV{8,WA{3,PMHBS{{RESTORE OUTER STACK BASE POINTER{14098
{{MOV{12,2(XT){7,XR{{RESTORE POINTER TO P$EXA NODE{14099
{{BEQ{7,XT{7,XS{6,PNTH1{JUMP IF NO HISTORY STACK ENTRIES{14100
{{MOV{7,XT{11,-(XS){{ELSE STACK INNER STACK BASE PTR{14101
{{MOV{21,=NDEXC{11,-(XS){{STACK PTR TO SPECIAL NODE NDEXC{14102
{{BRN{6,SUCCP{{{AND SUCCEED{14103
*
*      HERE IF NO HISTORY STACK ENTRIES DURING PATTERN
*
{PNTH1{ADD{19,*NUM04{7,XS{{REMOVE P$EXB ENTRY AND NODE PTR{14107
{{BRN{6,SUCCP{{{AND SUCCEED{14108
*
*      HERE IF END OF MATCH AT OUTER LEVEL
*
{PNTH2{MOV{8,WB{3,PMSSL{{SAVE FINAL CURSOR IN SAFE PLACE{14112
{{BZE{3,PMDFL{6,PNTH6{{JUMP IF NO PATTERN ASSIGNMENTS{14113
{{EJC{{{{{14114
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      NOW WE MUST PERFORM PATTERN ASSIGNMENTS. THIS IS DONE BY
*      SCANNING THE HISTORY STACK FOR MATCHING NDPAB-NDPAD PAIRS
*
{PNTH3{DCA{7,XT{{{POINT PAST CURSOR ENTRY{14121
{{MOV{11,-(XT){8,WA{{LOAD NODE POINTER{14122
{{BEQ{8,WA{21,=NDPAD{6,PNTH4{JUMP IF NDPAD ENTRY{14123
{{BNE{8,WA{21,=NDPAB{6,PNTH5{JUMP IF NOT NDPAB ENTRY{14124
*
*      HERE FOR NDPAB ENTRY, STACK INITIAL CURSOR
*      NOTE THAT THERE MUST BE MORE ENTRIES ON THE STACK.
*
{{MOV{12,1(XT){11,-(XS){{STACK INITIAL CURSOR{14129
{{CHK{{{{CHECK FOR STACK OVERFLOW{14130
{{BRN{6,PNTH3{{{LOOP BACK IF OK{14131
*
*      HERE FOR NDPAD ENTRY. THE STARTING CURSOR FROM THE
*      MATCHING NDPAD ENTRY IS NOW THE TOP STACK ENTRY.
*
{PNTH4{MOV{12,1(XT){8,WA{{LOAD FINAL CURSOR{14136
{{MOV{9,(XS){8,WB{{LOAD INITIAL CURSOR FROM STACK{14137
{{MOV{7,XT{9,(XS){{SAVE HISTORY STACK SCAN PTR{14138
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF STRING{14139
*
*      BUILD SUBSTRING AND PERFORM ASSIGNMENT
*
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14143
{{JSR{6,SBSTR{{{CONSTRUCT SUBSTRING{14144
{{MOV{7,XR{8,WB{{COPY SUBSTRING POINTER{14145
{{MOV{9,(XS){7,XT{{RELOAD HISTORY STACK SCAN PTR{14146
{{MOV{12,2(XT){7,XL{{LOAD POINTER TO P$PAC NODE WITH NAM{14147
{{MOV{13,PARM2(XL){8,WA{{LOAD NAME OFFSET{14148
{{MOV{13,PARM1(XL){7,XL{{LOAD NAME BASE{14149
{{JSR{6,ASINP{{{PERFORM ASSIGNMENT{14150
{{PPM{6,EXFAL{{{MATCH FAILS IF NAME EVAL FAILS{14151
{{MOV{10,(XS)+{7,XT{{ELSE RESTORE HISTORY STACK PTR{14152
{{EJC{{{{{14153
*
*      END OF PATTERN MATCH (CONTINUED)
*
*      HERE CHECK FOR END OF ENTRIES
*
{PNTH5{BNE{7,XT{7,XS{6,PNTH3{LOOP IF MORE ENTRIES TO SCAN{14159
*
*      HERE AFTER DEALING WITH PATTERN ASSIGNMENTS
*
{PNTH6{MOV{3,PMHBS{7,XS{{WIPE OUT HISTORY STACK{14163
{{MOV{10,(XS)+{8,WB{{LOAD INITIAL CURSOR{14164
{{MOV{10,(XS)+{8,WC{{LOAD MATCH TYPE CODE{14165
{{MOV{3,PMSSL{8,WA{{LOAD FINAL CURSOR VALUE{14166
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14167
{{ZER{3,R$PMS{{{CLEAR SUBJECT STRING PTR FOR GBCOL{14168
{{BZE{8,WC{6,PNTH7{{JUMP IF CALL BY NAME{14169
{{BEQ{8,WC{18,=NUM02{6,PNTH9{EXIT IF STATEMENT LEVEL CALL{14170
*
*      HERE WE HAVE A CALL BY VALUE, BUILD SUBSTRING
*
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF STRING{14174
{{JSR{6,SBSTR{{{BUILD SUBSTRING{14175
{{MOV{7,XR{11,-(XS){{STACK RESULT{14176
{{LCW{7,XR{{{GET NEXT CODE WORD{14177
{{BRI{9,(XR){{{EXECUTE IT{14178
*
*      HERE FOR CALL BY NAME, MAKE STACK ENTRIES FOR O$RPL
*
{PNTH7{MOV{8,WB{11,-(XS){{STACK INITIAL CURSOR{14182
{{MOV{8,WA{11,-(XS){{STACK FINAL CURSOR{14183
*
*      HERE WITH XL POINTING TO SCBLK OR BCBLK
*
{PNTH8{MOV{7,XL{11,-(XS){{STACK SUBJECT POINTER{14192
*
*      HERE TO OBEY NEXT CODE WORD
*
{PNTH9{LCW{7,XR{{{GET NEXT CODE WORD{14196
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14197
{{EJC{{{{{14198
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$POS{ENT{2,BL$P1{{{P1BLK{14204
*
*      OPTIMIZE POS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND POS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLE PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT.)
*
*      POS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14222
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14223
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14224
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14225
*
*      EXPRESSION ARGUMENT CIRCUIT MERGES HERE
*
{PPOS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{14229
{{MOV{13,PARM1(XR){8,WB{{GET DESIRED CURSOR POSITION{14230
{{BGT{8,WB{3,PMSSL{6,EXFAL{ABORT IF OFF END{14231
{{MOV{8,WB{12,2(XT){{FAKE NUMBER OF UNANCHORED MOVES{14232
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{14233
{{EJC{{{{{14234
*
*      POS (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$PSD{ENT{2,BL$P1{{{P1BLK{14240
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14241
{{ERR{1,050{26,POS evaluated argument is not integer{{{14242
{{ERR{1,051{26,POS evaluated argument is negative or too large{{{14243
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14244
{{PPM{6,PPOS1{{{PROCESS EXPRESSION CASE{14245
*
{PPOS1{BEQ{8,WB{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14247
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14248
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{14249
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14250
{{MOV{3,EVLIO{8,WA{{GET ORIGINAL NODE PTR{14251
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14252
{{BRN{6,PPOS2{{{MERGE WITH INTEGER ARGUMENT CODE{14253
{{EJC{{{{{14254
*
*      PATTERN ASSIGNMENT (INITIAL ENTRY, SAVE CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS
*
{P$PAA{ENT{2,BL$P0{{{P0BLK{14263
{{MOV{8,WB{11,-(XS){{STACK INITIAL CURSOR{14264
{{MOV{21,=NDPAB{11,-(XS){{STACK PTR TO NDPAB SPECIAL NODE{14265
{{BRN{6,SUCCP{{{AND SUCCEED MATCHING NULL{14266
{{EJC{{{{{14267
*
*      PATTERN ASSIGNMENT (REMOVE SAVED CURSOR)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY PATTERN)
*
{P$PAB{ENT{{{{ENTRY POINT{14276
{{BRN{6,FAILP{{{JUST FAIL (ENTRY IS ALREADY POPPED){14277
{{EJC{{{{{14278
*
*      PATTERN ASSIGNMENT (END OF MATCH, MAKE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      PARM1                 NAME BASE OF VARIABLE
*      PARM2                 NAME OFFSET OF VARIABLE
*
{P$PAC{ENT{2,BL$P2{{{P2BLK{14288
{{MOV{8,WB{11,-(XS){{STACK DUMMY CURSOR VALUE{14289
{{MOV{7,XR{11,-(XS){{STACK POINTER TO P$PAC NODE{14290
{{MOV{8,WB{11,-(XS){{STACK FINAL CURSOR{14291
{{MOV{21,=NDPAD{11,-(XS){{STACK PTR TO SPECIAL NDPAD NODE{14292
{{MNZ{3,PMDFL{{{SET DOT FLAG NON-ZERO{14293
{{BRN{6,SUCCP{{{AND SUCCEED{14294
{{EJC{{{{{14295
*
*      PATTERN ASSIGNMENT (REMOVE ASSIGN ENTRY)
*
*      SEE COMPOUND PATTERNS DESCRIPTION FOR THE STRUCTURE AND
*      ALGORITHMS FOR MATCHING THIS NODE TYPE.
*
*      NO PARAMETERS (DUMMY NODE)
*
{P$PAD{ENT{{{{ENTRY POINT{14304
{{BRN{6,FLPOP{{{FAIL AND REMOVE P$PAC NODE{14305
{{EJC{{{{{14306
*
*      REM
*
*      NO PARAMETERS
*
{P$REM{ENT{2,BL$P0{{{P0BLK{14312
{{MOV{3,PMSSL{8,WB{{POINT CURSOR TO END OF STRING{14313
{{BRN{6,SUCCP{{{AND SUCCEED{14314
{{EJC{{{{{14315
*
*      RPOS (EXPRESSION ARGUMENT)
*
*      OPTIMIZE RPOS IF IT IS THE FIRST PATTERN ELEMENT,
*      UNANCHORED MODE, CURSOR IS ZERO AND RPOS ARGUMENT
*      IS NOT BEYOND END OF STRING.  FORCE CURSOR POSITION
*      AND NUMBER OF UNANCHORED MOVES.
*
*      THIS OPTIMIZATION IS PERFORMED INVISIBLY PROVIDED
*      THE ARGUMENT IS EITHER A SIMPLE INTEGER OR AN
*      EXPRESSION THAT IS AN UNTRACED VARIABLE (THAT IS,
*      IT HAS NO SIDE EFFECTS THAT WOULD BE LOST BY SHORT-
*      CIRCUITING THE NORMAL LOGIC OF FAILING AND MOVING THE
*      UNANCHORED STARTING POINT).
*
*      PARM1                 EXPRESSION POINTER
*
{P$RPD{ENT{2,BL$P1{{{P1BLK{14333
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14334
{{ERR{1,052{26,RPOS evaluated argument is not integer{{{14335
{{ERR{1,053{26,RPOS evaluated argument is negative or too large{{{14336
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14337
{{PPM{6,PRPS1{{{MERGE WITH NORMAL CASE IF OK{14338
*
{PRPS1{MOV{3,PMSSL{8,WC{{GET LENGTH OF STRING{14340
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS REMAINING{14341
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14342
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14343
{{BNZ{3,EVLIF{6,FAILP{{FAIL IF COMPLEX ARGUMENT{14344
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14345
{{MOV{3,EVLIO{8,WA{{GET ORIGINAL NODE PTR{14346
{{BNE{8,WA{11,-(XT){6,FAILP{FAIL IF POS IS NOT FIRST NODE{14347
{{BRN{6,PRPS2{{{MERGE WITH INTEGER ARG CODE{14348
{{EJC{{{{{14349
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$RPS{ENT{2,BL$P1{{{P1BLK{14355
*
*      RPOS (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{{MOV{3,PMSSL{8,WC{{GET LENGTH OF STRING{14361
{{SUB{8,WB{8,WC{{GET NUMBER OF CHARACTERS REMAINING{14362
{{BEQ{8,WC{13,PARM1(XR){6,SUCCP{SUCCEED IF AT RIGHT LOCATION{14363
{{BNZ{8,WB{6,FAILP{{DON'T LOOK FURTHER IF CURSOR NOT 0{14364
{{MOV{3,PMHBS{7,XT{{GET HISTORY STACK BASE PTR{14365
{{BNE{7,XR{11,-(XT){6,FAILP{FAIL IF RPOS IS NOT FIRST NODE{14366
*
*      EXPRESSION ARGUMENT MERGES HERE
*
{PRPS2{BNE{11,-(XT){21,=NDUNA{6,FAILP{FAIL IF NOT UNANCHORED MODE{14370
{{MOV{3,PMSSL{8,WB{{POINT TO END OF STRING{14371
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{14372
{{SUB{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR{14373
{{MOV{8,WB{12,2(XT){{FAKE NUMBER OF UNANCHORED MOVES{14374
{{BRN{6,SUCCP{{{CONTINUE MATCH WITH ADJUSTED CURSOR{14375
{{EJC{{{{{14376
*
*      RTAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$RTB{ENT{2,BL$P1{{{P1BLK{14382
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PRTB1{MOV{8,WB{8,WC{{SAVE INITIAL CURSOR{14386
{{MOV{3,PMSSL{8,WB{{POINT TO END OF STRING{14387
{{BLT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF STRING NOT LONG ENOUGH{14388
{{SUB{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR{14389
{{BGE{8,WB{8,WC{6,SUCCP{AND SUCCEED IF NOT TOO FAR ALREADY{14390
{{BRN{6,FAILP{{{IN WHICH CASE, FAIL{14391
{{EJC{{{{{14392
*
*      RTAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$RTD{ENT{2,BL$P1{{{P1BLK{14398
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14399
{{ERR{1,054{26,RTAB evaluated argument is not integer{{{14400
{{ERR{1,055{26,RTAB evaluated argument is negative or too large{{{14401
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14402
{{PPM{6,PRTB1{{{MERGE WITH NORMAL CASE IF SUCCESS{14403
{{EJC{{{{{14404
*
*      SPAN (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$SPD{ENT{2,BL$P1{{{P1BLK{14410
{{JSR{6,EVALS{{{EVALUATE STRING ARGUMENT{14411
{{ERR{1,056{26,SPAN evaluated argument is not a string{{{14412
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14413
{{PPM{6,PSPN1{{{MERGE WITH MULTI-CHAR CASE IF OK{14414
{{EJC{{{{{14415
*
*      SPAN (MULTI-CHARACTER ARGUMENT CASE)
*
*      PARM1                 POINTER TO CTBLK
*      PARM2                 BIT MASK TO SELECT BIT COLUMN
*
{P$SPN{ENT{2,BL$P2{{{P2BLK{14422
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PSPN1{MOV{3,PMSSL{8,WC{{COPY SUBJECT STRING LENGTH{14426
{{SUB{8,WB{8,WC{{CALCULATE NUMBER OF CHARACTERS LEFT{14427
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{14428
{{MOV{3,R$PMS{7,XL{{POINT TO SUBJECT STRING{14429
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14430
{{MOV{8,WB{3,PSAVC{{SAVE INITIAL CURSOR{14431
{{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{14432
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARS LEFT{14433
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPN2{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{14437
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{14438
{{MOV{13,PARM1(XR){7,XR{{POINT TO CTBLK{14439
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{14440
{{MOV{13,CTCHS(XR){8,WA{{LOAD CTBLK ENTRY{14441
{{MOV{3,PSAVE{7,XR{{RESTORE NODE POINTER{14442
{{ANB{13,PARM2(XR){8,WA{{AND WITH SELECTED BIT{14443
{{ZRB{8,WA{6,PSPN3{{JUMP IF NO MATCH{14444
{{ICV{8,WB{{{ELSE PUSH CURSOR{14445
{{BCT{8,WC{6,PSPN2{{LOOP BACK UNLESS END OF STRING{14446
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPN3{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{14450
{{BRN{6,FAILP{{{ELSE FAIL IF NULL STRING MATCHED{14451
{{EJC{{{{{14452
*
*      SPAN (ONE CHARACTER ARGUMENT)
*
*      PARM1                 CHARACTER ARGUMENT
*
{P$SPS{ENT{2,BL$P1{{{P1BLK{14458
{{MOV{3,PMSSL{8,WC{{GET SUBJECT STRING LENGTH{14459
{{SUB{8,WB{8,WC{{CALCULATE NUMBER OF CHARACTERS LEFT{14460
{{BZE{8,WC{6,FAILP{{FAIL IF NO CHARACTERS LEFT{14461
{{MOV{3,R$PMS{7,XL{{ELSE POINT TO SUBJECT STRING{14462
{{PLC{7,XL{8,WB{{POINT TO CURRENT CHARACTER{14463
{{MOV{8,WB{3,PSAVC{{SAVE INITIAL CURSOR{14464
{{LCT{8,WC{8,WC{{SET COUNTER FOR CHARACTERS LEFT{14465
*
*      LOOP TO SCAN MATCHING CHARACTERS
*
{PSPS1{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER, BUMP POINTER{14469
{{BNE{8,WA{13,PARM1(XR){6,PSPS2{JUMP IF NO MATCH{14470
{{ICV{8,WB{{{ELSE PUSH CURSOR{14471
{{BCT{8,WC{6,PSPS1{{AND LOOP UNLESS END OF STRING{14472
*
*      HERE AFTER SCANNING MATCHING CHARACTERS
*
{PSPS2{BNE{8,WB{3,PSAVC{6,SUCCP{SUCCEED IF CHARS MATCHED{14476
{{BRN{6,FAILP{{{FAIL IF NULL STRING MATCHED{14477
{{EJC{{{{{14478
*
*      MULTI-CHARACTER STRING
*
*      NOTE THAT ONE CHARACTER STRINGS USE THE CIRCUIT FOR
*      ONE CHARACTER ANY ARGUMENTS (P$AN1).
*
*      PARM1                 POINTER TO SCBLK FOR STRING ARG
*
{P$STR{ENT{2,BL$P1{{{P1BLK{14487
{{MOV{13,PARM1(XR){7,XL{{GET POINTER TO STRING{14488
*
*      MERGE HERE AFTER EVALUATING EXPRESSION WITH STRING VALUE
*
{PSTR1{MOV{7,XR{3,PSAVE{{SAVE NODE POINTER{14492
{{MOV{3,R$PMS{7,XR{{LOAD SUBJECT STRING POINTER{14493
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{14494
{{ADD{13,SCLEN(XL){8,WB{{COMPUTE NEW CURSOR POSITION{14495
{{BGT{8,WB{3,PMSSL{6,FAILP{FAIL IF PAST END OF STRING{14496
{{MOV{8,WB{3,PSAVC{{SAVE UPDATED CURSOR{14497
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARS TO COMPARE{14498
{{PLC{7,XL{{{POINT TO CHARS OF TEST STRING{14499
{{CMC{6,FAILP{6,FAILP{{COMPARE, FAIL IF NOT EQUAL{14500
{{MOV{3,PSAVE{7,XR{{IF ALL MATCHED, RESTORE NODE PTR{14501
{{MOV{3,PSAVC{8,WB{{RESTORE UPDATED CURSOR{14502
{{BRN{6,SUCCP{{{AND SUCCEED{14503
{{EJC{{{{{14504
*
*      SUCCEED
*
*      SEE SECTION ON COMPOUND PATTERNS FOR DETAILS OF THE
*      STRUCTURE AND ALGORITHMS FOR MATCHING THIS NODE TYPE
*
*      NO PARAMETERS
*
{P$SUC{ENT{2,BL$P0{{{P0BLK{14513
{{MOV{8,WB{11,-(XS){{STACK CURSOR{14514
{{MOV{7,XR{11,-(XS){{STACK POINTER TO THIS NODE{14515
{{BRN{6,SUCCP{{{SUCCEED MATCHING NULL{14516
{{EJC{{{{{14517
*
*      TAB (INTEGER ARGUMENT)
*
*      PARM1                 INTEGER ARGUMENT
*
{P$TAB{ENT{2,BL$P1{{{P1BLK{14523
*
*      EXPRESSION ARGUMENT CASE MERGES HERE
*
{PTAB1{BGT{8,WB{13,PARM1(XR){6,FAILP{FAIL IF TOO FAR ALREADY{14527
{{MOV{13,PARM1(XR){8,WB{{ELSE SET NEW CURSOR POSITION{14528
{{BLE{8,WB{3,PMSSL{6,SUCCP{SUCCEED IF NOT OFF END{14529
{{BRN{6,FAILP{{{ELSE FAIL{14530
{{EJC{{{{{14531
*
*      TAB (EXPRESSION ARGUMENT)
*
*      PARM1                 EXPRESSION POINTER
*
{P$TBD{ENT{2,BL$P1{{{P1BLK{14537
{{JSR{6,EVALI{{{EVALUATE INTEGER ARGUMENT{14538
{{ERR{1,057{26,TAB evaluated argument is not integer{{{14539
{{ERR{1,058{26,TAB evaluated argument is negative or too large{{{14540
{{PPM{6,FAILP{{{FAIL IF EVALUATION FAILS{14541
{{PPM{6,PTAB1{{{MERGE WITH NORMAL CASE IF OK{14542
{{EJC{{{{{14543
*
*      ANCHOR MOVEMENT
*
*      NO PARAMETERS (DUMMY NODE)
*
{P$UNA{ENT{{{{ENTRY POINT{14549
{{MOV{8,WB{7,XR{{COPY INITIAL PATTERN NODE POINTER{14550
{{MOV{9,(XS){8,WB{{GET INITIAL CURSOR{14551
{{BEQ{8,WB{3,PMSSL{6,EXFAL{MATCH FAILS IF AT END OF STRING{14552
{{ICV{8,WB{{{ELSE INCREMENT CURSOR{14553
{{MOV{8,WB{9,(XS){{STORE INCREMENTED CURSOR{14554
{{MOV{7,XR{11,-(XS){{RESTACK INITIAL NODE PTR{14555
{{MOV{21,=NDUNA{11,-(XS){{RESTACK UNANCHORED NODE{14556
{{BRI{9,(XR){{{REMATCH FIRST NODE{14557
{{EJC{{{{{14558
*
*      END OF PATTERN MATCH ROUTINES
*
*      THE FOLLOWING ENTRY POINT MARKS THE END OF THE PATTERN
*      MATCHING ROUTINES AND ALSO THE END OF THE ENTRY POINTS
*      REFERENCED FROM THE FIRST WORD OF BLOCKS IN DYNAMIC STORE
*
{P$YYY{ENT{2,BL$$I{{{MARK LAST ENTRY IN PATTERN SECTION{14566
{{TTL{27,S P I T B O L -- SNOBOL4 BUILT-IN LABEL ROUTINES{{{{14567
*
*      THE FOLLOWING SECTION CONTAINS THE ROUTINES FOR LABELS
*      WHICH HAVE A PREDEFINED MEANING IN SNOBOL4.
*
*      CONTROL IS PASSED DIRECTLY TO THE LABEL NAME ENTRY POINT.
*
*      ENTRY NAMES ARE OF THE FORM L$XXX WHERE XXX IS THE THREE
*      LETTER VARIABLE NAME IDENTIFIER.
*
*      ENTRIES ARE IN ALPHABETICAL ORDER
{{EJC{{{{{14578
*
*      ABORT
*
{L$ABO{ENT{{{{ENTRY POINT{14582
*
*      MERGE HERE IF EXECUTION TERMINATES IN ERROR
*
{LABO1{MOV{3,KVERT{8,WA{{LOAD ERROR CODE{14586
{{BZE{8,WA{6,LABO3{{JUMP IF NO ERROR HAS OCCURED{14587
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{14589
{{MOV{3,KVSTN{8,WC{{CURRENT STATEMENT{14593
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{14594
{{MOV{3,R$COD{7,XR{{CURRENT CODE BLOCK{14597
{{MOV{13,CDSLN(XR){8,WC{{LINE NUMBER{14598
{{ZER{8,WB{{{COLUMN NUMBER{14602
{{MOV{3,STAGE{7,XR{{{14603
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{14604
{{PPM{6,STPR4{{{IF SYSTEM DOES NOT WANT PRINT{14605
{{JSR{6,PRTPG{{{ELSE EJECT PRINTER{14607
{{BZE{7,XR{6,LABO2{{DID SYSEA REQUEST PRINT{14609
{{JSR{6,PRTST{{{PRINT TEXT FROM SYSEA{14610
{LABO2{JSR{6,ERMSG{{{PRINT ERROR MESSAGE{14612
{{ZER{7,XR{{{INDICATE NO MESSAGE TO PRINT{14613
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{14614
*
*      HERE IF NO ERROR HAD OCCURED
*
{LABO3{ERB{1,036{26,Goto ABORT with no preceding error{{{14618
{{EJC{{{{{14619
*
*      CONTINUE
*
{L$CNT{ENT{{{{ENTRY POINT{14623
*
*      MERGE HERE AFTER EXECUTION ERROR
*
{LCNT1{MOV{3,R$CNT{7,XR{{LOAD CONTINUATION CODE BLOCK PTR{14627
{{BZE{7,XR{6,LCNT3{{JUMP IF NO PREVIOUS ERROR{14628
{{ZER{3,R$CNT{{{CLEAR FLAG{14629
{{MOV{7,XR{3,R$COD{{ELSE STORE AS NEW CODE BLOCK PTR{14630
{{BNE{9,(XR){22,=B$CDC{6,LCNT2{JUMP IF NOT COMPLEX GO{14631
{{MOV{3,STXOC{8,WA{{GET OFFSET OF ERROR{14632
{{BGE{8,WA{3,STXOF{6,LCNT4{JUMP IF ERROR IN GOTO EVALUATION{14633
*
*      HERE IF ERROR DID NOT OCCUR IN COMPLEX FAILURE GOTO
*
{LCNT2{ADD{3,STXOF{7,XR{{ADD FAILURE OFFSET{14637
{{LCP{7,XR{{{LOAD CODE POINTER{14638
{{MOV{3,FLPTR{7,XS{{RESET STACK POINTER{14639
{{LCW{7,XR{{{GET NEXT CODE WORD{14640
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14641
*
*      HERE IF NO PREVIOUS ERROR
*
{LCNT3{ICV{3,ERRFT{{{FATAL ERROR{14645
{{ERB{1,037{26,Goto CONTINUE with no preceding error{{{14646
*
*      HERE IF ERROR IN EVALUATION OF FAILURE GOTO.
*      CANNOT CONTINUE BACK TO FAILURE GOTO!
*
{LCNT4{ICV{3,ERRFT{{{FATAL ERROR{14651
{{ERB{1,332{26,Goto CONTINUE with error in failure goto{{{14652
{{EJC{{{{{14653
*
*      END
*
{L$END{ENT{{{{ENTRY POINT{14657
*
*      MERGE HERE FROM END CODE CIRCUIT
*
{LEND0{MOV{21,=ENDMS{7,XR{{POINT TO MESSAGE /NORMAL TERM.../{14661
{{BRN{6,STOPR{{{JUMP TO ROUTINE TO STOP RUN{14662
{{EJC{{{{{14663
*
*      FRETURN
*
{L$FRT{ENT{{{{ENTRY POINT{14667
{{MOV{21,=SCFRT{8,WA{{POINT TO STRING /FRETURN/{14668
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14669
{{EJC{{{{{14670
*
*      NRETURN
*
{L$NRT{ENT{{{{ENTRY POINT{14674
{{MOV{21,=SCNRT{8,WA{{POINT TO STRING /NRETURN/{14675
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14676
{{EJC{{{{{14677
*
*      RETURN
*
{L$RTN{ENT{{{{ENTRY POINT{14681
{{MOV{21,=SCRTN{8,WA{{POINT TO STRING /RETURN/{14682
{{BRN{6,RETRN{{{JUMP TO COMMON RETURN ROUTINE{14683
{{EJC{{{{{14684
*
*      SCONTINUE
*
{L$SCN{ENT{{{{ENTRY POINT{14688
{{MOV{3,R$CNT{7,XR{{LOAD CONTINUATION CODE BLOCK PTR{14689
{{BZE{7,XR{6,LSCN2{{JUMP IF NO PREVIOUS ERROR{14690
{{ZER{3,R$CNT{{{CLEAR FLAG{14691
{{BNE{3,KVERT{18,=NM320{6,LSCN1{ERROR MUST BE USER INTERRUPT{14692
{{BEQ{3,KVERT{18,=NM321{6,LSCN2{DETECT SCONTINUE LOOP{14693
{{MOV{7,XR{3,R$COD{{ELSE STORE AS NEW CODE BLOCK PTR{14694
{{ADD{3,STXOC{7,XR{{ADD RESUME OFFSET{14695
{{LCP{7,XR{{{LOAD CODE POINTER{14696
{{LCW{7,XR{{{GET NEXT CODE WORD{14697
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14698
*
*      HERE IF NO USER INTERRUPT
*
{LSCN1{ICV{3,ERRFT{{{FATAL ERROR{14702
{{ERB{1,331{26,Goto SCONTINUE with no user interrupt{{{14703
*
*      HERE IF IN SCONTINUE LOOP OR IF NO PREVIOUS ERROR
*
{LSCN2{ICV{3,ERRFT{{{FATAL ERROR{14707
{{ERB{1,321{26,Goto SCONTINUE with no preceding error{{{14708
{{EJC{{{{{14709
*
*      UNDEFINED LABEL
*
{L$UND{ENT{{{{ENTRY POINT{14713
{{ERB{1,038{26,Goto undefined label{{{14714
{{TTL{27,S P I T B O L -- PREDEFINED SNOBOL4 FUNCTIONS{{{{14715
*
*      THE FOLLOWING SECTION CONTAINS CODING FOR FUNCTIONS
*      WHICH ARE PREDEFINED AND AVAILABLE AT THE SNOBOL LEVEL.
*
*      THESE ROUTINES RECEIVE CONTROL DIRECTLY FROM THE CODE OR
*      INDIRECTLY THROUGH THE O$FNC, O$FNS OR CFUNC ROUTINES.
*      IN BOTH CASES THE CONDITIONS ON ENTRY ARE AS FOLLOWS
*
*      THE ARGUMENTS ARE ON THE STACK. THE NUMBER OF ARGUMENTS
*      HAS BEEN ADJUSTED TO CORRESPOND TO THE SVBLK SVNAR FIELD.
*
*      IN CERTAIN FUNCTIONS THE DIRECT CALL IS NOT PERMITTED
*      AND IN THESE INSTANCES WE ALSO HAVE.
*
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS IN CALL
*
*      CONTROL RETURNS BY PLACING THE FUNCTION RESULT VALUE ON
*      ON THE STACK AND CONTINUING EXECUTION WITH THE NEXT
*      WORD FROM THE GENERATED CODE.
*
*      THE NAMES OF THE ENTRY POINTS OF THESE FUNCTIONS ARE OF
*      THE FORM S$XXX WHERE XXX IS THE THREE LETTER CODE FOR
*      THE SYSTEM VARIABLE NAME. THE FUNCTIONS ARE IN ORDER
*      ALPHABETICALLY BY THEIR ENTRY NAMES.
{{EJC{{{{{14740
*
*      ANY
*
{S$ANY{ENT{{{{ENTRY POINT{14794
{{MOV{22,=P$ANS{8,WB{{SET PCODE FOR SINGLE CHAR CASE{14795
{{MOV{22,=P$ANY{7,XL{{PCODE FOR MULTI-CHAR CASE{14796
{{MOV{22,=P$AYD{8,WC{{PCODE FOR EXPRESSION CASE{14797
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{14798
{{ERR{1,059{26,ANY argument is not a string or expression{{{14799
{{MOV{7,XR{11,-(XS){{STACK RESULT{14800
{{LCW{7,XR{{{GET NEXT CODE WORD{14801
{{BRI{9,(XR){{{EXECUTE IT{14802
{{EJC{{{{{14803
*
*      APPLY
*
*      APPLY DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S$APP{ENT{{{{ENTRY POINT{14829
{{BZE{8,WA{6,SAPP3{{JUMP IF NO ARGUMENTS{14830
{{DCV{8,WA{{{ELSE GET APPLIED FUNC ARG COUNT{14831
{{MOV{8,WA{8,WB{{COPY{14832
{{WTB{8,WB{{{CONVERT TO BYTES{14833
{{MOV{7,XS{7,XT{{COPY STACK POINTER{14834
{{ADD{8,WB{7,XT{{POINT TO FUNCTION ARGUMENT ON STACK{14835
{{MOV{9,(XT){7,XR{{LOAD FUNCTION PTR (APPLY 1ST ARG){14836
{{BZE{8,WA{6,SAPP2{{JUMP IF NO ARGS FOR APPLIED FUNC{14837
{{LCT{8,WB{8,WA{{ELSE SET COUNTER FOR LOOP{14838
*
*      LOOP TO MOVE ARGUMENTS UP ON STACK
*
{SAPP1{DCA{7,XT{{{POINT TO NEXT ARGUMENT{14842
{{MOV{9,(XT){12,1(XT){{MOVE ARGUMENT UP{14843
{{BCT{8,WB{6,SAPP1{{LOOP TILL ALL MOVED{14844
*
*      MERGE HERE TO CALL FUNCTION (WA = NUMBER OF ARGUMENTS)
*
{SAPP2{ICA{7,XS{{{ADJUST STACK PTR FOR APPLY 1ST ARG{14848
{{JSR{6,GTNVR{{{GET VARIABLE BLOCK ADDR FOR FUNC{14849
{{PPM{6,SAPP3{{{JUMP IF NOT NATURAL VARIABLE{14850
{{MOV{13,VRFNC(XR){7,XL{{ELSE POINT TO FUNCTION BLOCK{14851
{{BRN{6,CFUNC{{{GO CALL APPLIED FUNCTION{14852
*
*      HERE FOR INVALID FIRST ARGUMENT
*
{SAPP3{ERB{1,060{26,APPLY first arg is not natural variable name{{{14856
{{EJC{{{{{14857
*
*      ARBNO
*
*      ARBNO BUILDS A COMPOUND PATTERN. SEE DESCRIPTION AT
*      START OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S$ABN{ENT{{{{ENTRY POINT{14864
{{ZER{7,XR{{{SET PARM1 = 0 FOR THE MOMENT{14865
{{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATIVE NODE{14866
{{JSR{6,PBILD{{{BUILD ALTERNATIVE NODE{14867
{{MOV{7,XR{7,XL{{SAVE PTR TO ALTERNATIVE PATTERN{14868
{{MOV{22,=P$ABC{8,WB{{PCODE FOR P$ABC{14869
{{ZER{7,XR{{{P0BLK{14870
{{JSR{6,PBILD{{{BUILD P$ABC NODE{14871
{{MOV{7,XL{13,PTHEN(XR){{PUT ALTERNATIVE NODE AS SUCCESSOR{14872
{{MOV{7,XL{8,WA{{REMEMBER ALTERNATIVE NODE POINTER{14873
{{MOV{7,XR{7,XL{{COPY P$ABC NODE PTR{14874
{{MOV{9,(XS){7,XR{{LOAD ARBNO ARGUMENT{14875
{{MOV{8,WA{9,(XS){{STACK ALTERNATIVE NODE POINTER{14876
{{JSR{6,GTPAT{{{GET ARBNO ARGUMENT AS PATTERN{14877
{{ERR{1,061{26,ARBNO argument is not pattern{{{14878
{{JSR{6,PCONC{{{CONCAT ARG WITH P$ABC NODE{14879
{{MOV{7,XR{7,XL{{REMEMBER PTR TO CONCD PATTERNS{14880
{{MOV{22,=P$ABA{8,WB{{PCODE FOR P$ABA{14881
{{ZER{7,XR{{{P0BLK{14882
{{JSR{6,PBILD{{{BUILD P$ABA NODE{14883
{{MOV{7,XL{13,PTHEN(XR){{CONCATENATE NODES{14884
{{MOV{9,(XS){7,XL{{RECALL PTR TO ALTERNATIVE NODE{14885
{{MOV{7,XR{13,PARM1(XL){{POINT ALTERNATIVE BACK TO ARGUMENT{14886
{{LCW{7,XR{{{GET NEXT CODE WORD{14887
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{14888
{{EJC{{{{{14889
*
*      ARG
*
{S$ARG{ENT{{{{ENTRY POINT{14893
{{JSR{6,GTSMI{{{GET SECOND ARG AS SMALL INTEGER{14894
{{ERR{1,062{26,ARG second argument is not integer{{{14895
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE OR NEGATIVE{14896
{{MOV{7,XR{8,WA{{SAVE ARGUMENT NUMBER{14897
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{14898
{{JSR{6,GTNVR{{{LOCATE VRBLK{14899
{{PPM{6,SARG1{{{JUMP IF NOT NATURAL VARIABLE{14900
{{MOV{13,VRFNC(XR){7,XR{{ELSE LOAD FUNCTION BLOCK POINTER{14901
{{BNE{9,(XR){22,=B$PFC{6,SARG1{JUMP IF NOT PROGRAM DEFINED{14902
{{BZE{8,WA{6,EXFAL{{FAIL IF ARG NUMBER IS ZERO{14903
{{BGT{8,WA{13,FARGS(XR){6,EXFAL{FAIL IF ARG NUMBER IS TOO LARGE{14904
{{WTB{8,WA{{{ELSE CONVERT TO BYTE OFFSET{14905
{{ADD{8,WA{7,XR{{POINT TO ARGUMENT SELECTED{14906
{{MOV{13,PFAGB(XR){7,XR{{LOAD ARGUMENT VRBLK POINTER{14907
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{14908
*
*      HERE IF 1ST ARGUMENT IS BAD
*
{SARG1{ERB{1,063{26,ARG first argument is not program function name{{{14912
{{EJC{{{{{14913
*
*      ARRAY
*
{S$ARR{ENT{{{{ENTRY POINT{14917
{{MOV{10,(XS)+{7,XL{{LOAD INITIAL ELEMENT VALUE{14918
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{14919
{{JSR{6,GTINT{{{CONVERT FIRST ARG TO INTEGER{14920
{{PPM{6,SAR02{{{JUMP IF NOT INTEGER{14921
*
*      HERE FOR INTEGER FIRST ARGUMENT, BUILD VCBLK
*
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{14925
{{ILE{6,SAR10{{{JUMP IF ZERO OR NEG (BAD DIMENSION){14926
{{MFI{8,WA{6,SAR11{{ELSE CONVERT TO ONE WORD, TEST OVFL{14927
{{JSR{6,VMAKE{{{CREATE VECTOR{14928
{{PPM{6,SAR11{{{FAIL IF TOO LARGE{14929
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{14930
{{EJC{{{{{14931
*
*      ARRAY (CONTINUED)
*
*      HERE IF FIRST ARGUMENT IS NOT AN INTEGER
*
{SAR02{MOV{7,XR{11,-(XS){{REPLACE ARGUMENT ON STACK{14937
{{JSR{6,XSCNI{{{INITIALIZE SCAN OF FIRST ARGUMENT{14938
{{ERR{1,064{26,ARRAY first argument is not integer or string{{{14939
{{PPM{6,EXNUL{{{DUMMY (UNUSED) NULL STRING EXIT{14940
{{MOV{3,R$XSC{11,-(XS){{SAVE PROTOTYPE POINTER{14941
{{MOV{7,XL{11,-(XS){{SAVE DEFAULT VALUE{14942
{{ZER{3,ARCDM{{{ZERO COUNT OF DIMENSIONS{14943
{{ZER{3,ARPTR{{{ZERO OFFSET TO INDICATE PASS ONE{14944
{{LDI{4,INTV1{{{LOAD INTEGER ONE{14945
{{STI{3,ARNEL{{{INITIALIZE ELEMENT COUNT{14946
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. THE FIRST TIME
*      (ARPTR EQ 0), IT IS USED TO COUNT THE NUMBER OF ELEMENTS
*      AND NUMBER OF DIMENSIONS. THE SECOND TIME (ARPTR GT 0) IS
*      USED TO ACTUALLY FILL IN THE DIM,LBD FIELDS OF THE ARBLK.
*
{SAR03{LDI{4,INTV1{{{LOAD ONE AS DEFAULT LOW BOUND{14953
{{STI{3,ARSVL{{{SAVE AS LOW BOUND{14954
{{MOV{18,=CH$CL{8,WC{{SET DELIMITER ONE = COLON{14955
{{MOV{18,=CH$CM{7,XL{{SET DELIMITER TWO = COMMA{14956
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{14957
{{JSR{6,XSCAN{{{SCAN NEXT BOUND{14958
{{BNE{8,WA{18,=NUM01{6,SAR04{JUMP IF NOT COLON{14959
*
*      HERE WE HAVE A COLON ENDING A LOW BOUND
*
{{JSR{6,GTINT{{{CONVERT LOW BOUND{14963
{{ERR{1,065{26,ARRAY first argument lower bound is not integer{{{14964
{{LDI{13,ICVAL(XR){{{LOAD VALUE OF LOW BOUND{14965
{{STI{3,ARSVL{{{STORE LOW BOUND VALUE{14966
{{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{14967
{{MOV{8,WC{7,XL{{AND DELIMITER TWO = COMMA{14968
{{ZER{8,WA{{{RETAIN BLANKS IN PROTOTYPE{14969
{{JSR{6,XSCAN{{{SCAN HIGH BOUND{14970
{{EJC{{{{{14971
*
*      ARRAY (CONTINUED)
*
*      MERGE HERE TO PROCESS UPPER BOUND
*
{SAR04{JSR{6,GTINT{{{CONVERT HIGH BOUND TO INTEGER{14977
{{ERR{1,066{26,ARRAY first argument upper bound is not integer{{{14978
{{LDI{13,ICVAL(XR){{{GET HIGH BOUND{14979
{{SBI{3,ARSVL{{{SUBTRACT LOWER BOUND{14980
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{14981
{{ILT{6,SAR10{{{BAD DIMENSION IF NEGATIVE{14982
{{ADI{4,INTV1{{{ADD 1 TO GET DIMENSION{14983
{{IOV{6,SAR10{{{BAD DIMENSION IF OVERFLOW{14984
{{MOV{3,ARPTR{7,XL{{LOAD OFFSET (ALSO PASS INDICATOR){14985
{{BZE{7,XL{6,SAR05{{JUMP IF FIRST PASS{14986
*
*      HERE IN SECOND PASS TO STORE LBD AND DIM IN ARBLK
*
{{ADD{9,(XS){7,XL{{POINT TO CURRENT LOCATION IN ARBLK{14990
{{STI{13,CFP$I(XL){{{STORE DIMENSION{14991
{{LDI{3,ARSVL{{{LOAD LOW BOUND{14992
{{STI{9,(XL){{{STORE LOW BOUND{14993
{{ADD{19,*ARDMS{3,ARPTR{{BUMP OFFSET TO NEXT BOUNDS{14994
{{BRN{6,SAR06{{{JUMP TO CHECK FOR END OF BOUNDS{14995
*
*      HERE IN PASS 1
*
{SAR05{ICV{3,ARCDM{{{BUMP DIMENSION COUNT{14999
{{MLI{3,ARNEL{{{MULTIPLY DIMENSION BY COUNT SO FAR{15000
{{IOV{6,SAR11{{{TOO LARGE IF OVERFLOW{15001
{{STI{3,ARNEL{{{ELSE STORE UPDATED ELEMENT COUNT{15002
*
*      MERGE HERE AFTER PROCESSING ONE SET OF BOUNDS
*
{SAR06{BNZ{8,WA{6,SAR03{{LOOP BACK UNLESS END OF BOUNDS{15006
{{BNZ{3,ARPTR{6,SAR09{{JUMP IF END OF PASS 2{15007
{{EJC{{{{{15008
*
*      ARRAY (CONTINUED)
*
*      HERE AT END OF PASS ONE, BUILD ARBLK
*
{{LDI{3,ARNEL{{{GET NUMBER OF ELEMENTS{15014
{{MFI{8,WB{6,SAR11{{GET AS ADDR INTEGER, TEST OVFLO{15015
{{WTB{8,WB{{{ELSE CONVERT TO LENGTH IN BYTES{15016
{{MOV{19,*ARSI${8,WA{{SET SIZE OF STANDARD FIELDS{15017
{{LCT{8,WC{3,ARCDM{{SET DIMENSION COUNT TO CONTROL LOOP{15018
*
*      LOOP TO ALLOW SPACE FOR DIMENSIONS
*
{SAR07{ADD{19,*ARDMS{8,WA{{ALLOW SPACE FOR ONE SET OF BOUNDS{15022
{{BCT{8,WC{6,SAR07{{LOOP BACK TILL ALL ACCOUNTED FOR{15023
{{MOV{8,WA{7,XL{{SAVE SIZE (=AROFS){15024
*
*      NOW ALLOCATE SPACE FOR ARBLK
*
{{ADD{8,WB{8,WA{{ADD SPACE FOR ELEMENTS{15028
{{ICA{8,WA{{{ALLOW FOR ARPRO PROTOTYPE FIELD{15029
{{BGT{8,WA{3,MXLEN{6,SAR11{FAIL IF TOO LARGE{15030
{{JSR{6,ALLOC{{{ELSE ALLOCATE ARBLK{15031
{{MOV{9,(XS){8,WB{{LOAD DEFAULT VALUE{15032
{{MOV{7,XR{9,(XS){{SAVE ARBLK POINTER{15033
{{MOV{8,WA{8,WC{{SAVE LENGTH IN BYTES{15034
{{BTW{8,WA{{{CONVERT LENGTH BACK TO WORDS{15035
{{LCT{8,WA{8,WA{{SET COUNTER TO CONTROL LOOP{15036
*
*      LOOP TO CLEAR ENTIRE ARBLK TO DEFAULT VALUE
*
{SAR08{MOV{8,WB{10,(XR)+{{SET ONE WORD{15040
{{BCT{8,WA{6,SAR08{{LOOP TILL ALL SET{15041
{{EJC{{{{{15042
*
*      ARRAY (CONTINUED)
*
*      NOW SET INITIAL FIELDS OF ARBLK
*
{{MOV{10,(XS)+{7,XR{{RELOAD ARBLK POINTER{15048
{{MOV{9,(XS){8,WB{{LOAD PROTOTYPE{15049
{{MOV{22,=B$ART{9,(XR){{SET TYPE WORD{15050
{{MOV{8,WC{13,ARLEN(XR){{STORE LENGTH IN BYTES{15051
{{ZER{13,IDVAL(XR){{{ZERO ID TILL WE GET IT BUILT{15052
{{MOV{7,XL{13,AROFS(XR){{SET PROTOTYPE FIELD PTR{15053
{{MOV{3,ARCDM{13,ARNDM(XR){{SET NUMBER OF DIMENSIONS{15054
{{MOV{7,XR{8,WC{{SAVE ARBLK POINTER{15055
{{ADD{7,XL{7,XR{{POINT TO PROTOTYPE FIELD{15056
{{MOV{8,WB{9,(XR){{STORE PROTOTYPE PTR IN ARBLK{15057
{{MOV{19,*ARLBD{3,ARPTR{{SET OFFSET FOR PASS 2 BOUNDS SCAN{15058
{{MOV{8,WB{3,R$XSC{{RESET STRING POINTER FOR XSCAN{15059
{{MOV{8,WC{9,(XS){{STORE ARBLK POINTER ON STACK{15060
{{ZER{3,XSOFS{{{RESET OFFSET PTR TO START OF STRING{15061
{{BRN{6,SAR03{{{JUMP BACK TO RESCAN BOUNDS{15062
*
*      HERE AFTER FILLING IN BOUNDS INFORMATION (END PASS TWO)
*
{SAR09{MOV{10,(XS)+{7,XR{{RELOAD POINTER TO ARBLK{15066
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{15067
*
*      HERE FOR BAD DIMENSION
*
{SAR10{ERB{1,067{26,ARRAY dimension is zero,negative or out of range{{{15071
*
*      HERE IF ARRAY IS TOO LARGE
*
{SAR11{ERB{1,068{26,ARRAY size exceeds maximum permitted{{{15075
{{EJC{{{{{15076
*
*      ATAN
*
{S$ATN{ENT{{{{ENTRY POINT{15081
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15082
{{JSR{6,GTREA{{{CONVERT TO REAL{15083
{{ERR{1,301{26,ATAN argument not numeric{{{15084
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15085
{{ATN{{{{TAKE ARCTANGENT{15086
{{BRN{6,EXREA{{{OVERFLOW, OUT OF RANGE NOT POSSIBLE{15087
{{EJC{{{{{15088
{{EJC{{{{{15091
*
*      BACKSPACE
*
{S$BSP{ENT{{{{ENTRY POINT{15095
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{15096
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{15097
{{ERR{1,316{26,BACKSPACE argument is not a suitable name{{{15098
{{ERR{1,317{26,BACKSPACE file does not exist{{{15099
{{JSR{6,SYSBS{{{CALL BACKSPACE FILE FUNCTION{15100
{{ERR{1,317{26,BACKSPACE file does not exist{{{15101
{{ERR{1,318{26,BACKSPACE file does not permit backspace{{{15102
{{ERR{1,319{26,BACKSPACE caused non-recoverable error{{{15103
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{15104
{{EJC{{{{{15105
*
*      BREAK
*
{S$BRK{ENT{{{{ENTRY POINT{15138
{{MOV{22,=P$BKS{8,WB{{SET PCODE FOR SINGLE CHAR CASE{15139
{{MOV{22,=P$BRK{7,XL{{PCODE FOR MULTI-CHAR CASE{15140
{{MOV{22,=P$BKD{8,WC{{PCODE FOR EXPRESSION CASE{15141
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{15142
{{ERR{1,069{26,BREAK argument is not a string or expression{{{15143
{{MOV{7,XR{11,-(XS){{STACK RESULT{15144
{{LCW{7,XR{{{GET NEXT CODE WORD{15145
{{BRI{9,(XR){{{EXECUTE IT{15146
{{EJC{{{{{15147
*
*      BREAKX
*
*      BREAKX IS A COMPOUND PATTERN. SEE DESCRIPTION AT START
*      OF PATTERN MATCHING SECTION FOR STRUCTURE FORMED.
*
{S$BKX{ENT{{{{ENTRY POINT{15154
{{MOV{22,=P$BKS{8,WB{{PCODE FOR SINGLE CHAR ARGUMENT{15155
{{MOV{22,=P$BRK{7,XL{{PCODE FOR MULTI-CHAR ARGUMENT{15156
{{MOV{22,=P$BXD{8,WC{{PCODE FOR EXPRESSION CASE{15157
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{15158
{{ERR{1,070{26,BREAKX argument is not a string or expression{{{15159
*
*      NOW HOOK BREAKX NODE ON AT FRONT END
*
{{MOV{7,XR{11,-(XS){{SAVE PTR TO BREAK NODE{15163
{{MOV{22,=P$BKX{8,WB{{SET PCODE FOR BREAKX NODE{15164
{{JSR{6,PBILD{{{BUILD IT{15165
{{MOV{9,(XS){13,PTHEN(XR){{SET BREAK NODE AS SUCCESSOR{15166
{{MOV{22,=P$ALT{8,WB{{SET PCODE FOR ALTERNATION NODE{15167
{{JSR{6,PBILD{{{BUILD (PARM1=ALT=BREAKX NODE){15168
{{MOV{7,XR{8,WA{{SAVE PTR TO ALTERNATION NODE{15169
{{MOV{9,(XS){7,XR{{POINT TO BREAK NODE{15170
{{MOV{8,WA{13,PTHEN(XR){{SET ALTERNATE NODE AS SUCCESSOR{15171
{{LCW{7,XR{{{RESULT ON STACK{15172
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{15173
{{EJC{{{{{15174
*
*      CHAR
*
{S$CHR{ENT{{{{ENTRY POINT{15178
{{JSR{6,GTSMI{{{CONVERT ARG TO INTEGER{15179
{{ERR{1,281{26,CHAR argument not integer{{{15180
{{PPM{6,SCHR1{{{TOO BIG ERROR EXIT{15181
{{BGE{8,WC{18,=CFP$A{6,SCHR1{SEE IF OUT OF RANGE OF HOST SET{15182
{{MOV{18,=NUM01{8,WA{{IF NOT SET SCBLK ALLOCATION{15183
{{MOV{8,WC{8,WB{{SAVE CHAR CODE{15184
{{JSR{6,ALOCS{{{ALLOCATE 1 BAU SCBLK{15185
{{MOV{7,XR{7,XL{{COPY SCBLK POINTER{15186
{{PSC{7,XL{{{GET SET TO STUFF CHAR{15187
{{SCH{8,WB{9,(XL){{STUFF IT{15188
{{CSC{7,XL{{{COMPLETE STORE CHARACTER{15189
{{ZER{7,XL{{{CLEAR SLOP IN XL{15190
{{MOV{7,XR{11,-(XS){{STACK RESULT{15191
{{LCW{7,XR{{{GET NEXT CODE WORD{15192
{{BRI{9,(XR){{{EXECUTE IT{15193
*
*      HERE IF CHAR ARGUMENT IS OUT OF RANGE
*
{SCHR1{ERB{1,282{26,CHAR argument not in range{{{15197
{{EJC{{{{{15198
*
*      CHOP
*
{S$CHP{ENT{{{{ENTRY POINT{15203
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15204
{{JSR{6,GTREA{{{CONVERT TO REAL{15205
{{ERR{1,302{26,CHOP argument not numeric{{{15206
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15207
{{CHP{{{{TRUNCATE TO INTEGER VALUED REAL{15208
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE{15209
{{EJC{{{{{15210
*
*      CLEAR
*
{S$CLR{ENT{{{{ENTRY POINT{15215
{{JSR{6,XSCNI{{{INITIALIZE TO SCAN ARGUMENT{15216
{{ERR{1,071{26,CLEAR argument is not a string{{{15217
{{PPM{6,SCLR2{{{JUMP IF NULL{15218
*
*      LOOP TO SCAN OUT NAMES IN FIRST ARGUMENT. VARIABLES IN
*      THE LIST ARE FLAGGED BY SETTING VRGET OF VRBLK TO ZERO.
*
{SCLR1{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15223
{{MOV{8,WC{7,XL{{DELIMITER TWO = COMMA{15224
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15225
{{JSR{6,XSCAN{{{SCAN NEXT VARIABLE NAME{15226
{{JSR{6,GTNVR{{{LOCATE VRBLK{15227
{{ERR{1,072{26,CLEAR argument has null variable name{{{15228
{{ZER{13,VRGET(XR){{{ELSE FLAG BY ZEROING VRGET FIELD{15229
{{BNZ{8,WA{6,SCLR1{{LOOP BACK IF STOPPED BY COMMA{15230
*
*      HERE AFTER FLAGGING VARIABLES IN ARGUMENT LIST
*
{SCLR2{MOV{3,HSHTB{8,WB{{POINT TO START OF HASH TABLE{15234
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
{SCLR3{BEQ{8,WB{3,HSHTE{6,EXNUL{EXIT RETURNING NULL IF NONE LEFT{15238
{{MOV{8,WB{7,XR{{ELSE COPY SLOT POINTER{15239
{{ICA{8,WB{{{BUMP SLOT POINTER{15240
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE INTO LOOP{15241
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{SCLR4{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{15245
{{BZE{7,XR{6,SCLR3{{JUMP FOR NEXT BUCKET IF CHAIN END{15246
{{BNZ{13,VRGET(XR){6,SCLR5{{JUMP IF NOT FLAGGED{15247
{{EJC{{{{{15248
*
*      CLEAR (CONTINUED)
*
*      HERE FOR FLAGGED VARIABLE, DO NOT SET VALUE TO NULL
*
{{JSR{6,SETVR{{{FOR FLAGGED VAR, RESTORE VRGET{15254
{{BRN{6,SCLR4{{{AND LOOP BACK FOR NEXT VRBLK{15255
*
*      HERE TO SET VALUE OF A VARIABLE TO NULL
*      PROTECTED VARIABLES (ARB, ETC) ARE EXEMPT
*
{SCLR5{BEQ{13,VRSTO(XR){22,=B$VRE{6,SCLR4{CHECK FOR PROTECTED VARIABLE{15260
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{15261
*
*      LOOP TO LOCATE VALUE AT END OF POSSIBLE TRBLK CHAIN
*
{SCLR6{MOV{7,XL{8,WA{{SAVE BLOCK POINTER{15265
{{MOV{13,VRVAL(XL){7,XL{{LOAD NEXT VALUE FIELD{15266
{{BEQ{9,(XL){22,=B$TRT{6,SCLR6{LOOP BACK IF TRAPPED{15267
*
*      NOW STORE THE NULL VALUE
*
{{MOV{8,WA{7,XL{{RESTORE BLOCK POINTER{15271
{{MOV{21,=NULLS{13,VRVAL(XL){{STORE NULL CONSTANT VALUE{15272
{{BRN{6,SCLR4{{{LOOP BACK FOR NEXT VRBLK{15273
{{EJC{{{{{15274
*
*      CODE
*
{S$COD{ENT{{{{ENTRY POINT{15278
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15279
{{JSR{6,GTCOD{{{CONVERT TO CODE{15280
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS IMPOSSIBLE{15281
{{MOV{7,XR{11,-(XS){{STACK RESULT{15282
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15283
{{LCW{7,XR{{{GET NEXT CODE WORD{15284
{{BRI{9,(XR){{{EXECUTE IT{15285
{{EJC{{{{{15286
*
*      COLLECT
*
{S$COL{ENT{{{{ENTRY POINT{15290
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15291
{{JSR{6,GTINT{{{CONVERT TO INTEGER{15292
{{ERR{1,073{26,COLLECT argument is not integer{{{15293
{{LDI{13,ICVAL(XR){{{LOAD COLLECT ARGUMENT{15294
{{STI{3,CLSVI{{{SAVE COLLECT ARGUMENT{15295
{{ZER{8,WB{{{SET NO MOVE UP{15296
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15297
{{JSR{6,GBCOL{{{PERFORM GARBAGE COLLECTION{15303
{{MOV{3,DNAME{8,WA{{POINT TO END OF MEMORY{15305
{{SUB{3,DNAMP{8,WA{{SUBTRACT NEXT LOCATION{15306
{{BTW{8,WA{{{CONVERT BYTES TO WORDS{15307
{{MTI{8,WA{{{CONVERT WORDS AVAILABLE AS INTEGER{15308
{{SBI{3,CLSVI{{{SUBTRACT ARGUMENT{15309
{{IOV{6,EXFAL{{{FAIL IF OVERFLOW{15310
{{ILT{6,EXFAL{{{FAIL IF NOT ENOUGH{15311
{{ADI{3,CLSVI{{{ELSE RECOMPUTE AVAILABLE{15312
{{BRN{6,EXINT{{{AND EXIT WITH INTEGER RESULT{15313
{{EJC{{{{{15314
*
*      CONVERT
*
{S$CNV{ENT{{{{ENTRY POINT{15343
{{JSR{6,GTSTG{{{CONVERT SECOND ARGUMENT TO STRING{15344
{{PPM{6,SCV29{{{ERROR IF SECOND ARGUMENT NOT STRING{15345
{{BZE{8,WA{6,SCV29{{OR IF NULL STRING{15346
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{15348
{{MOV{9,(XS){7,XL{{LOAD FIRST ARGUMENT{15350
{{BNE{9,(XL){22,=B$PDT{6,SCV01{JUMP IF NOT PROGRAM DEFINED{15351
*
*      HERE FOR PROGRAM DEFINED DATATYPE
*
{{MOV{13,PDDFP(XL){7,XL{{POINT TO DFBLK{15355
{{MOV{13,DFNAM(XL){7,XL{{LOAD DATATYPE NAME{15356
{{JSR{6,IDENT{{{COMPARE WITH SECOND ARG{15357
{{PPM{6,EXITS{{{EXIT IF IDENT WITH ARG AS RESULT{15358
{{BRN{6,EXFAL{{{ELSE FAIL{15359
*
*      HERE IF NOT PROGRAM DEFINED DATATYPE
*
{SCV01{MOV{7,XR{11,-(XS){{SAVE STRING ARGUMENT{15363
{{MOV{21,=SVCTB{7,XL{{POINT TO TABLE OF NAMES TO COMPARE{15364
{{ZER{8,WB{{{INITIALIZE COUNTER{15365
{{MOV{8,WA{8,WC{{SAVE LENGTH OF ARGUMENT STRING{15366
*
*      LOOP THROUGH TABLE ENTRIES
*
{SCV02{MOV{10,(XL)+{7,XR{{LOAD NEXT TABLE ENTRY, BUMP POINTER{15370
{{BZE{7,XR{6,EXFAL{{FAIL IF ZERO MARKING END OF LIST{15371
{{BNE{8,WC{13,SCLEN(XR){6,SCV05{JUMP IF WRONG LENGTH{15372
{{MOV{7,XL{3,CNVTP{{ELSE STORE TABLE POINTER{15373
{{PLC{7,XR{{{POINT TO CHARS OF TABLE ENTRY{15374
{{MOV{9,(XS){7,XL{{LOAD POINTER TO STRING ARGUMENT{15375
{{PLC{7,XL{{{POINT TO CHARS OF STRING ARG{15376
{{MOV{8,WC{8,WA{{SET NUMBER OF CHARS TO COMPARE{15377
{{CMC{6,SCV04{6,SCV04{{COMPARE, JUMP IF NO MATCH{15378
{{EJC{{{{{15379
*
*      CONVERT (CONTINUED)
*
*      HERE WE HAVE A MATCH
*
{SCV03{MOV{8,WB{7,XL{{COPY ENTRY NUMBER{15385
{{ICA{7,XS{{{POP STRING ARG OFF STACK{15386
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{15387
{{BSW{7,XL{2,CNVTT{{JUMP TO APPROPRIATE ROUTINE{15388
{{IFF{1,0{6,SCV06{{STRING{15406
{{IFF{1,1{6,SCV07{{INTEGER{15406
{{IFF{1,2{6,SCV09{{NAME{15406
{{IFF{1,3{6,SCV10{{PATTERN{15406
{{IFF{1,4{6,SCV11{{ARRAY{15406
{{IFF{1,5{6,SCV19{{TABLE{15406
{{IFF{1,6{6,SCV25{{EXPRESSION{15406
{{IFF{1,7{6,SCV26{{CODE{15406
{{IFF{1,8{6,SCV27{{NUMERIC{15406
{{IFF{2,CNVRT{6,SCV08{{REAL{15406
{{ESW{{{{END OF SWITCH TABLE{15406
*
*      HERE IF NO MATCH WITH TABLE ENTRY
*
{SCV04{MOV{3,CNVTP{7,XL{{RESTORE TABLE POINTER, MERGE{15410
*
*      MERGE HERE IF LENGTHS DID NOT MATCH
*
{SCV05{ICV{8,WB{{{BUMP ENTRY NUMBER{15414
{{BRN{6,SCV02{{{LOOP BACK TO CHECK NEXT ENTRY{15415
*
*      HERE TO CONVERT TO STRING
*
{SCV06{MOV{7,XR{11,-(XS){{REPLACE STRING ARGUMENT ON STACK{15419
{{JSR{6,GTSTG{{{CONVERT TO STRING{15420
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15421
{{MOV{7,XR{11,-(XS){{STACK RESULT{15422
{{LCW{7,XR{{{GET NEXT CODE WORD{15423
{{BRI{9,(XR){{{EXECUTE IT{15424
{{EJC{{{{{15425
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT TO INTEGER
*
{SCV07{JSR{6,GTINT{{{CONVERT TO INTEGER{15431
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15432
{{MOV{7,XR{11,-(XS){{STACK RESULT{15433
{{LCW{7,XR{{{GET NEXT CODE WORD{15434
{{BRI{9,(XR){{{EXECUTE IT{15435
*
*      HERE TO CONVERT TO REAL
*
{SCV08{JSR{6,GTREA{{{CONVERT TO REAL{15441
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15442
{{MOV{7,XR{11,-(XS){{STACK RESULT{15443
{{LCW{7,XR{{{GET NEXT CODE WORD{15444
{{BRI{9,(XR){{{EXECUTE IT{15445
*
*      HERE TO CONVERT TO NAME
*
{SCV09{BEQ{9,(XR){22,=B$NML{6,EXIXR{RETURN IF ALREADY A NAME{15450
{{JSR{6,GTNVR{{{ELSE TRY STRING TO NAME CONVERT{15451
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15452
{{BRN{6,EXVNM{{{ELSE EXIT BUILDING NMBLK FOR VRBLK{15453
*
*      HERE TO CONVERT TO PATTERN
*
{SCV10{JSR{6,GTPAT{{{CONVERT TO PATTERN{15457
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15458
{{MOV{7,XR{11,-(XS){{STACK RESULT{15459
{{LCW{7,XR{{{GET NEXT CODE WORD{15460
{{BRI{9,(XR){{{EXECUTE IT{15461
*
*      CONVERT TO ARRAY
*
*      IF THE FIRST ARGUMENT IS A TABLE, THEN WE GO THROUGH
*      AN INTERMEDIATE ARRAY OF ADDRESSES THAT IS SORTED TO
*      PROVIDE A RESULT ORDERED BY TIME OF ENTRY IN THE
*      ORIGINAL TABLE.  SEE C3.762.
*
{SCV11{MOV{7,XR{11,-(XS){{SAVE ARGUMENT ON STACK{15470
{{ZER{8,WA{{{USE TABLE CHAIN BLOCK ADDRESSES{15471
{{JSR{6,GTARR{{{GET AN ARRAY{15472
{{PPM{6,EXFAL{{{FAIL IF EMPTY TABLE{15473
{{PPM{6,EXFAL{{{FAIL IF NOT CONVERTIBLE{15474
{{MOV{10,(XS)+{7,XL{{RELOAD ORIGINAL ARG{15475
{{BNE{9,(XL){22,=B$TBT{6,EXSID{EXIT IF ORIGINAL NOT A TABLE{15476
{{MOV{7,XR{11,-(XS){{SORT THE INTERMEDIATE ARRAY{15477
{{MOV{21,=NULLS{11,-(XS){{ON FIRST COLUMN{15478
{{ZER{8,WA{{{SORT ASCENDING{15479
{{JSR{6,SORTA{{{DO SORT{15480
{{PPM{6,EXFAL{{{IF SORT FAILS, SO SHALL WE{15481
{{MOV{7,XR{8,WB{{SAVE ARRAY RESULT{15482
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){15483
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{15484
{{LCT{8,WA{8,WA{{COPY TO CONTROL LOOP{15485
{{ADD{19,*ARVL2{7,XR{{POINT TO FIRST ELEMENT IN ARRAY{15486
*
*      HERE FOR EACH ROW OF THIS 2-COLUMN ARRAY
*
{SCV12{MOV{9,(XR){7,XL{{GET TEBLK ADDRESS{15490
{{MOV{13,TESUB(XL){10,(XR)+{{REPLACE WITH SUBSCRIPT{15491
{{MOV{13,TEVAL(XL){10,(XR)+{{REPLACE WITH VALUE{15492
{{BCT{8,WA{6,SCV12{{LOOP TILL ALL COPIED OVER{15493
{{MOV{8,WB{7,XR{{RETRIEVE ARRAY ADDRESS{15494
{{BRN{6,EXSID{{{EXIT SETTING ID FIELD{15495
*
*      CONVERT TO TABLE
*
{SCV19{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{15499
{{MOV{7,XR{11,-(XS){{REPLACE ARBLK POINTER ON STACK{15500
{{BEQ{8,WA{22,=B$TBT{6,EXITS{RETURN ARG IF ALREADY A TABLE{15501
{{BNE{8,WA{22,=B$ART{6,EXFAL{ELSE FAIL IF NOT AN ARRAY{15502
{{EJC{{{{{15503
*
*      CONVERT (CONTINUED)
*
*      HERE TO CONVERT AN ARRAY TO TABLE
*
{{BNE{13,ARNDM(XR){18,=NUM02{6,EXFAL{FAIL IF NOT 2-DIM ARRAY{15509
{{LDI{13,ARDM2(XR){{{LOAD DIM 2{15510
{{SBI{4,INTV2{{{SUBTRACT 2 TO COMPARE{15511
{{INE{6,EXFAL{{{FAIL IF DIM2 NOT 2{15512
*
*      HERE WE HAVE AN ARBLK OF THE RIGHT SHAPE
*
{{LDI{13,ARDIM(XR){{{LOAD DIM 1 (NUMBER OF ELEMENTS){15516
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{15517
{{LCT{8,WB{8,WA{{COPY TO CONTROL LOOP{15518
{{ADD{18,=TBSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{15519
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15520
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{15521
{{MOV{7,XR{8,WC{{COPY TBBLK POINTER{15522
{{MOV{7,XR{11,-(XS){{SAVE TBBLK POINTER{15523
{{MOV{22,=B$TBT{10,(XR)+{{STORE TYPE WORD{15524
{{ZER{10,(XR)+{{{STORE ZERO FOR IDVAL FOR NOW{15525
{{MOV{8,WA{10,(XR)+{{STORE LENGTH{15526
{{MOV{21,=NULLS{10,(XR)+{{NULL INITIAL LOOKUP VALUE{15527
*
*      LOOP TO INITIALIZE BUCKET PTRS TO POINT TO TABLE
*
{SCV20{MOV{8,WC{10,(XR)+{{SET BUCKET PTR TO POINT TO TBBLK{15531
{{BCT{8,WB{6,SCV20{{LOOP TILL ALL INITIALIZED{15532
{{MOV{19,*ARVL2{8,WB{{SET OFFSET TO FIRST ARBLK ELEMENT{15533
*
*      LOOP TO COPY ELEMENTS FROM ARRAY TO TABLE
*
{SCV21{MOV{12,1(XS){7,XL{{POINT TO ARBLK{15537
{{BEQ{8,WB{13,ARLEN(XL){6,SCV24{JUMP IF ALL MOVED{15538
{{ADD{8,WB{7,XL{{ELSE POINT TO CURRENT LOCATION{15539
{{ADD{19,*NUM02{8,WB{{BUMP OFFSET{15540
{{MOV{9,(XL){7,XR{{LOAD SUBSCRIPT NAME{15541
{{DCA{7,XL{{{ADJUST PTR TO MERGE (TRVAL=1+1){15542
{{EJC{{{{{15543
*
*      CONVERT (CONTINUED)
*
*      LOOP TO CHASE DOWN TRBLK CHAIN FOR VALUE
*
{SCV22{MOV{13,TRVAL(XL){7,XL{{POINT TO NEXT VALUE{15549
{{BEQ{9,(XL){22,=B$TRT{6,SCV22{LOOP BACK IF TRAPPED{15550
*
*      HERE WITH NAME IN XR, VALUE IN XL
*
{SCV23{MOV{7,XL{11,-(XS){{STACK VALUE{15554
{{MOV{12,1(XS){7,XL{{LOAD TBBLK POINTER{15555
{{JSR{6,TFIND{{{BUILD TEBLK (NOTE WB GT 0 BY NAME){15556
{{PPM{6,EXFAL{{{FAIL IF ACESS FAILS{15557
{{MOV{10,(XS)+{13,TEVAL(XL){{STORE VALUE IN TEBLK{15558
{{BRN{6,SCV21{{{LOOP BACK FOR NEXT ELEMENT{15559
*
*      HERE AFTER MOVING ALL ELEMENTS TO TBBLK
*
{SCV24{MOV{10,(XS)+{7,XR{{LOAD TBBLK POINTER{15563
{{ICA{7,XS{{{POP ARBLK POINTER{15564
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{15565
*
*      CONVERT TO EXPRESSION
*
{SCV25{ZER{8,WB{{{BY VALUE{15570
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{15571
{{PPM{6,EXFAL{{{FAIL IF CONVERSION NOT POSSIBLE{15575
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15576
{{MOV{7,XR{11,-(XS){{STACK RESULT{15577
{{LCW{7,XR{{{GET NEXT CODE WORD{15578
{{BRI{9,(XR){{{EXECUTE IT{15579
*
*      CONVERT TO CODE
*
{SCV26{JSR{6,GTCOD{{{CONVERT TO CODE{15583
{{PPM{6,EXFAL{{{FAIL IF CONVERSION IS NOT POSSIBLE{15584
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{15585
{{MOV{7,XR{11,-(XS){{STACK RESULT{15586
{{LCW{7,XR{{{GET NEXT CODE WORD{15587
{{BRI{9,(XR){{{EXECUTE IT{15588
*
*      CONVERT TO NUMERIC
*
{SCV27{JSR{6,GTNUM{{{CONVERT TO NUMERIC{15592
{{PPM{6,EXFAL{{{FAIL IF UNCONVERTIBLE{15593
{SCV31{MOV{7,XR{11,-(XS){{STACK RESULT{15594
{{LCW{7,XR{{{GET NEXT CODE WORD{15595
{{BRI{9,(XR){{{EXECUTE IT{15596
{{EJC{{{{{15597
*
*      SECOND ARGUMENT NOT STRING OR NULL
*
{SCV29{ERB{1,074{26,CONVERT second argument is not a string{{{15623
*
*      COPY
*
{S$COP{ENT{{{{ENTRY POINT{15628
{{JSR{6,COPYB{{{COPY THE BLOCK{15629
{{PPM{6,EXITS{{{RETURN IF NO IDVAL FIELD{15630
{{BRN{6,EXSID{{{EXIT SETTING ID VALUE{15631
{{EJC{{{{{15632
*
*      COS
*
{S$COS{ENT{{{{ENTRY POINT{15637
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{15638
{{JSR{6,GTREA{{{CONVERT TO REAL{15639
{{ERR{1,303{26,COS argument not numeric{{{15640
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{15641
{{COS{{{{TAKE COSINE{15642
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{15643
{{ERB{1,322{26,COS argument is out of range{{{15644
{{EJC{{{{{15645
*
*      DATA
*
{S$DAT{ENT{{{{ENTRY POINT{15650
{{JSR{6,XSCNI{{{PREPARE TO SCAN ARGUMENT{15651
{{ERR{1,075{26,DATA argument is not a string{{{15652
{{ERR{1,076{26,DATA argument is null{{{15653
*
*      SCAN OUT DATATYPE NAME
*
{{MOV{18,=CH$PP{8,WC{{DELIMITER ONE = LEFT PAREN{15657
{{MOV{8,WC{7,XL{{DELIMITER TWO = LEFT PAREN{15658
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15659
{{JSR{6,XSCAN{{{SCAN DATATYPE NAME{15660
{{BNZ{8,WA{6,SDAT1{{SKIP IF LEFT PAREN FOUND{15661
{{ERB{1,077{26,DATA argument is missing a left paren{{{15662
*
*      HERE AFTER SCANNING DATATYPE NAME
*
{SDAT1{MOV{13,SCLEN(XR){8,WA{{GET LENGTH{15667
{{BZE{8,WA{6,SDT1A{{AVOID FOLDING IF NULL STRING{15668
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{15669
{SDT1A{MOV{7,XR{7,XL{{SAVE NAME PTR{15670
{{MOV{13,SCLEN(XR){8,WA{{GET LENGTH{15674
{{CTB{8,WA{2,SCSI${{COMPUTE SPACE NEEDED{15675
{{JSR{6,ALOST{{{REQUEST STATIC STORE FOR NAME{15676
{{MOV{7,XR{11,-(XS){{SAVE DATATYPE NAME{15677
{{MVW{{{{COPY NAME TO STATIC{15678
{{MOV{9,(XS){7,XR{{GET NAME PTR{15679
{{ZER{7,XL{{{SCRUB DUD REGISTER{15680
{{JSR{6,GTNVR{{{LOCATE VRBLK FOR DATATYPE NAME{15681
{{ERR{1,078{26,DATA argument has null datatype name{{{15682
{{MOV{7,XR{3,DATDV{{SAVE VRBLK POINTER FOR DATATYPE{15683
{{MOV{7,XS{3,DATXS{{STORE STARTING STACK VALUE{15684
{{ZER{8,WB{{{ZERO COUNT OF FIELD NAMES{15685
*
*      LOOP TO SCAN FIELD NAMES AND STACK VRBLK POINTERS
*
{SDAT2{MOV{18,=CH$RP{8,WC{{DELIMITER ONE = RIGHT PAREN{15689
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO = COMMA{15690
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15691
{{JSR{6,XSCAN{{{SCAN NEXT FIELD NAME{15692
{{BNZ{8,WA{6,SDAT3{{JUMP IF DELIMITER FOUND{15693
{{ERB{1,079{26,DATA argument is missing a right paren{{{15694
*
*      HERE AFTER SCANNING OUT ONE FIELD NAME
*
{SDAT3{JSR{6,GTNVR{{{LOCATE VRBLK FOR FIELD NAME{15698
{{ERR{1,080{26,DATA argument has null field name{{{15699
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{15700
{{ICV{8,WB{{{INCREMENT COUNTER{15701
{{BEQ{8,WA{18,=NUM02{6,SDAT2{LOOP BACK IF STOPPED BY COMMA{15702
{{EJC{{{{{15703
*
*      DATA (CONTINUED)
*
*      NOW BUILD THE DFBLK
*
{{MOV{18,=DFSI${8,WA{{SET SIZE OF DFBLK STANDARD FIELDS{15709
{{ADD{8,WB{8,WA{{ADD NUMBER OF FIELDS{15710
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15711
{{MOV{8,WB{8,WC{{PRESERVE NO. OF FIELDS{15712
{{JSR{6,ALOST{{{ALLOCATE SPACE FOR DFBLK{15713
{{MOV{8,WC{8,WB{{GET NO OF FIELDS{15714
{{MOV{3,DATXS{7,XT{{POINT TO START OF STACK{15715
{{MOV{9,(XT){8,WC{{LOAD DATATYPE NAME{15716
{{MOV{7,XR{9,(XT){{SAVE DFBLK POINTER ON STACK{15717
{{MOV{22,=B$DFC{10,(XR)+{{STORE TYPE WORD{15718
{{MOV{8,WB{10,(XR)+{{STORE NUMBER OF FIELDS (FARGS){15719
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (DFLEN){15720
{{SUB{19,*PDDFS{8,WA{{COMPUTE PDBLK LENGTH (FOR DFPDL){15721
{{MOV{8,WA{10,(XR)+{{STORE PDBLK LENGTH (DFPDL){15722
{{MOV{8,WC{10,(XR)+{{STORE DATATYPE NAME (DFNAM){15723
{{LCT{8,WC{8,WB{{COPY NUMBER OF FIELDS{15724
*
*      LOOP TO MOVE FIELD NAME VRBLK POINTERS TO DFBLK
*
{SDAT4{MOV{11,-(XT){10,(XR)+{{MOVE ONE FIELD NAME VRBLK POINTER{15728
{{BCT{8,WC{6,SDAT4{{LOOP TILL ALL MOVED{15729
*
*      NOW DEFINE THE DATATYPE FUNCTION
*
{{MOV{8,WA{8,WC{{COPY LENGTH OF PDBLK FOR LATER LOOP{15733
{{MOV{3,DATDV{7,XR{{POINT TO VRBLK{15734
{{MOV{3,DATXS{7,XT{{POINT BACK ON STACK{15735
{{MOV{9,(XT){7,XL{{LOAD DFBLK POINTER{15736
{{JSR{6,DFFNC{{{DEFINE FUNCTION{15737
{{EJC{{{{{15738
*
*      DATA (CONTINUED)
*
*      LOOP TO BUILD FFBLKS
*
*
*      NOTICE THAT THE FFBLKS ARE CONSTRUCTED IN REVERSE ORDER
*      SO THAT THE REQUIRED OFFSETS CAN BE OBTAINED FROM
*      SUCCESSIVE DECREMENTATION OF THE PDBLK LENGTH (IN WC).
*
{SDAT5{MOV{19,*FFSI${8,WA{{SET LENGTH OF FFBLK{15749
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR FFBLK{15750
{{MOV{22,=B$FFC{9,(XR){{SET TYPE WORD{15751
{{MOV{18,=NUM01{13,FARGS(XR){{STORE FARGS (ALWAYS ONE){15752
{{MOV{3,DATXS{7,XT{{POINT BACK ON STACK{15753
{{MOV{9,(XT){13,FFDFP(XR){{COPY DFBLK PTR TO FFBLK{15754
{{DCA{8,WC{{{DECREMENT OLD DFPDL TO GET NEXT OFS{15755
{{MOV{8,WC{13,FFOFS(XR){{SET OFFSET TO THIS FIELD{15756
{{ZER{13,FFNXT(XR){{{TENTATIVELY SET ZERO FORWARD PTR{15757
{{MOV{7,XR{7,XL{{COPY FFBLK POINTER FOR DFFNC{15758
{{MOV{9,(XS){7,XR{{LOAD VRBLK POINTER FOR FIELD{15759
{{MOV{13,VRFNC(XR){7,XR{{LOAD CURRENT FUNCTION POINTER{15760
{{BNE{9,(XR){22,=B$FFC{6,SDAT6{SKIP IF NOT CURRENTLY A FIELD FUNC{15761
*
*      HERE WE MUST CHAIN AN OLD FFBLK PTR TO PRESERVE IT IN THE
*      CASE OF MULTIPLE FIELD FUNCTIONS WITH THE SAME NAME
*
{{MOV{7,XR{13,FFNXT(XL){{LINK NEW FFBLK TO PREVIOUS CHAIN{15766
*
*      MERGE HERE TO DEFINE FIELD FUNCTION
*
{SDAT6{MOV{10,(XS)+{7,XR{{LOAD VRBLK POINTER{15770
{{JSR{6,DFFNC{{{DEFINE FIELD FUNCTION{15771
{{BNE{7,XS{3,DATXS{6,SDAT5{LOOP BACK TILL ALL DONE{15772
{{ICA{7,XS{{{POP DFBLK POINTER{15773
{{BRN{6,EXNUL{{{RETURN WITH NULL RESULT{15774
{{EJC{{{{{15775
*
*      DATATYPE
*
{S$DTP{ENT{{{{ENTRY POINT{15779
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15780
{{JSR{6,DTYPE{{{GET DATATYPE{15781
{{MOV{7,XR{11,-(XS){{STACK RESULT{15782
{{LCW{7,XR{{{GET NEXT CODE WORD{15783
{{BRI{9,(XR){{{EXECUTE IT{15784
{{EJC{{{{{15785
*
*      DATE
*
{S$DTE{ENT{{{{ENTRY POINT{15789
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15790
{{JSR{6,GTINT{{{CONVERT TO AN INTEGER{15791
{{ERR{1,330{26,DATE argument is not integer{{{15792
{{JSR{6,SYSDT{{{CALL SYSTEM DATE ROUTINE{15793
{{MOV{12,1(XL){8,WA{{LOAD LENGTH FOR SBSTR{15794
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF LENGTH IS ZERO{15795
{{ZER{8,WB{{{SET ZERO OFFSET{15796
{{JSR{6,SBSTR{{{USE SBSTR TO BUILD SCBLK{15797
{{MOV{7,XR{11,-(XS){{STACK RESULT{15798
{{LCW{7,XR{{{GET NEXT CODE WORD{15799
{{BRI{9,(XR){{{EXECUTE IT{15800
{{EJC{{{{{15801
*
*      DEFINE
*
{S$DEF{ENT{{{{ENTRY POINT{15805
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{15806
{{ZER{3,DEFLB{{{ZERO LABEL POINTER IN CASE NULL{15807
{{BEQ{7,XR{21,=NULLS{6,SDF01{JUMP IF NULL SECOND ARGUMENT{15808
{{JSR{6,GTNVR{{{ELSE FIND VRBLK FOR LABEL{15809
{{PPM{6,SDF12{{{JUMP IF NOT A VARIABLE NAME{15810
{{MOV{7,XR{3,DEFLB{{ELSE SET SPECIFIED ENTRY{15811
*
*      SCAN FUNCTION NAME
*
{SDF01{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{15815
{{ERR{1,081{26,DEFINE first argument is not a string{{{15816
{{ERR{1,082{26,DEFINE first argument is null{{{15817
{{MOV{18,=CH$PP{8,WC{{DELIMITER ONE = LEFT PAREN{15818
{{MOV{8,WC{7,XL{{DELIMITER TWO = LEFT PAREN{15819
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15820
{{JSR{6,XSCAN{{{SCAN OUT FUNCTION NAME{15821
{{BNZ{8,WA{6,SDF02{{JUMP IF LEFT PAREN FOUND{15822
{{ERB{1,083{26,DEFINE first argument is missing a left paren{{{15823
*
*      HERE AFTER SCANNING OUT FUNCTION NAME
*
{SDF02{JSR{6,GTNVR{{{GET VARIABLE NAME{15827
{{ERR{1,084{26,DEFINE first argument has null function name{{{15828
{{MOV{7,XR{3,DEFVR{{SAVE VRBLK POINTER FOR FUNCTION NAM{15829
{{ZER{8,WB{{{ZERO COUNT OF ARGUMENTS{15830
{{MOV{7,XS{3,DEFXS{{SAVE INITIAL STACK POINTER{15831
{{BNZ{3,DEFLB{6,SDF03{{JUMP IF SECOND ARGUMENT GIVEN{15832
{{MOV{7,XR{3,DEFLB{{ELSE DEFAULT IS FUNCTION NAME{15833
*
*      LOOP TO SCAN ARGUMENT NAMES AND STACK VRBLK POINTERS
*
{SDF03{MOV{18,=CH$RP{8,WC{{DELIMITER ONE = RIGHT PAREN{15837
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO = COMMA{15838
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15839
{{JSR{6,XSCAN{{{SCAN OUT NEXT ARGUMENT NAME{15840
{{BNZ{8,WA{6,SDF04{{SKIP IF DELIMITER FOUND{15841
{{ERB{1,085{26,Null arg name or missing ) in DEFINE first arg.{{{15842
{{EJC{{{{{15843
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING AN ARGUMENT NAME
*
{SDF04{BNE{7,XR{21,=NULLS{6,SDF05{SKIP IF NON-NULL{15849
{{BZE{8,WB{6,SDF06{{IGNORE NULL IF CASE OF NO ARGUMENTS{15850
*
*      HERE AFTER DEALING WITH THE CASE OF NO ARGUMENTS
*
{SDF05{JSR{6,GTNVR{{{GET VRBLK POINTER{15854
{{PPM{6,SDF03{{{LOOP BACK TO IGNORE NULL NAME{15855
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT VRBLK POINTER{15856
{{ICV{8,WB{{{INCREMENT COUNTER{15857
{{BEQ{8,WA{18,=NUM02{6,SDF03{LOOP BACK IF STOPPED BY A COMMA{15858
*
*      HERE AFTER SCANNING OUT FUNCTION ARGUMENT NAMES
*
{SDF06{MOV{8,WB{3,DEFNA{{SAVE NUMBER OF ARGUMENTS{15862
{{ZER{8,WB{{{ZERO COUNT OF LOCALS{15863
*
*      LOOP TO SCAN LOCAL NAMES AND STACK VRBLK POINTERS
*
{SDF07{MOV{18,=CH$CM{8,WC{{SET DELIMITER ONE = COMMA{15867
{{MOV{8,WC{7,XL{{SET DELIMITER TWO = COMMA{15868
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{15869
{{JSR{6,XSCAN{{{SCAN OUT NEXT LOCAL NAME{15870
{{BNE{7,XR{21,=NULLS{6,SDF08{SKIP IF NON-NULL{15871
{{BZE{8,WA{6,SDF09{{EXIT SCAN IF END OF STRING{15872
*
*      HERE AFTER SCANNING OUT A LOCAL NAME
*
{SDF08{JSR{6,GTNVR{{{GET VRBLK POINTER{15876
{{PPM{6,SDF07{{{LOOP BACK TO IGNORE NULL NAME{15877
{{ICV{8,WB{{{IF OK, INCREMENT COUNT{15878
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{15879
{{BNZ{8,WA{6,SDF07{{LOOP BACK IF STOPPED BY A COMMA{15880
{{EJC{{{{{15881
*
*      DEFINE (CONTINUED)
*
*      HERE AFTER SCANNING LOCALS, BUILD PFBLK
*
{SDF09{MOV{8,WB{8,WA{{COPY COUNT OF LOCALS{15887
{{ADD{3,DEFNA{8,WA{{ADD NUMBER OF ARGUMENTS{15888
{{MOV{8,WA{8,WC{{SET SUM ARGS+LOCALS AS LOOP COUNT{15889
{{ADD{18,=PFSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{15890
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{15891
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR PFBLK{15892
{{MOV{7,XR{7,XL{{SAVE POINTER TO PFBLK{15893
{{MOV{22,=B$PFC{10,(XR)+{{STORE FIRST WORD{15894
{{MOV{3,DEFNA{10,(XR)+{{STORE NUMBER OF ARGUMENTS{15895
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (PFLEN){15896
{{MOV{3,DEFVR{10,(XR)+{{STORE VRBLK PTR FOR FUNCTION NAME{15897
{{MOV{8,WB{10,(XR)+{{STORE NUMBER OF LOCALS{15898
{{ZER{10,(XR)+{{{DEAL WITH LABEL LATER{15899
{{ZER{10,(XR)+{{{ZERO PFCTR{15900
{{ZER{10,(XR)+{{{ZERO PFRTR{15901
{{BZE{8,WC{6,SDF11{{SKIP IF NO ARGS OR LOCALS{15902
{{MOV{7,XL{8,WA{{KEEP PFBLK POINTER{15903
{{MOV{3,DEFXS{7,XT{{POINT BEFORE ARGUMENTS{15904
{{LCT{8,WC{8,WC{{GET COUNT OF ARGS+LOCALS FOR LOOP{15905
*
*      LOOP TO MOVE LOCALS AND ARGS TO PFBLK
*
{SDF10{MOV{11,-(XT){10,(XR)+{{STORE ONE ENTRY AND BUMP POINTERS{15909
{{BCT{8,WC{6,SDF10{{LOOP TILL ALL STORED{15910
{{MOV{8,WA{7,XL{{RECOVER PFBLK POINTER{15911
{{EJC{{{{{15912
*
*      DEFINE (CONTINUED)
*
*      NOW DEAL WITH LABEL
*
{SDF11{MOV{3,DEFXS{7,XS{{POP STACK{15918
{{MOV{3,DEFLB{13,PFCOD(XL){{STORE LABEL VRBLK IN PFBLK{15919
{{MOV{3,DEFVR{7,XR{{POINT BACK TO VRBLK FOR FUNCTION{15920
{{JSR{6,DFFNC{{{DEFINE FUNCTION{15921
{{BRN{6,EXNUL{{{AND EXIT RETURNING NULL{15922
*
*      HERE FOR ERRONEOUS LABEL
*
{SDF12{ERB{1,086{26,DEFINE function entry point is not defined label{{{15926
{{EJC{{{{{15927
*
*      DETACH
*
{S$DET{ENT{{{{ENTRY POINT{15931
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{15932
{{JSR{6,GTVAR{{{LOCATE VARIABLE{15933
{{ERR{1,087{26,DETACH argument is not appropriate name{{{15934
{{JSR{6,DTACH{{{DETACH I/O ASSOCIATION FROM NAME{15935
{{BRN{6,EXNUL{{{RETURN NULL RESULT{15936
{{EJC{{{{{15937
*
*      DIFFER
*
{S$DIF{ENT{{{{ENTRY POINT{15941
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{15942
{{MOV{10,(XS)+{7,XL{{LOAD FIRST ARGUMENT{15943
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{15944
{{PPM{6,EXFAL{{{FAIL IF IDENT{15945
{{BRN{6,EXNUL{{{RETURN NULL IF DIFFER{15946
{{EJC{{{{{15947
*
*      DUMP
*
{S$DMP{ENT{{{{ENTRY POINT{15951
{{JSR{6,GTSMI{{{LOAD DUMP ARG AS SMALL INTEGER{15952
{{ERR{1,088{26,DUMP argument is not integer{{{15953
{{ERR{1,089{26,DUMP argument is negative or too large{{{15954
{{JSR{6,DUMPR{{{ELSE CALL DUMP ROUTINE{15955
{{BRN{6,EXNUL{{{AND RETURN NULL AS RESULT{15956
{{EJC{{{{{15957
*
*      DUPL
*
{S$DUP{ENT{{{{ENTRY POINT{15961
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT AS SMALL INTEGR{15962
{{ERR{1,090{26,DUPL second argument is not integer{{{15963
{{PPM{6,SDUP7{{{JUMP IF NEGATIVE OR TOO BIG{15964
{{MOV{7,XR{8,WB{{SAVE DUPLICATION FACTOR{15965
{{JSR{6,GTSTG{{{GET FIRST ARG AS STRING{15966
{{PPM{6,SDUP4{{{JUMP IF NOT A STRING{15967
*
*      HERE FOR CASE OF DUPLICATION OF A STRING
*
{{MTI{8,WA{{{ACQUIRE LENGTH AS INTEGER{15971
{{STI{3,DUPSI{{{SAVE FOR THE MOMENT{15972
{{MTI{8,WB{{{GET DUPLICATION FACTOR AS INTEGER{15973
{{MLI{3,DUPSI{{{FORM PRODUCT{15974
{{IOV{6,SDUP3{{{JUMP IF OVERFLOW{15975
{{IEQ{6,EXNUL{{{RETURN NULL IF RESULT LENGTH = 0{15976
{{MFI{8,WA{6,SDUP3{{GET AS ADDR INTEGER, CHECK OVFLO{15977
*
*      MERGE HERE WITH RESULT LENGTH IN WA
*
{SDUP1{MOV{7,XR{7,XL{{SAVE STRING POINTER{15981
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR STRING{15982
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT POINTER{15983
{{MOV{7,XL{8,WC{{SAVE POINTER TO ARGUMENT STRING{15984
{{PSC{7,XR{{{PREPARE TO STORE CHARS OF RESULT{15985
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{15986
*
*      LOOP THROUGH DUPLICATIONS
*
{SDUP2{MOV{8,WC{7,XL{{POINT BACK TO ARGUMENT STRING{15990
{{MOV{13,SCLEN(XL){8,WA{{GET NUMBER OF CHARACTERS{15991
{{PLC{7,XL{{{POINT TO CHARS IN ARGUMENT STRING{15992
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{15993
{{BCT{8,WB{6,SDUP2{{LOOP TILL ALL DUPLICATIONS DONE{15994
{{ZER{7,XL{{{CLEAR GARBAGE VALUE{15995
{{LCW{7,XR{{{GET NEXT CODE WORD{15996
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{15997
{{EJC{{{{{15998
*
*      DUPL (CONTINUED)
*
*      HERE IF TOO LARGE, SET MAX LENGTH AND LET ALOCS CATCH IT
*
{SDUP3{MOV{3,DNAME{8,WA{{SET IMPOSSIBLE LENGTH FOR ALOCS{16004
{{BRN{6,SDUP1{{{MERGE BACK{16005
*
*      HERE IF NOT A STRING
*
{SDUP4{JSR{6,GTPAT{{{CONVERT ARGUMENT TO PATTERN{16009
{{ERR{1,091{26,DUPL first argument is not a string or pattern{{{16010
*
*      HERE TO DUPLICATE A PATTERN ARGUMENT
*
{{MOV{7,XR{11,-(XS){{STORE PATTERN ON STACK{16014
{{MOV{21,=NDNTH{7,XR{{START OFF WITH NULL PATTERN{16015
{{BZE{8,WB{6,SDUP6{{NULL PATTERN IS RESULT IF DUPFAC=0{16016
{{MOV{8,WB{11,-(XS){{PRESERVE LOOP COUNT{16017
*
*      LOOP TO DUPLICATE BY SUCCESSIVE CONCATENATION
*
{SDUP5{MOV{7,XR{7,XL{{COPY CURRENT VALUE AS RIGHT ARGUMNT{16021
{{MOV{12,1(XS){7,XR{{GET A NEW COPY OF LEFT{16022
{{JSR{6,PCONC{{{CONCATENATE{16023
{{DCV{9,(XS){{{COUNT DOWN{16024
{{BNZ{9,(XS){6,SDUP5{{LOOP{16025
{{ICA{7,XS{{{POP LOOP COUNT{16026
*
*      HERE TO EXIT AFTER CONSTRUCTING PATTERN
*
{SDUP6{MOV{7,XR{9,(XS){{STORE RESULT ON STACK{16030
{{LCW{7,XR{{{GET NEXT CODE WORD{16031
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16032
*
*      FAIL IF SECOND ARG IS OUT OF RANGE
*
{SDUP7{ICA{7,XS{{{POP FIRST ARGUMENT{16036
{{BRN{6,EXFAL{{{FAIL{16037
{{EJC{{{{{16038
*
*      EJECT
*
{S$EJC{ENT{{{{ENTRY POINT{16042
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{16043
{{ERR{1,092{26,EJECT argument is not a suitable name{{{16044
{{PPM{6,SEJC1{{{NULL ARGUMENT{16045
{{ERR{1,093{26,EJECT file does not exist{{{16046
{{JSR{6,SYSEF{{{CALL EJECT FILE FUNCTION{16047
{{ERR{1,093{26,EJECT file does not exist{{{16048
{{ERR{1,094{26,EJECT file does not permit page eject{{{16049
{{ERR{1,095{26,EJECT caused non-recoverable output error{{{16050
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{16051
*
*      HERE TO EJECT STANDARD OUTPUT FILE
*
{SEJC1{JSR{6,SYSEP{{{CALL ROUTINE TO EJECT PRINTER{16055
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{16056
{{EJC{{{{{16057
*
*      ENDFILE
*
{S$ENF{ENT{{{{ENTRY POINT{16061
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{16062
{{ERR{1,096{26,ENDFILE argument is not a suitable name{{{16063
{{ERR{1,097{26,ENDFILE argument is null{{{16064
{{ERR{1,098{26,ENDFILE file does not exist{{{16065
{{JSR{6,SYSEN{{{CALL ENDFILE ROUTINE{16066
{{ERR{1,098{26,ENDFILE file does not exist{{{16067
{{ERR{1,099{26,ENDFILE file does not permit endfile{{{16068
{{ERR{1,100{26,ENDFILE caused non-recoverable output error{{{16069
{{MOV{7,XL{8,WB{{REMEMBER VRBLK PTR FROM IOFCB CALL{16070
{{MOV{7,XL{7,XR{{COPY POINTER{16071
*
*      LOOP TO FIND TRTRF BLOCK
*
{SENF1{MOV{7,XR{7,XL{{REMEMBER PREVIOUS ENTRY{16075
{{MOV{13,TRVAL(XR){7,XR{{CHAIN ALONG{16076
{{BNE{9,(XR){22,=B$TRT{6,EXNUL{SKIP OUT IF CHAIN END{16077
{{BNE{13,TRTYP(XR){18,=TRTFC{6,SENF1{LOOP IF NOT FOUND{16078
{{MOV{13,TRVAL(XR){13,TRVAL(XL){{REMOVE TRTRF{16079
{{MOV{13,TRTRF(XR){3,ENFCH{{POINT TO HEAD OF IOCHN{16080
{{MOV{13,TRFPT(XR){8,WC{{POINT TO FCBLK{16081
{{MOV{8,WB{7,XR{{FILEARG1 VRBLK FROM IOFCB{16082
{{JSR{6,SETVR{{{RESET IT{16083
{{MOV{20,=R$FCB{7,XL{{PTR TO HEAD OF FCBLK CHAIN{16084
{{SUB{19,*NUM02{7,XL{{ADJUST READY TO ENTER LOOP{16085
*
*      FIND FCBLK
*
{SENF2{MOV{7,XL{7,XR{{COPY PTR{16089
{{MOV{12,2(XL){7,XL{{GET NEXT LINK{16090
{{BZE{7,XL{6,SENF4{{STOP IF CHAIN END{16091
{{BEQ{12,3(XL){8,WC{6,SENF3{JUMP IF FCBLK FOUND{16092
{{BRN{6,SENF2{{{LOOP{16093
*
*      REMOVE FCBLK
*
{SENF3{MOV{12,2(XL){12,2(XR){{DELETE FCBLK FROM CHAIN{16097
*
*      LOOP WHICH DETACHES ALL VBLS ON IOCHN CHAIN
*
{SENF4{MOV{3,ENFCH{7,XL{{GET CHAIN HEAD{16101
{{BZE{7,XL{6,EXNUL{{FINISHED IF CHAIN END{16102
{{MOV{13,TRTRF(XL){3,ENFCH{{CHAIN ALONG{16103
{{MOV{13,IONMO(XL){8,WA{{NAME OFFSET{16104
{{MOV{13,IONMB(XL){7,XL{{NAME BASE{16105
{{JSR{6,DTACH{{{DETACH NAME{16106
{{BRN{6,SENF4{{{LOOP TILL DONE{16107
{{EJC{{{{{16108
*
*      EQ
*
{S$EQF{ENT{{{{ENTRY POINT{16112
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16113
{{ERR{1,101{26,EQ first argument is not numeric{{{16114
{{ERR{1,102{26,EQ second argument is not numeric{{{16115
{{PPM{6,EXFAL{{{FAIL IF LT{16116
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16117
{{PPM{6,EXFAL{{{FAIL IF GT{16118
{{EJC{{{{{16119
*
*      EVAL
*
{S$EVL{ENT{{{{ENTRY POINT{16123
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16124
{{LCW{8,WC{{{LOAD NEXT CODE WORD{16130
{{BNE{8,WC{21,=OFNE${6,SEVL1{JUMP IF CALLED BY VALUE{16131
{{SCP{7,XL{{{COPY CODE POINTER{16132
{{MOV{9,(XL){8,WA{{GET NEXT CODE WORD{16133
{{BNE{8,WA{21,=ORNM${6,SEVL2{BY NAME UNLESS EXPRESSION{16134
{{BNZ{12,1(XS){6,SEVL2{{JUMP IF BY NAME{16135
*
*      HERE IF CALLED BY VALUE
*
{SEVL1{ZER{8,WB{{{SET FLAG FOR BY VALUE{16139
{{MOV{8,WC{11,-(XS){{SAVE CODE WORD{16141
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{16142
{{ERR{1,103{26,EVAL argument is not expression{{{16143
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16144
{{ZER{8,WB{{{SET FLAG FOR BY VALUE{16145
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY VALUE{16149
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{16150
{{MOV{7,XR{7,XL{{COPY RESULT{16151
{{MOV{9,(XS){7,XR{{RELOAD NEXT CODE WORD{16152
{{MOV{7,XL{9,(XS){{STACK RESULT{16153
{{BRI{9,(XR){{{JUMP TO EXECUTE NEXT CODE WORD{16154
*
*      HERE IF CALLED BY NAME
*
{SEVL2{MOV{18,=NUM01{8,WB{{SET FLAG FOR BY NAME{16158
{{JSR{6,GTEXP{{{CONVERT TO EXPRESSION{16160
{{ERR{1,103{26,EVAL argument is not expression{{{16161
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16162
{{MOV{18,=NUM01{8,WB{{SET FLAG FOR BY NAME{16163
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{16165
{{PPM{6,EXFAL{{{FAIL IF EVALUATION FAILS{16166
{{BRN{6,EXNAM{{{EXIT WITH NAME{16167
{{EJC{{{{{16170
*
*      EXIT
*
{S$EXT{ENT{{{{ENTRY POINT{16174
{{ZER{8,WB{{{CLEAR AMOUNT OF STATIC SHIFT{16175
{{ZER{3,R$CCB{{{FORGET INTERIM CODE BLOCK{16176
{{JSR{6,GBCOL{{{COMPACT MEMORY BY COLLECTING{16182
{{JSR{6,GTSTG{{{{16184
{{ERR{1,288{26,EXIT second argument is not a string{{{16185
{{MOV{7,XR{7,XL{{COPY SECOND ARG STRING POINTER{16186
{{JSR{6,GTSTG{{{CONVERT ARG TO STRING{16187
{{ERR{1,104{26,EXIT first argument is not suitable integer or string{{{16188
{{MOV{7,XL{11,-(XS){{SAVE SECOND ARGUMENT{16189
{{MOV{7,XR{7,XL{{COPY FIRST ARG STRING PTR{16190
{{JSR{6,GTINT{{{CHECK IT IS INTEGER{16191
{{PPM{6,SEXT1{{{SKIP IF UNCONVERTIBLE{16192
{{ZER{7,XL{{{NOTE IT IS INTEGER{16193
{{LDI{13,ICVAL(XR){{{GET INTEGER ARG{16194
*
*      MERGE TO CALL OSINT EXIT ROUTINE
*
{SEXT1{MOV{3,R$FCB{8,WB{{GET FCBLK CHAIN HEADER{16198
{{MOV{21,=HEADV{7,XR{{POINT TO V.V STRING{16199
{{MOV{10,(XS)+{8,WA{{PROVIDE SECOND ARGUMENT SCBLK{16200
{{JSR{6,SYSXI{{{CALL EXTERNAL ROUTINE{16201
{{ERR{1,105{26,EXIT action not available in this implementation{{{16202
{{ERR{1,106{26,EXIT action caused irrecoverable error{{{16203
{{IEQ{6,EXNUL{{{RETURN IF ARGUMENT 0{16204
{{IGT{6,SEXT2{{{SKIP IF POSITIVE{16205
{{NGI{{{{MAKE POSITIVE{16206
*
*      CHECK FOR OPTION RESPECIFICATION
*
*      SYSXI RETURNS 0 IN WA WHEN A FILE HAS BEEN RESUMED,
*      1 WHEN THIS IS A CONTINUATION OF AN EXIT(4) OR EXIT(-4)
*      ACTION.
*
{SEXT2{MFI{8,WC{{{GET VALUE IN WORK REG{16214
{{ADD{8,WC{8,WA{{PREPARE TO TEST FOR CONTINUE{16215
{{BEQ{8,WA{18,=NUM05{6,SEXT5{CONTINUED EXECUTION IF 4 PLUS 1{16216
{{ZER{3,GBCNT{{{RESUMING EXECUTION SO RESET{16217
{{BGE{8,WC{18,=NUM03{6,SEXT3{SKIP IF WAS 3 OR 4{16218
{{MOV{8,WC{11,-(XS){{SAVE VALUE{16219
{{ZER{8,WC{{{SET TO READ OPTIONS{16220
{{JSR{6,PRPAR{{{READ SYSPP OPTIONS{16221
{{MOV{10,(XS)+{8,WC{{RESTORE VALUE{16222
*
*      DEAL WITH HEADER OPTION (FIDDLED BY PRPAR)
*
{SEXT3{MNZ{3,HEADP{{{ASSUME NO HEADERS{16226
{{BNE{8,WC{18,=NUM01{6,SEXT4{SKIP IF NOT 1{16227
{{ZER{3,HEADP{{{REQUEST HEADER PRINTING{16228
*
*      ALMOST READY TO RESUME RUNNING
*
{SEXT4{JSR{6,SYSTM{{{GET EXECUTION TIME START (SGD11){16232
{{STI{3,TIMSX{{{SAVE AS INITIAL TIME{16233
{{LDI{3,KVSTC{{{RESET TO ENSURE ...{16234
{{STI{3,KVSTL{{{... CORRECT EXECUTION STATS{16235
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{16236
{{BRN{6,EXNUL{{{RESUME EXECUTION{16237
*
*      HERE AFTER EXIT(4) OR EXIT(-4) -- CREATE SAVE FILE
*      OR LOAD MODULE AND CONTINUE EXECUTION.
*
*      RETURN INTEGER 1 TO SIGNAL THE CONTINUATION OF THE
*      ORIGINAL EXECUTION.
*
{SEXT5{MOV{21,=INTON{7,XR{{INTEGER ONE{16245
{{BRN{6,EXIXR{{{RETURN AS RESULT{16246
{{EJC{{{{{16248
*
*      EXP
*
{S$EXP{ENT{{{{ENTRY POINT{16253
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16254
{{JSR{6,GTREA{{{CONVERT TO REAL{16255
{{ERR{1,304{26,EXP argument not numeric{{{16256
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{16257
{{ETX{{{{TAKE EXPONENTIAL{16258
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{16259
{{ERB{1,305{26,EXP produced real overflow{{{16260
{{EJC{{{{{16261
*
*      FIELD
*
{S$FLD{ENT{{{{ENTRY POINT{16266
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (FIELD NUMBER){16267
{{ERR{1,107{26,FIELD second argument is not integer{{{16268
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{16269
{{MOV{7,XR{8,WB{{ELSE SAVE INTEGER VALUE{16270
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16271
{{JSR{6,GTNVR{{{POINT TO VRBLK{16272
{{PPM{6,SFLD1{{{JUMP (ERROR) IF NOT VARIABLE NAME{16273
{{MOV{13,VRFNC(XR){7,XR{{ELSE POINT TO FUNCTION BLOCK{16274
{{BNE{9,(XR){22,=B$DFC{6,SFLD1{ERROR IF NOT DATATYPE FUNCTION{16275
*
*      HERE IF FIRST ARGUMENT IS A DATATYPE FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF ARGUMENT NUMBER IS ZERO{16279
{{BGT{8,WB{13,FARGS(XR){6,EXFAL{FAIL IF TOO LARGE{16280
{{WTB{8,WB{{{ELSE CONVERT TO BYTE OFFSET{16281
{{ADD{8,WB{7,XR{{POINT TO FIELD NAME{16282
{{MOV{13,DFFLB(XR){7,XR{{LOAD VRBLK POINTER{16283
{{BRN{6,EXVNM{{{EXIT TO BUILD NMBLK{16284
*
*      HERE FOR BAD FIRST ARGUMENT
*
{SFLD1{ERB{1,108{26,FIELD first argument is not datatype name{{{16288
{{EJC{{{{{16289
*
*      FENCE
*
{S$FNC{ENT{{{{ENTRY POINT{16293
{{MOV{22,=P$FNC{8,WB{{SET PCODE FOR P$FNC{16294
{{ZER{7,XR{{{P0BLK{16295
{{JSR{6,PBILD{{{BUILD P$FNC NODE{16296
{{MOV{7,XR{7,XL{{SAVE POINTER TO IT{16297
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16298
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{16299
{{ERR{1,259{26,FENCE argument is not pattern{{{16300
{{JSR{6,PCONC{{{CONCATENATE TO P$FNC NODE{16301
{{MOV{7,XR{7,XL{{SAVE PTR TO CONCATENATED PATTERN{16302
{{MOV{22,=P$FNA{8,WB{{SET FOR P$FNA PCODE{16303
{{ZER{7,XR{{{P0BLK{16304
{{JSR{6,PBILD{{{CONSTRUCT P$FNA NODE{16305
{{MOV{7,XL{13,PTHEN(XR){{SET PATTERN AS PTHEN{16306
{{MOV{7,XR{11,-(XS){{SET AS RESULT{16307
{{LCW{7,XR{{{GET NEXT CODE WORD{16308
{{BRI{9,(XR){{{EXECUTE NEXT CODE WORD{16309
{{EJC{{{{{16310
*
*      GE
*
{S$GEF{ENT{{{{ENTRY POINT{16314
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16315
{{ERR{1,109{26,GE first argument is not numeric{{{16316
{{ERR{1,110{26,GE second argument is not numeric{{{16317
{{PPM{6,EXFAL{{{FAIL IF LT{16318
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16319
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16320
{{EJC{{{{{16321
*
*      GT
*
{S$GTF{ENT{{{{ENTRY POINT{16325
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16326
{{ERR{1,111{26,GT first argument is not numeric{{{16327
{{ERR{1,112{26,GT second argument is not numeric{{{16328
{{PPM{6,EXFAL{{{FAIL IF LT{16329
{{PPM{6,EXFAL{{{FAIL IF EQ{16330
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16331
{{EJC{{{{{16332
*
*      HOST
*
{S$HST{ENT{{{{ENTRY POINT{16336
{{MOV{10,(XS)+{8,WC{{GET FIFTH ARG{16337
{{MOV{10,(XS)+{8,WB{{GET FOURTH ARG{16338
{{MOV{10,(XS)+{7,XR{{GET THIRD ARG{16339
{{MOV{10,(XS)+{7,XL{{GET SECOND ARG{16340
{{MOV{10,(XS)+{8,WA{{GET FIRST ARG{16341
{{JSR{6,SYSHS{{{ENTER SYSHS ROUTINE{16342
{{ERR{1,254{26,Erroneous argument for HOST{{{16343
{{ERR{1,255{26,Error during execution of HOST{{{16344
{{PPM{6,SHST1{{{STORE HOST STRING{16345
{{PPM{6,EXNUL{{{RETURN NULL RESULT{16346
{{PPM{6,EXIXR{{{RETURN XR{16347
{{PPM{6,EXFAL{{{FAIL RETURN{16348
{{PPM{6,SHST3{{{STORE ACTUAL STRING{16349
{{PPM{6,SHST4{{{RETURN COPY OF XR{16350
*
*      RETURN HOST STRING
*
{SHST1{BZE{7,XL{6,EXNUL{{NULL STRING IF SYSHS UNCOOPERATIVE{16354
{{MOV{13,SCLEN(XL){8,WA{{LENGTH{16355
{{ZER{8,WB{{{ZERO OFFSET{16356
*
*      COPY STRING AND RETURN
*
{SHST2{JSR{6,SBSTR{{{BUILD COPY OF STRING{16360
{{MOV{7,XR{11,-(XS){{STACK THE RESULT{16361
{{LCW{7,XR{{{LOAD NEXT CODE WORD{16362
{{BRI{9,(XR){{{EXECUTE IT{16363
*
*      RETURN ACTUAL STRING POINTED TO BY XL
*
{SHST3{ZER{8,WB{{{TREAT XL LIKE AN SCBLK PTR{16367
{{SUB{18,=CFP$F{8,WB{{BY CREATING A NEGATIVE OFFSET{16368
{{BRN{6,SHST2{{{JOIN TO COPY STRING{16369
*
*      RETURN COPY OF BLOCK POINTED TO BY XR
*
{SHST4{MOV{7,XR{11,-(XS){{STACK RESULTS{16373
{{JSR{6,COPYB{{{MAKE COPY OF BLOCK{16374
{{PPM{6,EXITS{{{IF NOT AN AGGREGATE STRUCTURE{16375
{{BRN{6,EXSID{{{SET CURRENT ID VALUE OTHERWISE{16376
{{EJC{{{{{16377
*
*      IDENT
*
{S$IDN{ENT{{{{ENTRY POINT{16381
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{16382
{{MOV{10,(XS)+{7,XL{{LOAD FIRST ARGUMENT{16383
{{JSR{6,IDENT{{{CALL IDENT COMPARISON ROUTINE{16384
{{PPM{6,EXNUL{{{RETURN NULL IF IDENT{16385
{{BRN{6,EXFAL{{{FAIL IF DIFFER{16386
{{EJC{{{{{16387
*
*      INPUT
*
{S$INP{ENT{{{{ENTRY POINT{16391
{{ZER{8,WB{{{INPUT FLAG{16392
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{16393
{{ERR{1,113{26,INPUT third argument is not a string{{{16394
{{ERR{1,114{26,Inappropriate second argument for INPUT{{{16395
{{ERR{1,115{26,Inappropriate first argument for INPUT{{{16396
{{ERR{1,116{26,Inappropriate file specification for INPUT{{{16397
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{16398
{{ERR{1,117{26,INPUT file cannot be read{{{16399
{{ERR{1,289{26,INPUT channel currently in use{{{16400
{{BRN{6,EXNUL{{{RETURN NULL STRING{16401
{{EJC{{{{{16402
*
*      INTEGER
*
{S$INT{ENT{{{{ENTRY POINT{16435
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16436
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{16437
{{PPM{6,EXFAL{{{FAIL IF NON-NUMERIC{16438
{{BEQ{8,WA{22,=B$ICL{6,EXNUL{RETURN NULL IF INTEGER{16439
{{BRN{6,EXFAL{{{FAIL IF REAL{16440
{{EJC{{{{{16441
*
*      ITEM
*
*      ITEM DOES NOT PERMIT THE DIRECT (FAST) CALL SO THAT
*      WA CONTAINS THE ACTUAL NUMBER OF ARGUMENTS PASSED.
*
{S$ITM{ENT{{{{ENTRY POINT{16448
*
*      DEAL WITH CASE OF NO ARGS
*
{{BNZ{8,WA{6,SITM1{{JUMP IF AT LEAST ONE ARG{16452
{{MOV{21,=NULLS{11,-(XS){{ELSE SUPPLY GARBAGE NULL ARG{16453
{{MOV{18,=NUM01{8,WA{{AND FIX ARGUMENT COUNT{16454
*
*      CHECK FOR NAME/VALUE CASES
*
{SITM1{SCP{7,XR{{{GET CURRENT CODE POINTER{16458
{{MOV{9,(XR){7,XL{{LOAD NEXT CODE WORD{16459
{{DCV{8,WA{{{GET NUMBER OF SUBSCRIPTS{16460
{{MOV{8,WA{7,XR{{COPY FOR ARREF{16461
{{BEQ{7,XL{21,=OFNE${6,SITM2{JUMP IF CALLED BY NAME{16462
*
*      HERE IF CALLED BY VALUE
*
{{ZER{8,WB{{{SET CODE FOR CALL BY VALUE{16466
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{16467
*
*      HERE FOR CALL BY NAME
*
{SITM2{MNZ{8,WB{{{SET CODE FOR CALL BY NAME{16471
{{LCW{8,WA{{{LOAD AND IGNORE OFNE$ CALL{16472
{{BRN{6,ARREF{{{OFF TO ARRAY REFERENCE ROUTINE{16473
{{EJC{{{{{16474
*
*      LE
*
{S$LEF{ENT{{{{ENTRY POINT{16478
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16479
{{ERR{1,118{26,LE first argument is not numeric{{{16480
{{ERR{1,119{26,LE second argument is not numeric{{{16481
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16482
{{PPM{6,EXNUL{{{RETURN NULL IF EQ{16483
{{PPM{6,EXFAL{{{FAIL IF GT{16484
{{EJC{{{{{16485
*
*      LEN
*
{S$LEN{ENT{{{{ENTRY POINT{16489
{{MOV{22,=P$LEN{8,WB{{SET PCODE FOR INTEGER ARG CASE{16490
{{MOV{22,=P$LND{8,WA{{SET PCODE FOR EXPR ARG CASE{16491
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{16492
{{ERR{1,120{26,LEN argument is not integer or expression{{{16493
{{ERR{1,121{26,LEN argument is negative or too large{{{16494
{{MOV{7,XR{11,-(XS){{STACK RESULT{16495
{{LCW{7,XR{{{GET NEXT CODE WORD{16496
{{BRI{9,(XR){{{EXECUTE IT{16497
{{EJC{{{{{16498
*
*      LEQ
*
{S$LEQ{ENT{{{{ENTRY POINT{16502
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16503
{{ERR{1,122{26,LEQ first argument is not a string{{{16504
{{ERR{1,123{26,LEQ second argument is not a string{{{16505
{{PPM{6,EXFAL{{{FAIL IF LLT{16506
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16507
{{PPM{6,EXFAL{{{FAIL IF LGT{16508
{{EJC{{{{{16509
*
*      LGE
*
{S$LGE{ENT{{{{ENTRY POINT{16513
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16514
{{ERR{1,124{26,LGE first argument is not a string{{{16515
{{ERR{1,125{26,LGE second argument is not a string{{{16516
{{PPM{6,EXFAL{{{FAIL IF LLT{16517
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16518
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16519
{{EJC{{{{{16520
*
*      LGT
*
{S$LGT{ENT{{{{ENTRY POINT{16524
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16525
{{ERR{1,126{26,LGT first argument is not a string{{{16526
{{ERR{1,127{26,LGT second argument is not a string{{{16527
{{PPM{6,EXFAL{{{FAIL IF LLT{16528
{{PPM{6,EXFAL{{{FAIL IF LEQ{16529
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16530
{{EJC{{{{{16531
*
*      LLE
*
{S$LLE{ENT{{{{ENTRY POINT{16535
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16536
{{ERR{1,128{26,LLE first argument is not a string{{{16537
{{ERR{1,129{26,LLE second argument is not a string{{{16538
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16539
{{PPM{6,EXNUL{{{RETURN NULL IF LEQ{16540
{{PPM{6,EXFAL{{{FAIL IF LGT{16541
{{EJC{{{{{16542
*
*      LLT
*
{S$LLT{ENT{{{{ENTRY POINT{16546
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16547
{{ERR{1,130{26,LLT first argument is not a string{{{16548
{{ERR{1,131{26,LLT second argument is not a string{{{16549
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16550
{{PPM{6,EXFAL{{{FAIL IF LEQ{16551
{{PPM{6,EXFAL{{{FAIL IF LGT{16552
{{EJC{{{{{16553
*
*      LNE
*
{S$LNE{ENT{{{{ENTRY POINT{16557
{{JSR{6,LCOMP{{{CALL STRING COMPARISON ROUTINE{16558
{{ERR{1,132{26,LNE first argument is not a string{{{16559
{{ERR{1,133{26,LNE second argument is not a string{{{16560
{{PPM{6,EXNUL{{{RETURN NULL IF LLT{16561
{{PPM{6,EXFAL{{{FAIL IF LEQ{16562
{{PPM{6,EXNUL{{{RETURN NULL IF LGT{16563
{{EJC{{{{{16564
*
*      LN
*
{S$LNF{ENT{{{{ENTRY POINT{16569
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{16570
{{JSR{6,GTREA{{{CONVERT TO REAL{16571
{{ERR{1,306{26,LN argument not numeric{{{16572
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{16573
{{REQ{6,SLNF1{{{OVERFLOW IF ARGUMENT IS 0{16574
{{RLT{6,SLNF2{{{ERROR IF ARGUMENT LESS THAN 0{16575
{{LNF{{{{TAKE NATURAL LOGARITHM{16576
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{16577
{SLNF1{ERB{1,307{26,LN produced real overflow{{{16578
*
*      HERE FOR BAD ARGUMENT
*
{SLNF2{ERB{1,315{26,LN argument negative{{{16582
{{EJC{{{{{16583
*
*      LOCAL
*
{S$LOC{ENT{{{{ENTRY POINT{16588
{{JSR{6,GTSMI{{{GET SECOND ARGUMENT (LOCAL NUMBER){16589
{{ERR{1,134{26,LOCAL second argument is not integer{{{16590
{{PPM{6,EXFAL{{{FAIL IF OUT OF RANGE{16591
{{MOV{7,XR{8,WB{{SAVE LOCAL NUMBER{16592
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16593
{{JSR{6,GTNVR{{{POINT TO VRBLK{16594
{{PPM{6,SLOC1{{{JUMP IF NOT VARIABLE NAME{16595
{{MOV{13,VRFNC(XR){7,XR{{ELSE LOAD FUNCTION POINTER{16596
{{BNE{9,(XR){22,=B$PFC{6,SLOC1{JUMP IF NOT PROGRAM DEFINED{16597
*
*      HERE IF WE HAVE A PROGRAM DEFINED FUNCTION NAME
*
{{BZE{8,WB{6,EXFAL{{FAIL IF SECOND ARG IS ZERO{16601
{{BGT{8,WB{13,PFNLO(XR){6,EXFAL{OR TOO LARGE{16602
{{ADD{13,FARGS(XR){8,WB{{ELSE ADJUST OFFSET TO INCLUDE ARGS{16603
{{WTB{8,WB{{{CONVERT TO BYTES{16604
{{ADD{8,WB{7,XR{{POINT TO LOCAL POINTER{16605
{{MOV{13,PFAGB(XR){7,XR{{LOAD VRBLK POINTER{16606
{{BRN{6,EXVNM{{{EXIT BUILDING NMBLK{16607
*
*      HERE IF FIRST ARGUMENT IS NO GOOD
*
{SLOC1{ERB{1,135{26,LOCAL first arg is not a program function name{{{16611
{{EJC{{{{{16614
*
*      LOAD
*
{S$LOD{ENT{{{{ENTRY POINT{16618
{{JSR{6,GTSTG{{{LOAD LIBRARY NAME{16619
{{ERR{1,136{26,LOAD second argument is not a string{{{16620
{{MOV{7,XR{7,XL{{SAVE LIBRARY NAME{16621
{{JSR{6,XSCNI{{{PREPARE TO SCAN FIRST ARGUMENT{16622
{{ERR{1,137{26,LOAD first argument is not a string{{{16623
{{ERR{1,138{26,LOAD first argument is null{{{16624
{{MOV{7,XL{11,-(XS){{STACK LIBRARY NAME{16625
{{MOV{18,=CH$PP{8,WC{{SET DELIMITER ONE = LEFT PAREN{16626
{{MOV{8,WC{7,XL{{SET DELIMITER TWO = LEFT PAREN{16627
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16628
{{JSR{6,XSCAN{{{SCAN FUNCTION NAME{16629
{{MOV{7,XR{11,-(XS){{SAVE PTR TO FUNCTION NAME{16630
{{BNZ{8,WA{6,SLOD1{{JUMP IF LEFT PAREN FOUND{16631
{{ERB{1,139{26,LOAD first argument is missing a left paren{{{16632
*
*      HERE AFTER SUCCESSFULLY SCANNING FUNCTION NAME
*
{SLOD1{JSR{6,GTNVR{{{LOCATE VRBLK{16636
{{ERR{1,140{26,LOAD first argument has null function name{{{16637
{{MOV{7,XR{3,LODFN{{SAVE VRBLK POINTER{16638
{{ZER{3,LODNA{{{ZERO COUNT OF ARGUMENTS{16639
*
*      LOOP TO SCAN ARGUMENT DATATYPE NAMES
*
{SLOD2{MOV{18,=CH$RP{8,WC{{DELIMITER ONE IS RIGHT PAREN{16643
{{MOV{18,=CH$CM{7,XL{{DELIMITER TWO IS COMMA{16644
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16645
{{JSR{6,XSCAN{{{SCAN NEXT ARGUMENT NAME{16646
{{ICV{3,LODNA{{{BUMP ARGUMENT COUNT{16647
{{BNZ{8,WA{6,SLOD3{{JUMP IF OK DELIMITER WAS FOUND{16648
{{ERB{1,141{26,LOAD first argument is missing a right paren{{{16649
{{EJC{{{{{16650
*
*      LOAD (CONTINUED)
*
*      COME HERE TO ANALYZE THE DATATYPE POINTER IN (XR). THIS
*      CODE IS USED BOTH FOR ARGUMENTS (WA=1,2) AND FOR THE
*      RESULT DATATYPE (WITH WA SET TO ZERO).
*
{SLOD3{MOV{8,WA{8,WB{{SAVE SCAN MODE{16659
{{MOV{13,SCLEN(XR){8,WA{{DATATYPE LENGTH{16660
{{BZE{8,WA{6,SLD3A{{BYPASS IF NULL STRING{16661
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{16662
{SLD3A{MOV{8,WB{8,WA{{RESTORE SCAN MODE{16663
{{MOV{7,XR{11,-(XS){{STACK DATATYPE NAME POINTER{16664
{{MOV{18,=NUM01{8,WB{{SET STRING CODE IN CASE{16668
{{MOV{21,=SCSTR{7,XL{{POINT TO /STRING/{16669
{{JSR{6,IDENT{{{CHECK FOR MATCH{16670
{{PPM{6,SLOD4{{{JUMP IF MATCH{16671
{{MOV{9,(XS){7,XR{{ELSE RELOAD NAME{16672
{{ADD{8,WB{8,WB{{SET CODE FOR INTEGER (2){16673
{{MOV{21,=SCINT{7,XL{{POINT TO /INTEGER/{16674
{{JSR{6,IDENT{{{CHECK FOR MATCH{16675
{{PPM{6,SLOD4{{{JUMP IF MATCH{16676
{{MOV{9,(XS){7,XR{{ELSE RELOAD STRING POINTER{16679
{{ICV{8,WB{{{SET CODE FOR REAL (3){16680
{{MOV{21,=SCREA{7,XL{{POINT TO /REAL/{16681
{{JSR{6,IDENT{{{CHECK FOR MATCH{16682
{{PPM{6,SLOD4{{{JUMP IF MATCH{16683
{{MOV{9,(XS){7,XR{{RELOAD STRING POINTER{16686
{{ICV{8,WB{{{CODE FOR FILE (4, OR 3 IF NO REALS){16687
{{MOV{21,=SCFIL{7,XL{{POINT TO /FILE/{16688
{{JSR{6,IDENT{{{CHECK FOR MATCH{16689
{{PPM{6,SLOD4{{{JUMP IF MATCH{16690
{{ZER{8,WB{{{ELSE GET CODE FOR NO CONVERT{16692
*
*      MERGE HERE WITH PROPER DATATYPE CODE IN WB
*
{SLOD4{MOV{8,WB{9,(XS){{STORE CODE ON STACK{16696
{{BEQ{8,WA{18,=NUM02{6,SLOD2{LOOP BACK IF ARG STOPPED BY COMMA{16697
{{BZE{8,WA{6,SLOD5{{JUMP IF THAT WAS THE RESULT TYPE{16698
*
*      HERE WE SCAN OUT THE RESULT TYPE (ARG STOPPED BY ) )
*
{{MOV{3,MXLEN{8,WC{{SET DUMMY (IMPOSSIBLE) DELIMITER 1{16702
{{MOV{8,WC{7,XL{{AND DELIMITER TWO{16703
{{MNZ{8,WA{{{SKIP/TRIM BLANKS IN PROTOTYPE{16704
{{JSR{6,XSCAN{{{SCAN RESULT NAME{16705
{{ZER{8,WA{{{SET CODE FOR PROCESSING RESULT{16706
{{BRN{6,SLOD3{{{JUMP BACK TO PROCESS RESULT NAME{16707
{{EJC{{{{{16708
*
*      LOAD (CONTINUED)
*
*      HERE AFTER PROCESSING ALL ARGS AND RESULT
*
{SLOD5{MOV{3,LODNA{8,WA{{GET NUMBER OF ARGUMENTS{16714
{{MOV{8,WA{8,WC{{COPY FOR LATER{16715
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{16716
{{ADD{19,*EFSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{16717
{{JSR{6,ALLOC{{{ALLOCATE EFBLK{16718
{{MOV{22,=B$EFC{9,(XR){{SET TYPE WORD{16719
{{MOV{8,WC{13,FARGS(XR){{SET NUMBER OF ARGUMENTS{16720
{{ZER{13,EFUSE(XR){{{SET USE COUNT (DFFNC WILL SET TO 1){16721
{{ZER{13,EFCOD(XR){{{ZERO CODE POINTER FOR NOW{16722
{{MOV{10,(XS)+{13,EFRSL(XR){{STORE RESULT TYPE CODE{16723
{{MOV{3,LODFN{13,EFVAR(XR){{STORE FUNCTION VRBLK POINTER{16724
{{MOV{8,WA{13,EFLEN(XR){{STORE EFBLK LENGTH{16725
{{MOV{7,XR{8,WB{{SAVE EFBLK POINTER{16726
{{ADD{8,WA{7,XR{{POINT PAST END OF EFBLK{16727
{{LCT{8,WC{8,WC{{SET NUMBER OF ARGUMENTS FOR LOOP{16728
*
*      LOOP TO SET ARGUMENT TYPE CODES FROM STACK
*
{SLOD6{MOV{10,(XS)+{11,-(XR){{STORE ONE TYPE CODE FROM STACK{16732
{{BCT{8,WC{6,SLOD6{{LOOP TILL ALL STORED{16733
*
*      NOW LOAD THE EXTERNAL FUNCTION AND PERFORM DEFINITION
*
{{MOV{10,(XS)+{7,XR{{LOAD FUNCTION STRING NAME{16737
{{MOV{13,SCLEN(XR){8,WA{{FUNCTION NAME LENGTH{16739
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{16740
{{MOV{9,(XS){7,XL{{LOAD LIBRARY NAME{16742
{{MOV{8,WB{9,(XS){{STORE EFBLK POINTER{16743
{{JSR{6,SYSLD{{{CALL FUNCTION TO LOAD EXTERNAL FUNC{16744
{{ERR{1,142{26,LOAD function does not exist{{{16745
{{ERR{1,143{26,LOAD function caused input error during load{{{16746
{{ERR{1,328{26,LOAD function - insufficient memory{{{16747
{{MOV{10,(XS)+{7,XL{{RECALL EFBLK POINTER{16748
{{MOV{7,XR{13,EFCOD(XL){{STORE CODE POINTER{16749
{{MOV{3,LODFN{7,XR{{POINT TO VRBLK FOR FUNCTION{16750
{{JSR{6,DFFNC{{{PERFORM FUNCTION DEFINITION{16751
{{BRN{6,EXNUL{{{RETURN NULL RESULT{16752
{{EJC{{{{{16754
*
*      LPAD
*
{S$LPD{ENT{{{{ENTRY POINT{16758
{{JSR{6,GTSTG{{{GET PAD CHARACTER{16759
{{ERR{1,144{26,LPAD third argument is not a string{{{16760
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){16761
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{16762
{{JSR{6,GTSMI{{{GET PAD LENGTH{16763
{{ERR{1,145{26,LPAD second argument is not integer{{{16764
{{PPM{6,SLPD4{{{SKIP IF NEGATIVE OR LARGE{16765
*
*      MERGE TO CHECK FIRST ARG
*
{SLPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){16769
{{ERR{1,146{26,LPAD first argument is not a string{{{16770
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{16771
{{MOV{7,XR{7,XL{{ELSE MOVE PTR TO STRING TO PAD{16772
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WC{8,WA{{COPY LENGTH{16780
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{16781
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT{16782
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH OF ARGUMENT{16783
{{SUB{8,WA{8,WC{{CALCULATE NUMBER OF PAD CHARACTERS{16784
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{16785
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{16786
*
*      LOOP TO PERFORM PAD
*
{SLPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{16790
{{BCT{8,WC{6,SLPD2{{LOOP TILL ALL PAD CHARS STORED{16791
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{16792
*
*      NOW COPY STRING
*
{{BZE{8,WA{6,SLPD3{{EXIT IF NULL STRING{16796
{{PLC{7,XL{{{ELSE POINT TO CHARS IN ARGUMENT{16797
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{16798
{{ZER{7,XL{{{CLEAR GARBAGE XL{16799
*
*      HERE TO EXIT WITH RESULT ON STACK
*
{SLPD3{LCW{7,XR{{{LOAD NEXT CODE WORD{16803
{{BRI{9,(XR){{{EXECUTE IT{16804
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SLPD4{ZER{8,WC{{{ZERO PAD COUNT{16808
{{BRN{6,SLPD1{{{MERGE{16809
{{EJC{{{{{16810
*
*      LT
*
{S$LTF{ENT{{{{ENTRY POINT{16814
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16815
{{ERR{1,147{26,LT first argument is not numeric{{{16816
{{ERR{1,148{26,LT second argument is not numeric{{{16817
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16818
{{PPM{6,EXFAL{{{FAIL IF EQ{16819
{{PPM{6,EXFAL{{{FAIL IF GT{16820
{{EJC{{{{{16821
*
*      NE
*
{S$NEF{ENT{{{{ENTRY POINT{16825
{{JSR{6,ACOMP{{{CALL ARITHMETIC COMPARISON ROUTINE{16826
{{ERR{1,149{26,NE first argument is not numeric{{{16827
{{ERR{1,150{26,NE second argument is not numeric{{{16828
{{PPM{6,EXNUL{{{RETURN NULL IF LT{16829
{{PPM{6,EXFAL{{{FAIL IF EQ{16830
{{PPM{6,EXNUL{{{RETURN NULL IF GT{16831
{{EJC{{{{{16832
*
*      NOTANY
*
{S$NAY{ENT{{{{ENTRY POINT{16836
{{MOV{22,=P$NAS{8,WB{{SET PCODE FOR SINGLE CHAR ARG{16837
{{MOV{22,=P$NAY{7,XL{{PCODE FOR MULTI-CHAR ARG{16838
{{MOV{22,=P$NAD{8,WC{{SET PCODE FOR EXPR ARG{16839
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{16840
{{ERR{1,151{26,NOTANY argument is not a string or expression{{{16841
{{MOV{7,XR{11,-(XS){{STACK RESULT{16842
{{LCW{7,XR{{{GET NEXT CODE WORD{16843
{{BRI{9,(XR){{{EXECUTE IT{16844
{{EJC{{{{{16845
*
*      OPSYN
*
{S$OPS{ENT{{{{ENTRY POINT{16849
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{16850
{{ERR{1,152{26,OPSYN third argument is not integer{{{16851
{{ERR{1,153{26,OPSYN third argument is negative or too large{{{16852
{{MOV{8,WC{8,WB{{IF OK, SAVE THIRD ARGUMNET{16853
{{MOV{10,(XS)+{7,XR{{LOAD SECOND ARGUMENT{16854
{{JSR{6,GTNVR{{{LOCATE VARIABLE BLOCK{16855
{{ERR{1,154{26,OPSYN second arg is not natural variable name{{{16856
{{MOV{13,VRFNC(XR){7,XL{{IF OK, LOAD FUNCTION BLOCK POINTER{16857
{{BNZ{8,WB{6,SOPS2{{JUMP IF OPERATOR OPSYN CASE{16858
*
*      HERE FOR FUNCTION OPSYN (THIRD ARG ZERO)
*
{{MOV{10,(XS)+{7,XR{{LOAD FIRST ARGUMENT{16862
{{JSR{6,GTNVR{{{GET VRBLK POINTER{16863
{{ERR{1,155{26,OPSYN first arg is not natural variable name{{{16864
*
*      MERGE HERE TO PERFORM FUNCTION DEFINITION
*
{SOPS1{JSR{6,DFFNC{{{CALL FUNCTION DEFINER{16868
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT{16869
*
*      HERE FOR OPERATOR OPSYN (THIRD ARG NON-ZERO)
*
{SOPS2{JSR{6,GTSTG{{{GET OPERATOR NAME{16873
{{PPM{6,SOPS5{{{JUMP IF NOT STRING{16874
{{BNE{8,WA{18,=NUM01{6,SOPS5{ERROR IF NOT ONE CHAR LONG{16875
{{PLC{7,XR{{{ELSE POINT TO CHARACTER{16876
{{LCH{8,WC{9,(XR){{LOAD CHARACTER NAME{16877
{{EJC{{{{{16878
*
*      OPSYN (CONTINUED)
*
*      NOW SET TO SEARCH FOR MATCHING UNARY OR BINARY OPERATOR
*      NAME AS APPROPRIATE. NOTE THAT THERE ARE =OPBUN UNDEFINED
*      BINARY OPERATORS AND =OPUUN UNDEFINED UNARY OPERATORS.
*
{{MOV{20,=R$UUB{8,WA{{POINT TO UNOP POINTERS IN CASE{16886
{{MOV{21,=OPNSU{7,XR{{POINT TO NAMES OF UNARY OPERATORS{16887
{{ADD{18,=OPBUN{8,WB{{ADD NO. OF UNDEFINED BINARY OPS{16888
{{BEQ{8,WB{18,=OPUUN{6,SOPS3{JUMP IF UNOP (THIRD ARG WAS 1){16889
{{MOV{20,=R$UBA{8,WA{{ELSE POINT TO BINARY OPERATOR PTRS{16890
{{MOV{21,=OPSNB{7,XR{{POINT TO NAMES OF BINARY OPERATORS{16891
{{MOV{18,=OPBUN{8,WB{{SET NUMBER OF UNDEFINED BINOPS{16892
*
*      MERGE HERE TO CHECK LIST (WB = NUMBER TO CHECK)
*
{SOPS3{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{16896
*
*      LOOP TO SEARCH FOR NAME MATCH
*
{SOPS4{BEQ{8,WC{9,(XR){6,SOPS6{JUMP IF NAMES MATCH{16900
{{ICA{8,WA{{{ELSE PUSH POINTER TO FUNCTION PTR{16901
{{ICA{7,XR{{{BUMP POINTER{16902
{{BCT{8,WB{6,SOPS4{{LOOP BACK TILL ALL CHECKED{16903
*
*      HERE IF BAD OPERATOR NAME
*
{SOPS5{ERB{1,156{26,OPSYN first arg is not correct operator name{{{16907
*
*      COME HERE ON FINDING A MATCH IN THE OPERATOR NAME TABLE
*
{SOPS6{MOV{8,WA{7,XR{{COPY POINTER TO FUNCTION BLOCK PTR{16911
{{SUB{19,*VRFNC{7,XR{{MAKE IT LOOK LIKE DUMMY VRBLK{16912
{{BRN{6,SOPS1{{{MERGE BACK TO DEFINE OPERATOR{16913
{{EJC{{{{{16914
*
*      OUTPUT
*
{S$OUP{ENT{{{{ENTRY POINT{16939
{{MOV{18,=NUM03{8,WB{{OUTPUT FLAG{16940
{{JSR{6,IOPUT{{{CALL INPUT/OUTPUT ASSOC. ROUTINE{16941
{{ERR{1,157{26,OUTPUT third argument is not a string{{{16942
{{ERR{1,158{26,Inappropriate second argument for OUTPUT{{{16943
{{ERR{1,159{26,Inappropriate first argument for OUTPUT{{{16944
{{ERR{1,160{26,Inappropriate file specification for OUTPUT{{{16945
{{PPM{6,EXFAL{{{FAIL IF FILE DOES NOT EXIST{16946
{{ERR{1,161{26,OUTPUT file cannot be written to{{{16947
{{ERR{1,290{26,OUTPUT channel currently in use{{{16948
{{BRN{6,EXNUL{{{RETURN NULL STRING{16949
{{EJC{{{{{16950
*
*      POS
*
{S$POS{ENT{{{{ENTRY POINT{16954
{{MOV{22,=P$POS{8,WB{{SET PCODE FOR INTEGER ARG CASE{16955
{{MOV{22,=P$PSD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{16956
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{16957
{{ERR{1,162{26,POS argument is not integer or expression{{{16958
{{ERR{1,163{26,POS argument is negative or too large{{{16959
{{MOV{7,XR{11,-(XS){{STACK RESULT{16960
{{LCW{7,XR{{{GET NEXT CODE WORD{16961
{{BRI{9,(XR){{{EXECUTE IT{16962
{{EJC{{{{{16963
*
*      PROTOTYPE
*
{S$PRO{ENT{{{{ENTRY POINT{16967
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{16968
{{MOV{13,TBLEN(XR){8,WB{{LENGTH IF TABLE, VECTOR (=VCLEN){16969
{{BTW{8,WB{{{CONVERT TO WORDS{16970
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD OF ARGUMENT BLOCK{16971
{{BEQ{8,WA{22,=B$ART{6,SPRO4{JUMP IF ARRAY{16972
{{BEQ{8,WA{22,=B$TBT{6,SPRO1{JUMP IF TABLE{16973
{{BEQ{8,WA{22,=B$VCT{6,SPRO3{JUMP IF VECTOR{16974
{{ERB{1,164{26,PROTOTYPE argument is not valid object{{{16979
*
*      HERE FOR TABLE
*
{SPRO1{SUB{18,=TBSI${8,WB{{SUBTRACT STANDARD FIELDS{16983
*
*      MERGE FOR VECTOR
*
{SPRO2{MTI{8,WB{{{CONVERT TO INTEGER{16987
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{16988
*
*      HERE FOR VECTOR
*
{SPRO3{SUB{18,=VCSI${8,WB{{SUBTRACT STANDARD FIELDS{16992
{{BRN{6,SPRO2{{{MERGE{16993
*
*      HERE FOR ARRAY
*
{SPRO4{ADD{13,AROFS(XR){7,XR{{POINT TO PROTOTYPE FIELD{16997
{{MOV{9,(XR){7,XR{{LOAD PROTOTYPE{16998
{{MOV{7,XR{11,-(XS){{STACK RESULT{16999
{{LCW{7,XR{{{GET NEXT CODE WORD{17000
{{BRI{9,(XR){{{EXECUTE IT{17001
{{EJC{{{{{17011
*
*      REMDR
*
{S$RMD{ENT{{{{ENTRY POINT{17015
{{JSR{6,ARITH{{{GET TWO INTEGERS OR TWO REALS{17017
{{ERR{1,166{26,REMDR first argument is not numeric{{{17018
{{ERR{1,165{26,REMDR second argument is not numeric{{{17019
{{PPM{6,SRM06{{{IF REAL{17020
*
*      BOTH ARGUMENTS INTEGER
*
{{ZER{8,WB{{{SET POSITIVE FLAG{17037
{{LDI{13,ICVAL(XR){{{LOAD LEFT ARGUMENT VALUE{17038
{{IGE{6,SRM01{{{JUMP IF POSITIVE{17039
{{MNZ{8,WB{{{SET NEGATIVE FLAG{17040
{SRM01{RMI{13,ICVAL(XL){{{GET REMAINDER{17041
{{IOV{6,SRM05{{{ERROR IF OVERFLOW{17042
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*
{{BZE{8,WB{6,SRM03{{IF RESULT SHOULD BE POSITIVE{17046
{{ILE{6,EXINT{{{IF SHOULD BE NEGATIVE, AND IS{17047
{SRM02{NGI{{{{ADJUST SIGN OF RESULT{17048
{{BRN{6,EXINT{{{RETURN RESULT{17049
{SRM03{ILT{6,SRM02{{{SHOULD BE POS, AND RESULT NEGATIVE{17050
{{BRN{6,EXINT{{{SHOULD BE POSITIVE, AND IS{17051
*
*      FAIL FIRST ARGUMENT
*
{SRM04{ERB{1,166{26,REMDR first argument is not numeric{{{17055
*
*      FAIL IF OVERFLOW
*
{SRM05{ERB{1,167{26,REMDR caused integer overflow{{{17059
*
*      HERE WITH 1ST ARGUMENT IN (XR), 2ND IN (XL), BOTH REAL
*
*      RESULT = N1 - CHOP(N1/N2)*N2
*
{SRM06{ZER{8,WB{{{SET POSITIVE FLAG{17066
{{LDR{13,RCVAL(XR){{{LOAD LEFT ARGUMENT VALUE{17067
{{RGE{6,SRM07{{{JUMP IF POSITIVE{17068
{{MNZ{8,WB{{{SET NEGATIVE FLAG{17069
{SRM07{DVR{13,RCVAL(XL){{{COMPUTE N1/N2{17070
{{ROV{6,SRM10{{{JUMP IF OVERFLOW{17071
{{CHP{{{{CHOP RESULT{17072
{{MLR{13,RCVAL(XL){{{TIMES N2{17073
{{SBR{13,RCVAL(XR){{{COMPUTE DIFFERENCE{17074
*
*      MAKE SIGN OF RESULT MATCH SIGN OF FIRST ARGUMENT
*      -RESULT IS IN RA AT THIS POINT
*
{{BZE{8,WB{6,SRM09{{IF RESULT SHOULD BE POSITIVE{17079
{{RLE{6,EXREA{{{IF SHOULD BE NEGATIVE, AND IS{17080
{SRM08{NGR{{{{ADJUST SIGN OF RESULT{17081
{{BRN{6,EXREA{{{RETURN RESULT{17082
{SRM09{RLT{6,SRM08{{{SHOULD BE POS, AND RESULT NEGATIVE{17083
{{BRN{6,EXREA{{{SHOULD BE POSITIVE, AND IS{17084
*
*      FAIL IF OVERFLOW
*
{SRM10{ERB{1,312{26,REMDR caused real overflow{{{17088
{{EJC{{{{{17090
*
*      REPLACE
*
*      THE ACTUAL REPLACE OPERATION USES AN SCBLK WHOSE CFP$A
*      CHARS CONTAIN THE TRANSLATED VERSIONS OF ALL THE CHARS.
*      THE TABLE POINTER IS REMEMBERED FROM CALL TO CALL AND
*      THE TABLE IS ONLY BUILT WHEN THE ARGUMENTS CHANGE.
*
*      WE ALSO PERFORM AN OPTIMIZATION GLEANED FROM SPITBOL 370.
*      IF THE SECOND ARGUMENT IS &ALPHABET, THERE IS NO NEED TO
*      TO BUILD A REPLACE TABLE.  THE THIRD ARGUMENT CAN BE
*      USED DIRECTLY AS THE REPLACE TABLE.
*
{S$RPL{ENT{{{{ENTRY POINT{17104
{{JSR{6,GTSTG{{{LOAD THIRD ARGUMENT AS STRING{17105
{{ERR{1,168{26,REPLACE third argument is not a string{{{17106
{{MOV{7,XR{7,XL{{SAVE THIRD ARG PTR{17107
{{JSR{6,GTSTG{{{GET SECOND ARGUMENT{17108
{{ERR{1,169{26,REPLACE second argument is not a string{{{17109
*
*      CHECK TO SEE IF THIS IS THE SAME TABLE AS LAST TIME
*
{{BNE{7,XR{3,R$RA2{6,SRPL1{JUMP IF 2ND ARGUMENT DIFFERENT{17113
{{BEQ{7,XL{3,R$RA3{6,SRPL4{JUMP IF ARGS SAME AS LAST TIME{17114
*
*      HERE WE BUILD A NEW REPLACE TABLE (NOTE WA = 2ND ARG LEN)
*
{SRPL1{MOV{13,SCLEN(XL){8,WB{{LOAD 3RD ARGUMENT LENGTH{17118
{{BNE{8,WA{8,WB{6,SRPL6{JUMP IF ARGUMENTS NOT SAME LENGTH{17119
{{BEQ{7,XR{3,KVALP{6,SRPL5{JUMP IF 2ND ARG IS ALPHABET STRING{17120
{{BZE{8,WB{6,SRPL6{{JUMP IF NULL 2ND ARGUMENT{17121
{{MOV{7,XL{3,R$RA3{{SAVE THIRD ARG FOR NEXT TIME IN{17122
{{MOV{7,XR{3,R$RA2{{SAVE SECOND ARG FOR NEXT TIME IN{17123
{{MOV{3,KVALP{7,XL{{POINT TO ALPHABET STRING{17124
{{MOV{13,SCLEN(XL){8,WA{{LOAD ALPHABET SCBLK LENGTH{17125
{{MOV{3,R$RPT{7,XR{{POINT TO CURRENT TABLE (IF ANY){17126
{{BNZ{7,XR{6,SRPL2{{JUMP IF WE ALREADY HAVE A TABLE{17127
*
*      HERE WE ALLOCATE A NEW TABLE
*
{{JSR{6,ALOCS{{{ALLOCATE NEW TABLE{17131
{{MOV{8,WC{8,WA{{KEEP SCBLK LENGTH{17132
{{MOV{7,XR{3,R$RPT{{SAVE TABLE POINTER FOR NEXT TIME{17133
*
*      MERGE HERE WITH POINTER TO NEW TABLE BLOCK IN (XR)
*
{SRPL2{CTB{8,WA{2,SCSI${{COMPUTE LENGTH OF SCBLK{17137
{{MVW{{{{COPY TO GET INITIAL TABLE VALUES{17138
{{EJC{{{{{17139
*
*      REPLACE (CONTINUED)
*
*      NOW WE MUST PLUG SELECTED ENTRIES AS REQUIRED. NOTE THAT
*      WE ARE SHORT OF INDEX REGISTERS FOR THE FOLLOWING LOOP.
*      HENCE THE NEED TO REPEATEDLY RE-INITIALISE CHAR PTR XL
*
{{MOV{3,R$RA2{7,XL{{POINT TO SECOND ARGUMENT{17147
{{LCT{8,WB{8,WB{{NUMBER OF CHARS TO PLUG{17148
{{ZER{8,WC{{{ZERO CHAR OFFSET{17149
{{MOV{3,R$RA3{7,XR{{POINT TO 3RD ARG{17150
{{PLC{7,XR{{{GET CHAR PTR FOR 3RD ARG{17151
*
*      LOOP TO PLUG CHARS
*
{SRPL3{MOV{3,R$RA2{7,XL{{POINT TO 2ND ARG{17155
{{PLC{7,XL{8,WC{{POINT TO NEXT CHAR{17156
{{ICV{8,WC{{{INCREMENT OFFSET{17157
{{LCH{8,WA{9,(XL){{GET NEXT CHAR{17158
{{MOV{3,R$RPT{7,XL{{POINT TO TRANSLATE TABLE{17159
{{PSC{7,XL{8,WA{{CONVERT CHAR TO OFFSET INTO TABLE{17160
{{LCH{8,WA{10,(XR)+{{GET TRANSLATED CHAR{17161
{{SCH{8,WA{9,(XL){{STORE IN TABLE{17162
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{17163
{{BCT{8,WB{6,SRPL3{{LOOP TILL DONE{17164
{{EJC{{{{{17165
*
*      REPLACE (CONTINUED)
*
*      HERE TO USE R$RPT AS REPLACE TABLE.
*
{SRPL4{MOV{3,R$RPT{7,XL{{REPLACE TABLE TO USE{17171
*
*      HERE TO PERFORM TRANSLATE USING TABLE IN XL.
*
{SRPL5{JSR{6,GTSTG{{{GET FIRST ARGUMENT{17176
{{ERR{1,170{26,REPLACE first argument is not a string{{{17177
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF NULL ARGUMENT{17186
{{MOV{7,XL{11,-(XS){{STACK REPLACE TABLE TO USE{17187
{{MOV{7,XR{7,XL{{COPY POINTER{17188
{{MOV{8,WA{8,WC{{SAVE LENGTH{17189
{{CTB{8,WA{2,SCHAR{{GET SCBLK LENGTH{17190
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{17191
{{MOV{7,XR{8,WB{{SAVE ADDRESS OF COPY{17192
{{MVW{{{{MOVE SCBLK CONTENTS TO COPY{17193
{{MOV{10,(XS)+{7,XR{{UNSTACK REPLACE TABLE{17194
{{PLC{7,XR{{{POINT TO CHARS OF TABLE{17195
{{MOV{8,WB{7,XL{{POINT TO STRING TO TRANSLATE{17196
{{PLC{7,XL{{{POINT TO CHARS OF STRING{17197
{{MOV{8,WC{8,WA{{SET NUMBER OF CHARS TO TRANSLATE{17198
{{TRC{{{{PERFORM TRANSLATION{17199
{SRPL8{MOV{8,WB{11,-(XS){{STACK RESULT{17200
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17201
{{BRI{9,(XR){{{EXECUTE IT{17202
*
*      ERROR POINT
*
{SRPL6{ERB{1,171{26,Null or unequally long 2nd, 3rd args to REPLACE{{{17206
{{EJC{{{{{17221
*
*      REWIND
*
{S$REW{ENT{{{{ENTRY POINT{17225
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{17226
{{ERR{1,172{26,REWIND argument is not a suitable name{{{17227
{{ERR{1,173{26,REWIND argument is null{{{17228
{{ERR{1,174{26,REWIND file does not exist{{{17229
{{JSR{6,SYSRW{{{CALL SYSTEM REWIND FUNCTION{17230
{{ERR{1,174{26,REWIND file does not exist{{{17231
{{ERR{1,175{26,REWIND file does not permit rewind{{{17232
{{ERR{1,176{26,REWIND caused non-recoverable error{{{17233
{{BRN{6,EXNUL{{{EXIT WITH NULL RESULT IF NO ERROR{17234
{{EJC{{{{{17235
*
*      REVERSE
*
{S$RVS{ENT{{{{ENTRY POINT{17239
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{17241
{{ERR{1,177{26,REVERSE argument is not a string{{{17242
{{BZE{8,WA{6,EXIXR{{RETURN ARGUMENT IF NULL{17248
{{MOV{7,XR{7,XL{{ELSE SAVE POINTER TO STRING ARG{17249
{{JSR{6,ALOCS{{{ALLOCATE SPACE FOR NEW SCBLK{17250
{{MOV{7,XR{11,-(XS){{STORE SCBLK PTR ON STACK AS RESULT{17251
{{PSC{7,XR{{{PREPARE TO STORE IN NEW SCBLK{17252
{{PLC{7,XL{8,WC{{POINT PAST LAST CHAR IN ARGUMENT{17253
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{17254
*
*      LOOP TO MOVE CHARS IN REVERSE ORDER
*
{SRVS1{LCH{8,WB{11,-(XL){{LOAD NEXT CHAR FROM ARGUMENT{17258
{{SCH{8,WB{10,(XR)+{{STORE IN RESULT{17259
{{BCT{8,WC{6,SRVS1{{LOOP TILL ALL MOVED{17260
*
*      HERE WHEN COMPLETE TO EXECUTE NEXT CODE WORD
*
{SRVS4{CSC{7,XR{{{COMPLETE STORE CHARACTERS{17264
{{ZER{7,XL{{{CLEAR GARBAGE XL{17265
{SRVS2{LCW{7,XR{{{LOAD NEXT CODE WORD{17266
{{BRI{9,(XR){{{EXECUTE IT{17267
{{EJC{{{{{17291
*
*      RPAD
*
{S$RPD{ENT{{{{ENTRY POINT{17295
{{JSR{6,GTSTG{{{GET PAD CHARACTER{17296
{{ERR{1,178{26,RPAD third argument is not a string{{{17297
{{PLC{7,XR{{{POINT TO CHARACTER (NULL IS BLANK){17298
{{LCH{8,WB{9,(XR){{LOAD PAD CHARACTER{17299
{{JSR{6,GTSMI{{{GET PAD LENGTH{17300
{{ERR{1,179{26,RPAD second argument is not integer{{{17301
{{PPM{6,SRPD3{{{SKIP IF NEGATIVE OR LARGE{17302
*
*      MERGE TO CHECK FIRST ARG.
*
{SRPD1{JSR{6,GTSTG{{{GET FIRST ARGUMENT (STRING TO PAD){17306
{{ERR{1,180{26,RPAD first argument is not a string{{{17307
{{BGE{8,WA{8,WC{6,EXIXR{RETURN 1ST ARG IF TOO LONG TO PAD{17308
{{MOV{7,XR{7,XL{{ELSE MOVE PTR TO STRING TO PAD{17309
*
*      NOW WE ARE READY FOR THE PAD
*
*      (XL)                  POINTER TO STRING TO PAD
*      (WB)                  PAD CHARACTER
*      (WC)                  LENGTH TO PAD STRING TO
*
{{MOV{8,WC{8,WA{{COPY LENGTH{17317
{{JSR{6,ALOCS{{{ALLOCATE SCBLK FOR NEW STRING{17318
{{MOV{7,XR{11,-(XS){{SAVE AS RESULT{17319
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH OF ARGUMENT{17320
{{SUB{8,WA{8,WC{{CALCULATE NUMBER OF PAD CHARACTERS{17321
{{PSC{7,XR{{{POINT TO CHARS IN RESULT STRING{17322
{{LCT{8,WC{8,WC{{SET COUNTER FOR PAD LOOP{17323
*
*      COPY ARGUMENT STRING
*
{{BZE{8,WA{6,SRPD2{{JUMP IF ARGUMENT IS NULL{17327
{{PLC{7,XL{{{ELSE POINT TO ARGUMENT CHARS{17328
{{MVC{{{{MOVE CHARACTERS TO RESULT STRING{17329
{{ZER{7,XL{{{CLEAR GARBAGE XL{17330
*
*      LOOP TO SUPPLY PAD CHARACTERS
*
{SRPD2{SCH{8,WB{10,(XR)+{{STORE PAD CHARACTER, BUMP PTR{17334
{{BCT{8,WC{6,SRPD2{{LOOP TILL ALL PAD CHARS STORED{17335
{{CSC{7,XR{{{COMPLETE CHARACTER STORING{17336
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17337
{{BRI{9,(XR){{{EXECUTE IT{17338
*
*      HERE IF 2ND ARG IS NEGATIVE OR LARGE
*
{SRPD3{ZER{8,WC{{{ZERO PAD COUNT{17342
{{BRN{6,SRPD1{{{MERGE{17343
{{EJC{{{{{17344
*
*      RTAB
*
{S$RTB{ENT{{{{ENTRY POINT{17348
{{MOV{22,=P$RTB{8,WB{{SET PCODE FOR INTEGER ARG CASE{17349
{{MOV{22,=P$RTD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17350
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17351
{{ERR{1,181{26,RTAB argument is not integer or expression{{{17352
{{ERR{1,182{26,RTAB argument is negative or too large{{{17353
{{MOV{7,XR{11,-(XS){{STACK RESULT{17354
{{LCW{7,XR{{{GET NEXT CODE WORD{17355
{{BRI{9,(XR){{{EXECUTE IT{17356
{{EJC{{{{{17357
*
*      SET
*
{S$SET{ENT{{{{ENTRY POINT{17362
{{MOV{10,(XS)+{3,R$IO2{{SAVE THIRD ARG (WHENCE){17363
{{MOV{10,(XS)+{3,R$IO1{{SAVE SECOND ARG (OFFSET){17370
{{JSR{6,IOFCB{{{CALL FCBLK ROUTINE{17372
{{ERR{1,291{26,SET first argument is not a suitable name{{{17373
{{ERR{1,292{26,SET first argument is null{{{17374
{{ERR{1,295{26,SET file does not exist{{{17375
{{MOV{3,R$IO1{8,WB{{LOAD SECOND ARG{17378
{{MOV{3,R$IO2{8,WC{{LOAD THIRD ARG{17380
{{JSR{6,SYSST{{{CALL SYSTEM SET ROUTINE{17381
{{ERR{1,293{26,Inappropriate second argument to SET{{{17382
{{ERR{1,294{26,Inappropriate third argument to SET{{{17383
{{ERR{1,295{26,SET file does not exist{{{17384
{{ERR{1,296{26,SET file does not permit setting file pointer{{{17385
{{ERR{1,297{26,SET caused non-recoverable I/O error{{{17386
{{BRN{6,EXINT{{{OTHERWISE RETURN POSITION{17391
{{EJC{{{{{17393
*
*      TAB
*
{S$TAB{ENT{{{{ENTRY POINT{17398
{{MOV{22,=P$TAB{8,WB{{SET PCODE FOR INTEGER ARG CASE{17399
{{MOV{22,=P$TBD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17400
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17401
{{ERR{1,183{26,TAB argument is not integer or expression{{{17402
{{ERR{1,184{26,TAB argument is negative or too large{{{17403
{{MOV{7,XR{11,-(XS){{STACK RESULT{17404
{{LCW{7,XR{{{GET NEXT CODE WORD{17405
{{BRI{9,(XR){{{EXECUTE IT{17406
{{EJC{{{{{17407
*
*      RPOS
*
{S$RPS{ENT{{{{ENTRY POINT{17411
{{MOV{22,=P$RPS{8,WB{{SET PCODE FOR INTEGER ARG CASE{17412
{{MOV{22,=P$RPD{8,WA{{SET PCODE FOR EXPRESSION ARG CASE{17413
{{JSR{6,PATIN{{{CALL COMMON ROUTINE TO BUILD NODE{17414
{{ERR{1,185{26,RPOS argument is not integer or expression{{{17415
{{ERR{1,186{26,RPOS argument is negative or too large{{{17416
{{MOV{7,XR{11,-(XS){{STACK RESULT{17417
{{LCW{7,XR{{{GET NEXT CODE WORD{17418
{{BRI{9,(XR){{{EXECUTE IT{17419
{{EJC{{{{{17422
*
*      RSORT
*
{S$RSR{ENT{{{{ENTRY POINT{17426
{{MNZ{8,WA{{{MARK AS RSORT{17427
{{JSR{6,SORTA{{{CALL SORT ROUTINE{17428
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{17429
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{17430
{{EJC{{{{{17432
*
*      SETEXIT
*
{S$STX{ENT{{{{ENTRY POINT{17436
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17437
{{MOV{3,STXVR{8,WA{{LOAD OLD VRBLK POINTER{17438
{{ZER{7,XL{{{LOAD ZERO IN CASE NULL ARG{17439
{{BEQ{7,XR{21,=NULLS{6,SSTX1{JUMP IF NULL ARGUMENT (RESET CALL){17440
{{JSR{6,GTNVR{{{ELSE GET SPECIFIED VRBLK{17441
{{PPM{6,SSTX2{{{JUMP IF NOT NATURAL VARIABLE{17442
{{MOV{13,VRLBL(XR){7,XL{{ELSE LOAD LABEL{17443
{{BEQ{7,XL{21,=STNDL{6,SSTX2{JUMP IF LABEL IS NOT DEFINED{17444
{{BNE{9,(XL){22,=B$TRT{6,SSTX1{JUMP IF NOT TRAPPED{17445
{{MOV{13,TRLBL(XL){7,XL{{ELSE LOAD PTR TO REAL LABEL CODE{17446
*
*      HERE TO SET/RESET SETEXIT TRAP
*
{SSTX1{MOV{7,XR{3,STXVR{{STORE NEW VRBLK POINTER (OR NULL){17450
{{MOV{7,XL{3,R$SXC{{STORE NEW CODE PTR (OR ZERO){17451
{{BEQ{8,WA{21,=NULLS{6,EXNUL{RETURN NULL IF NULL RESULT{17452
{{MOV{8,WA{7,XR{{ELSE COPY VRBLK POINTER{17453
{{BRN{6,EXVNM{{{AND RETURN BUILDING NMBLK{17454
*
*      HERE IF BAD ARGUMENT
*
{SSTX2{ERB{1,187{26,SETEXIT argument is not label name or null{{{17458
*
*      SIN
*
{S$SIN{ENT{{{{ENTRY POINT{17463
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17464
{{JSR{6,GTREA{{{CONVERT TO REAL{17465
{{ERR{1,308{26,SIN argument not numeric{{{17466
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17467
{{SIN{{{{TAKE SINE{17468
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{17469
{{ERB{1,323{26,SIN argument is out of range{{{17470
{{EJC{{{{{17471
*
*      SQRT
*
{S$SQR{ENT{{{{ENTRY POINT{17477
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17478
{{JSR{6,GTREA{{{CONVERT TO REAL{17479
{{ERR{1,313{26,SQRT argument not numeric{{{17480
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17481
{{RLT{6,SSQR1{{{NEGATIVE NUMBER{17482
{{SQR{{{{TAKE SQUARE ROOT{17483
{{BRN{6,EXREA{{{NO OVERFLOW POSSIBLE, RESULT IN RA{17484
*
*      HERE IF BAD ARGUMENT
*
{SSQR1{ERB{1,314{26,SQRT argument negative{{{17488
{{EJC{{{{{17489
{{EJC{{{{{17493
*
*      SORT
*
{S$SRT{ENT{{{{ENTRY POINT{17497
{{ZER{8,WA{{{MARK AS SORT{17498
{{JSR{6,SORTA{{{CALL SORT ROUTINE{17499
{{PPM{6,EXFAL{{{IF CONVERSION FAILS, SO SHALL WE{17500
{{BRN{6,EXSID{{{RETURN, SETTING IDVAL{17501
{{EJC{{{{{17503
*
*      SPAN
*
{S$SPN{ENT{{{{ENTRY POINT{17507
{{MOV{22,=P$SPS{8,WB{{SET PCODE FOR SINGLE CHAR ARG{17508
{{MOV{22,=P$SPN{7,XL{{SET PCODE FOR MULTI-CHAR ARG{17509
{{MOV{22,=P$SPD{8,WC{{SET PCODE FOR EXPRESSION ARG{17510
{{JSR{6,PATST{{{CALL COMMON ROUTINE TO BUILD NODE{17511
{{ERR{1,188{26,SPAN argument is not a string or expression{{{17512
{{MOV{7,XR{11,-(XS){{STACK RESULT{17513
{{LCW{7,XR{{{GET NEXT CODE WORD{17514
{{BRI{9,(XR){{{EXECUTE IT{17515
{{EJC{{{{{17516
*
*      SIZE
*
{S$SI${ENT{{{{ENTRY POINT{17520
{{JSR{6,GTSTG{{{LOAD STRING ARGUMENT{17522
{{ERR{1,189{26,SIZE argument is not a string{{{17523
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH.
*
{{MTI{8,WA{{{LOAD LENGTH AS INTEGER{17531
{{BRN{6,EXINT{{{EXIT WITH INTEGER RESULT{17532
{{EJC{{{{{17533
*
*      STOPTR
*
{S$STT{ENT{{{{ENTRY POINT{17537
{{ZER{7,XL{{{INDICATE STOPTR CASE{17538
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{17539
{{ERR{1,190{26,STOPTR first argument is not appropriate name{{{17540
{{ERR{1,191{26,STOPTR second argument is not trace type{{{17541
{{BRN{6,EXNUL{{{RETURN NULL{17542
{{EJC{{{{{17543
*
*      SUBSTR
*
{S$SUB{ENT{{{{ENTRY POINT{17547
{{JSR{6,GTSMI{{{LOAD THIRD ARGUMENT{17548
{{ERR{1,192{26,SUBSTR third argument is not integer{{{17549
{{PPM{6,EXFAL{{{JUMP IF NEGATIVE OR TOO LARGE{17550
{{MOV{7,XR{3,SBSSV{{SAVE THIRD ARGUMENT{17551
{{JSR{6,GTSMI{{{LOAD SECOND ARGUMENT{17552
{{ERR{1,193{26,SUBSTR second argument is not integer{{{17553
{{PPM{6,EXFAL{{{JUMP IF OUT OF RANGE{17554
{{MOV{7,XR{8,WC{{SAVE SECOND ARGUMENT{17555
{{BZE{8,WC{6,EXFAL{{JUMP IF SECOND ARGUMENT ZERO{17556
{{DCV{8,WC{{{ELSE DECREMENT FOR ONES ORIGIN{17557
{{JSR{6,GTSTG{{{LOAD FIRST ARGUMENT{17559
{{ERR{1,194{26,SUBSTR first argument is not a string{{{17560
*
*      MERGE WITH BFBLK OR SCBLK PTR IN XR.  WA HAS LENGTH
*
{{MOV{8,WC{8,WB{{COPY SECOND ARG TO WB{17568
{{MOV{3,SBSSV{8,WC{{RELOAD THIRD ARGUMENT{17569
{{BNZ{8,WC{6,SSUB2{{SKIP IF THIRD ARG GIVEN{17570
{{MOV{8,WA{8,WC{{ELSE GET STRING LENGTH{17571
{{BGT{8,WB{8,WC{6,EXFAL{FAIL IF IMPROPER{17572
{{SUB{8,WB{8,WC{{REDUCE BY OFFSET TO START{17573
*
*      MERGE
*
{SSUB2{MOV{8,WA{7,XL{{SAVE STRING LENGTH{17577
{{MOV{8,WC{8,WA{{SET LENGTH OF SUBSTRING{17578
{{ADD{8,WB{8,WC{{ADD 2ND ARG TO 3RD ARG{17579
{{BGT{8,WC{7,XL{6,EXFAL{JUMP IF IMPROPER SUBSTRING{17580
{{MOV{7,XR{7,XL{{COPY POINTER TO FIRST ARG{17581
{{JSR{6,SBSTR{{{BUILD SUBSTRING{17582
{{MOV{7,XR{11,-(XS){{STACK RESULT{17583
{{LCW{7,XR{{{GET NEXT CODE WORD{17584
{{BRI{9,(XR){{{EXECUTE IT{17585
{{EJC{{{{{17586
*
*      TABLE
*
{S$TBL{ENT{{{{ENTRY POINT{17590
{{MOV{10,(XS)+{7,XL{{GET INITIAL LOOKUP VALUE{17591
{{ICA{7,XS{{{POP SECOND ARGUMENT{17592
{{JSR{6,GTSMI{{{LOAD ARGUMENT{17593
{{ERR{1,195{26,TABLE argument is not integer{{{17594
{{ERR{1,196{26,TABLE argument is out of range{{{17595
{{BNZ{8,WC{6,STBL1{{JUMP IF NON-ZERO{17596
{{MOV{18,=TBNBK{8,WC{{ELSE SUPPLY DEFAULT VALUE{17597
*
*      MERGE HERE WITH NUMBER OF HEADERS IN WC
*
{STBL1{JSR{6,TMAKE{{{MAKE TABLE{17601
{{BRN{6,EXSID{{{EXIT SETTING IDVAL{17602
{{EJC{{{{{17603
*
*      TAN
*
{S$TAN{ENT{{{{ENTRY POINT{17608
{{MOV{10,(XS)+{7,XR{{GET ARGUMENT{17609
{{JSR{6,GTREA{{{CONVERT TO REAL{17610
{{ERR{1,309{26,TAN argument not numeric{{{17611
{{LDR{13,RCVAL(XR){{{LOAD ACCUMULATOR WITH ARGUMENT{17612
{{TAN{{{{TAKE TANGENT{17613
{{RNO{6,EXREA{{{IF NO OVERFLOW, RETURN RESULT IN RA{17614
{{ERB{1,310{26,TAN produced real overflow or argument is out of range{{{17615
{{EJC{{{{{17616
*
*      TIME
*
{S$TIM{ENT{{{{ENTRY POINT{17621
{{JSR{6,SYSTM{{{GET TIMER VALUE{17622
{{SBI{3,TIMSX{{{SUBTRACT STARTING TIME{17623
{{BRN{6,EXINT{{{EXIT WITH INTEGER VALUE{17624
{{EJC{{{{{17625
*
*      TRACE
*
{S$TRA{ENT{{{{ENTRY POINT{17629
{{BEQ{12,3(XS){21,=NULLS{6,STR02{JUMP IF FIRST ARGUMENT IS NULL{17630
{{MOV{10,(XS)+{7,XR{{LOAD FOURTH ARGUMENT{17631
{{ZER{7,XL{{{TENTATIVELY SET ZERO POINTER{17632
{{BEQ{7,XR{21,=NULLS{6,STR01{JUMP IF 4TH ARGUMENT IS NULL{17633
{{JSR{6,GTNVR{{{ELSE POINT TO VRBLK{17634
{{PPM{6,STR03{{{JUMP IF NOT VARIABLE NAME{17635
{{MOV{7,XR{7,XL{{ELSE SAVE VRBLK IN TRFNC{17636
*
*      HERE WITH VRBLK OR ZERO IN XL
*
{STR01{MOV{10,(XS)+{7,XR{{LOAD THIRD ARGUMENT (TAG){17640
{{ZER{8,WB{{{SET ZERO AS TRTYP VALUE FOR NOW{17641
{{JSR{6,TRBLD{{{BUILD TRBLK FOR TRACE CALL{17642
{{MOV{7,XR{7,XL{{MOVE TRBLK POINTER FOR TRACE{17643
{{JSR{6,TRACE{{{CALL TRACE PROCEDURE{17644
{{ERR{1,198{26,TRACE first argument is not appropriate name{{{17645
{{ERR{1,199{26,TRACE second argument is not trace type{{{17646
{{BRN{6,EXNUL{{{RETURN NULL{17647
*
*      HERE TO CALL SYSTEM TRACE TOGGLE ROUTINE
*
{STR02{JSR{6,SYSTT{{{CALL IT{17651
{{ADD{19,*NUM04{7,XS{{POP TRACE ARGUMENTS{17652
{{BRN{6,EXNUL{{{RETURN{17653
*
*      HERE FOR BAD FOURTH ARGUMENT
*
{STR03{ERB{1,197{26,TRACE fourth arg is not function name or null{{{17657
{{EJC{{{{{17658
*
*      TRIM
*
{S$TRM{ENT{{{{ENTRY POINT{17662
{{JSR{6,GTSTG{{{LOAD ARGUMENT AS STRING{17664
{{ERR{1,200{26,TRIM argument is not a string{{{17665
{{BZE{8,WA{6,EXNUL{{RETURN NULL IF ARGUMENT IS NULL{17671
{{MOV{7,XR{7,XL{{COPY STRING POINTER{17672
{{CTB{8,WA{2,SCHAR{{GET BLOCK LENGTH{17673
{{JSR{6,ALLOC{{{ALLOCATE COPY SAME SIZE{17674
{{MOV{7,XR{8,WB{{SAVE POINTER TO COPY{17675
{{MVW{{{{COPY OLD STRING BLOCK TO NEW{17676
{{MOV{8,WB{7,XR{{RESTORE PTR TO NEW BLOCK{17677
{{JSR{6,TRIMR{{{TRIM BLANKS (WB IS NON-ZERO){17678
{{MOV{7,XR{11,-(XS){{STACK RESULT{17679
{{LCW{7,XR{{{GET NEXT CODE WORD{17680
{{BRI{9,(XR){{{EXECUTE IT{17681
{{EJC{{{{{17724
*
*      UNLOAD
*
{S$UNL{ENT{{{{ENTRY POINT{17728
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{17729
{{JSR{6,GTNVR{{{POINT TO VRBLK{17730
{{ERR{1,201{26,UNLOAD argument is not natural variable name{{{17731
{{MOV{21,=STNDF{7,XL{{GET PTR TO UNDEFINED FUNCTION{17732
{{JSR{6,DFFNC{{{UNDEFINE NAMED FUNCTION{17733
{{BRN{6,EXNUL{{{RETURN NULL AS RESULT{17734
{{TTL{27,S P I T B O L -- UTILITY ROUTINES{{{{17756
*
*      THE FOLLOWING SECTION CONTAINS UTILITY ROUTINES USED FOR
*      VARIOUS PURPOSES THROUGHOUT THE SYSTEM. THESE DIFFER
*      FROM THE PROCEDURES IN THE UTILITY PROCEDURES SECTION IN
*      THEY ARE NOT IN PROCEDURE FORM AND THEY DO NOT RETURN
*      TO THEIR CALLERS. THEY ARE ACCESSED WITH A BRANCH TYPE
*      INSTRUCTION AFTER SETTING THE REGISTERS TO APPROPRIATE
*      PARAMETER VALUES.
*
*      THE REGISTER VALUES REQUIRED FOR EACH ROUTINE ARE
*      DOCUMENTED AT THE START OF EACH ROUTINE. REGISTERS NOT
*      MENTIONED MAY CONTAIN ANY VALUES EXCEPT THAT XR,XL
*      CAN ONLY CONTAIN PROPER COLLECTABLE POINTERS.
*
*      SOME OF THESE ROUTINES WILL TOLERATE GARBAGE POINTERS
*      IN XL,XR ON ENTRY. THIS IS ALWAYS DOCUMENTED AND IN
*      EACH CASE, THE ROUTINE CLEARS THESE GARBAGE VALUES BEFORE
*      EXITING AFTER COMPLETING ITS TASK.
*
*      THE ROUTINES HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE ASSEMBLED IN ALPHABETICAL ORDER.
{{EJC{{{{{17778
*      ARREF -- ARRAY REFERENCE
*
*      (XL)                  MAY BE NON-COLLECTABLE
*      (XR)                  NUMBER OF SUBSCRIPTS
*      (WB)                  SET ZERO/NONZERO FOR VALUE/NAME
*                            THE VALUE IN WB MUST BE COLLECTABLE
*      STACK                 SUBSCRIPTS AND ARRAY OPERAND
*      BRN  ARREF            JUMP TO CALL FUNCTION
*
*      ARREF CONTINUES BY EXECUTING THE NEXT CODE WORD WITH
*      THE RESULT NAME OR VALUE PLACED ON TOP OF THE STACK.
*      TO DEAL WITH THE PROBLEM OF ACCESSING SUBSCRIPTS IN THE
*      ORDER OF STACKING, XL IS USED AS A SUBSCRIPT POINTER
*      WORKING BELOW THE STACK POINTER.
*
{ARREF{RTN{{{{{17794
{{MOV{7,XR{8,WA{{COPY NUMBER OF SUBSCRIPTS{17795
{{MOV{7,XS{7,XT{{POINT TO STACK FRONT{17796
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{17797
{{ADD{7,XR{7,XT{{POINT TO ARRAY OPERAND ON STACK{17798
{{ICA{7,XT{{{FINAL VALUE FOR STACK POPPING{17799
{{MOV{7,XT{3,ARFXS{{KEEP FOR LATER{17800
{{MOV{11,-(XT){7,XR{{LOAD ARRAY OPERAND POINTER{17801
{{MOV{7,XR{3,R$ARF{{KEEP ARRAY POINTER{17802
{{MOV{7,XT{7,XR{{SAVE POINTER TO SUBSCRIPTS{17803
{{MOV{3,R$ARF{7,XL{{POINT XL TO POSSIBLE VCBLK OR TBBLK{17804
{{MOV{9,(XL){8,WC{{LOAD FIRST WORD{17805
{{BEQ{8,WC{22,=B$ART{6,ARF01{JUMP IF ARBLK{17806
{{BEQ{8,WC{22,=B$VCT{6,ARF07{JUMP IF VCBLK{17807
{{BEQ{8,WC{22,=B$TBT{6,ARF10{JUMP IF TBBLK{17808
{{ERB{1,235{26,Subscripted operand is not table or array{{{17809
*
*      HERE FOR ARRAY (ARBLK)
*
{ARF01{BNE{8,WA{13,ARNDM(XL){6,ARF09{JUMP IF WRONG NUMBER OF DIMS{17813
{{LDI{4,INTV0{{{GET INITIAL SUBSCRIPT OF ZERO{17814
{{MOV{7,XR{7,XT{{POINT BEFORE SUBSCRIPTS{17815
{{ZER{8,WA{{{INITIAL OFFSET TO BOUNDS{17816
{{BRN{6,ARF03{{{JUMP INTO LOOP{17817
*
*      LOOP TO COMPUTE SUBSCRIPTS BY MULTIPLICATIONS
*
{ARF02{MLI{13,ARDM2(XR){{{MULTIPLY TOTAL BY NEXT DIMENSION{17821
*
*      MERGE HERE FIRST TIME
*
{ARF03{MOV{11,-(XT){7,XR{{LOAD NEXT SUBSCRIPT{17825
{{STI{3,ARFSI{{{SAVE CURRENT SUBSCRIPT{17826
{{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE IN CASE{17827
{{BEQ{9,(XR){22,=B$ICL{6,ARF04{JUMP IF IT WAS AN INTEGER{17828
{{EJC{{{{{17829
*
*      ARREF (CONTINUED)
*
*
{{JSR{6,GTINT{{{CONVERT TO INTEGER{17834
{{PPM{6,ARF12{{{JUMP IF NOT INTEGER{17835
{{LDI{13,ICVAL(XR){{{IF OK, LOAD INTEGER VALUE{17836
*
*      HERE WITH INTEGER SUBSCRIPT IN (IA)
*
{ARF04{MOV{3,R$ARF{7,XR{{POINT TO ARRAY{17840
{{ADD{8,WA{7,XR{{OFFSET TO NEXT BOUNDS{17841
{{SBI{13,ARLBD(XR){{{SUBTRACT LOW BOUND TO COMPARE{17842
{{IOV{6,ARF13{{{OUT OF RANGE FAIL IF OVERFLOW{17843
{{ILT{6,ARF13{{{OUT OF RANGE FAIL IF TOO SMALL{17844
{{SBI{13,ARDIM(XR){{{SUBTRACT DIMENSION{17845
{{IGE{6,ARF13{{{OUT OF RANGE FAIL IF TOO LARGE{17846
{{ADI{13,ARDIM(XR){{{ELSE RESTORE SUBSCRIPT OFFSET{17847
{{ADI{3,ARFSI{{{ADD TO CURRENT TOTAL{17848
{{ADD{19,*ARDMS{8,WA{{POINT TO NEXT BOUNDS{17849
{{BNE{7,XT{7,XS{6,ARF02{LOOP BACK IF MORE TO GO{17850
*
*      HERE WITH INTEGER SUBSCRIPT COMPUTED
*
{{MFI{8,WA{{{GET AS ONE WORD INTEGER{17854
{{WTB{8,WA{{{CONVERT TO OFFSET{17855
{{MOV{3,R$ARF{7,XL{{POINT TO ARBLK{17856
{{ADD{13,AROFS(XL){8,WA{{ADD OFFSET PAST BOUNDS{17857
{{ICA{8,WA{{{ADJUST FOR ARPRO FIELD{17858
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{17859
*
*      MERGE HERE TO GET VALUE FOR VALUE CALL
*
{ARF05{JSR{6,ACESS{{{GET VALUE{17863
{{PPM{6,ARF13{{{FAIL IF ACESS FAILS{17864
*
*      RETURN VALUE
*
{ARF06{MOV{3,ARFXS{7,XS{{POP STACK ENTRIES{17868
{{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17869
{{MOV{7,XR{11,-(XS){{STACK RESULT{17870
{{LCW{7,XR{{{GET NEXT CODE WORD{17871
{{BRI{9,(XR){{{EXECUTE IT{17872
{{EJC{{{{{17873
*
*      ARREF (CONTINUED)
*
*      HERE FOR VECTOR
*
{ARF07{BNE{8,WA{18,=NUM01{6,ARF09{ERROR IF MORE THAN 1 SUBSCRIPT{17879
{{MOV{9,(XS){7,XR{{ELSE LOAD SUBSCRIPT{17880
{{JSR{6,GTINT{{{CONVERT TO INTEGER{17881
{{PPM{6,ARF12{{{ERROR IF NOT INTEGER{17882
{{LDI{13,ICVAL(XR){{{ELSE LOAD INTEGER VALUE{17883
{{SBI{4,INTV1{{{SUBTRACT FOR ONES OFFSET{17884
{{MFI{8,WA{6,ARF13{{GET SUBSCRIPT AS ONE WORD{17885
{{ADD{18,=VCVLS{8,WA{{ADD OFFSET FOR STANDARD FIELDS{17886
{{WTB{8,WA{{{CONVERT OFFSET TO BYTES{17887
{{BGE{8,WA{13,VCLEN(XL){6,ARF13{FAIL IF OUT OF RANGE SUBSCRIPT{17888
{{BZE{8,WB{6,ARF05{{BACK TO GET VALUE IF VALUE CALL{17889
*
*      RETURN NAME
*
{ARF08{MOV{3,ARFXS{7,XS{{POP STACK ENTRIES{17893
{{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17894
{{BRN{6,EXNAM{{{ELSE EXIT WITH NAME{17895
*
*      HERE IF SUBSCRIPT COUNT IS WRONG
*
{ARF09{ERB{1,236{26,Array referenced with wrong number of subscripts{{{17899
*
*      TABLE
*
{ARF10{BNE{8,WA{18,=NUM01{6,ARF11{ERROR IF MORE THAN 1 SUBSCRIPT{17903
{{MOV{9,(XS){7,XR{{ELSE LOAD SUBSCRIPT{17904
{{JSR{6,TFIND{{{CALL TABLE SEARCH ROUTINE{17905
{{PPM{6,ARF13{{{FAIL IF FAILED{17906
{{BNZ{8,WB{6,ARF08{{EXIT WITH NAME IF NAME CALL{17907
{{BRN{6,ARF06{{{ELSE EXIT WITH VALUE{17908
*
*      HERE FOR BAD TABLE REFERENCE
*
{ARF11{ERB{1,237{26,Table referenced with more than one subscript{{{17912
*
*      HERE FOR BAD SUBSCRIPT
*
{ARF12{ERB{1,238{26,Array subscript is not integer{{{17916
*
*      HERE TO SIGNAL FAILURE
*
{ARF13{ZER{3,R$ARF{{{FINISHED WITH ARRAY POINTER{17920
{{BRN{6,EXFAL{{{FAIL{17921
{{EJC{{{{{17922
*
*      CFUNC -- CALL A FUNCTION
*
*      CFUNC IS USED TO CALL A SNOBOL LEVEL FUNCTION. IT IS
*      USED BY THE APPLY FUNCTION (S$APP), THE FUNCTION
*      TRACE ROUTINE (TRXEQ) AND THE MAIN FUNCTION CALL ENTRY
*      (O$FNC, O$FNS). IN THE LATTER CASES, CFUNC IS USED ONLY
*      IF THE NUMBER OF ARGUMENTS IS INCORRECT.
*
*      (XL)                  POINTER TO FUNCTION BLOCK
*      (WA)                  ACTUAL NUMBER OF ARGUMENTS
*      (XS)                  POINTS TO STACKED ARGUMENTS
*      BRN  CFUNC            JUMP TO CALL FUNCTION
*
*      CFUNC CONTINUES BY EXECUTING THE FUNCTION
*
{CFUNC{RTN{{{{{17939
{{BLT{8,WA{13,FARGS(XL){6,CFNC1{JUMP IF TOO FEW ARGUMENTS{17940
{{BEQ{8,WA{13,FARGS(XL){6,CFNC3{JUMP IF CORRECT NUMBER OF ARGS{17941
*
*      HERE IF TOO MANY ARGUMENTS SUPPLIED, POP THEM OFF
*
{{MOV{8,WA{8,WB{{COPY ACTUAL NUMBER{17945
{{SUB{13,FARGS(XL){8,WB{{GET NUMBER OF EXTRA ARGS{17946
{{WTB{8,WB{{{CONVERT TO BYTES{17947
{{ADD{8,WB{7,XS{{POP OFF UNWANTED ARGUMENTS{17948
{{BRN{6,CFNC3{{{JUMP TO GO OFF TO FUNCTION{17949
*
*      HERE IF TOO FEW ARGUMENTS
*
{CFNC1{MOV{13,FARGS(XL){8,WB{{LOAD REQUIRED NUMBER OF ARGUMENTS{17953
{{BEQ{8,WB{18,=NINI9{6,CFNC3{JUMP IF CASE OF VAR NUM OF ARGS{17954
{{SUB{8,WA{8,WB{{CALCULATE NUMBER MISSING{17955
{{LCT{8,WB{8,WB{{SET COUNTER TO CONTROL LOOP{17956
*
*      LOOP TO SUPPLY EXTRA NULL ARGUMENTS
*
{CFNC2{MOV{21,=NULLS{11,-(XS){{STACK A NULL ARGUMENT{17960
{{BCT{8,WB{6,CFNC2{{LOOP TILL PROPER NUMBER STACKED{17961
*
*      MERGE HERE TO JUMP TO FUNCTION
*
{CFNC3{BRI{9,(XL){{{JUMP THROUGH FCODE FIELD{17965
{{EJC{{{{{17966
*
*      EXFAL -- EXIT SIGNALLING SNOBOL FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXFAL            JUMP TO FAIL
*
*      EXFAL CONTINUES BY EXECUTING THE APPROPRIATE FAIL GOTO
*
{EXFAL{RTN{{{{{17975
{{MOV{3,FLPTR{7,XS{{POP STACK{17976
{{MOV{9,(XS){7,XR{{LOAD FAILURE OFFSET{17977
{{ADD{3,R$COD{7,XR{{POINT TO FAILURE CODE LOCATION{17978
{{LCP{7,XR{{{SET CODE POINTER{17979
{{LCW{7,XR{{{LOAD NEXT CODE WORD{17980
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{17981
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{17982
{{EJC{{{{{17983
*
*      EXINT -- EXIT WITH INTEGER RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (IA)                  INTEGER VALUE
*      BRN  EXINT            JUMP TO EXIT WITH INTEGER
*
*      EXINT CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXIXR
*
{EXINT{RTN{{{{{17994
{{ZER{7,XL{{{CLEAR DUD VALUE{17995
{{JSR{6,ICBLD{{{BUILD ICBLK{17996
{{EJC{{{{{17997
*      EXIXR -- EXIT WITH RESULT IN (XR)
*
*      (XR)                  RESULT
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXIXR            JUMP TO EXIT WITH RESULT IN (XR)
*
*      EXIXR CONTINUES BY EXECUTING THE NEXT CODE WORD
*      WHICH IT DOES BY FALLING THROUGH TO EXITS.
{EXIXR{RTN{{{{{18006
*
{{MOV{7,XR{11,-(XS){{STACK RESULT{18008
*
*
*      EXITS -- EXIT WITH RESULT IF ANY STACKED
*
*      (XR,XL)               MAY BE NON-COLLECTABLE
*
*      BRN  EXITS            ENTER EXITS ROUTINE
*
{EXITS{RTN{{{{{18017
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18018
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18019
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18020
{{EJC{{{{{18021
*
*      EXNAM -- EXIT WITH NAME IN (XL,WA)
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      (XR)                  MAY BE NON-COLLECTABLE
*      BRN  EXNAM            JUMP TO EXIT WITH NAME IN (XL,WA)
*
*      EXNAM CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNAM{RTN{{{{{18032
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{18033
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{18034
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18035
{{BRI{9,(XR){{{EXECUTE IT{18036
{{EJC{{{{{18037
*
*      EXNUL -- EXIT WITH NULL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  EXNUL            JUMP TO EXIT WITH NULL VALUE
*
*      EXNUL CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXNUL{RTN{{{{{18046
{{MOV{21,=NULLS{11,-(XS){{STACK NULL VALUE{18047
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18048
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18049
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18050
{{EJC{{{{{18051
*
*      EXREA -- EXIT WITH REAL RESULT
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      (RA)                  REAL VALUE
*      BRN  EXREA            JUMP TO EXIT WITH REAL VALUE
*
*      EXREA CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXREA{RTN{{{{{18063
{{ZER{7,XL{{{CLEAR DUD VALUE{18064
{{JSR{6,RCBLD{{{BUILD RCBLK{18065
{{BRN{6,EXIXR{{{JUMP TO EXIT WITH RESULT IN XR{18066
{{EJC{{{{{18068
*
*      EXSID -- EXIT SETTING ID FIELD
*
*      EXSID IS USED TO EXIT AFTER BUILDING ANY OF THE FOLLOWING
*      BLOCKS (ARBLK, TBBLK, PDBLK, VCBLK). IT SETS THE IDVAL.
*
*      (XR)                  PTR TO BLOCK WITH IDVAL FIELD
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXSID            JUMP TO EXIT AFTER SETTING ID FIELD
*
*      EXSID CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{EXSID{RTN{{{{{18081
{{MOV{3,CURID{8,WA{{LOAD CURRENT ID VALUE{18082
{{BNE{8,WA{18,=CFP$M{6,EXSI1{JUMP IF NO OVERFLOW{18083
{{ZER{8,WA{{{ELSE RESET FOR WRAPAROUND{18084
*
*      HERE WITH OLD IDVAL IN WA
*
{EXSI1{ICV{8,WA{{{BUMP ID VALUE{18088
{{MOV{8,WA{3,CURID{{STORE FOR NEXT TIME{18089
{{MOV{8,WA{13,IDVAL(XR){{STORE ID VALUE{18090
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN (XR){18091
{{EJC{{{{{18092
*
*      EXVNM -- EXIT WITH NAME OF VARIABLE
*
*      EXVNM EXITS AFTER STACKING A VALUE WHICH IS A NMBLK
*      REFERENCING THE NAME OF A GIVEN NATURAL VARIABLE.
*
*      (XR)                  VRBLK POINTER
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  EXVNM            EXIT WITH VRBLK POINTER IN XR
*
{EXVNM{RTN{{{{{18103
{{MOV{7,XR{7,XL{{COPY NAME BASE POINTER{18104
{{MOV{19,*NMSI${8,WA{{SET SIZE OF NMBLK{18105
{{JSR{6,ALLOC{{{ALLOCATE NMBLK{18106
{{MOV{22,=B$NML{9,(XR){{STORE TYPE WORD{18107
{{MOV{7,XL{13,NMBAS(XR){{STORE NAME BASE{18108
{{MOV{19,*VRVAL{13,NMOFS(XR){{STORE NAME OFFSET{18109
{{BRN{6,EXIXR{{{EXIT WITH RESULT IN XR{18110
{{EJC{{{{{18111
*
*      FLPOP -- FAIL AND POP IN PATTERN MATCHING
*
*      FLPOP POPS THE NODE AND CURSOR ON THE STACK AND THEN
*      DROPS THROUGH INTO FAILP TO CAUSE PATTERN FAILURE
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FLPOP            JUMP TO FAIL AND POP STACK
*
{FLPOP{RTN{{{{{18121
{{ADD{19,*NUM02{7,XS{{POP TWO ENTRIES OFF STACK{18122
{{EJC{{{{{18123
*
*      FAILP -- FAILURE IN MATCHING PATTERN NODE
*
*      FAILP IS USED AFTER FAILING TO MATCH A PATTERN NODE.
*      SEE PATTERN MATCH ROUTINES FOR DETAILS OF USE.
*
*      (XL,XR)               MAY BE NON-COLLECTABLE
*      BRN  FAILP            SIGNAL FAILURE TO MATCH
*
*      FAILP CONTINUES BY MATCHING AN ALTERNATIVE FROM THE STACK
*
{FAILP{RTN{{{{{18135
{{MOV{10,(XS)+{7,XR{{LOAD ALTERNATIVE NODE POINTER{18136
{{MOV{10,(XS)+{8,WB{{RESTORE OLD CURSOR{18137
{{MOV{9,(XR){7,XL{{LOAD PCODE ENTRY POINTER{18138
{{BRI{7,XL{{{JUMP TO EXECUTE CODE FOR NODE{18139
{{EJC{{{{{18140
*
*      INDIR -- COMPUTE INDIRECT REFERENCE
*
*      (WB)                  NONZERO/ZERO FOR BY NAME/VALUE
*      BRN  INDIR            JUMP TO GET INDIRECT REF ON STACK
*
*      INDIR CONTINUES BY EXECUTING THE NEXT CODE WORD
*
{INDIR{RTN{{{{{18149
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{18150
{{BEQ{9,(XR){22,=B$NML{6,INDR2{JUMP IF A NAME{18151
{{JSR{6,GTNVR{{{ELSE CONVERT TO VARIABLE{18152
{{ERR{1,239{26,Indirection operand is not name{{{18153
{{BZE{8,WB{6,INDR1{{SKIP IF BY VALUE{18154
{{MOV{7,XR{11,-(XS){{ELSE STACK VRBLK PTR{18155
{{MOV{19,*VRVAL{11,-(XS){{STACK NAME OFFSET{18156
{{LCW{7,XR{{{LOAD NEXT CODE WORD{18157
{{MOV{9,(XR){7,XL{{LOAD ENTRY ADDRESS{18158
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18159
*
*      HERE TO GET VALUE OF NATURAL VARIABLE
*
{INDR1{BRI{9,(XR){{{JUMP THROUGH VRGET FIELD OF VRBLK{18163
*
*      HERE IF OPERAND IS A NAME
*
{INDR2{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{18167
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{18168
{{BNZ{8,WB{6,EXNAM{{EXIT IF CALLED BY NAME{18169
{{JSR{6,ACESS{{{ELSE GET VALUE FIRST{18170
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18171
{{BRN{6,EXIXR{{{ELSE RETURN WITH VALUE IN XR{18172
{{EJC{{{{{18173
*
*      MATCH -- INITIATE PATTERN MATCH
*
*      (WB)                  MATCH TYPE CODE
*      BRN  MATCH            JUMP TO INITIATE PATTERN MATCH
*
*      MATCH CONTINUES BY EXECUTING THE PATTERN MATCH. SEE
*      PATTERN MATCH ROUTINES (P$XXX) FOR FULL DETAILS.
*
{MATCH{RTN{{{{{18183
{{MOV{10,(XS)+{7,XR{{LOAD PATTERN OPERAND{18184
{{JSR{6,GTPAT{{{CONVERT TO PATTERN{18185
{{ERR{1,240{26,Pattern match right operand is not pattern{{{18186
{{MOV{7,XR{7,XL{{IF OK, SAVE PATTERN POINTER{18187
{{BNZ{8,WB{6,MTCH1{{JUMP IF NOT MATCH BY NAME{18188
{{MOV{9,(XS){8,WA{{ELSE LOAD NAME OFFSET{18189
{{MOV{7,XL{11,-(XS){{SAVE PATTERN POINTER{18190
{{MOV{12,2(XS){7,XL{{LOAD NAME BASE{18191
{{JSR{6,ACESS{{{ACCESS SUBJECT VALUE{18192
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18193
{{MOV{9,(XS){7,XL{{RESTORE PATTERN POINTER{18194
{{MOV{7,XR{9,(XS){{STACK SUBJECT STRING VAL FOR MERGE{18195
{{ZER{8,WB{{{RESTORE TYPE CODE{18196
*
*      MERGE HERE WITH SUBJECT VALUE ON STACK
*
{MTCH1{JSR{6,GTSTG{{{CONVERT SUBJECT TO STRING{18201
{{ERR{1,241{26,Pattern match left operand is not a string{{{18202
{{MOV{8,WB{11,-(XS){{STACK MATCH TYPE CODE{18203
{{MOV{7,XR{3,R$PMS{{IF OK, STORE SUBJECT STRING POINTER{18211
{{MOV{8,WA{3,PMSSL{{AND LENGTH{18212
{{ZER{11,-(XS){{{STACK INITIAL CURSOR (ZERO){18213
{{ZER{8,WB{{{SET INITIAL CURSOR{18214
{{MOV{7,XS{3,PMHBS{{SET HISTORY STACK BASE PTR{18215
{{ZER{3,PMDFL{{{RESET PATTERN ASSIGNMENT FLAG{18216
{{MOV{7,XL{7,XR{{SET INITIAL NODE POINTER{18217
{{BNZ{3,KVANC{6,MTCH2{{JUMP IF ANCHORED{18218
*
*      HERE FOR UNANCHORED
*
{{MOV{7,XR{11,-(XS){{STACK INITIAL NODE POINTER{18222
{{MOV{21,=NDUNA{11,-(XS){{STACK POINTER TO ANCHOR MOVE NODE{18223
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{18224
*
*      HERE IN ANCHORED MODE
*
{MTCH2{ZER{11,-(XS){{{DUMMY CURSOR VALUE{18228
{{MOV{21,=NDABO{11,-(XS){{STACK POINTER TO ABORT NODE{18229
{{BRI{9,(XR){{{START MATCH OF FIRST NODE{18230
{{EJC{{{{{18231
*
*      RETRN -- RETURN FROM FUNCTION
*
*      (WA)                  STRING POINTER FOR RETURN TYPE
*      BRN  RETRN            JUMP TO RETURN FROM (SNOBOL) FUNC
*
*      RETRN CONTINUES BY EXECUTING THE CODE AT THE RETURN POINT
*      THE STACK IS CLEANED OF ANY GARBAGE LEFT BY OTHER
*      ROUTINES WHICH MAY HAVE ALTERED FLPTR SINCE FUNCTION
*      ENTRY BY USING FLPRT, RESERVED FOR USE ONLY BY
*      FUNCTION CALL AND RETURN.
*
{RETRN{RTN{{{{{18244
{{BNZ{3,KVFNC{6,RTN01{{JUMP IF NOT LEVEL ZERO{18245
{{ERB{1,242{26,Function return from level zero{{{18246
*
*      HERE IF NOT LEVEL ZERO RETURN
*
{RTN01{MOV{3,FLPRT{7,XS{{POP STACK{18250
{{ICA{7,XS{{{REMOVE FAILURE OFFSET{18251
{{MOV{10,(XS)+{7,XR{{POP PFBLK POINTER{18252
{{MOV{10,(XS)+{3,FLPTR{{POP FAILURE POINTER{18253
{{MOV{10,(XS)+{3,FLPRT{{POP OLD FLPRT{18254
{{MOV{10,(XS)+{8,WB{{POP CODE POINTER OFFSET{18255
{{MOV{10,(XS)+{8,WC{{POP OLD CODE BLOCK POINTER{18256
{{ADD{8,WC{8,WB{{MAKE OLD CODE POINTER ABSOLUTE{18257
{{LCP{8,WB{{{RESTORE OLD CODE POINTER{18258
{{MOV{8,WC{3,R$COD{{RESTORE OLD CODE BLOCK POINTER{18259
{{DCV{3,KVFNC{{{DECREMENT FUNCTION LEVEL{18260
{{MOV{3,KVTRA{8,WB{{LOAD TRACE{18261
{{ADD{3,KVFTR{8,WB{{ADD FTRACE{18262
{{BZE{8,WB{6,RTN06{{JUMP IF NO TRACING POSSIBLE{18263
*
*      HERE IF THERE MAY BE A TRACE
*
{{MOV{8,WA{11,-(XS){{SAVE FUNCTION RETURN TYPE{18267
{{MOV{7,XR{11,-(XS){{SAVE PFBLK POINTER{18268
{{MOV{8,WA{3,KVRTN{{SET RTNTYPE FOR TRACE FUNCTION{18269
{{MOV{3,R$FNC{7,XL{{LOAD FNCLEVEL TRBLK PTR (IF ANY){18270
{{JSR{6,KTREX{{{EXECUTE POSSIBLE FNCLEVEL TRACE{18271
{{MOV{13,PFVBL(XR){7,XL{{LOAD VRBLK PTR (SGD13){18272
{{BZE{3,KVTRA{6,RTN02{{JUMP IF TRACE IS OFF{18273
{{MOV{13,PFRTR(XR){7,XR{{ELSE LOAD RETURN TRACE TRBLK PTR{18274
{{BZE{7,XR{6,RTN02{{JUMP IF NOT RETURN TRACED{18275
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{18276
{{BZE{13,TRFNC(XR){6,RTN03{{JUMP IF PRINT TRACE{18277
{{MOV{19,*VRVAL{8,WA{{ELSE SET NAME OFFSET{18278
{{MOV{12,1(XS){3,KVRTN{{MAKE SURE RTNTYPE IS SET RIGHT{18279
{{JSR{6,TRXEQ{{{EXECUTE FULL TRACE{18280
{{EJC{{{{{18281
*
*      RETRN (CONTINUED)
*
*      HERE TO TEST FOR FTRACE
*
{RTN02{BZE{3,KVFTR{6,RTN05{{JUMP IF FTRACE IS OFF{18287
{{DCV{3,KVFTR{{{ELSE DECREMENT FTRACE{18288
*
*      HERE FOR PRINT TRACE OF FUNCTION RETURN
*
{RTN03{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{18292
{{MOV{12,1(XS){7,XR{{LOAD RETURN TYPE{18293
{{JSR{6,PRTST{{{PRINT IT{18294
{{MOV{18,=CH$BL{8,WA{{LOAD BLANK{18295
{{JSR{6,PRTCH{{{PRINT IT{18296
{{MOV{12,0(XS){7,XL{{LOAD PFBLK PTR{18297
{{MOV{13,PFVBL(XL){7,XL{{LOAD FUNCTION VRBLK PTR{18298
{{MOV{19,*VRVAL{8,WA{{SET VRBLK NAME OFFSET{18299
{{BNE{7,XR{21,=SCFRT{6,RTN04{JUMP IF NOT FRETURN CASE{18300
*
*      FOR FRETURN, JUST PRINT FUNCTION NAME
*
{{JSR{6,PRTNM{{{PRINT NAME{18304
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{18305
{{BRN{6,RTN05{{{MERGE{18306
*
*      HERE FOR RETURN OR NRETURN, PRINT FUNCTION NAME = VALUE
*
{RTN04{JSR{6,PRTNV{{{PRINT NAME = VALUE{18310
*
*      HERE AFTER COMPLETING TRACE
*
{RTN05{MOV{10,(XS)+{7,XR{{POP PFBLK POINTER{18314
{{MOV{10,(XS)+{8,WA{{POP RETURN TYPE STRING{18315
*
*      MERGE HERE IF NO TRACE REQUIRED
*
{RTN06{MOV{8,WA{3,KVRTN{{SET RTNTYPE KEYWORD{18319
{{MOV{13,PFVBL(XR){7,XL{{LOAD POINTER TO FN VRBLK{18320
{{EJC{{{{{18321
*      RETRN (CONTINUED)
*
*      GET VALUE OF FUNCTION
*
{RTN07{MOV{7,XL{3,RTNBP{{SAVE BLOCK POINTER{18326
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{18327
{{BEQ{9,(XL){22,=B$TRT{6,RTN07{LOOP BACK IF TRAPPED{18328
{{MOV{7,XL{3,RTNFV{{ELSE SAVE FUNCTION RESULT VALUE{18329
{{MOV{10,(XS)+{3,RTNSV{{SAVE ORIGINAL FUNCTION VALUE{18330
{{MOV{10,(XS)+{7,XL{{POP SAVED POINTER{18334
{{BZE{7,XL{6,RTN7C{{NO ACTION IF NONE{18335
{{BZE{3,KVPFL{6,RTN7C{{JUMP IF NO PROFILING{18336
{{JSR{6,PRFLU{{{ELSE PROFILE LAST FUNC STMT{18337
{{BEQ{3,KVPFL{18,=NUM02{6,RTN7A{BRANCH ON VALUE OF PROFILE KEYWD{18338
*
*      HERE IF &PROFILE = 1. START TIME MUST BE FRIGGED TO
*      APPEAR EARLIER THAN IT ACTUALLY IS, BY AMOUNT USED BEFORE
*      THE CALL.
*
{{LDI{3,PFSTM{{{LOAD CURRENT TIME{18344
{{SBI{13,ICVAL(XL){{{FRIG BY SUBTRACTING SAVED AMOUNT{18345
{{BRN{6,RTN7B{{{AND MERGE{18346
*
*      HERE IF &PROFILE = 2
*
{RTN7A{LDI{13,ICVAL(XL){{{LOAD SAVED TIME{18350
*
*      BOTH PROFILE TYPES MERGE HERE
*
{RTN7B{STI{3,PFSTM{{{STORE BACK CORRECT START TIME{18354
*
*      MERGE HERE IF NO PROFILING
*
{RTN7C{MOV{13,FARGS(XR){8,WB{{GET NUMBER OF ARGS{18358
{{ADD{13,PFNLO(XR){8,WB{{ADD NUMBER OF LOCALS{18360
{{BZE{8,WB{6,RTN10{{JUMP IF NO ARGS/LOCALS{18361
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{18362
{{ADD{13,PFLEN(XR){7,XR{{AND POINT TO END OF PFBLK{18363
*
*      LOOP TO RESTORE FUNCTIONS AND LOCALS
*
{RTN08{MOV{11,-(XR){7,XL{{LOAD NEXT VRBLK POINTER{18367
*
*      LOOP TO FIND VALUE BLOCK
*
{RTN09{MOV{7,XL{8,WA{{SAVE BLOCK POINTER{18371
{{MOV{13,VRVAL(XL){7,XL{{LOAD POINTER TO NEXT VALUE{18372
{{BEQ{9,(XL){22,=B$TRT{6,RTN09{LOOP BACK IF TRAPPED{18373
{{MOV{8,WA{7,XL{{ELSE RESTORE LAST BLOCK POINTER{18374
{{MOV{10,(XS)+{13,VRVAL(XL){{RESTORE OLD VARIABLE VALUE{18375
{{BCT{8,WB{6,RTN08{{LOOP TILL ALL PROCESSED{18376
*
*      NOW RESTORE FUNCTION VALUE AND EXIT
*
{RTN10{MOV{3,RTNBP{7,XL{{RESTORE PTR TO LAST FUNCTION BLOCK{18380
{{MOV{3,RTNSV{13,VRVAL(XL){{RESTORE OLD FUNCTION VALUE{18381
{{MOV{3,RTNFV{7,XR{{RELOAD FUNCTION RESULT{18382
{{MOV{3,R$COD{7,XL{{POINT TO NEW CODE BLOCK{18383
{{MOV{3,KVSTN{3,KVLST{{SET LASTNO FROM STNO{18384
{{MOV{13,CDSTM(XL){3,KVSTN{{RESET PROPER STNO VALUE{18385
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE FROM LINE{18387
{{MOV{13,CDSLN(XL){3,KVLIN{{RESET PROPER LINE VALUE{18388
{{MOV{3,KVRTN{8,WA{{LOAD RETURN TYPE{18390
{{BEQ{8,WA{21,=SCRTN{6,EXIXR{EXIT WITH RESULT IN XR IF RETURN{18391
{{BEQ{8,WA{21,=SCFRT{6,EXFAL{FAIL IF FRETURN{18392
{{EJC{{{{{18393
*
*      RETRN (CONTINUED)
*
*      HERE FOR NRETURN
*
{{BEQ{9,(XR){22,=B$NML{6,RTN11{JUMP IF IS A NAME{18399
{{JSR{6,GTNVR{{{ELSE TRY CONVERT TO VARIABLE NAME{18400
{{ERR{1,243{26,Function result in NRETURN is not name{{{18401
{{MOV{7,XR{7,XL{{IF OK, COPY VRBLK (NAME BASE) PTR{18402
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{18403
{{BRN{6,RTN12{{{AND MERGE{18404
*
*      HERE IF RETURNED RESULT IS A NAME
*
{RTN11{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{18408
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{18409
*
*      MERGE HERE WITH RETURNED NAME IN (XL,WA)
*
{RTN12{MOV{7,XL{7,XR{{PRESERVE XL{18413
{{LCW{8,WB{{{LOAD NEXT WORD{18414
{{MOV{7,XR{7,XL{{RESTORE XL{18415
{{BEQ{8,WB{21,=OFNE${6,EXNAM{EXIT IF CALLED BY NAME{18416
{{MOV{8,WB{11,-(XS){{ELSE SAVE CODE WORD{18417
{{JSR{6,ACESS{{{GET VALUE{18418
{{PPM{6,EXFAL{{{FAIL IF ACCESS FAILS{18419
{{MOV{7,XR{7,XL{{IF OK, COPY RESULT{18420
{{MOV{9,(XS){7,XR{{RELOAD NEXT CODE WORD{18421
{{MOV{7,XL{9,(XS){{STORE RESULT ON STACK{18422
{{MOV{9,(XR){7,XL{{LOAD ROUTINE ADDRESS{18423
{{BRI{7,XL{{{JUMP TO EXECUTE NEXT CODE WORD{18424
{{EJC{{{{{18425
*
*      STCOV -- SIGNAL STATEMENT COUNTER OVERFLOW
*
*      BRN  STCOV            JUMP TO SIGNAL STATEMENT COUNT OFLO
*
*      PERMIT UP TO 10 MORE STATEMENTS TO BE OBEYED SO THAT
*      SETEXIT TRAP CAN REGAIN CONTROL.
*      STCOV CONTINUES BY ISSUING THE ERROR MESSAGE
*
{STCOV{RTN{{{{{18435
{{ICV{3,ERRFT{{{FATAL ERROR{18436
{{LDI{4,INTVT{{{GET 10{18437
{{ADI{3,KVSTL{{{ADD TO FORMER LIMIT{18438
{{STI{3,KVSTL{{{STORE AS NEW STLIMIT{18439
{{LDI{4,INTVT{{{GET 10{18440
{{STI{3,KVSTC{{{SET AS NEW COUNT{18441
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{18442
{{ERB{1,244{26,Statement count exceeds value of STLIMIT keyword{{{18443
{{EJC{{{{{18444
*
*      STMGO -- START EXECUTION OF NEW STATEMENT
*
*      (XR)                  POINTER TO CDBLK FOR NEW STATEMENT
*      BRN  STMGO            JUMP TO EXECUTE NEW STATEMENT
*
*      STMGO CONTINUES BY EXECUTING THE NEXT STATEMENT
*
{STMGO{RTN{{{{{18453
{{MOV{7,XR{3,R$COD{{SET NEW CODE BLOCK POINTER{18454
{{DCV{3,STMCT{{{SEE IF TIME TO CHECK SOMETHING{18455
{{BZE{3,STMCT{6,STGO2{{JUMP IF SO{18456
{{MOV{3,KVSTN{3,KVLST{{SET LASTNO{18457
{{MOV{13,CDSTM(XR){3,KVSTN{{SET STNO{18458
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE{18460
{{MOV{13,CDSLN(XR){3,KVLIN{{SET LINE{18461
{{ADD{19,*CDCOD{7,XR{{POINT TO FIRST CODE WORD{18463
{{LCP{7,XR{{{SET CODE POINTER{18464
*
*      HERE TO EXECUTE FIRST CODE WORD OF STATEMENT
*
{STGO1{LCW{7,XR{{{LOAD NEXT CODE WORD{18468
{{ZER{7,XL{{{CLEAR GARBAGE XL{18469
{{BRI{9,(XR){{{EXECUTE IT{18470
*
*      CHECK PROFILING, POLLING, STLIMIT, STATEMENT TRACING
*
{STGO2{BZE{3,KVPFL{6,STGO3{{SKIP IF NO PROFILING{18474
{{JSR{6,PRFLU{{{ELSE PROFILE THE STATEMENT IN KVSTN{18475
*
*      HERE WHEN FINISHED WITH PROFILING
*
{STGO3{MOV{3,KVSTN{3,KVLST{{SET LASTNO{18479
{{MOV{13,CDSTM(XR){3,KVSTN{{SET STNO{18480
{{MOV{3,KVLIN{3,KVLLN{{SET LASTLINE{18482
{{MOV{13,CDSLN(XR){3,KVLIN{{SET LINE{18483
{{ADD{19,*CDCOD{7,XR{{POINT TO FIRST CODE WORD{18485
{{LCP{7,XR{{{SET CODE POINTER{18486
*
*      HERE TO CHECK FOR POLLING
*
{{MOV{3,STMCS{11,-(XS){{SAVE PRESENT COUNT START ON STACK{18491
{{DCV{3,POLCT{{{POLL INTERVAL WITHIN STMCT{18492
{{BNZ{3,POLCT{6,STGO4{{JUMP IF NOT POLL TIME YET{18493
{{ZER{8,WA{{{=0 FOR POLL{18494
{{MOV{3,KVSTN{8,WB{{STATEMENT NUMBER{18495
{{MOV{7,XR{7,XL{{MAKE COLLECTABLE{18496
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{18497
{{ERR{1,320{26,User interrupt{{{18498
{{PPM{{{{SINGLE STEP{18499
{{PPM{{{{EXPRESSION EVALUATION{18500
{{MOV{7,XL{7,XR{{RESTORE CODE BLOCK POINTER{18501
{{MOV{8,WA{3,POLCS{{POLL INTERVAL START VALUE{18502
{{JSR{6,STGCC{{{RECOMPUTE COUNTER VALUES{18503
*
*      CHECK STATEMENT LIMIT
*
{STGO4{LDI{3,KVSTC{{{GET STMT COUNT{18508
{{ILT{6,STGO5{{{OMIT COUNTING IF NEGATIVE{18509
{{MTI{10,(XS)+{{{RELOAD START VALUE OF COUNTER{18510
{{NGI{{{{NEGATE{18511
{{ADI{3,KVSTC{{{STMT COUNT MINUS COUNTER{18512
{{STI{3,KVSTC{{{REPLACE IT{18513
{{ILE{6,STCOV{{{FAIL IF STLIMIT REACHED{18514
{{BZE{3,R$STC{6,STGO5{{JUMP IF NO STATEMENT TRACE{18515
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{18516
{{MOV{3,R$STC{7,XL{{LOAD POINTER TO STCOUNT TRBLK{18517
{{JSR{6,KTREX{{{EXECUTE KEYWORD TRACE{18518
*
*      RESET STMGO COUNTER
*
{STGO5{MOV{3,STMCS{3,STMCT{{RESET COUNTER{18522
{{BRN{6,STGO1{{{FETCH NEXT CODE WORD{18523
{{EJC{{{{{18524
*
*      STOPR -- TERMINATE RUN
*
*      (XR)                  POINTS TO ENDING MESSAGE
*      BRN STOPR             JUMP TO TERMINATE RUN
*
*      TERMINATE RUN AND PRINT STATISTICS.  ON ENTRY XR POINTS
*      TO ENDING MESSAGE OR IS ZERO IF MESSAGE  PRINTED ALREADY.
*
{STOPR{RTN{{{{{18534
{{BZE{7,XR{6,STPRA{{SKIP IF SYSAX ALREADY CALLED{18536
{{JSR{6,SYSAX{{{CALL AFTER EXECUTION PROC{18537
{STPRA{ADD{3,RSMEM{3,DNAME{{USE THE RESERVE MEMORY{18538
{{BNE{7,XR{21,=ENDMS{6,STPR0{SKIP IF NOT NORMAL END MESSAGE{18542
{{BNZ{3,EXSTS{6,STPR3{{SKIP IF EXEC STATS SUPPRESSED{18543
{{ZER{3,ERICH{{{CLEAR ERRORS TO INT.CH. FLAG{18544
*
*      LOOK TO SEE IF AN ENDING MESSAGE IS SUPPLIED
*
{STPR0{JSR{6,PRTPG{{{EJECT PRINTER{18548
{{BZE{7,XR{6,STPR1{{SKIP IF NO MESSAGE{18549
{{JSR{6,PRTST{{{PRINT MESSAGE{18550
*
*      MERGE HERE IF NO MESSAGE TO PRINT
*
{STPR1{JSR{6,PRTIS{{{PRINT BLANK LINE{18554
{{BNZ{3,GBCFL{6,STPR5{{IF IN GARBAGE COLLECTION, SKIP{18556
{{MOV{21,=STPM7{7,XR{{POINT TO MESSAGE /IN FILE XXX/{18557
{{JSR{6,PRTST{{{PRINT IT{18558
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{18559
{{MOV{3,KVSTN{8,WC{{GET STATEMENT NUMBER{18560
{{JSR{6,FILNM{{{GET FILE NAME{18561
{{MOV{7,XL{7,XR{{PREPARE TO PRINT{18562
{{JSR{6,PRTST{{{PRINT FILE NAME{18563
{{JSR{6,PRTIS{{{PRINT TO INTERACTIVE CHANNEL{18564
{{MOV{3,R$COD{7,XR{{GET CODE POINTER{18571
{{MTI{13,CDSLN(XR){{{GET SOURCE LINE NUMBER{18572
{{MOV{21,=STPM6{7,XR{{POINT TO MESSAGE /IN LINE XXX/{18573
{{JSR{6,PRTMX{{{PRINT IT{18574
{STPR5{MTI{3,KVSTN{{{GET STATEMENT NUMBER{18576
{{MOV{21,=STPM1{7,XR{{POINT TO MESSAGE /IN STATEMENT XXX/{18577
{{JSR{6,PRTMX{{{PRINT IT{18578
{{JSR{6,SYSTM{{{GET CURRENT TIME{18579
{{SBI{3,TIMSX{{{MINUS START TIME = ELAPSED EXEC TIM{18580
{{STI{3,STPTI{{{SAVE FOR LATER{18581
{{MOV{21,=STPM3{7,XR{{POINT TO MSG /EXECUTION TIME MSEC /{18582
{{JSR{6,PRTMX{{{PRINT IT{18583
{{LDI{3,KVSTL{{{GET STATEMENT LIMIT{18584
{{ILT{6,STPR2{{{SKIP IF NEGATIVE{18585
{{SBI{3,KVSTC{{{MINUS COUNTER = COURSE COUNT{18586
{{STI{3,STPSI{{{SAVE{18587
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER START VALUE{18588
{{SUB{3,STMCT{8,WA{{MINUS CURRENT COUNTER{18589
{{MTI{8,WA{{{CONVERT TO INTEGER{18590
{{ADI{3,STPSI{{{ADD IN COURSE COUNT{18591
{{STI{3,STPSI{{{SAVE{18592
{{MOV{21,=STPM2{7,XR{{POINT TO MESSAGE /STMTS EXECUTED/{18593
{{JSR{6,PRTMX{{{PRINT IT{18594
{{LDI{3,STPTI{{{RELOAD ELAPSED TIME{18597
{{MLI{4,INTTH{{{*1000 (MICROSECS){18598
{{IOV{6,STPR2{{{JUMP IF WE CANNOT COMPUTE{18599
{{DVI{3,STPSI{{{DIVIDE BY STATEMENT COUNT{18600
{{IOV{6,STPR2{{{JUMP IF OVERFLOW{18601
{{MOV{21,=STPM4{7,XR{{POINT TO MSG (MCSEC PER STATEMENT /{18602
{{JSR{6,PRTMX{{{PRINT IT{18603
{{EJC{{{{{18605
*
*      STOPR (CONTINUED)
*
*      MERGE TO SKIP MESSAGE (OVERFLOW OR NEGATIVE STLIMIT)
*
{STPR2{MTI{3,GBCNT{{{LOAD COUNT OF COLLECTIONS{18611
{{MOV{21,=STPM5{7,XR{{POINT TO MESSAGE /REGENERATIONS /{18612
{{JSR{6,PRTMX{{{PRINT IT{18613
{{JSR{6,PRTMM{{{PRINT MEMORY USAGE{18614
{{JSR{6,PRTIS{{{ONE MORE BLANK FOR LUCK{18615
*
*      CHECK IF DUMP REQUESTED
*
{STPR3{JSR{6,PRFLR{{{PRINT PROFILE IF WANTED{18622
*
{{MOV{3,KVDMP{7,XR{{LOAD DUMP KEYWORD{18624
{{JSR{6,DUMPR{{{EXECUTE DUMP IF REQUESTED{18626
{{MOV{3,R$FCB{7,XL{{GET FCBLK CHAIN HEAD{18627
{{MOV{3,KVABE{8,WA{{LOAD ABEND VALUE{18628
{{MOV{3,KVCOD{8,WB{{LOAD CODE VALUE{18629
{{JSR{6,SYSEJ{{{EXIT TO SYSTEM{18630
*
*      HERE AFTER SYSEA CALL AND SUPPRESSING ERROR MSG PRINT
*
{STPR4{RTN{{{{{18635
{{ADD{3,RSMEM{3,DNAME{{USE THE RESERVE MEMORY{18636
{{BZE{3,EXSTS{6,STPR1{{IF EXECUTION STATS REQUESTED{18637
{{BRN{6,STPR3{{{CHECK IF DUMP OR PROFILE NEEDED{18638
{{EJC{{{{{18641
*
*      SUCCP -- SIGNAL SUCCESSFUL MATCH OF A PATTERN NODE
*
*      SEE PATTERN MATCH ROUTINES FOR DETAILS
*
*      (XR)                  CURRENT NODE
*      (WB)                  CURRENT CURSOR
*      (XL)                  MAY BE NON-COLLECTABLE
*      BRN  SUCCP            SIGNAL SUCCESSFUL PATTERN MATCH
*
*      SUCCP CONTINUES BY MATCHING THE SUCCESSOR NODE
*
{SUCCP{RTN{{{{{18654
{{MOV{13,PTHEN(XR){7,XR{{LOAD SUCCESSOR NODE{18655
{{MOV{9,(XR){7,XL{{LOAD NODE CODE ENTRY ADDRESS{18656
{{BRI{7,XL{{{JUMP TO MATCH SUCCESSOR NODE{18657
{{EJC{{{{{18658
*
*      SYSAB -- PRINT /ABNORMAL END/ AND TERMINATE
*
{SYSAB{RTN{{{{{18662
{{MOV{21,=ENDAB{7,XR{{POINT TO MESSAGE{18663
{{MOV{18,=NUM01{3,KVABE{{SET ABEND FLAG{18664
{{JSR{6,PRTNL{{{SKIP TO NEW LINE{18665
{{BRN{6,STOPR{{{JUMP TO PACK UP{18666
{{EJC{{{{{18667
*
*      SYSTU -- PRINT /TIME UP/ AND TERMINATE
*
{SYSTU{RTN{{{{{18671
{{MOV{21,=ENDTU{7,XR{{POINT TO MESSAGE{18672
{{MOV{4,STRTU{8,WA{{GET CHARS /TU/{18673
{{MOV{8,WA{3,KVCOD{{PUT IN KVCOD{18674
{{MOV{3,TIMUP{8,WA{{CHECK STATE OF TIMEUP SWITCH{18675
{{MNZ{3,TIMUP{{{SET SWITCH{18676
{{BNZ{8,WA{6,STOPR{{STOP RUN IF ALREADY SET{18677
{{ERB{1,245{26,Translation/execution time expired{{{18678
{{TTL{27,S P I T B O L -- UTILITY PROCEDURES{{{{18679
*
*      THE FOLLOWING SECTION CONTAINS PROCEDURES WHICH ARE
*      USED FOR VARIOUS PURPOSES THROUGHOUT THE SYSTEM.
*
*      EACH PROCEDURE IS PRECEDED BY A DESCRIPTION OF THE
*      CALLING SEQUENCE. USUALLY THE ARGUMENTS ARE IN REGISTERS
*      BUT ARGUMENTS CAN ALSO OCCUR ON THE STACK AND AS
*      PARAMETERS ASSEMBLED AFTER THE JSR INSTRUCTION.
*
*      THE FOLLOWING CONSIDERATIONS APPLY TO THESE DESCRIPTIONS.
*
*      1)   THE STACK POINTER (XS) IS NOT CHANGED UNLESS THE
*           CHANGE IS EXPLICITLY DOCUMENTED IN THE CALL.
*
*      2)   REGISTERS WHOSE ENTRY VALUES ARE NOT MENTIONED
*           MAY CONTAIN ANY VALUE EXCEPT THAT XL,XR MAY ONLY
*           CONTAIN PROPER (COLLECTABLE) POINTER VALUES.
*           THIS CONDITION ON MEANS THAT THE CALLED ROUTINE
*           MAY IF IT CHOOSES PRESERVE XL,XR BY STACKING.
*
*      3)   REGISTERS NOT MENTIONED ON EXIT CONTAIN THE SAME
*           VALUES AS THEY DID ON ENTRY EXCEPT THAT VALUES IN
*           XR,XL MAY HAVE BEEN RELOCATED BY THE COLLECTOR.
*
*      4)   REGISTERS WHICH ARE DESTROYED ON EXIT MAY CONTAIN
*           ANY VALUE EXCEPT THAT VALUES IN XL,XR ARE PROPER
*           (COLLECTABLE) POINTERS.
*
*      5)   THE CODE POINTER REGISTER POINTS TO THE CURRENT
*           CODE LOCATION ON ENTRY AND IS UNCHANGED ON EXIT.
*
*      IN THE ABOVE DESCRIPTION, A COLLECTABLE POINTER IS ONE
*      WHICH EITHER POINTS OUTSIDE THE DYNAMIC REGION OR
*      POINTS TO THE START OF A BLOCK IN THE DYNAMIC REGION.
*
*      IN THOSE CASES WHERE THE CALLING SEQUENCE CONTAINS
*      PARAMETERS WHICH ARE USED AS ALTERNATE RETURN POINTS,
*      THESE PARAMETERS MAY BE REPLACED BY ERROR CODES
*      ASSEMBLED WITH THE ERR INSTRUCTION. THIS WILL RESULT
*      IN THE POSTING OF THE ERROR IF THE RETURN IS TAKEN.
*
*      THE PROCEDURES ALL HAVE NAMES CONSISTING OF FIVE LETTERS
*      AND ARE IN ALPHABETICAL ORDER BY THEIR NAMES.
{{EJC{{{{{18723
*
*      ACESS - ACCESS VARIABLE VALUE WITH TRACE/INPUT CHECKS
*
*      ACESS LOADS THE VALUE OF A VARIABLE. TRACE AND INPUT
*      ASSOCIATIONS ARE TESTED FOR AND EXECUTED AS REQUIRED.
*      ACESS ALSO HANDLES THE SPECIAL CASES OF PSEUDO-VARIABLES.
*
*      (XL)                  VARIABLE NAME BASE
*      (WA)                  VARIABLE NAME OFFSET
*      JSR  ACESS            CALL TO ACCESS VALUE
*      PPM  LOC              TRANSFER LOC IF ACCESS FAILURE
*      (XR)                  VARIABLE VALUE
*      (WA,WB,WC)            DESTROYED
*      (XL,RA)               DESTROYED
*
*      FAILURE CAN OCCUR IF AN INPUT ASSOCIATION CAUSES AN END
*      OF FILE CONDITION OR IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ACESS{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){18743
{{MOV{7,XL{7,XR{{COPY NAME BASE{18744
{{ADD{8,WA{7,XR{{POINT TO VARIABLE LOCATION{18745
{{MOV{9,(XR){7,XR{{LOAD VARIABLE VALUE{18746
*
*      LOOP HERE TO CHECK FOR SUCCESSIVE TRBLKS
*
{ACS02{BNE{9,(XR){22,=B$TRT{6,ACS18{JUMP IF NOT TRAPPED{18750
*
*      HERE IF TRAPPED
*
{{BEQ{7,XR{21,=TRBKV{6,ACS12{JUMP IF KEYWORD VARIABLE{18754
{{BNE{7,XR{21,=TRBEV{6,ACS05{JUMP IF NOT EXPRESSION VARIABLE{18755
*
*      HERE FOR EXPRESSION VARIABLE, EVALUATE VARIABLE
*
{{MOV{13,EVEXP(XL){7,XR{{LOAD EXPRESSION POINTER{18759
{{ZER{8,WB{{{EVALUATE BY VALUE{18760
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{18761
{{PPM{6,ACS04{{{JUMP IF EVALUATION FAILURE{18762
{{BRN{6,ACS02{{{CHECK VALUE FOR MORE TRBLKS{18763
{{EJC{{{{{18764
*
*      ACESS (CONTINUED)
*
*      HERE ON READING END OF FILE
*
{ACS03{ADD{19,*NUM03{7,XS{{POP TRBLK PTR, NAME BASE AND OFFSET{18770
{{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18771
*
*      MERGE HERE WHEN EVALUATION OF EXPRESSION FAILS
*
{ACS04{EXI{1,1{{{TAKE ALTERNATE (FAILURE) RETURN{18775
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ACS05{MOV{13,TRTYP(XR){8,WB{{LOAD TRAP TYPE CODE{18779
{{BNZ{8,WB{6,ACS10{{JUMP IF NOT INPUT ASSOCIATION{18780
{{BZE{3,KVINP{6,ACS09{{IGNORE INPUT ASSOC IF INPUT IS OFF{18781
*
*      HERE FOR INPUT ASSOCIATION
*
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{18785
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{18786
{{MOV{7,XR{11,-(XS){{STACK TRBLK POINTER{18787
{{MOV{3,KVTRM{3,ACTRM{{TEMP TO HOLD TRIM KEYWORD{18788
{{MOV{13,TRFPT(XR){7,XL{{GET FILE CTRL BLK PTR OR ZERO{18789
{{BNZ{7,XL{6,ACS06{{JUMP IF NOT STANDARD INPUT FILE{18790
{{BEQ{13,TRTER(XR){21,=V$TER{6,ACS21{JUMP IF TERMINAL{18791
*
*      HERE TO READ FROM STANDARD INPUT FILE
*
{{MOV{3,CSWIN{8,WA{{LENGTH FOR READ BUFFER{18795
{{JSR{6,ALOCS{{{BUILD STRING OF APPROPRIATE LENGTH{18796
{{JSR{6,SYSRD{{{READ NEXT STANDARD INPUT IMAGE{18797
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{18798
{{BRN{6,ACS07{{{ELSE MERGE WITH OTHER FILE CASE{18799
*
*      HERE FOR INPUT FROM OTHER THAN STANDARD INPUT FILE
*
{ACS06{MOV{7,XL{8,WA{{FCBLK PTR{18803
{{JSR{6,SYSIL{{{GET INPUT RECORD MAX LENGTH (TO WA){18804
{{BNZ{8,WC{6,ACS6A{{JUMP IF NOT BINARY FILE{18805
{{MOV{8,WC{3,ACTRM{{DISABLE TRIM FOR BINARY FILE{18806
{ACS6A{JSR{6,ALOCS{{{ALLOCATE STRING OF CORRECT SIZE{18807
{{MOV{7,XL{8,WA{{FCBLK PTR{18808
{{JSR{6,SYSIN{{{CALL SYSTEM INPUT ROUTINE{18809
{{PPM{6,ACS03{{{JUMP TO FAIL EXIT IF END OF FILE{18810
{{PPM{6,ACS22{{{ERROR{18811
{{PPM{6,ACS23{{{ERROR{18812
{{EJC{{{{{18813
*
*      ACESS (CONTINUED)
*
*      MERGE HERE AFTER OBTAINING INPUT RECORD
*
{ACS07{MOV{3,ACTRM{8,WB{{LOAD TRIM INDICATOR{18819
{{JSR{6,TRIMR{{{TRIM RECORD AS REQUIRED{18820
{{MOV{7,XR{8,WB{{COPY RESULT POINTER{18821
{{MOV{9,(XS){7,XR{{RELOAD POINTER TO TRBLK{18822
*
*      LOOP TO CHASE TO END OF TRBLK CHAIN AND STORE VALUE
*
{ACS08{MOV{7,XR{7,XL{{SAVE POINTER TO THIS TRBLK{18826
{{MOV{13,TRNXT(XR){7,XR{{LOAD FORWARD POINTER{18827
{{BEQ{9,(XR){22,=B$TRT{6,ACS08{LOOP IF THIS IS ANOTHER TRBLK{18828
{{MOV{8,WB{13,TRNXT(XL){{ELSE STORE RESULT AT END OF CHAIN{18829
{{MOV{10,(XS)+{7,XR{{RESTORE INITIAL TRBLK POINTER{18830
{{MOV{10,(XS)+{8,WA{{RESTORE NAME OFFSET{18831
{{MOV{10,(XS)+{7,XL{{RESTORE NAME BASE POINTER{18832
*
*      COME HERE TO MOVE TO NEXT TRBLK
*
{ACS09{MOV{13,TRNXT(XR){7,XR{{LOAD FORWARD PTR TO NEXT VALUE{18836
{{BRN{6,ACS02{{{BACK TO CHECK IF TRAPPED{18837
*
*      HERE TO CHECK FOR ACCESS TRACE TRBLK
*
{ACS10{BNE{8,WB{18,=TRTAC{6,ACS09{LOOP BACK IF NOT ACCESS TRACE{18841
{{BZE{3,KVTRA{6,ACS09{{IGNORE ACCESS TRACE IF TRACE OFF{18842
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{18843
{{BZE{13,TRFNC(XR){6,ACS11{{JUMP IF PRINT TRACE{18844
{{EJC{{{{{18845
*
*      ACESS (CONTINUED)
*
*      HERE FOR FULL FUNCTION TRACE
*
{{JSR{6,TRXEQ{{{CALL ROUTINE TO EXECUTE TRACE{18851
{{BRN{6,ACS09{{{JUMP FOR NEXT TRBLK{18852
*
*      HERE FOR CASE OF PRINT TRACE
*
{ACS11{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{18856
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{18857
{{BRN{6,ACS09{{{JUMP BACK FOR NEXT TRBLK{18858
*
*      HERE FOR KEYWORD VARIABLE
*
{ACS12{MOV{13,KVNUM(XL){7,XR{{LOAD KEYWORD NUMBER{18862
{{BGE{7,XR{18,=K$V$${6,ACS14{JUMP IF NOT ONE WORD VALUE{18863
{{MTI{15,KVABE(XR){{{ELSE LOAD VALUE AS INTEGER{18864
*
*      COMMON EXIT WITH KEYWORD VALUE AS INTEGER IN (IA)
*
{ACS13{JSR{6,ICBLD{{{BUILD ICBLK{18868
{{BRN{6,ACS18{{{JUMP TO EXIT{18869
*
*      HERE IF NOT ONE WORD KEYWORD VALUE
*
{ACS14{BGE{7,XR{18,=K$S$${6,ACS15{JUMP IF SPECIAL CASE{18873
{{SUB{18,=K$V$${7,XR{{ELSE GET OFFSET{18874
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{18875
{{ADD{21,=NDABO{7,XR{{POINT TO PATTERN VALUE{18876
{{BRN{6,ACS18{{{JUMP TO EXIT{18877
*
*      HERE IF SPECIAL KEYWORD CASE
*
{ACS15{MOV{3,KVRTN{7,XL{{LOAD RTNTYPE IN CASE{18881
{{LDI{3,KVSTL{{{LOAD STLIMIT IN CASE{18882
{{SUB{18,=K$S$${7,XR{{GET CASE NUMBER{18883
{{BSW{7,XR{2,K$$N${{SWITCH ON KEYWORD NUMBER{18884
{{IFF{2,K$$AL{6,ACS16{{JUMP IF ALPHABET{18898
{{IFF{2,K$$RT{6,ACS17{{RTNTYPE{18898
{{IFF{2,K$$SC{6,ACS19{{STCOUNT{18898
{{IFF{2,K$$ET{6,ACS20{{ERRTEXT{18898
{{IFF{2,K$$FL{6,ACS26{{FILE{18898
{{IFF{2,K$$LF{6,ACS27{{LASTFILE{18898
{{IFF{2,K$$SL{6,ACS13{{STLIMIT{18898
{{IFF{2,K$$LC{6,ACS24{{LCASE{18898
{{IFF{2,K$$UC{6,ACS25{{UCASE{18898
{{ESW{{{{END SWITCH ON KEYWORD NUMBER{18898
{{EJC{{{{{18899
*
*      ACESS (CONTINUED)
*
*      LCASE
*
{ACS24{MOV{21,=LCASE{7,XR{{LOAD POINTER TO LCASE STRING{18906
{{BRN{6,ACS18{{{COMMON RETURN{18907
*
*      UCASE
*
{ACS25{MOV{21,=UCASE{7,XR{{LOAD POINTER TO UCASE STRING{18911
{{BRN{6,ACS18{{{COMMON RETURN{18912
*
*      FILE
*
{ACS26{MOV{3,KVSTN{8,WC{{LOAD CURRENT STMT NUMBER{18918
{{BRN{6,ACS28{{{MERGE TO OBTAIN FILE NAME{18919
*
*      LASTFILE
*
{ACS27{MOV{3,KVLST{8,WC{{LOAD LAST STMT NUMBER{18923
*
*      MERGE HERE TO MAP STATEMENT NUMBER IN WC TO FILE NAME
*
{ACS28{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STMT{18927
{{BRN{6,ACS17{{{MERGE TO RETURN STRING IN XL{18928
*      ALPHABET
*
{ACS16{MOV{3,KVALP{7,XL{{LOAD POINTER TO ALPHABET STRING{18932
*
*      RTNTYPE MERGES HERE
*
{ACS17{MOV{7,XL{7,XR{{COPY STRING PTR TO PROPER REG{18936
*
*      COMMON RETURN POINT
*
{ACS18{EXI{{{{RETURN TO ACESS CALLER{18940
*
*      HERE FOR STCOUNT (IA HAS STLIMIT)
*
{ACS19{ILT{6,ACS29{{{IF COUNTING SUPPRESSED{18944
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER START VALUE{18945
{{SUB{3,STMCT{8,WA{{MINUS CURRENT COUNTER{18946
{{MTI{8,WA{{{CONVERT TO INTEGER{18947
{{ADI{3,KVSTL{{{ADD STLIMIT{18948
{ACS29{SBI{3,KVSTC{{{STCOUNT = LIMIT - LEFT{18949
{{BRN{6,ACS13{{{MERGE BACK WITH INTEGER RESULT{18950
*
*      ERRTEXT
*
{ACS20{MOV{3,R$ETX{7,XR{{GET ERRTEXT STRING{18954
{{BRN{6,ACS18{{{MERGE WITH RESULT{18955
*
*      HERE TO READ A RECORD FROM TERMINAL
*
{ACS21{MOV{18,=RILEN{8,WA{{BUFFER LENGTH{18959
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{18960
{{JSR{6,SYSRI{{{READ RECORD{18961
{{PPM{6,ACS03{{{ENDFILE{18962
{{BRN{6,ACS07{{{MERGE WITH RECORD READ{18963
*
*      ERROR RETURNS
*
{ACS22{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18967
{{ERB{1,202{26,Input from file caused non-recoverable error{{{18968
*
{ACS23{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{18970
{{ERB{1,203{26,Input file record has incorrect format{{{18971
{{ENP{{{{END PROCEDURE ACESS{18972
{{EJC{{{{{18973
*
*      ACOMP -- COMPARE TWO ARITHMETIC VALUES
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  ACOMP            CALL TO COMPARE VALUES
*      PPM  LOC              TRANSFER LOC IF ARG1 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC IF ARG2 IS NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR ARG1 LT ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 EQ ARG2
*      PPM  LOC              TRANSFER LOC FOR ARG1 GT ARG2
*      (NORMAL RETURN IS NEVER GIVEN)
*      (WA,WB,WC,IA,RA)      DESTROYED
*      (XL,XR)               DESTROYED
*
{ACOMP{PRC{25,N{1,5{{ENTRY POINT{18989
{{JSR{6,ARITH{{{LOAD ARITHMETIC OPERANDS{18990
{{PPM{6,ACMP7{{{JUMP IF FIRST ARG NON-NUMERIC{18991
{{PPM{6,ACMP8{{{JUMP IF SECOND ARG NON-NUMERIC{18992
{{PPM{6,ACMP4{{{JUMP IF REAL ARGUMENTS{18995
*
*      HERE FOR INTEGER ARGUMENTS
*
{{SBI{13,ICVAL(XL){{{SUBTRACT TO COMPARE{19000
{{IOV{6,ACMP3{{{JUMP IF OVERFLOW{19001
{{ILT{6,ACMP5{{{ELSE JUMP IF ARG1 LT ARG2{19002
{{IEQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{19003
*
*      HERE IF ARG1 GT ARG2
*
{ACMP1{EXI{1,5{{{TAKE GT EXIT{19007
*
*      HERE IF ARG1 EQ ARG2
*
{ACMP2{EXI{1,4{{{TAKE EQ EXIT{19011
{{EJC{{{{{19012
*
*      ACOMP (CONTINUED)
*
*      HERE FOR INTEGER OVERFLOW ON SUBTRACT
*
{ACMP3{LDI{13,ICVAL(XL){{{LOAD SECOND ARGUMENT{19018
{{ILT{6,ACMP1{{{GT IF NEGATIVE{19019
{{BRN{6,ACMP5{{{ELSE LT{19020
*
*      HERE FOR REAL OPERANDS
*
{ACMP4{SBR{13,RCVAL(XL){{{SUBTRACT TO COMPARE{19026
{{ROV{6,ACMP6{{{JUMP IF OVERFLOW{19027
{{RGT{6,ACMP1{{{ELSE JUMP IF ARG1 GT{19028
{{REQ{6,ACMP2{{{JUMP IF ARG1 EQ ARG2{19029
*
*      HERE IF ARG1 LT ARG2
*
{ACMP5{EXI{1,3{{{TAKE LT EXIT{19034
*
*      HERE IF OVERFLOW ON REAL SUBTRACTION
*
{ACMP6{LDR{13,RCVAL(XL){{{RELOAD ARG2{19040
{{RLT{6,ACMP1{{{GT IF NEGATIVE{19041
{{BRN{6,ACMP5{{{ELSE LT{19042
*
*      HERE IF ARG1 NON-NUMERIC
*
{ACMP7{EXI{1,1{{{TAKE ERROR EXIT{19047
*
*      HERE IF ARG2 NON-NUMERIC
*
{ACMP8{EXI{1,2{{{TAKE ERROR EXIT{19051
{{ENP{{{{END PROCEDURE ACOMP{19052
{{EJC{{{{{19053
*
*      ALLOC                 ALLOCATE BLOCK OF DYNAMIC STORAGE
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALLOC            CALL TO ALLOCATE BLOCK
*      (XR)                  POINTER TO ALLOCATED BLOCK
*
*      A POSSIBLE ALTERNATIVE TO AOV ... AND FOLLOWING STMT IS -
*      MOV  DNAME,XR .  SUB  WA,XR .  BLO XR,DNAMP,ALOC2 .
*      MOV  DNAMP,XR .  ADD  WA,XR
*
{ALLOC{PRC{25,E{1,0{{ENTRY POINT{19065
*
*      COMMON EXIT POINT
*
{ALOC1{MOV{3,DNAMP{7,XR{{POINT TO NEXT AVAILABLE LOC{19069
{{AOV{8,WA{7,XR{6,ALOC2{POINT PAST ALLOCATED BLOCK{19070
{{BGT{7,XR{3,DNAME{6,ALOC2{JUMP IF NOT ENOUGH ROOM{19071
{{MOV{7,XR{3,DNAMP{{STORE NEW POINTER{19072
{{SUB{8,WA{7,XR{{POINT BACK TO START OF ALLOCATED BK{19073
{{EXI{{{{RETURN TO CALLER{19074
*
*      HERE IF INSUFFICIENT ROOM, TRY A GARBAGE COLLECTION
*
{ALOC2{MOV{8,WB{3,ALLSV{{SAVE WB{19078
{ALC2A{ZER{8,WB{{{SET NO UPWARD MOVE FOR GBCOL{19079
{{JSR{6,GBCOL{{{GARBAGE COLLECT{19080
*
*      SEE IF ROOM AFTER GBCOL OR SYSMM CALL
*
{ALOC3{MOV{3,DNAMP{7,XR{{POINT TO FIRST AVAILABLE LOC{19087
{{AOV{8,WA{7,XR{6,ALC3A{POINT PAST NEW BLOCK{19088
{{BLO{7,XR{3,DNAME{6,ALOC4{JUMP IF THERE IS ROOM NOW{19089
*
*      FAILED AGAIN, SEE IF WE CAN GET MORE CORE
*
{ALC3A{JSR{6,SYSMM{{{TRY TO GET MORE MEMORY{19093
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){19094
{{ADD{7,XR{3,DNAME{{BUMP PTR BY AMOUNT OBTAINED{19095
{{BNZ{7,XR{6,ALOC3{{JUMP IF GOT MORE CORE{19096
{{ADD{3,RSMEM{3,DNAME{{GET THE RESERVE MEMORY{19106
{{ZER{3,RSMEM{{{ONLY PERMISSIBLE ONCE{19108
{{ICV{3,ERRFT{{{FATAL ERROR{19109
{{ERB{1,204{26,Memory overflow{{{19110
{{EJC{{{{{19111
*
*      HERE AFTER SUCCESSFUL GARBAGE COLLECTION
*
{ALOC4{STI{3,ALLIA{{{SAVE IA{19115
{{MOV{3,DNAME{8,WB{{GET DYNAMIC END ADRS{19119
{{SUB{3,DNAMP{8,WB{{COMPUTE FREE STORE{19120
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{19121
{{MTI{8,WB{{{PUT FREE STORE IN IA{19122
{{MLI{3,ALFSF{{{MULTIPLY BY FREE STORE FACTOR{19123
{{IOV{6,ALOC5{{{JUMP IF OVERFLOWED{19124
{{MOV{3,DNAME{8,WB{{DYNAMIC END ADRS{19125
{{SUB{3,DNAMB{8,WB{{COMPUTE TOTAL AMOUNT OF DYNAMIC{19126
{{BTW{8,WB{{{CONVERT TO WORDS{19127
{{MOV{8,WB{3,ALDYN{{STORE IT{19128
{{SBI{3,ALDYN{{{SUBTRACT FROM SCALED UP FREE STORE{19129
{{IGT{6,ALOC5{{{JUMP IF SUFFICIENT FREE STORE{19130
{{JSR{6,SYSMM{{{TRY TO GET MORE STORE{19131
{{WTB{7,XR{{{CONVERT TO BAUS (SGD05){19132
{{ADD{7,XR{3,DNAME{{ADJUST DYNAMIC END ADRS{19133
*
*      MERGE TO RESTORE IA AND WB
*
{ALOC5{LDI{3,ALLIA{{{RECOVER IA{19137
{{MOV{3,ALLSV{8,WB{{RESTORE WB{19138
{{BRN{6,ALOC1{{{JUMP BACK TO EXIT{19139
{{ENP{{{{END PROCEDURE ALLOC{19140
{{EJC{{{{{19141
*
*      ALOCS -- ALLOCATE STRING BLOCK
*
*      ALOCS IS USED TO BUILD A FRAME FOR A STRING BLOCK INTO
*      WHICH THE ACTUAL CHARACTERS ARE PLACED BY THE CALLER.
*      ALL STRINGS ARE CREATED WITH A CALL TO ALOCS (THE
*      EXCEPTIONS OCCUR IN TRIMR AND S$RPL PROCEDURES).
*
*      (WA)                  LENGTH OF STRING TO BE ALLOCATED
*      JSR  ALOCS            CALL TO ALLOCATE SCBLK
*      (XR)                  POINTER TO RESULTING SCBLK
*      (WA)                  DESTROYED
*      (WC)                  CHARACTER COUNT (ENTRY VALUE OF WA)
*
*      THE RESULTING SCBLK HAS THE TYPE WORD AND THE LENGTH
*      FILLED IN AND THE LAST WORD IS CLEARED TO ZERO CHARACTERS
*      TO ENSURE CORRECT RIGHT PADDING OF THE FINAL WORD.
*
{ALOCS{PRC{25,E{1,0{{ENTRY POINT{19201
{{BGT{8,WA{3,KVMXL{6,ALCS2{JUMP IF LENGTH EXCEEDS MAXLENGTH{19202
{{MOV{8,WA{8,WC{{ELSE COPY LENGTH{19203
{{CTB{8,WA{2,SCSI${{COMPUTE LENGTH OF SCBLK IN BYTES{19204
{{MOV{3,DNAMP{7,XR{{POINT TO NEXT AVAILABLE LOCATION{19205
{{AOV{8,WA{7,XR{6,ALCS0{POINT PAST BLOCK{19206
{{BLO{7,XR{3,DNAME{6,ALCS1{JUMP IF THERE IS ROOM{19207
*
*      INSUFFICIENT MEMORY
*
{ALCS0{ZER{7,XR{{{ELSE CLEAR GARBAGE XR VALUE{19211
{{JSR{6,ALLOC{{{AND USE STANDARD ALLOCATOR{19212
{{ADD{8,WA{7,XR{{POINT PAST END OF BLOCK TO MERGE{19213
*
*      MERGE HERE WITH XR POINTING BEYOND NEW BLOCK
*
{ALCS1{MOV{7,XR{3,DNAMP{{SET UPDATED STORAGE POINTER{19217
{{ZER{11,-(XR){{{STORE ZERO CHARS IN LAST WORD{19218
{{DCA{8,WA{{{DECREMENT LENGTH{19219
{{SUB{8,WA{7,XR{{POINT BACK TO START OF BLOCK{19220
{{MOV{22,=B$SCL{9,(XR){{SET TYPE WORD{19221
{{MOV{8,WC{13,SCLEN(XR){{STORE LENGTH IN CHARS{19222
{{EXI{{{{RETURN TO ALOCS CALLER{19223
*
*      COME HERE IF STRING IS TOO LONG
*
{ALCS2{ERB{1,205{26,String length exceeds value of MAXLNGTH keyword{{{19227
{{ENP{{{{END PROCEDURE ALOCS{19228
{{EJC{{{{{19229
*
*      ALOST -- ALLOCATE SPACE IN STATIC REGION
*
*      (WA)                  LENGTH REQUIRED IN BYTES
*      JSR  ALOST            CALL TO ALLOCATE SPACE
*      (XR)                  POINTER TO ALLOCATED BLOCK
*      (WB)                  DESTROYED
*
*      NOTE THAT THE CODING ENSURES THAT THE RESULTING VALUE
*      OF STATE IS ALWAYS LESS THAN DNAMB. THIS FACT IS USED
*      IN TESTING A VARIABLE NAME FOR BEING IN THE STATIC REGION
*
{ALOST{PRC{25,E{1,0{{ENTRY POINT{19242
*
*      MERGE BACK HERE AFTER ALLOCATING NEW CHUNK
*
{ALST1{MOV{3,STATE{7,XR{{POINT TO CURRENT END OF AREA{19246
{{AOV{8,WA{7,XR{6,ALST2{POINT BEYOND PROPOSED BLOCK{19247
{{BGE{7,XR{3,DNAMB{6,ALST2{JUMP IF OVERLAP WITH DYNAMIC AREA{19248
{{MOV{7,XR{3,STATE{{ELSE STORE NEW POINTER{19249
{{SUB{8,WA{7,XR{{POINT BACK TO START OF BLOCK{19250
{{EXI{{{{RETURN TO ALOST CALLER{19251
*
*      HERE IF NO ROOM, PREPARE TO MOVE DYNAMIC STORAGE UP
*
{ALST2{MOV{8,WA{3,ALSTA{{SAVE WA{19255
{{BGE{8,WA{19,*E$STS{6,ALST3{SKIP IF REQUESTED CHUNK IS LARGE{19256
{{MOV{19,*E$STS{8,WA{{ELSE SET TO GET LARGE ENOUGH CHUNK{19257
*
*      HERE WITH AMOUNT TO MOVE UP IN WA
*
{ALST3{JSR{6,ALLOC{{{ALLOCATE BLOCK TO ENSURE ROOM{19261
{{MOV{7,XR{3,DNAMP{{AND DELETE IT{19262
{{MOV{8,WA{8,WB{{COPY MOVE UP AMOUNT{19263
{{JSR{6,GBCOL{{{CALL GBCOL TO MOVE DYNAMIC AREA UP{19264
{{MOV{3,ALSTA{8,WA{{RESTORE WA{19268
{{BRN{6,ALST1{{{LOOP BACK TO TRY AGAIN{19269
{{ENP{{{{END PROCEDURE ALOST{19270
{{EJC{{{{{19271
*
*      ARITH -- FETCH ARITHMETIC OPERANDS
*
*      ARITH IS USED BY FUNCTIONS AND OPERATORS WHICH EXPECT
*      TWO NUMERIC ARGUMENTS (OPERANDS) WHICH MUST BOTH BE
*      INTEGER OR BOTH BE REAL. ARITH FETCHES TWO ARGUMENTS FROM
*      THE STACK AND PERFORMS ANY NECESSARY CONVERSIONS.
*
*      1(XS)                 FIRST ARGUMENT (LEFT OPERAND)
*      0(XS)                 SECOND ARGUMENT (RIGHT OPERAND)
*      JSR  ARITH            CALL TO FETCH NUMERIC ARGUMENTS
*      PPM  LOC              TRANSFER LOC FOR OPND 1 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR OPND 2 NON-NUMERIC
*      PPM  LOC              TRANSFER LOC FOR REAL OPERANDS
*
*      FOR INTEGER ARGS, CONTROL RETURNS PAST THE PARAMETERS
*
*      (IA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO ICBLK FOR LEFT OPERAND
*      (XL)                  PTR TO ICBLK FOR RIGHT OPERAND
*      (XS)                  POPPED TWICE
*      (WA,WB,RA)            DESTROYED
*
*      FOR REAL ARGUMENTS, CONTROL RETURNS TO THE LOCATION
*      SPECIFIED BY THE THIRD PARAMETER.
*
*      (RA)                  LEFT OPERAND VALUE
*      (XR)                  PTR TO RCBLK FOR LEFT OPERAND
*      (XL)                  PTR TO RCBLK FOR RIGHT OPERAND
*      (WA,WB,WC)            DESTROYED
*      (XS)                  POPPED TWICE
{{EJC{{{{{19345
*
*      ARITH (CONTINUED)
*
*      ENTRY POINT
*
{ARITH{PRC{25,N{1,3{{ENTRY POINT{19354
{{MOV{10,(XS)+{7,XL{{LOAD RIGHT OPERAND{19356
{{MOV{10,(XS)+{7,XR{{LOAD LEFT OPERAND{19357
{{MOV{9,(XL){8,WA{{GET RIGHT OPERAND TYPE WORD{19358
{{BEQ{8,WA{22,=B$ICL{6,ARTH1{JUMP IF INTEGER{19359
{{BEQ{8,WA{22,=B$RCL{6,ARTH4{JUMP IF REAL{19362
{{MOV{7,XR{11,-(XS){{ELSE REPLACE LEFT ARG ON STACK{19364
{{MOV{7,XL{7,XR{{COPY LEFT ARG POINTER{19365
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{19366
{{PPM{6,ARTH6{{{JUMP IF UNCONVERTIBLE{19367
{{MOV{7,XR{7,XL{{ELSE COPY CONVERTED RESULT{19368
{{MOV{9,(XL){8,WA{{GET RIGHT OPERAND TYPE WORD{19369
{{MOV{10,(XS)+{7,XR{{RELOAD LEFT ARGUMENT{19370
{{BEQ{8,WA{22,=B$RCL{6,ARTH4{JUMP IF RIGHT ARG IS REAL{19373
*
*      HERE IF RIGHT ARG IS AN INTEGER
*
{ARTH1{BNE{9,(XR){22,=B$ICL{6,ARTH3{JUMP IF LEFT ARG NOT INTEGER{19378
*
*      EXIT FOR INTEGER CASE
*
{ARTH2{LDI{13,ICVAL(XR){{{LOAD LEFT OPERAND VALUE{19382
{{EXI{{{{RETURN TO ARITH CALLER{19383
*
*      HERE FOR RIGHT OPERAND INTEGER, LEFT OPERAND NOT
*
{ARTH3{JSR{6,GTNUM{{{CONVERT LEFT ARG TO NUMERIC{19387
{{PPM{6,ARTH7{{{JUMP IF NOT CONVERTIBLE{19388
{{BEQ{8,WA{22,=B$ICL{6,ARTH2{JUMP BACK IF INTEGER-INTEGER{19389
*
*      HERE WE MUST CONVERT REAL-INTEGER TO REAL-REAL
*
{{MOV{7,XR{11,-(XS){{PUT LEFT ARG BACK ON STACK{19395
{{LDI{13,ICVAL(XL){{{LOAD RIGHT ARGUMENT VALUE{19396
{{ITR{{{{CONVERT TO REAL{19397
{{JSR{6,RCBLD{{{GET REAL BLOCK FOR RIGHT ARG, MERGE{19398
{{MOV{7,XR{7,XL{{COPY RIGHT ARG PTR{19399
{{MOV{10,(XS)+{7,XR{{LOAD LEFT ARGUMENT{19400
{{BRN{6,ARTH5{{{MERGE FOR REAL-REAL CASE{19401
{{EJC{{{{{19402
*
*      ARITH (CONTINUED)
*
*      HERE IF RIGHT ARGUMENT IS REAL
*
{ARTH4{BEQ{9,(XR){22,=B$RCL{6,ARTH5{JUMP IF LEFT ARG REAL{19408
{{JSR{6,GTREA{{{ELSE CONVERT TO REAL{19409
{{PPM{6,ARTH7{{{ERROR IF UNCONVERTIBLE{19410
*
*      HERE FOR REAL-REAL
*
{ARTH5{LDR{13,RCVAL(XR){{{LOAD LEFT OPERAND VALUE{19414
{{EXI{1,3{{{TAKE REAL-REAL EXIT{19415
*
*      HERE FOR ERROR CONVERTING RIGHT ARGUMENT
*
{ARTH6{ICA{7,XS{{{POP UNWANTED LEFT ARG{19420
{{EXI{1,2{{{TAKE APPROPRIATE ERROR EXIT{19421
*
*      HERE FOR ERROR CONVERTING LEFT OPERAND
*
{ARTH7{EXI{1,1{{{TAKE APPROPRIATE ERROR RETURN{19425
{{ENP{{{{END PROCEDURE ARITH{19426
{{EJC{{{{{19427
*
*      ASIGN -- PERFORM ASSIGNMENT
*
*      ASIGN PERFORMS THE ASSIGNMENT OF A VALUE TO A VARIABLE
*      WITH APPROPRIATE CHECKS FOR OUTPUT ASSOCIATIONS AND
*      VALUE TRACE ASSOCIATIONS WHICH ARE EXECUTED AS REQUIRED.
*      ASIGN ALSO HANDLES THE SPECIAL CASES OF ASSIGNMENT TO
*      PATTERN AND EXPRESSION VARIABLES.
*
*      (WB)                  VALUE TO BE ASSIGNED
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      JSR  ASIGN            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC FOR FAILURE
*      (XR,XL,WA,WB,WC)      DESTROYED
*      (RA)                  DESTROYED
*
*      FAILURE OCCURS IF THE EVALUATION OF AN EXPRESSION
*      ASSOCIATED WITH AN EXPRESSION VARIABLE FAILS.
*
{ASIGN{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){19448
*
*      MERGE BACK HERE TO ASSIGN RESULT TO EXPRESSION VARIABLE.
*
{ASG01{ADD{8,WA{7,XL{{POINT TO VARIABLE VALUE{19452
{{MOV{9,(XL){7,XR{{LOAD VARIABLE VALUE{19453
{{BEQ{9,(XR){22,=B$TRT{6,ASG02{JUMP IF TRAPPED{19454
{{MOV{8,WB{9,(XL){{ELSE PERFORM ASSIGNMENT{19455
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{19456
{{EXI{{{{AND RETURN TO ASIGN CALLER{19457
*
*      HERE IF VALUE IS TRAPPED
*
{ASG02{SUB{8,WA{7,XL{{RESTORE NAME BASE{19461
{{BEQ{7,XR{21,=TRBKV{6,ASG14{JUMP IF KEYWORD VARIABLE{19462
{{BNE{7,XR{21,=TRBEV{6,ASG04{JUMP IF NOT EXPRESSION VARIABLE{19463
*
*      HERE FOR ASSIGNMENT TO EXPRESSION VARIABLE
*
{{MOV{13,EVEXP(XL){7,XR{{POINT TO EXPRESSION{19467
{{MOV{8,WB{11,-(XS){{STORE VALUE TO ASSIGN ON STACK{19468
{{MOV{18,=NUM01{8,WB{{SET FOR EVALUATION BY NAME{19469
{{JSR{6,EVALX{{{EVALUATE EXPRESSION BY NAME{19470
{{PPM{6,ASG03{{{JUMP IF EVALUATION FAILS{19471
{{MOV{10,(XS)+{8,WB{{ELSE RELOAD VALUE TO ASSIGN{19472
{{BRN{6,ASG01{{{LOOP BACK TO PERFORM ASSIGNMENT{19473
{{EJC{{{{{19474
*
*      ASIGN (CONTINUED)
*
*      HERE FOR FAILURE DURING EXPRESSION EVALUATION
*
{ASG03{ICA{7,XS{{{REMOVE STACKED VALUE ENTRY{19480
{{EXI{1,1{{{TAKE FAILURE EXIT{19481
*
*      HERE IF NOT KEYWORD OR EXPRESSION VARIABLE
*
{ASG04{MOV{7,XR{11,-(XS){{SAVE PTR TO FIRST TRBLK{19485
*
*      LOOP TO CHASE DOWN TRBLK CHAIN AND ASSIGN VALUE AT END
*
{ASG05{MOV{7,XR{8,WC{{SAVE PTR TO THIS TRBLK{19489
{{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK{19490
{{BEQ{9,(XR){22,=B$TRT{6,ASG05{LOOP BACK IF ANOTHER TRBLK{19491
{{MOV{8,WC{7,XR{{ELSE POINT BACK TO LAST TRBLK{19492
{{MOV{8,WB{13,TRVAL(XR){{STORE VALUE AT END OF CHAIN{19493
{{MOV{10,(XS)+{7,XR{{RESTORE PTR TO FIRST TRBLK{19494
*
*      LOOP TO PROCESS TRBLK ENTRIES ON CHAIN
*
{ASG06{MOV{13,TRTYP(XR){8,WB{{LOAD TYPE CODE OF TRBLK{19498
{{BEQ{8,WB{18,=TRTVL{6,ASG08{JUMP IF VALUE TRACE{19499
{{BEQ{8,WB{18,=TRTOU{6,ASG10{JUMP IF OUTPUT ASSOCIATION{19500
*
*      HERE TO MOVE TO NEXT TRBLK ON CHAIN
*
{ASG07{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK ON CHAIN{19504
{{BEQ{9,(XR){22,=B$TRT{6,ASG06{LOOP BACK IF ANOTHER TRBLK{19505
{{EXI{{{{ELSE END OF CHAIN, RETURN TO CALLER{19506
*
*      HERE TO PROCESS VALUE TRACE
*
{ASG08{BZE{3,KVTRA{6,ASG07{{IGNORE VALUE TRACE IF TRACE OFF{19510
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE COUNT{19511
{{BZE{13,TRFNC(XR){6,ASG09{{JUMP IF PRINT TRACE{19512
{{JSR{6,TRXEQ{{{ELSE EXECUTE FUNCTION TRACE{19513
{{BRN{6,ASG07{{{AND LOOP BACK{19514
{{EJC{{{{{19515
*
*      ASIGN (CONTINUED)
*
*      HERE FOR PRINT TRACE
*
{ASG09{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{19521
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{19522
{{BRN{6,ASG07{{{LOOP BACK FOR NEXT TRBLK{19523
*
*      HERE FOR OUTPUT ASSOCIATION
*
{ASG10{BZE{3,KVOUP{6,ASG07{{IGNORE OUTPUT ASSOC IF OUTPUT OFF{19527
{ASG1B{MOV{7,XR{7,XL{{COPY TRBLK POINTER{19528
{{MOV{13,TRNXT(XR){7,XR{{POINT TO NEXT TRBLK{19529
{{BEQ{9,(XR){22,=B$TRT{6,ASG1B{LOOP BACK IF ANOTHER TRBLK{19530
{{MOV{7,XL{7,XR{{ELSE POINT BACK TO LAST TRBLK{19531
{{MOV{13,TRVAL(XR){11,-(XS){{STACK VALUE TO OUTPUT{19533
{{JSR{6,GTSTG{{{CONVERT TO STRING{19539
{{PPM{6,ASG12{{{GET DATATYPE NAME IF UNCONVERTIBLE{19540
*
*      MERGE WITH STRING OR BUFFER TO OUTPUT IN XR
*
{ASG11{MOV{13,TRFPT(XL){8,WA{{FCBLK PTR{19544
{{BZE{8,WA{6,ASG13{{JUMP IF STANDARD OUTPUT FILE{19545
*
*      HERE FOR OUTPUT TO FILE
*
{ASG1A{JSR{6,SYSOU{{{CALL SYSTEM OUTPUT ROUTINE{19549
{{ERR{1,206{26,Output caused file overflow{{{19550
{{ERR{1,207{26,Output caused non-recoverable error{{{19551
{{EXI{{{{ELSE ALL DONE, RETURN TO CALLER{19552
*
*      IF NOT PRINTABLE, GET DATATYPE NAME INSTEAD
*
{ASG12{JSR{6,DTYPE{{{CALL DATATYPE ROUTINE{19556
{{BRN{6,ASG11{{{MERGE{19557
*
*      HERE TO PRINT A STRING TO STANDARD OUTPUT OR TERMINAL
*
{ASG13{BEQ{13,TRTER(XL){21,=V$TER{6,ASG1A{JUMP IF TERMINAL OUTPUT{19562
{{ICV{8,WA{{{SIGNAL STANDARD OUTPUT{19563
{{BRN{6,ASG1A{{{USE SYSOU TO PERFORM OUTPUT{19564
{{EJC{{{{{19579
*
*      ASIGN (CONTINUED)
*
*      HERE FOR KEYWORD ASSIGNMENT
*
{ASG14{MOV{13,KVNUM(XL){7,XL{{LOAD KEYWORD NUMBER{19585
{{BEQ{7,XL{18,=K$ETX{6,ASG19{JUMP IF ERRTEXT{19586
{{MOV{8,WB{7,XR{{COPY VALUE TO BE ASSIGNED{19587
{{JSR{6,GTINT{{{CONVERT TO INTEGER{19588
{{ERR{1,208{26,Keyword value assigned is not integer{{{19589
{{LDI{13,ICVAL(XR){{{ELSE LOAD VALUE{19590
{{BEQ{7,XL{18,=K$STL{6,ASG16{JUMP IF SPECIAL CASE OF STLIMIT{19591
{{MFI{8,WA{6,ASG18{{ELSE GET ADDR INTEGER, TEST OVFLOW{19592
{{BGT{8,WA{3,MXLEN{6,ASG18{FAIL IF TOO LARGE{19593
{{BEQ{7,XL{18,=K$ERT{6,ASG17{JUMP IF SPECIAL CASE OF ERRTYPE{19594
{{BEQ{7,XL{18,=K$PFL{6,ASG21{JUMP IF SPECIAL CASE OF PROFILE{19597
{{BEQ{7,XL{18,=K$MXL{6,ASG24{JUMP IF SPECIAL CASE OF MAXLNGTH{19599
{{BEQ{7,XL{18,=K$FLS{6,ASG26{JUMP IF SPECIAL CASE OF FULLSCAN{19600
{{BLT{7,XL{18,=K$P$${6,ASG15{JUMP UNLESS PROTECTED{19601
{{ERB{1,209{26,Keyword in assignment is protected{{{19602
*
*      HERE TO DO ASSIGNMENT IF NOT PROTECTED
*
{ASG15{MOV{8,WA{15,KVABE(XL){{STORE NEW VALUE{19606
{{EXI{{{{RETURN TO ASIGN CALLER{19607
*
*      HERE FOR SPECIAL CASE OF STLIMIT
*
*      SINCE STCOUNT IS MAINTAINED AS (STLIMIT-STCOUNT)
*      IT IS ALSO NECESSARY TO MODIFY STCOUNT APPROPRIATELY.
*
{ASG16{SBI{3,KVSTL{{{SUBTRACT OLD LIMIT{19614
{{ADI{3,KVSTC{{{ADD OLD COUNTER{19615
{{STI{3,KVSTC{{{STORE COURSE COUNTER VALUE{19616
{{LDI{3,KVSTL{{{CHECK IF COUNTING SUPPRESSED{19617
{{ILT{6,ASG25{{{DO NOT REFINE IF SO{19618
{{MOV{3,STMCS{8,WA{{REFINE WITH COUNTER BREAKOUT{19619
{{SUB{3,STMCT{8,WA{{VALUES{19620
{{MTI{8,WA{{{CONVERT TO INTEGER{19621
{{NGI{{{{CURRENT-START VALUE{19622
{{ADI{3,KVSTC{{{ADD IN COURSE COUNTER VALUE{19623
{{STI{3,KVSTC{{{SAVE REFINED VALUE{19624
{ASG25{LDI{13,ICVAL(XR){{{RELOAD NEW LIMIT VALUE{19625
{{STI{3,KVSTL{{{STORE NEW LIMIT VALUE{19626
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTERS{19627
{{EXI{{{{RETURN TO ASIGN CALLER{19628
*
*      HERE FOR SPECIAL CASE OF ERRTYPE
*
{ASG17{BLE{8,WA{18,=NINI9{6,ERROR{OK TO SIGNAL IF IN RANGE{19632
*
*      HERE IF VALUE ASSIGNED IS OUT OF RANGE
*
{ASG18{ERB{1,210{26,Keyword value assigned is negative or too large{{{19636
*
*      HERE FOR SPECIAL CASE OF ERRTEXT
*
{ASG19{MOV{8,WB{11,-(XS){{STACK VALUE{19640
{{JSR{6,GTSTG{{{CONVERT TO STRING{19641
{{ERR{1,211{26,Value assigned to keyword ERRTEXT not a string{{{19642
{{MOV{7,XR{3,R$ETX{{MAKE ASSIGNMENT{19643
{{EXI{{{{RETURN TO CALLER{19644
*
*      HERE FOR KEYWORD PROFILE
*
{ASG21{BGT{8,WA{18,=NUM02{6,ASG18{MOAN IF NOT 0,1, OR 2{19658
{{BZE{8,WA{6,ASG15{{JUST ASSIGN IF ZERO{19659
{{BZE{3,PFDMP{6,ASG22{{BRANCH IF FIRST ASSIGNMENT{19660
{{BEQ{8,WA{3,PFDMP{6,ASG23{ALSO IF SAME VALUE AS BEFORE{19661
{{ERB{1,268{26,Inconsistent value assigned to keyword PROFILE{{{19662
*
{ASG22{MOV{8,WA{3,PFDMP{{NOTE VALUE ON FIRST ASSIGNMENT{19664
{ASG23{MOV{8,WA{3,KVPFL{{STORE NEW VALUE{19665
{{JSR{6,STGCC{{{RECOMPUTE COUNTDOWN COUNTS{19666
{{JSR{6,SYSTM{{{GET THE TIME{19667
{{STI{3,PFSTM{{{FUDGE SOME KIND OF START TIME{19668
{{EXI{{{{RETURN TO ASIGN CALLER{19669
*
*      HERE FOR KEYWORD MAXLNGTH
*
{ASG24{BGE{8,WA{18,=MNLEN{6,ASG15{IF ACCEPTABLE VALUE{19674
{{ERB{1,287{26,Value assigned to keyword MAXLNGTH is too small{{{19675
*
*      HERE FOR KEYWORD FULLSCAN
*
{ASG26{BNZ{8,WA{6,ASG15{{IF ACCEPTABLE VALUE{19679
{{ERB{1,274{26,Value assigned to keyword FULLSCAN is zero{{{19680
*
{{ENP{{{{END PROCEDURE ASIGN{19682
{{EJC{{{{{19683
*
*      ASINP -- ASSIGN DURING PATTERN MATCH
*
*      ASINP IS LIKE ASIGN AND HAS A SIMILAR CALLING SEQUENCE
*      AND EFFECT. THE DIFFERENCE IS THAT THE GLOBAL PATTERN
*      VARIABLES ARE SAVED AND RESTORED IF REQUIRED.
*
*      (XL)                  BASE POINTER FOR VARIABLE
*      (WA)                  OFFSET FOR VARIABLE
*      (WB)                  VALUE TO BE ASSIGNED
*      JSR  ASINP            CALL TO ASSIGN VALUE TO VARIABLE
*      PPM  LOC              TRANSFER LOC IF FAILURE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{ASINP{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{19699
{{ADD{8,WA{7,XL{{POINT TO VARIABLE{19700
{{MOV{9,(XL){7,XR{{LOAD CURRENT CONTENTS{19701
{{BEQ{9,(XR){22,=B$TRT{6,ASNP1{JUMP IF TRAPPED{19702
{{MOV{8,WB{9,(XL){{ELSE PERFORM ASSIGNMENT{19703
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{19704
{{EXI{{{{RETURN TO ASINP CALLER{19705
*
*      HERE IF VARIABLE IS TRAPPED
*
{ASNP1{SUB{8,WA{7,XL{{RESTORE BASE POINTER{19709
{{MOV{3,PMSSL{11,-(XS){{STACK SUBJECT STRING LENGTH{19710
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE PTR{19711
{{MOV{3,R$PMS{11,-(XS){{STACK SUBJECT STRING POINTER{19712
{{MOV{3,PMDFL{11,-(XS){{STACK DOT FLAG{19713
{{JSR{6,ASIGN{{{CALL FULL-BLOWN ASSIGNMENT ROUTINE{19714
{{PPM{6,ASNP2{{{JUMP IF FAILURE{19715
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{19716
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{19717
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{19718
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{19719
{{EXI{{{{RETURN TO ASINP CALLER{19720
*
*      HERE IF FAILURE IN ASIGN CALL
*
{ASNP2{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{19724
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{19725
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{19726
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{19727
{{EXI{1,1{{{TAKE FAILURE EXIT{19728
{{ENP{{{{END PROCEDURE ASINP{19729
{{EJC{{{{{19730
*
*      BLKLN -- DETERMINE LENGTH OF BLOCK
*
*      BLKLN DETERMINES THE LENGTH OF A BLOCK IN DYNAMIC STORE.
*
*      (WA)                  FIRST WORD OF BLOCK
*      (XR)                  POINTER TO BLOCK
*      JSR  BLKLN            CALL TO GET BLOCK LENGTH
*      (WA)                  LENGTH OF BLOCK IN BYTES
*      (XL)                  DESTROYED
*
*      BLKLN IS USED BY THE GARBAGE COLLECTOR AND IS NOT
*      PERMITTED TO CALL GBCOL DIRECTLY OR INDIRECTLY.
*
*      THE FIRST WORD STORED IN THE BLOCK (I.E. AT XR) MAY
*      BE ANYTHING, BUT THE CONTENTS OF WA MUST BE CORRECT.
*
{BLKLN{PRC{25,E{1,0{{ENTRY POINT{19748
{{MOV{8,WA{7,XL{{COPY FIRST WORD{19749
{{LEI{7,XL{{{GET ENTRY ID (BL$XX){19750
{{BSW{7,XL{2,BL$$${6,BLN00{SWITCH ON BLOCK TYPE{19751
{{IFF{2,BL$AR{6,BLN01{{ARBLK{19791
{{IFF{2,BL$CD{6,BLN12{{CDBLK{19791
{{IFF{2,BL$EX{6,BLN12{{EXBLK{19791
{{IFF{2,BL$IC{6,BLN07{{ICBLK{19791
{{IFF{2,BL$NM{6,BLN03{{NMBLK{19791
{{IFF{2,BL$P0{6,BLN02{{P0BLK{19791
{{IFF{2,BL$P1{6,BLN03{{P1BLK{19791
{{IFF{2,BL$P2{6,BLN04{{P2BLK{19791
{{IFF{2,BL$RC{6,BLN09{{RCBLK{19791
{{IFF{2,BL$SC{6,BLN10{{SCBLK{19791
{{IFF{2,BL$SE{6,BLN02{{SEBLK{19791
{{IFF{2,BL$TB{6,BLN01{{TBBLK{19791
{{IFF{2,BL$VC{6,BLN01{{VCBLK{19791
{{IFF{1,13{6,BLN00{{{19791
{{IFF{1,14{6,BLN00{{{19791
{{IFF{1,15{6,BLN00{{{19791
{{IFF{2,BL$PD{6,BLN08{{PDBLK{19791
{{IFF{2,BL$TR{6,BLN05{{TRBLK{19791
{{IFF{1,18{6,BLN00{{{19791
{{IFF{1,19{6,BLN00{{{19791
{{IFF{1,20{6,BLN00{{{19791
{{IFF{2,BL$CT{6,BLN06{{CTBLK{19791
{{IFF{2,BL$DF{6,BLN01{{DFBLK{19791
{{IFF{2,BL$EF{6,BLN01{{EFBLK{19791
{{IFF{2,BL$EV{6,BLN03{{EVBLK{19791
{{IFF{2,BL$FF{6,BLN05{{FFBLK{19791
{{IFF{2,BL$KV{6,BLN03{{KVBLK{19791
{{IFF{2,BL$PF{6,BLN01{{PFBLK{19791
{{IFF{2,BL$TE{6,BLN04{{TEBLK{19791
{{ESW{{{{END OF JUMP TABLE ON BLOCK TYPE{19791
{{EJC{{{{{19792
*
*      BLKLN (CONTINUED)
*
*      HERE FOR BLOCKS WITH LENGTH IN SECOND WORD
*
{BLN00{MOV{12,1(XR){8,WA{{LOAD LENGTH{19798
{{EXI{{{{RETURN TO BLKLN CALLER{19799
*
*      HERE FOR LENGTH IN THIRD WORD (AR,CD,DF,EF,EX,PF,TB,VC)
*
{BLN01{MOV{12,2(XR){8,WA{{LOAD LENGTH FROM THIRD WORD{19803
{{EXI{{{{RETURN TO BLKLN CALLER{19804
*
*      HERE FOR TWO WORD BLOCKS (P0,SE)
*
{BLN02{MOV{19,*NUM02{8,WA{{LOAD LENGTH (TWO WORDS){19808
{{EXI{{{{RETURN TO BLKLN CALLER{19809
*
*      HERE FOR THREE WORD BLOCKS (NM,P1,EV,KV)
*
{BLN03{MOV{19,*NUM03{8,WA{{LOAD LENGTH (THREE WORDS){19813
{{EXI{{{{RETURN TO BLKLN CALLER{19814
*
*      HERE FOR FOUR WORD BLOCKS (P2,TE,BC)
*
{BLN04{MOV{19,*NUM04{8,WA{{LOAD LENGTH (FOUR WORDS){19818
{{EXI{{{{RETURN TO BLKLN CALLER{19819
*
*      HERE FOR FIVE WORD BLOCKS (FF,TR)
*
{BLN05{MOV{19,*NUM05{8,WA{{LOAD LENGTH{19823
{{EXI{{{{RETURN TO BLKLN CALLER{19824
{{EJC{{{{{19825
*
*      BLKLN (CONTINUED)
*
*      HERE FOR CTBLK
*
{BLN06{MOV{19,*CTSI${8,WA{{SET SIZE OF CTBLK{19831
{{EXI{{{{RETURN TO BLKLN CALLER{19832
*
*      HERE FOR ICBLK
*
{BLN07{MOV{19,*ICSI${8,WA{{SET SIZE OF ICBLK{19836
{{EXI{{{{RETURN TO BLKLN CALLER{19837
*
*      HERE FOR PDBLK
*
{BLN08{MOV{13,PDDFP(XR){7,XL{{POINT TO DFBLK{19841
{{MOV{13,DFPDL(XL){8,WA{{LOAD PDBLK LENGTH FROM DFBLK{19842
{{EXI{{{{RETURN TO BLKLN CALLER{19843
*
*      HERE FOR RCBLK
*
{BLN09{MOV{19,*RCSI${8,WA{{SET SIZE OF RCBLK{19849
{{EXI{{{{RETURN TO BLKLN CALLER{19850
*
*      HERE FOR SCBLK
*
{BLN10{MOV{13,SCLEN(XR){8,WA{{LOAD LENGTH IN CHARACTERS{19855
{{CTB{8,WA{2,SCSI${{CALCULATE LENGTH IN BYTES{19856
{{EXI{{{{RETURN TO BLKLN CALLER{19857
*
*      HERE FOR LENGTH IN FOURTH WORD (CD,EX)
*
{BLN12{MOV{12,3(XR){8,WA{{LOAD LENGTH FROM CDLEN/EXLEN{19871
{{EXI{{{{RETURN TO BLKLN CALLER{19872
{{ENP{{{{END PROCEDURE BLKLN{19874
{{EJC{{{{{19875
*
*      COPYB -- COPY A BLOCK
*
*      (XS)                  BLOCK TO BE COPIED
*      JSR  COPYB            CALL TO COPY BLOCK
*      PPM  LOC              RETURN IF BLOCK HAS NO IDVAL FIELD
*                            NORMAL RETURN IF IDVAL FIELD
*      (XR)                  COPY OF BLOCK
*      (XS)                  POPPED
*      (XL,WA,WB,WC)         DESTROYED
*
{COPYB{PRC{25,N{1,1{{ENTRY POINT{19887
{{MOV{9,(XS){7,XR{{LOAD ARGUMENT{19888
{{BEQ{7,XR{21,=NULLS{6,COP10{RETURN ARGUMENT IF IT IS NULL{19889
{{MOV{9,(XR){8,WA{{ELSE LOAD TYPE WORD{19890
{{MOV{8,WA{8,WB{{COPY TYPE WORD{19891
{{JSR{6,BLKLN{{{GET LENGTH OF ARGUMENT BLOCK{19892
{{MOV{7,XR{7,XL{{COPY POINTER{19893
{{JSR{6,ALLOC{{{ALLOCATE BLOCK OF SAME SIZE{19894
{{MOV{7,XR{9,(XS){{STORE POINTER TO COPY{19895
{{MVW{{{{COPY CONTENTS OF OLD BLOCK TO NEW{19896
{{ZER{7,XL{{{CLEAR GARBAGE XL{19897
{{MOV{9,(XS){7,XR{{RELOAD POINTER TO START OF COPY{19898
{{BEQ{8,WB{22,=B$TBT{6,COP05{JUMP IF TABLE{19899
{{BEQ{8,WB{22,=B$VCT{6,COP01{JUMP IF VECTOR{19900
{{BEQ{8,WB{22,=B$PDT{6,COP01{JUMP IF PROGRAM DEFINED{19901
{{BNE{8,WB{22,=B$ART{6,COP10{RETURN COPY IF NOT ARRAY{19906
*
*      HERE FOR ARRAY (ARBLK)
*
{{ADD{13,AROFS(XR){7,XR{{POINT TO PROTOTYPE FIELD{19910
{{BRN{6,COP02{{{JUMP TO MERGE{19911
*
*      HERE FOR VECTOR, PROGRAM DEFINED
*
{COP01{ADD{19,*PDFLD{7,XR{{POINT TO PDFLD = VCVLS{19915
*
*      MERGE HERE FOR ARBLK, VCBLK, PDBLK TO DELETE TRAP
*      BLOCKS FROM ALL VALUE FIELDS (THE COPY IS UNTRAPPED)
*
{COP02{MOV{9,(XR){7,XL{{LOAD NEXT POINTER{19920
*
*      LOOP TO GET VALUE AT END OF TRBLK CHAIN
*
{COP03{BNE{9,(XL){22,=B$TRT{6,COP04{JUMP IF NOT TRAPPED{19924
{{MOV{13,TRVAL(XL){7,XL{{ELSE POINT TO NEXT VALUE{19925
{{BRN{6,COP03{{{AND LOOP BACK{19926
{{EJC{{{{{19927
*
*      COPYB (CONTINUED)
*
*      HERE WITH UNTRAPPED VALUE IN XL
*
{COP04{MOV{7,XL{10,(XR)+{{STORE REAL VALUE, BUMP POINTER{19933
{{BNE{7,XR{3,DNAMP{6,COP02{LOOP BACK IF MORE TO GO{19934
{{BRN{6,COP09{{{ELSE JUMP TO EXIT{19935
*
*      HERE TO COPY A TABLE
*
{COP05{ZER{13,IDVAL(XR){{{ZERO ID TO STOP DUMP BLOWING UP{19939
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{19940
{{MOV{19,*TBBUK{8,WC{{SET INITIAL OFFSET{19941
*
*      LOOP THROUGH BUCKETS IN TABLE
*
{COP06{MOV{9,(XS){7,XR{{LOAD TABLE POINTER{19945
{{BEQ{8,WC{13,TBLEN(XR){6,COP09{JUMP TO EXIT IF ALL DONE{19946
{{MOV{8,WC{8,WB{{ELSE COPY OFFSET{19947
{{SUB{19,*TENXT{8,WB{{SUBTRACT LINK OFFSET TO MERGE{19948
{{ADD{8,WB{7,XR{{NEXT BUCKET HEADER LESS LINK OFFSET{19949
{{ICA{8,WC{{{BUMP OFFSET{19950
*
*      LOOP THROUGH TEBLKS ON ONE CHAIN
*
{COP07{MOV{13,TENXT(XR){7,XL{{LOAD POINTER TO NEXT TEBLK{19954
{{MOV{9,(XS){13,TENXT(XR){{SET END OF CHAIN POINTER IN CASE{19955
{{BEQ{9,(XL){22,=B$TBT{6,COP06{BACK FOR NEXT BUCKET IF CHAIN END{19956
{{SUB{8,WB{7,XR{{POINT TO HEAD OF PREVIOUS BLOCK{19957
{{MOV{7,XR{11,-(XS){{STACK PTR TO PREVIOUS BLOCK{19958
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{19959
{{JSR{6,ALLOC{{{ALLOCATE NEW TEBLK{19960
{{MOV{7,XR{11,-(XS){{STACK PTR TO NEW TEBLK{19961
{{MVW{{{{COPY OLD TEBLK TO NEW TEBLK{19962
{{MOV{10,(XS)+{7,XR{{RESTORE POINTER TO NEW TEBLK{19963
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER TO PREVIOUS BLOCK{19964
{{ADD{8,WB{7,XL{{ADD OFFSET BACK IN{19965
{{MOV{7,XR{13,TENXT(XL){{LINK NEW BLOCK TO PREVIOUS{19966
{{MOV{7,XR{7,XL{{COPY POINTER TO NEW BLOCK{19967
*
*      LOOP TO SET REAL VALUE AFTER REMOVING TRAP CHAIN
*
{COP08{MOV{13,TEVAL(XL){7,XL{{LOAD VALUE{19971
{{BEQ{9,(XL){22,=B$TRT{6,COP08{LOOP BACK IF TRAPPED{19972
{{MOV{7,XL{13,TEVAL(XR){{STORE UNTRAPPED VALUE IN TEBLK{19973
{{ZER{8,WB{{{ZERO OFFSET WITHIN TEBLK{19974
{{BRN{6,COP07{{{BACK FOR NEXT TEBLK{19975
*
*      COMMON EXIT POINT
*
{COP09{MOV{10,(XS)+{7,XR{{LOAD POINTER TO BLOCK{19979
{{EXI{{{{RETURN{19980
*
*      ALTERNATIVE RETURN
*
{COP10{EXI{1,1{{{RETURN{19984
{{EJC{{{{{19985
{{ENP{{{{END PROCEDURE COPYB{20003
*
*      CDGCG -- GENERATE CODE FOR COMPLEX GOTO
*
*      USED BY CMPIL TO PROCESS COMPLEX GOTO TREE
*
*      (WB)                  MUST BE COLLECTABLE
*      (XR)                  EXPRESSION POINTER
*      JSR  CDGCG            CALL TO GENERATE COMPLEX GOTO
*      (XL,XR,WA)            DESTROYED
*
{CDGCG{PRC{25,E{1,0{{ENTRY POINT{20014
{{MOV{13,CMOPN(XR){7,XL{{GET UNARY GOTO OPERATOR{20015
{{MOV{13,CMROP(XR){7,XR{{POINT TO GOTO OPERAND{20016
{{BEQ{7,XL{21,=OPDVD{6,CDGC2{JUMP IF DIRECT GOTO{20017
{{JSR{6,CDGNM{{{GENERATE OPND BY NAME IF NOT DIRECT{20018
*
*      RETURN POINT
*
{CDGC1{MOV{7,XL{8,WA{{GOTO OPERATOR{20022
{{JSR{6,CDWRD{{{GENERATE IT{20023
{{EXI{{{{RETURN TO CALLER{20024
*
*      DIRECT GOTO
*
{CDGC2{JSR{6,CDGVL{{{GENERATE OPERAND BY VALUE{20028
{{BRN{6,CDGC1{{{MERGE TO RETURN{20029
{{ENP{{{{END PROCEDURE CDGCG{20030
{{EJC{{{{{20031
*
*      CDGEX -- BUILD EXPRESSION BLOCK
*
*      CDGEX IS PASSED A POINTER TO AN EXPRESSION TREE (SEE
*      EXPAN) AND RETURNS AN EXPRESSION (SEBLK OR EXBLK).
*
*      (WA)                  0 IF BY VALUE, 1 IF BY NAME
*      (WC)                  SOME COLLECTABLE VALUE
*      (WB)                  INTEGER IN RANGE 0 LE X LE MXLEN
*      (XL)                  PTR TO EXPRESSION TREE
*      JSR  CDGEX            CALL TO BUILD EXPRESSION
*      (XR)                  PTR TO SEBLK OR EXBLK
*      (XL,WA,WB)            DESTROYED
*
{CDGEX{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20048
{{BLO{9,(XL){22,=B$VR${6,CDGX1{JUMP IF NOT VARIABLE{20049
*
*      HERE FOR NATURAL VARIABLE, BUILD SEBLK
*
{{MOV{19,*SESI${8,WA{{SET SIZE OF SEBLK{20053
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR SEBLK{20054
{{MOV{22,=B$SEL{9,(XR){{SET TYPE WORD{20055
{{MOV{7,XL{13,SEVAR(XR){{STORE VRBLK POINTER{20056
{{EXI{{{{RETURN TO CDGEX CALLER{20057
*
*      HERE IF NOT VARIABLE, BUILD EXBLK
*
{CDGX1{MOV{7,XL{7,XR{{COPY TREE POINTER{20061
{{MOV{8,WC{11,-(XS){{SAVE WC{20062
{{MOV{3,CWCOF{7,XL{{SAVE CURRENT OFFSET{20063
{{BZE{8,WA{6,CDGX2{{JUMP IF BY VALUE{20065
{{MOV{9,(XR){8,WA{{GET TYPE WORD{20067
{{BNE{8,WA{22,=B$CMT{6,CDGX2{CALL BY VALUE IF NOT CMBLK{20068
{{BGE{13,CMTYP(XR){18,=C$$NM{6,CDGX2{JUMP IF CMBLK ONLY BY VALUE{20069
{{EJC{{{{{20070
*
*      CDGEX (CONTINUED)
*
*      HERE IF EXPRESSION CAN BE EVALUATED BY NAME
*
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME{20076
{{MOV{21,=ORNM${8,WA{{LOAD RETURN BY NAME WORD{20077
{{BRN{6,CDGX3{{{MERGE WITH VALUE CASE{20078
*
*      HERE IF EXPRESSION CAN ONLY BE EVALUATED BY VALUE
*
{CDGX2{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20082
{{MOV{21,=ORVL${8,WA{{LOAD RETURN BY VALUE WORD{20083
*
*      MERGE HERE TO CONSTRUCT EXBLK
*
{CDGX3{JSR{6,CDWRD{{{GENERATE RETURN WORD{20087
{{JSR{6,EXBLD{{{BUILD EXBLK{20088
{{MOV{10,(XS)+{8,WC{{RESTORE WC{20089
{{EXI{{{{RETURN TO CDGEX CALLER{20090
{{ENP{{{{END PROCEDURE CDGEX{20091
{{EJC{{{{{20092
*
*      CDGNM -- GENERATE CODE BY NAME
*
*      CDGNM IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY NAME FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF CODE GENERATED. THE INPUT
*      TO CDGNM IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGNM IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGNM            CALL TO GENERATE CODE BY NAME
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGNM{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20117
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20118
{{MOV{8,WB{11,-(XS){{SAVE ENTRY WB{20119
{{CHK{{{{CHECK FOR STACK OVERFLOW{20120
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{20121
{{BEQ{8,WA{22,=B$CMT{6,CGN04{JUMP IF CMBLK{20122
{{BHI{8,WA{22,=B$VR${6,CGN02{JUMP IF SIMPLE VARIABLE{20123
*
*      MERGE HERE FOR OPERAND YIELDING VALUE (E.G. CONSTANT)
*
{CGN01{ERB{1,212{26,Syntax error: Value used where name is required{{{20127
*
*      HERE FOR NATURAL VARIABLE REFERENCE
*
{CGN02{MOV{21,=OLVN${8,WA{{LOAD VARIABLE LOAD CALL{20131
{{JSR{6,CDWRD{{{GENERATE IT{20132
{{MOV{7,XR{8,WA{{COPY VRBLK POINTER{20133
{{JSR{6,CDWRD{{{GENERATE VRBLK POINTER{20134
{{EJC{{{{{20135
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT WITH WC SET CORRECTLY
*
{CGN03{MOV{10,(XS)+{8,WB{{RESTORE ENTRY WB{20141
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{20142
{{EXI{{{{RETURN TO CDGNM CALLER{20143
*
*      HERE FOR CMBLK
*
{CGN04{MOV{7,XR{7,XL{{COPY CMBLK POINTER{20147
{{MOV{13,CMTYP(XR){7,XR{{LOAD CMBLK TYPE{20148
{{BGE{7,XR{18,=C$$NM{6,CGN01{ERROR IF NOT NAME OPERAND{20149
{{BSW{7,XR{2,C$$NM{{ELSE SWITCH ON TYPE{20150
{{IFF{2,C$ARR{6,CGN05{{ARRAY REFERENCE{20158
{{IFF{2,C$FNC{6,CGN08{{FUNCTION CALL{20158
{{IFF{2,C$DEF{6,CGN09{{DEFERRED EXPRESSION{20158
{{IFF{2,C$IND{6,CGN10{{INDIRECT REFERENCE{20158
{{IFF{2,C$KEY{6,CGN11{{KEYWORD REFERENCE{20158
{{IFF{2,C$UBO{6,CGN08{{UNDEFINED BINARY OP{20158
{{IFF{2,C$UUO{6,CGN08{{UNDEFINED UNARY OP{20158
{{ESW{{{{END SWITCH ON CMBLK TYPE{20158
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGN05{MOV{19,*CMOPN{8,WB{{POINT TO ARRAY OPERAND{20162
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGN06{JSR{6,CMGEN{{{GENERATE CODE FOR NEXT OPERAND{20166
{{MOV{13,CMLEN(XL){8,WC{{LOAD LENGTH OF CMBLK{20167
{{BLT{8,WB{8,WC{6,CGN06{LOOP TILL ALL GENERATED{20168
*
*      GENERATE APPROPRIATE ARRAY CALL
*
{{MOV{21,=OAON${8,WA{{LOAD ONE-SUBSCRIPT CASE CALL{20172
{{BEQ{8,WC{19,*CMAR1{6,CGN07{JUMP TO EXIT IF ONE SUBSCRIPT CASE{20173
{{MOV{21,=OAMN${8,WA{{ELSE LOAD MULTI-SUBSCRIPT CASE CALL{20174
{{JSR{6,CDWRD{{{GENERATE CALL{20175
{{MOV{8,WC{8,WA{{COPY CMBLK LENGTH{20176
{{BTW{8,WA{{{CONVERT TO WORDS{20177
{{SUB{18,=CMVLS{8,WA{{CALCULATE NUMBER OF SUBSCRIPTS{20178
{{EJC{{{{{20179
*
*      CDGNM (CONTINUED)
*
*      HERE TO EXIT GENERATING WORD (NON-CONSTANT)
*
{CGN07{MNZ{8,WC{{{SET RESULT NON-CONSTANT{20185
{{JSR{6,CDWRD{{{GENERATE WORD{20186
{{BRN{6,CGN03{{{BACK TO EXIT{20187
*
*      HERE TO GENERATE CODE FOR FUNCTIONS AND UNDEFINED OPRS
*
{CGN08{MOV{7,XL{7,XR{{COPY CMBLK POINTER{20191
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR CALL{20192
{{MOV{21,=OFNE${8,WA{{GET EXTRA CALL FOR BY NAME{20193
{{BRN{6,CGN07{{{BACK TO GENERATE AND EXIT{20194
*
*      HERE TO GENERATE CODE FOR DEFERED EXPRESSION
*
{CGN09{MOV{13,CMROP(XL){7,XR{{CHECK IF VARIABLE{20198
{{BHI{9,(XR){22,=B$VR${6,CGN02{TREAT *VARIABLE AS SIMPLE VAR{20199
{{MOV{7,XR{7,XL{{COPY PTR TO EXPRESSION TREE{20200
{{MOV{18,=NUM01{8,WA{{RETURN NAME{20202
{{JSR{6,CDGEX{{{ELSE BUILD EXBLK{20204
{{MOV{21,=OLEX${8,WA{{SET CALL TO LOAD EXPR BY NAME{20205
{{JSR{6,CDWRD{{{GENERATE IT{20206
{{MOV{7,XR{8,WA{{COPY EXBLK POINTER{20207
{{JSR{6,CDWRD{{{GENERATE EXBLK POINTER{20208
{{BRN{6,CGN03{{{BACK TO EXIT{20209
*
*      HERE TO GENERATE CODE FOR INDIRECT REFERENCE
*
{CGN10{MOV{13,CMROP(XL){7,XR{{GET OPERAND{20213
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE FOR IT{20214
{{MOV{21,=OINN${8,WA{{LOAD CALL FOR INDIRECT BY NAME{20215
{{BRN{6,CGN12{{{MERGE{20216
*
*      HERE TO GENERATE CODE FOR KEYWORD REFERENCE
*
{CGN11{MOV{13,CMROP(XL){7,XR{{GET OPERAND{20220
{{JSR{6,CDGNM{{{GENERATE CODE BY NAME FOR IT{20221
{{MOV{21,=OKWN${8,WA{{LOAD CALL FOR KEYWORD BY NAME{20222
*
*      KEYWORD, INDIRECT MERGE HERE
*
{CGN12{JSR{6,CDWRD{{{GENERATE CODE FOR OPERATOR{20226
{{BRN{6,CGN03{{{EXIT{20227
{{ENP{{{{END PROCEDURE CDGNM{20228
{{EJC{{{{{20229
*
*      CDGVL -- GENERATE CODE BY VALUE
*
*      CDGVL IS CALLED DURING THE COMPILATION PROCESS TO
*      GENERATE CODE BY VALUE FOR AN EXPRESSION. SEE CDBLK
*      DESCRIPTION FOR DETAILS OF THE CODE GENERATED. THE INPUT
*      TO CDGVL IS AN EXPRESSION TREE AS GENERATED BY EXPAN.
*
*      CDGVL IS A RECURSIVE PROCEDURE WHICH PROCEEDS BY MAKING
*      RECURSIVE CALLS TO GENERATE CODE FOR OPERANDS.
*
*      (WB)                  INTEGER IN RANGE 0 LE N LE DNAMB
*      (XR)                  PTR TO TREE GENERATED BY EXPAN
*      (WC)                  CONSTANT FLAG (SEE BELOW)
*      JSR  CDGVL            CALL TO GENERATE CODE BY VALUE
*      (XR,WA)               DESTROYED
*      (WC)                  SET NON-ZERO IF NON-CONSTANT
*
*      WC IS SET TO A NON-ZERO (COLLECTABLE) VALUE IF THE
*      EXPRESSION FOR WHICH CODE IS GENERATED CANNOT BE
*      EVALUATED AT COMPILE TIME, OTHERWISE WC IS UNCHANGED.
*
*      IF WC IS NON-ZERO ON ENTRY, THEN PREEVALUATION IS NOT
*      ALLOWED REGARDLESS OF THE NATURE OF THE OPERAND.
*
*      THE CODE IS GENERATED IN THE CURRENT CCBLK (SEE CDWRD).
*
{CDGVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20257
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{20258
{{BEQ{8,WA{22,=B$CMT{6,CGV01{JUMP IF CMBLK{20259
{{BLT{8,WA{22,=B$VRA{6,CGV00{JUMP IF ICBLK, RCBLK, SCBLK{20260
{{BNZ{13,VRLEN(XR){6,CGVL0{{JUMP IF NOT SYSTEM VARIABLE{20261
{{MOV{7,XR{11,-(XS){{STACK XR{20262
{{MOV{13,VRSVP(XR){7,XR{{POINT TO SVBLK{20263
{{MOV{13,SVBIT(XR){8,WA{{GET SVBLK PROPERTY BITS{20264
{{MOV{10,(XS)+{7,XR{{RECOVER XR{20265
{{ANB{4,BTKWV{8,WA{{CHECK IF CONSTANT KEYWORD VALUE{20266
{{BEQ{8,WA{4,BTKWV{6,CGV00{JUMP IF CONSTANT KEYWORD VALUE{20267
*
*      HERE FOR VARIABLE VALUE REFERENCE
*
{CGVL0{MNZ{8,WC{{{INDICATE NON-CONSTANT VALUE{20271
*
*      MERGE HERE FOR SIMPLE CONSTANT (ICBLK,RCBLK,SCBLK)
*      AND FOR VARIABLES CORRESPONDING TO CONSTANT KEYWORDS.
*
{CGV00{MOV{7,XR{8,WA{{COPY PTR TO VAR OR CONSTANT{20276
{{JSR{6,CDWRD{{{GENERATE AS CODE WORD{20277
{{EXI{{{{RETURN TO CALLER{20278
{{EJC{{{{{20279
*
*      CDGVL (CONTINUED)
*
*      HERE FOR TREE NODE (CMBLK)
*
{CGV01{MOV{8,WB{11,-(XS){{SAVE ENTRY WB{20285
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20286
{{MOV{8,WC{11,-(XS){{SAVE ENTRY CONSTANT FLAG{20287
{{MOV{3,CWCOF{11,-(XS){{SAVE INITIAL CODE OFFSET{20288
{{CHK{{{{CHECK FOR STACK OVERFLOW{20289
*
*      PREPARE TO GENERATE CODE FOR CMBLK. WC IS SET TO THE
*      VALUE OF CSWNO (ZERO IF -OPTIMISE, 1 IF -NOOPT) TO
*      START WITH AND IS RESET NON-ZERO FOR ANY NON-CONSTANT
*      CODE GENERATED. IF IT IS STILL ZERO AFTER GENERATING ALL
*      THE CMBLK CODE, THEN ITS VALUE IS COMPUTED AS THE RESULT.
*
{{MOV{7,XR{7,XL{{COPY CMBLK POINTER{20297
{{MOV{13,CMTYP(XR){7,XR{{LOAD CMBLK TYPE{20298
{{MOV{3,CSWNO{8,WC{{RESET CONSTANT FLAG{20299
{{BLE{7,XR{18,=C$PR${6,CGV02{JUMP IF NOT PREDICATE VALUE{20300
{{MNZ{8,WC{{{ELSE FORCE NON-CONSTANT CASE{20301
*
*      HERE WITH WC SET APPROPRIATELY
*
{CGV02{BSW{7,XR{2,C$$NV{{SWITCH TO APPROPRIATE GENERATOR{20305
{{IFF{2,C$ARR{6,CGV03{{ARRAY REFERENCE{20325
{{IFF{2,C$FNC{6,CGV05{{FUNCTION CALL{20325
{{IFF{2,C$DEF{6,CGV14{{DEFERRED EXPRESSION{20325
{{IFF{2,C$IND{6,CGV31{{INDIRECT REFERENCE{20325
{{IFF{2,C$KEY{6,CGV27{{KEYWORD REFERENCE{20325
{{IFF{2,C$UBO{6,CGV29{{UNDEFINED BINOP{20325
{{IFF{2,C$UUO{6,CGV30{{UNDEFINED UNOP{20325
{{IFF{2,C$BVL{6,CGV18{{BINOPS WITH VAL OPDS{20325
{{IFF{2,C$UVL{6,CGV19{{UNOPS WITH VALU OPND{20325
{{IFF{2,C$ALT{6,CGV18{{ALTERNATION{20325
{{IFF{2,C$CNC{6,CGV24{{CONCATENATION{20325
{{IFF{2,C$CNP{6,CGV24{{CONCATENATION (NOT PATTERN MATCH){20325
{{IFF{2,C$UNM{6,CGV27{{UNOPS WITH NAME OPND{20325
{{IFF{2,C$BVN{6,CGV26{{BINARY $ AND .{20325
{{IFF{2,C$ASS{6,CGV21{{ASSIGNMENT{20325
{{IFF{2,C$INT{6,CGV31{{INTERROGATION{20325
{{IFF{2,C$NEG{6,CGV28{{NEGATION{20325
{{IFF{2,C$SEL{6,CGV15{{SELECTION{20325
{{IFF{2,C$PMT{6,CGV18{{PATTERN MATCH{20325
{{ESW{{{{END SWITCH ON CMBLK TYPE{20325
{{EJC{{{{{20326
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR ARRAY REFERENCE
*
{CGV03{MOV{19,*CMOPN{8,WB{{SET OFFSET TO ARRAY OPERAND{20332
*
*      LOOP TO GENERATE CODE FOR ARRAY OPERAND AND SUBSCRIPTS
*
{CGV04{JSR{6,CMGEN{{{GEN VALUE CODE FOR NEXT OPERAND{20336
{{MOV{13,CMLEN(XL){8,WC{{LOAD CMBLK LENGTH{20337
{{BLT{8,WB{8,WC{6,CGV04{LOOP BACK IF MORE TO GO{20338
*
*      GENERATE CALL TO APPROPRIATE ARRAY REFERENCE ROUTINE
*
{{MOV{21,=OAOV${8,WA{{SET ONE SUBSCRIPT CALL IN CASE{20342
{{BEQ{8,WC{19,*CMAR1{6,CGV32{JUMP TO EXIT IF 1-SUB CASE{20343
{{MOV{21,=OAMV${8,WA{{ELSE SET CALL FOR MULTI-SUBSCRIPTS{20344
{{JSR{6,CDWRD{{{GENERATE CALL{20345
{{MOV{8,WC{8,WA{{COPY LENGTH OF CMBLK{20346
{{SUB{19,*CMVLS{8,WA{{SUBTRACT STANDARD LENGTH{20347
{{BTW{8,WA{{{GET NUMBER OF WORDS{20348
{{BRN{6,CGV32{{{JUMP TO GENERATE SUBSCRIPT COUNT{20349
*
*      HERE TO GENERATE CODE FOR FUNCTION CALL
*
{CGV05{MOV{19,*CMVLS{8,WB{{SET OFFSET TO FIRST ARGUMENT{20353
*
*      LOOP TO GENERATE CODE FOR ARGUMENTS
*
{CGV06{BEQ{8,WB{13,CMLEN(XL){6,CGV07{JUMP IF ALL GENERATED{20357
{{JSR{6,CMGEN{{{ELSE GEN VALUE CODE FOR NEXT ARG{20358
{{BRN{6,CGV06{{{BACK TO GENERATE NEXT ARGUMENT{20359
*
*      HERE TO GENERATE ACTUAL FUNCTION CALL
*
{CGV07{SUB{19,*CMVLS{8,WB{{GET NUMBER OF ARG PTRS (BYTES){20363
{{BTW{8,WB{{{CONVERT BYTES TO WORDS{20364
{{MOV{13,CMOPN(XL){7,XR{{LOAD FUNCTION VRBLK POINTER{20365
{{BNZ{13,VRLEN(XR){6,CGV12{{JUMP IF NOT SYSTEM FUNCTION{20366
{{MOV{13,VRSVP(XR){7,XL{{LOAD SVBLK PTR IF SYSTEM VAR{20367
{{MOV{13,SVBIT(XL){8,WA{{LOAD BIT MASK{20368
{{ANB{4,BTFFC{8,WA{{TEST FOR FAST FUNCTION CALL ALLOWED{20369
{{ZRB{8,WA{6,CGV12{{JUMP IF NOT{20370
{{EJC{{{{{20371
*
*      CDGVL (CONTINUED)
*
*      HERE IF FAST FUNCTION CALL IS ALLOWED
*
{{MOV{13,SVBIT(XL){8,WA{{RELOAD BIT INDICATORS{20377
{{ANB{4,BTPRE{8,WA{{TEST FOR PREEVALUATION OK{20378
{{NZB{8,WA{6,CGV08{{JUMP IF PREEVALUATION PERMITTED{20379
{{MNZ{8,WC{{{ELSE SET RESULT NON-CONSTANT{20380
*
*      TEST FOR CORRECT NUMBER OF ARGS FOR FAST CALL
*
{CGV08{MOV{13,VRFNC(XR){7,XL{{LOAD PTR TO SVFNC FIELD{20384
{{MOV{13,FARGS(XL){8,WA{{LOAD SVNAR FIELD VALUE{20385
{{BEQ{8,WA{8,WB{6,CGV11{JUMP IF ARGUMENT COUNT IS CORRECT{20386
{{BHI{8,WA{8,WB{6,CGV09{JUMP IF TOO FEW ARGUMENTS GIVEN{20387
*
*      HERE IF TOO MANY ARGUMENTS, PREPARE TO GENERATE O$POPS
*
{{SUB{8,WA{8,WB{{GET NUMBER OF EXTRA ARGS{20391
{{LCT{8,WB{8,WB{{SET AS COUNT TO CONTROL LOOP{20392
{{MOV{21,=OPOP${8,WA{{SET POP CALL{20393
{{BRN{6,CGV10{{{JUMP TO COMMON LOOP{20394
*
*      HERE IF TOO FEW ARGUMENTS, PREPARE TO GENERATE NULLS
*
{CGV09{SUB{8,WB{8,WA{{GET NUMBER OF MISSING ARGUMENTS{20398
{{LCT{8,WB{8,WA{{LOAD AS COUNT TO CONTROL LOOP{20399
{{MOV{21,=NULLS{8,WA{{LOAD PTR TO NULL CONSTANT{20400
*
*      LOOP TO GENERATE CALLS TO FIX ARGUMENT COUNT
*
{CGV10{JSR{6,CDWRD{{{GENERATE ONE CALL{20404
{{BCT{8,WB{6,CGV10{{LOOP TILL ALL GENERATED{20405
*
*      HERE AFTER ADJUSTING ARG COUNT AS REQUIRED
*
{CGV11{MOV{7,XL{8,WA{{COPY POINTER TO SVFNC FIELD{20409
{{BRN{6,CGV36{{{JUMP TO GENERATE CALL{20410
{{EJC{{{{{20411
*
*      CDGVL (CONTINUED)
*
*      COME HERE IF FAST CALL IS NOT PERMITTED
*
{CGV12{MOV{21,=OFNS${8,WA{{SET ONE ARG CALL IN CASE{20417
{{BEQ{8,WB{18,=NUM01{6,CGV13{JUMP IF ONE ARG CASE{20418
{{MOV{21,=OFNC${8,WA{{ELSE LOAD CALL FOR MORE THAN 1 ARG{20419
{{JSR{6,CDWRD{{{GENERATE IT{20420
{{MOV{8,WB{8,WA{{COPY ARGUMENT COUNT{20421
*
*      ONE ARG CASE MERGES HERE
*
{CGV13{JSR{6,CDWRD{{{GENERATE =O$FNS OR ARG COUNT{20425
{{MOV{7,XR{8,WA{{COPY VRBLK POINTER{20426
{{BRN{6,CGV32{{{JUMP TO GENERATE VRBLK PTR{20427
*
*      HERE FOR DEFERRED EXPRESSION
*
{CGV14{MOV{13,CMROP(XL){7,XL{{POINT TO EXPRESSION TREE{20431
{{ZER{8,WA{{{RETURN VALUE{20433
{{JSR{6,CDGEX{{{BUILD EXBLK OR SEBLK{20435
{{MOV{7,XR{8,WA{{COPY BLOCK PTR{20436
{{JSR{6,CDWRD{{{GENERATE PTR TO EXBLK OR SEBLK{20437
{{BRN{6,CGV34{{{JUMP TO EXIT, CONSTANT TEST{20438
*
*      HERE TO GENERATE CODE FOR SELECTION
*
{CGV15{ZER{11,-(XS){{{ZERO PTR TO CHAIN OF FORWARD JUMPS{20442
{{ZER{11,-(XS){{{ZERO PTR TO PREV O$SLC FORWARD PTR{20443
{{MOV{19,*CMVLS{8,WB{{POINT TO FIRST ALTERNATIVE{20444
{{MOV{21,=OSLA${8,WA{{SET INITIAL CODE WORD{20445
*
*      0(XS)                 IS THE OFFSET TO THE PREVIOUS WORD
*                            WHICH REQUIRES FILLING IN WITH AN
*                            OFFSET TO THE FOLLOWING O$SLC,O$SLD
*
*      1(XS)                 IS THE HEAD OF A CHAIN OF OFFSET
*                            POINTERS INDICATING THOSE LOCATIONS
*                            TO BE FILLED WITH OFFSETS PAST
*                            THE END OF ALL THE ALTERNATIVES
*
{CGV16{JSR{6,CDWRD{{{GENERATE O$SLC (O$SLA FIRST TIME){20456
{{MOV{3,CWCOF{9,(XS){{SET CURRENT LOC AS PTR TO FILL IN{20457
{{JSR{6,CDWRD{{{GENERATE GARBAGE WORD THERE FOR NOW{20458
{{JSR{6,CMGEN{{{GEN VALUE CODE FOR ALTERNATIVE{20459
{{MOV{21,=OSLB${8,WA{{LOAD O$SLB POINTER{20460
{{JSR{6,CDWRD{{{GENERATE O$SLB CALL{20461
{{MOV{12,1(XS){8,WA{{LOAD OLD CHAIN PTR{20462
{{MOV{3,CWCOF{12,1(XS){{SET CURRENT LOC AS NEW CHAIN HEAD{20463
{{JSR{6,CDWRD{{{GENERATE FORWARD CHAIN LINK{20464
{{EJC{{{{{20465
*
*      CDGVL (CONTINUED)
*
*      NOW TO FILL IN THE SKIP OFFSET TO O$SLC,O$SLD
*
{{MOV{9,(XS){7,XR{{LOAD OFFSET TO WORD TO PLUG{20471
{{ADD{3,R$CCB{7,XR{{POINT TO ACTUAL LOCATION TO PLUG{20472
{{MOV{3,CWCOF{9,(XR){{PLUG PROPER OFFSET IN{20473
{{MOV{21,=OSLC${8,WA{{LOAD O$SLC PTR FOR NEXT ALTERNATIVE{20474
{{MOV{8,WB{7,XR{{COPY OFFSET (DESTROY GARBAGE XR){20475
{{ICA{7,XR{{{BUMP EXTRA TIME FOR TEST{20476
{{BLT{7,XR{13,CMLEN(XL){6,CGV16{LOOP BACK IF NOT LAST ALTERNATIVE{20477
*
*      HERE TO GENERATE CODE FOR LAST ALTERNATIVE
*
{{MOV{21,=OSLD${8,WA{{GET HEADER CALL{20481
{{JSR{6,CDWRD{{{GENERATE O$SLD CALL{20482
{{JSR{6,CMGEN{{{GENERATE CODE FOR LAST ALTERNATIVE{20483
{{ICA{7,XS{{{POP OFFSET PTR{20484
{{MOV{10,(XS)+{7,XR{{LOAD CHAIN PTR{20485
*
*      LOOP TO PLUG OFFSETS PAST STRUCTURE
*
{CGV17{ADD{3,R$CCB{7,XR{{MAKE NEXT PTR ABSOLUTE{20489
{{MOV{9,(XR){8,WA{{LOAD FORWARD PTR{20490
{{MOV{3,CWCOF{9,(XR){{PLUG REQUIRED OFFSET{20491
{{MOV{8,WA{7,XR{{COPY FORWARD PTR{20492
{{BNZ{8,WA{6,CGV17{{LOOP BACK IF MORE TO GO{20493
{{BRN{6,CGV33{{{ELSE JUMP TO EXIT (NOT CONSTANT){20494
*
*      HERE FOR BINARY OPS WITH VALUE OPERANDS
*
{CGV18{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND POINTER{20498
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR LEFT OPERAND{20499
*
*      HERE FOR UNARY OPS WITH VALUE OPERAND (BINOPS MERGE)
*
{CGV19{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT (ONLY) OPERAND PTR{20503
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20504
{{EJC{{{{{20505
*
*      CDGVL (CONTINUED)
*
*      MERGE HERE TO GENERATE OPERATOR CALL FROM CMOPN FIELD
*
{CGV20{MOV{13,CMOPN(XL){8,WA{{LOAD OPERATOR CALL POINTER{20511
{{BRN{6,CGV36{{{JUMP TO GENERATE IT WITH CONS TEST{20512
*
*      HERE FOR ASSIGNMENT
*
{CGV21{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND POINTER{20516
{{BLO{9,(XR){22,=B$VR${6,CGV22{JUMP IF NOT VARIABLE{20517
*
*      HERE FOR ASSIGNMENT TO SIMPLE VARIABLE
*
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20521
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20522
{{MOV{13,CMLOP(XL){8,WA{{RELOAD LEFT OPERAND VRBLK PTR{20523
{{ADD{19,*VRSTO{8,WA{{POINT TO VRSTO FIELD{20524
{{BRN{6,CGV32{{{JUMP TO GENERATE STORE PTR{20525
*
*      HERE IF NOT SIMPLE VARIABLE ASSIGNMENT
*
{CGV22{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH ON LEFT SIDE{20529
{{PPM{6,CGV23{{{JUMP IF NOT PATTERN MATCH{20530
*
*      HERE FOR PATTERN REPLACEMENT
*
{{MOV{13,CMROP(XR){13,CMLOP(XL){{SAVE PATTERN PTR IN SAFE PLACE{20534
{{MOV{13,CMLOP(XR){7,XR{{LOAD SUBJECT PTR{20535
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR SUBJECT{20536
{{MOV{13,CMLOP(XL){7,XR{{LOAD PATTERN PTR{20537
{{JSR{6,CDGVL{{{GEN CODE BY VALUE FOR PATTERN{20538
{{MOV{21,=OPMN${8,WA{{LOAD MATCH BY NAME CALL{20539
{{JSR{6,CDWRD{{{GENERATE IT{20540
{{MOV{13,CMROP(XL){7,XR{{LOAD REPLACEMENT VALUE PTR{20541
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20542
{{MOV{21,=ORPL${8,WA{{LOAD REPLACE CALL{20543
{{BRN{6,CGV32{{{JUMP TO GEN AND EXIT (NOT CONSTANT){20544
*
*      HERE FOR ASSIGNMENT TO COMPLEX VARIABLE
*
{CGV23{MNZ{8,WC{{{INHIBIT PRE-EVALUATION{20548
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR LEFT SIDE{20549
{{BRN{6,CGV31{{{MERGE WITH UNOP CIRCUIT{20550
{{EJC{{{{{20551
*
*      CDGVL (CONTINUED)
*
*      HERE FOR CONCATENATION
*
{CGV24{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND PTR{20557
{{BNE{9,(XR){22,=B$CMT{6,CGV18{ORDINARY BINOP IF NOT CMBLK{20558
{{MOV{13,CMTYP(XR){8,WB{{LOAD CMBLK TYPE CODE{20559
{{BEQ{8,WB{18,=C$INT{6,CGV25{SPECIAL CASE IF INTERROGATION{20560
{{BEQ{8,WB{18,=C$NEG{6,CGV25{OR NEGATION{20561
{{BNE{8,WB{18,=C$FNC{6,CGV18{ELSE ORDINARY BINOP IF NOT FUNCTION{20562
{{MOV{13,CMOPN(XR){7,XR{{ELSE LOAD FUNCTION VRBLK PTR{20563
{{BNZ{13,VRLEN(XR){6,CGV18{{ORDINARY BINOP IF NOT SYSTEM VAR{20564
{{MOV{13,VRSVP(XR){7,XR{{ELSE POINT TO SVBLK{20565
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT INDICATORS{20566
{{ANB{4,BTPRD{8,WA{{TEST FOR PREDICATE FUNCTION{20567
{{ZRB{8,WA{6,CGV18{{ORDINARY BINOP IF NOT{20568
*
*      HERE IF LEFT ARG OF CONCATENATION IS PREDICATE FUNCTION
*
{CGV25{MOV{13,CMLOP(XL){7,XR{{RELOAD LEFT ARG{20572
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20573
{{MOV{21,=OPOP${8,WA{{LOAD POP CALL{20574
{{JSR{6,CDWRD{{{GENERATE IT{20575
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND{20576
{{JSR{6,CDGVL{{{GEN CODE BY VALUE AS RESULT CODE{20577
{{BRN{6,CGV33{{{EXIT (NOT CONSTANT){20578
*
*      HERE TO GENERATE CODE FOR PATTERN, IMMEDIATE ASSIGNMENT
*
{CGV26{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND{20582
{{JSR{6,CDGVL{{{GEN CODE BY VALUE, MERGE{20583
*
*      HERE FOR UNOPS WITH ARG BY NAME (BINARY $ . MERGE)
*
{CGV27{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20587
{{JSR{6,CDGNM{{{GEN CODE BY NAME FOR RIGHT ARG{20588
{{MOV{13,CMOPN(XL){7,XR{{GET OPERATOR CODE WORD{20589
{{BNE{9,(XR){22,=O$KWV{6,CGV20{GEN CALL UNLESS KEYWORD VALUE{20590
{{EJC{{{{{20591
*
*      CDGVL (CONTINUED)
*
*      HERE FOR KEYWORD BY VALUE. THIS IS CONSTANT ONLY IF
*      THE OPERAND IS ONE OF THE SPECIAL SYSTEM VARIABLES WITH
*      THE SVCKW BIT SET TO INDICATE A CONSTANT KEYWORD VALUE.
*      NOTE THAT THE ONLY CONSTANT OPERAND BY NAME IS A VARIABLE
*
{{BNZ{8,WC{6,CGV20{{GEN CALL IF NON-CONSTANT (NOT VAR){20600
{{MNZ{8,WC{{{ELSE SET NON-CONSTANT IN CASE{20601
{{MOV{13,CMROP(XL){7,XR{{LOAD PTR TO OPERAND VRBLK{20602
{{BNZ{13,VRLEN(XR){6,CGV20{{GEN (NON-CONSTANT) IF NOT SYS VAR{20603
{{MOV{13,VRSVP(XR){7,XR{{ELSE LOAD PTR TO SVBLK{20604
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT MASK{20605
{{ANB{4,BTCKW{8,WA{{TEST FOR CONSTANT KEYWORD{20606
{{ZRB{8,WA{6,CGV20{{GO GEN IF NOT CONSTANT{20607
{{ZER{8,WC{{{ELSE SET RESULT CONSTANT{20608
{{BRN{6,CGV20{{{AND JUMP BACK TO GENERATE CALL{20609
*
*      HERE TO GENERATE CODE FOR NEGATION
*
{CGV28{MOV{21,=ONTA${8,WA{{GET INITIAL WORD{20613
{{JSR{6,CDWRD{{{GENERATE IT{20614
{{MOV{3,CWCOF{8,WB{{SAVE NEXT OFFSET{20615
{{JSR{6,CDWRD{{{GENERATE GUNK WORD FOR NOW{20616
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT OPERAND PTR{20617
{{JSR{6,CDGVL{{{GEN CODE BY VALUE{20618
{{MOV{21,=ONTB${8,WA{{LOAD END OF EVALUATION CALL{20619
{{JSR{6,CDWRD{{{GENERATE IT{20620
{{MOV{8,WB{7,XR{{COPY OFFSET TO WORD TO PLUG{20621
{{ADD{3,R$CCB{7,XR{{POINT TO ACTUAL WORD TO PLUG{20622
{{MOV{3,CWCOF{9,(XR){{PLUG WORD WITH CURRENT OFFSET{20623
{{MOV{21,=ONTC${8,WA{{LOAD FINAL CALL{20624
{{BRN{6,CGV32{{{JUMP TO GENERATE IT (NOT CONSTANT){20625
*
*      HERE TO GENERATE CODE FOR UNDEFINED BINARY OPERATOR
*
{CGV29{MOV{13,CMLOP(XL){7,XR{{LOAD LEFT OPERAND PTR{20629
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20630
{{EJC{{{{{20631
*
*      CDGVL (CONTINUED)
*
*      HERE TO GENERATE CODE FOR UNDEFINED UNARY OPERATOR
*
{CGV30{MOV{18,=C$UO${8,WB{{SET UNOP CODE + 1{20637
{{SUB{13,CMTYP(XL){8,WB{{SET NUMBER OF ARGS (1 OR 2){20638
*
*      MERGE HERE FOR UNDEFINED OPERATORS
*
{{MOV{13,CMROP(XL){7,XR{{LOAD RIGHT (ONLY) OPERAND POINTER{20642
{{JSR{6,CDGVL{{{GEN VALUE CODE FOR RIGHT OPERAND{20643
{{MOV{13,CMOPN(XL){7,XR{{LOAD POINTER TO OPERATOR DV{20644
{{MOV{13,DVOPN(XR){7,XR{{LOAD POINTER OFFSET{20645
{{WTB{7,XR{{{CONVERT WORD OFFSET TO BYTES{20646
{{ADD{20,=R$UBA{7,XR{{POINT TO PROPER FUNCTION PTR{20647
{{SUB{19,*VRFNC{7,XR{{SET STANDARD FUNCTION OFFSET{20648
{{BRN{6,CGV12{{{MERGE WITH FUNCTION CALL CIRCUIT{20649
*
*      HERE TO GENERATE CODE FOR INTERROGATION, INDIRECTION
*
{CGV31{MNZ{8,WC{{{SET NON CONSTANT{20653
{{BRN{6,CGV19{{{MERGE{20654
*
*      HERE TO EXIT GENERATING A WORD, RESULT NOT CONSTANT
*
{CGV32{JSR{6,CDWRD{{{GENERATE WORD, MERGE{20658
*
*      HERE TO EXIT WITH NO WORD GENERATED, NOT CONSTANT
*
{CGV33{MNZ{8,WC{{{INDICATE RESULT IS NOT CONSTANT{20662
*
*      COMMON EXIT POINT
*
{CGV34{ICA{7,XS{{{POP INITIAL CODE OFFSET{20666
{{MOV{10,(XS)+{8,WA{{RESTORE OLD CONSTANT FLAG{20667
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{20668
{{MOV{10,(XS)+{8,WB{{RESTORE ENTRY WB{20669
{{BNZ{8,WC{6,CGV35{{JUMP IF NOT CONSTANT{20670
{{MOV{8,WA{8,WC{{ELSE RESTORE ENTRY CONSTANT FLAG{20671
*
*      HERE TO RETURN AFTER DEALING WITH WC SETTING
*
{CGV35{EXI{{{{RETURN TO CDGVL CALLER{20675
*
*      EXIT HERE TO GENERATE WORD AND TEST FOR CONSTANT
*
{CGV36{JSR{6,CDWRD{{{GENERATE WORD{20679
{{BNZ{8,WC{6,CGV34{{JUMP TO EXIT IF NOT CONSTANT{20680
{{EJC{{{{{20681
*
*      CDGVL (CONTINUED)
*
*      HERE TO PREEVALUATE CONSTANT SUB-EXPRESSION
*
{{MOV{21,=ORVL${8,WA{{LOAD CALL TO RETURN VALUE{20687
{{JSR{6,CDWRD{{{GENERATE IT{20688
{{MOV{9,(XS){7,XL{{LOAD INITIAL CODE OFFSET{20689
{{JSR{6,EXBLD{{{BUILD EXBLK FOR EXPRESSION{20690
{{ZER{8,WB{{{SET TO EVALUATE BY VALUE{20691
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{20692
{{PPM{{{{SHOULD NOT FAIL{20693
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD OF RESULT{20694
{{BLO{8,WA{22,=P$AAA{6,CGV37{JUMP IF NOT PATTERN{20695
{{MOV{21,=OLPT${8,WA{{ELSE LOAD SPECIAL PATTERN LOAD CALL{20696
{{JSR{6,CDWRD{{{GENERATE IT{20697
*
*      MERGE HERE TO GENERATE POINTER TO RESULTING CONSTANT
*
{CGV37{MOV{7,XR{8,WA{{COPY CONSTANT POINTER{20701
{{JSR{6,CDWRD{{{GENERATE PTR{20702
{{ZER{8,WC{{{SET RESULT CONSTANT{20703
{{BRN{6,CGV34{{{JUMP BACK TO EXIT{20704
{{ENP{{{{END PROCEDURE CDGVL{20705
{{EJC{{{{{20706
*
*      CDWRD -- GENERATE ONE WORD OF CODE
*
*      CDWRD WRITES ONE WORD INTO THE CURRENT CODE BLOCK UNDER
*      CONSTRUCTION. A NEW, LARGER, BLOCK IS ALLOCATED IF THERE
*      IS INSUFFICIENT ROOM IN THE CURRENT BLOCK. CDWRD ENSURES
*      THAT THERE ARE AT LEAST FOUR WORDS LEFT IN THE BLOCK
*      AFTER ENTERING THE NEW WORD. THIS GUARANTEES THAT ANY
*      EXTRA SPACE AT THE END CAN BE SPLIT OFF AS A CCBLK.
*
*      (WA)                  WORD TO BE GENERATED
*      JSR  CDWRD            CALL TO GENERATE WORD
*
{CDWRD{PRC{25,E{1,0{{ENTRY POINT{20724
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{20725
{{MOV{8,WA{11,-(XS){{SAVE CODE WORD TO BE GENERATED{20726
*
*      MERGE BACK HERE AFTER ALLOCATING LARGER BLOCK
*
{CDWD1{MOV{3,R$CCB{7,XR{{LOAD PTR TO CCBLK BEING BUILT{20730
{{BNZ{7,XR{6,CDWD2{{JUMP IF BLOCK ALLOCATED{20731
*
*      HERE WE ALLOCATE AN ENTIRELY FRESH BLOCK
*
{{MOV{19,*E$CBS{8,WA{{LOAD INITIAL LENGTH{20735
{{JSR{6,ALLOC{{{ALLOCATE CCBLK{20736
{{MOV{22,=B$CCT{9,(XR){{STORE TYPE WORD{20737
{{MOV{19,*CCCOD{3,CWCOF{{SET INITIAL OFFSET{20738
{{MOV{8,WA{13,CCLEN(XR){{STORE BLOCK LENGTH{20739
{{ZER{13,CCSLN(XR){{{ZERO LINE NUMBER{20741
{{MOV{7,XR{3,R$CCB{{STORE PTR TO NEW BLOCK{20743
*
*      HERE WE HAVE A BLOCK WE CAN USE
*
{CDWD2{MOV{3,CWCOF{8,WA{{LOAD CURRENT OFFSET{20747
{{ADD{19,*NUM05{8,WA{{ADJUST FOR TEST (FIVE WORDS){20749
{{BLO{8,WA{13,CCLEN(XR){6,CDWD4{JUMP IF ROOM IN THIS BLOCK{20753
*
*      HERE IF NO ROOM IN CURRENT BLOCK
*
{{BGE{8,WA{3,MXLEN{6,CDWD5{JUMP IF ALREADY AT MAX SIZE{20757
{{ADD{19,*E$CBS{8,WA{{ELSE GET NEW SIZE{20758
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{20759
{{MOV{7,XR{7,XL{{COPY POINTER{20760
{{BLT{8,WA{3,MXLEN{6,CDWD3{JUMP IF NOT TOO LARGE{20761
{{MOV{3,MXLEN{8,WA{{ELSE RESET TO MAX ALLOWED SIZE{20762
{{EJC{{{{{20763
*
*      CDWRD (CONTINUED)
*
*      HERE WITH NEW BLOCK SIZE IN WA
*
{CDWD3{JSR{6,ALLOC{{{ALLOCATE NEW BLOCK{20769
{{MOV{7,XR{3,R$CCB{{STORE POINTER TO NEW BLOCK{20770
{{MOV{22,=B$CCT{10,(XR)+{{STORE TYPE WORD IN NEW BLOCK{20771
{{MOV{8,WA{10,(XR)+{{STORE BLOCK LENGTH{20772
{{MOV{13,CCSLN(XL){10,(XR)+{{COPY SOURCE LINE NUMBER WORD{20774
{{ADD{19,*CCUSE{7,XL{{POINT TO CCUSE,CCCOD FIELDS IN OLD{20776
{{MOV{9,(XL){8,WA{{LOAD CCUSE VALUE{20777
{{MVW{{{{COPY USEFUL WORDS FROM OLD BLOCK{20778
{{MOV{10,(XS)+{7,XL{{RESTORE XL{20779
{{BRN{6,CDWD1{{{MERGE BACK TO TRY AGAIN{20780
*
*      HERE WITH ROOM IN CURRENT BLOCK
*
{CDWD4{MOV{3,CWCOF{8,WA{{LOAD CURRENT OFFSET{20784
{{ICA{8,WA{{{GET NEW OFFSET{20785
{{MOV{8,WA{3,CWCOF{{STORE NEW OFFSET{20786
{{MOV{8,WA{13,CCUSE(XR){{STORE IN CCBLK FOR GBCOL{20787
{{DCA{8,WA{{{RESTORE PTR TO THIS WORD{20788
{{ADD{8,WA{7,XR{{POINT TO CURRENT ENTRY{20789
{{MOV{10,(XS)+{8,WA{{RELOAD WORD TO GENERATE{20790
{{MOV{8,WA{9,(XR){{STORE WORD IN BLOCK{20791
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{20792
{{EXI{{{{RETURN TO CALLER{20793
*
*      HERE IF COMPILED CODE IS TOO LONG FOR CDBLK
*
{CDWD5{ERB{1,213{26,Syntax error: Statement is too complicated.{{{20797
{{ENP{{{{END PROCEDURE CDWRD{20798
{{EJC{{{{{20799
*
*      CMGEN -- GENERATE CODE FOR CMBLK PTR
*
*      CMGEN IS A SUBSIDIARY PROCEDURE USED TO GENERATE VALUE
*      CODE FOR A CMBLK PTR FROM THE MAIN CODE GENERATORS.
*
*      (XL)                  CMBLK POINTER
*      (WB)                  OFFSET TO POINTER IN CMBLK
*      JSR  CMGEN            CALL TO GENERATE CODE
*      (XR,WA)               DESTROYED
*      (WB)                  BUMPED BY ONE WORD
*
{CMGEN{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{20812
{{MOV{7,XL{7,XR{{COPY CMBLK POINTER{20813
{{ADD{8,WB{7,XR{{POINT TO CMBLK POINTER{20814
{{MOV{9,(XR){7,XR{{LOAD CMBLK POINTER{20815
{{JSR{6,CDGVL{{{GENERATE CODE BY VALUE{20816
{{ICA{8,WB{{{BUMP OFFSET{20817
{{EXI{{{{RETURN TO CALLER{20818
{{ENP{{{{END PROCEDURE CMGEN{20819
{{EJC{{{{{20820
*
*      CMPIL (COMPILE SOURCE CODE)
*
*      CMPIL IS USED TO CONVERT SNOBOL4 SOURCE CODE TO INTERNAL
*      FORM (SEE CDBLK FORMAT). IT IS USED BOTH FOR THE INITIAL
*      COMPILE AND AT RUN TIME BY THE CODE AND CONVERT FUNCTIONS
*      THIS PROCEDURE HAS CONTROL FOR THE ENTIRE DURATION OF
*      INITIAL COMPILATION. AN ERROR IN ANY PROCEDURE CALLED
*      DURING COMPILATION WILL LEAD FIRST TO THE ERROR SECTION
*      AND ULTIMATELY BACK HERE FOR RESUMED COMPILATION. THE
*      RE-ENTRY POINTS AFTER AN ERROR ARE SPECIALLY LABELLED -
*
*      CMPCE                 RESUME AFTER CONTROL CARD ERROR
*      CMPLE                 RESUME AFTER LABEL ERROR
*      CMPSE                 RESUME AFTER STATEMENT ERROR
*
*      JSR  CMPIL            CALL TO COMPILE CODE
*      (XR)                  PTR TO CDBLK FOR ENTRY STATEMENT
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE FOLLOWING GLOBAL VARIABLES ARE REFERENCED
*
*      CMPLN                 LINE NUMBER OF FIRST LINE OF
*                            STATEMENT TO BE COMPILED
*
*      CMPSN                 NUMBER OF NEXT STATEMENT
*                            TO BE COMPILED.
*
*      CSWXX                 CONTROL CARD SWITCH VALUES ARE
*                            CHANGED WHEN RELEVANT CONTROL
*                            CARDS ARE MET.
*
*      CWCOF                 OFFSET TO NEXT WORD IN CODE BLOCK
*                            BEING BUILT (SEE CDWRD).
*
*      LSTSN                 NUMBER OF STATEMENT MOST RECENTLY
*                            COMPILED (INITIALLY SET TO ZERO).
*
*      R$CIM                 CURRENT (INITIAL) COMPILER IMAGE
*                            (ZERO FOR INITIAL COMPILE CALL)
*
*      R$CNI                 USED TO POINT TO FOLLOWING IMAGE.
*                            (SEE READR PROCEDURE).
*
*      SCNGO                 GOTO SWITCH FOR SCANE PROCEDURE
*
*      SCNIL                 LENGTH OF CURRENT IMAGE EXCLUDING
*                            CHARACTERS REMOVED BY -INPUT.
*
*      SCNPT                 CURRENT SCAN OFFSET, SEE SCANE.
*
*      SCNRS                 RESCAN SWITCH FOR SCANE PROCEDURE.
*
*      SCNSE                 OFFSET (IN R$CIM) OF MOST RECENTLY
*                            SCANNED ELEMENT. SET ZERO IF NOT
*                            CURRENTLY SCANNING ITEMS
{{EJC{{{{{20877
*
*      CMPIL (CONTINUED)
*
*      STAGE               STGIC  INITIAL COMPILE IN PROGRESS
*                          STGXC  CODE/CONVERT COMPILE
*                          STGEV  BUILDING EXBLK FOR EVAL
*                          STGXT  EXECUTE TIME (OUTSIDE COMPILE)
*                          STGCE  INITIAL COMPILE AFTER END LINE
*                          STGXE  EXECUTE COMPILE AFTER END LINE
*
*      CMPIL ALSO USES A FIXED NUMBER OF LOCATIONS ON THE
*      MAIN STACK AS FOLLOWS. (THE DEFINITIONS OF THE ACTUAL
*      OFFSETS ARE IN THE DEFINITIONS SECTION).
*
*      CMSTM(XS)             POINTER TO EXPAN TREE FOR BODY OF
*                            STATEMENT (SEE EXPAN PROCEDURE).
*
*      CMSGO(XS)             POINTER TO TREE REPRESENTATION OF
*                            SUCCESS GOTO (SEE PROCEDURE SCNGO)9
*                            ZERO IF NO SUCCESS GOTO IS GIVEN
*
*      CMFGO(XS)             LIKE CMSGO FOR FAILURE GOTO.
*
*      CMCGO(XS)             SET NON-ZERO ONLY IF THERE IS A
*                            CONDITIONAL GOTO. USED FOR -FAIL,
*                            -NOFAIL CODE GENERATION.
*
*      CMPCD(XS)             POINTER TO CDBLK FOR PREVIOUS
*                            STATEMENT. ZERO FOR 1ST STATEMENT.
*
*      CMFFP(XS)             SET NON-ZERO IF CDFAL IN PREVIOUS
*                            CDBLK NEEDS FILLING WITH FORWARD
*                            POINTER, ELSE SET TO ZERO.
*
*      CMFFC(XS)             SAME AS CMFFP FOR CURRENT CDBLK
*
*      CMSOP(XS)             OFFSET TO WORD IN PREVIOUS CDBLK
*                            TO BE FILLED IN WITH FORWARD PTR
*                            TO NEXT CDBLK FOR SUCCESS GOTO.
*                            ZERO IF NO FILL IN IS REQUIRED.
*
*      CMSOC(XS)             SAME AS CMSOP FOR CURRENT CDBLK.
*
*      CMLBL(XS)             POINTER TO VRBLK FOR LABEL OF
*                            CURRENT STATEMENT. ZERO IF NO LABEL
*
*      CMTRA(XS)             POINTER TO CDBLK FOR ENTRY STMNT.
{{EJC{{{{{20925
*
*      CMPIL (CONTINUED)
*
*      ENTRY POINT
*
{CMPIL{PRC{25,E{1,0{{ENTRY POINT{20931
{{LCT{8,WB{18,=CMNEN{{SET NUMBER OF STACK WORK LOCATIONS{20932
*
*      LOOP TO INITIALIZE STACK WORKING LOCATIONS
*
{CMP00{ZER{11,-(XS){{{STORE A ZERO, MAKE ONE ENTRY{20936
{{BCT{8,WB{6,CMP00{{LOOP BACK UNTIL ALL SET{20937
{{MOV{7,XS{3,CMPXS{{SAVE STACK POINTER FOR ERROR SEC{20938
{{SSS{3,CMPSS{{{SAVE S-R STACK POINTER IF ANY{20939
*
*      LOOP THROUGH STATEMENTS
*
{CMP01{MOV{3,SCNPT{8,WB{{SET SCAN POINTER OFFSET{20943
{{MOV{8,WB{3,SCNSE{{SET START OF ELEMENT LOCATION{20944
{{MOV{21,=OCER${8,WA{{POINT TO COMPILE ERROR CALL{20945
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY CDFAL{20946
{{BLT{8,WB{3,SCNIL{6,CMP04{JUMP IF CHARS LEFT ON THIS IMAGE{20947
*
*      LOOP HERE AFTER COMMENT OR CONTROL CARD
*      ALSO SPECIAL ENTRY AFTER CONTROL CARD ERROR
*
{CMPCE{ZER{7,XR{{{CLEAR POSSIBLE GARBAGE XR VALUE{20952
{{BNZ{3,CNIND{6,CMPC2{{IF WITHIN INCLUDE FILE{20954
{{BNE{3,STAGE{18,=STGIC{6,CMP02{SKIP UNLESS INITIAL COMPILE{20956
{CMPC2{JSR{6,READR{{{READ NEXT INPUT IMAGE{20957
{{BZE{7,XR{6,CMP09{{JUMP IF NO INPUT AVAILABLE{20958
{{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{20959
{{MOV{3,CMPSN{3,LSTSN{{STORE STMT NO FOR USE BY LISTR{20960
{{MOV{3,RDCLN{3,CMPLN{{STORE LINE NUMBER AT START OF STMT{20961
{{ZER{3,SCNPT{{{RESET SCAN POINTER{20962
{{BRN{6,CMP04{{{GO PROCESS IMAGE{20963
*
*      FOR EXECUTE TIME COMPILE, PERMIT EMBEDDED CONTROL CARDS
*      AND COMMENTS (BY SKIPPING TO NEXT SEMI-COLON)
*
{CMP02{MOV{3,R$CIM{7,XR{{GET CURRENT IMAGE{20968
{{MOV{3,SCNPT{8,WB{{GET CURRENT OFFSET{20969
{{PLC{7,XR{8,WB{{PREPARE TO GET CHARS{20970
*
*      SKIP TO SEMI-COLON
*
{CMP03{BGE{3,SCNPT{3,SCNIL{6,CMP09{END LOOP IF END OF IMAGE{20974
{{LCH{8,WC{10,(XR)+{{GET CHAR{20975
{{ICV{3,SCNPT{{{ADVANCE OFFSET{20976
{{BNE{8,WC{18,=CH$SM{6,CMP03{LOOP IF NOT SEMI-COLON{20977
{{EJC{{{{{20978
*
*      CMPIL (CONTINUED)
*
*      HERE WITH IMAGE AVAILABLE TO SCAN. NOTE THAT IF THE INPUT
*      STRING IS NULL, THEN EVERYTHING IS OK SINCE NULL IS
*      ACTUALLY ASSEMBLED AS A WORD OF BLANKS.
*
{CMP04{MOV{3,R$CIM{7,XR{{POINT TO CURRENT IMAGE{20986
{{MOV{3,SCNPT{8,WB{{LOAD CURRENT OFFSET{20987
{{MOV{8,WB{8,WA{{COPY FOR LABEL SCAN{20988
{{PLC{7,XR{8,WB{{POINT TO FIRST CHARACTER{20989
{{LCH{8,WC{10,(XR)+{{LOAD FIRST CHARACTER{20990
{{BEQ{8,WC{18,=CH$SM{6,CMP12{NO LABEL IF SEMICOLON{20991
{{BEQ{8,WC{18,=CH$AS{6,CMPCE{LOOP BACK IF COMMENT CARD{20992
{{BEQ{8,WC{18,=CH$MN{6,CMP32{JUMP IF CONTROL CARD{20993
{{MOV{3,R$CIM{3,R$CMP{{ABOUT TO DESTROY R$CIM{20994
{{MOV{20,=CMLAB{7,XL{{POINT TO LABEL WORK STRING{20995
{{MOV{7,XL{3,R$CIM{{SCANE IS TO SCAN WORK STRING{20996
{{PSC{7,XL{{{POINT TO FIRST CHARACTER POSITION{20997
{{SCH{8,WC{10,(XL)+{{STORE CHAR JUST LOADED{20998
{{MOV{18,=CH$SM{8,WC{{GET A SEMICOLON{20999
{{SCH{8,WC{9,(XL){{STORE AFTER FIRST CHAR{21000
{{CSC{7,XL{{{FINISHED CHARACTER STORING{21001
{{ZER{7,XL{{{CLEAR POINTER{21002
{{ZER{3,SCNPT{{{START AT FIRST CHARACTER{21003
{{MOV{3,SCNIL{11,-(XS){{PRESERVE IMAGE LENGTH{21004
{{MOV{18,=NUM02{3,SCNIL{{READ 2 CHARS AT MOST{21005
{{JSR{6,SCANE{{{SCAN FIRST CHAR FOR TYPE{21006
{{MOV{10,(XS)+{3,SCNIL{{RESTORE IMAGE LENGTH{21007
{{MOV{7,XL{8,WC{{NOTE RETURN CODE{21008
{{MOV{3,R$CMP{7,XL{{GET OLD R$CIM{21009
{{MOV{7,XL{3,R$CIM{{PUT IT BACK{21010
{{MOV{8,WB{3,SCNPT{{REINSTATE OFFSET{21011
{{BNZ{3,SCNBL{6,CMP12{{BLANK SEEN - CANT BE LABEL{21012
{{MOV{7,XL{7,XR{{POINT TO CURRENT IMAGE{21013
{{PLC{7,XR{8,WB{{POINT TO FIRST CHAR AGAIN{21014
{{BEQ{8,WC{18,=T$VAR{6,CMP06{OK IF LETTER{21015
{{BEQ{8,WC{18,=T$CON{6,CMP06{OK IF DIGIT{21016
*
*      DROP IN OR JUMP FROM ERROR SECTION IF SCANE FAILED
*
{CMPLE{MOV{3,R$CMP{3,R$CIM{{POINT TO BAD LINE{21020
{{ERB{1,214{26,Bad label or misplaced continuation line{{{21021
*
*      LOOP TO SCAN LABEL
*
{CMP05{BEQ{8,WC{18,=CH$SM{6,CMP07{SKIP IF SEMICOLON{21025
{{ICV{8,WA{{{BUMP OFFSET{21026
{{BEQ{8,WA{3,SCNIL{6,CMP07{JUMP IF END OF IMAGE (LABEL END){21027
{{EJC{{{{{21028
*
*      CMPIL (CONTINUED)
*
*      ENTER LOOP AT THIS POINT
*
{CMP06{LCH{8,WC{10,(XR)+{{ELSE LOAD NEXT CHARACTER{21034
{{BEQ{8,WC{18,=CH$HT{6,CMP07{JUMP IF HORIZONTAL TAB{21036
{{BNE{8,WC{18,=CH$BL{6,CMP05{LOOP BACK IF NON-BLANK{21041
*
*      HERE AFTER SCANNING OUT LABEL
*
{CMP07{MOV{8,WA{3,SCNPT{{SAVE UPDATED SCAN OFFSET{21045
{{SUB{8,WB{8,WA{{GET LENGTH OF LABEL{21046
{{BZE{8,WA{6,CMP12{{SKIP IF LABEL LENGTH ZERO{21047
{{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{21048
{{JSR{6,SBSTR{{{BUILD SCBLK FOR LABEL NAME{21049
{{JSR{6,GTNVR{{{LOCATE/CONTRUCT VRBLK{21050
{{PPM{{{{DUMMY (IMPOSSIBLE) ERROR RETURN{21051
{{MOV{7,XR{13,CMLBL(XS){{STORE LABEL POINTER{21052
{{BNZ{13,VRLEN(XR){6,CMP11{{JUMP IF NOT SYSTEM LABEL{21053
{{BNE{13,VRSVP(XR){21,=V$END{6,CMP11{JUMP IF NOT END LABEL{21054
*
*      HERE FOR END LABEL SCANNED OUT
*
{{ADD{18,=STGND{3,STAGE{{ADJUST STAGE APPROPRIATELY{21058
{{JSR{6,SCANE{{{SCAN OUT NEXT ELEMENT{21059
{{BEQ{7,XL{18,=T$SMC{6,CMP10{JUMP IF END OF IMAGE{21060
{{BNE{7,XL{18,=T$VAR{6,CMP08{ELSE ERROR IF NOT VARIABLE{21061
*
*      HERE CHECK FOR VALID INITIAL TRANSFER
*
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP08{JUMP IF NOT DEFINED (ERROR){21065
{{MOV{13,VRLBL(XR){13,CMTRA(XS){{ELSE SET INITIAL ENTRY POINTER{21066
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21067
{{BEQ{7,XL{18,=T$SMC{6,CMP10{JUMP IF OK (END OF IMAGE){21068
*
*      HERE FOR BAD TRANSFER LABEL
*
{CMP08{ERB{1,215{26,Syntax error: Undefined or erroneous entry label{{{21072
*
*      HERE FOR END OF INPUT (NO END LABEL DETECTED)
*
{CMP09{ZER{7,XR{{{CLEAR GARBAGE XR VALUE{21076
{{ADD{18,=STGND{3,STAGE{{ADJUST STAGE APPROPRIATELY{21077
{{BEQ{3,STAGE{18,=STGXE{6,CMP10{JUMP IF CODE CALL (OK){21078
{{ERB{1,216{26,Syntax error: Missing END line{{{21079
*
*      HERE AFTER PROCESSING END LINE (MERGE HERE ON END ERROR)
*
{CMP10{MOV{21,=OSTP${8,WA{{SET STOP CALL POINTER{21083
{{JSR{6,CDWRD{{{GENERATE AS STATEMENT CALL{21084
{{BRN{6,CMPSE{{{JUMP TO GENERATE AS FAILURE{21085
{{EJC{{{{{21086
*
*      CMPIL (CONTINUED)
*
*      HERE AFTER PROCESSING LABEL OTHER THAN END
*
{CMP11{BNE{3,STAGE{18,=STGIC{6,CMP12{JUMP IF CODE CALL - REDEF. OK{21092
{{BEQ{13,VRLBL(XR){21,=STNDL{6,CMP12{ELSE CHECK FOR REDEFINITION{21093
{{ZER{13,CMLBL(XS){{{LEAVE FIRST LABEL DECLN UNDISTURBED{21094
{{ERB{1,217{26,Syntax error: Duplicate label{{{21095
*
*      HERE AFTER DEALING WITH LABEL
*      NULL STATEMENTS AND STATEMENTS JUST CONTAINING A
*      CONSTANT SUBJECT ARE OPTIMIZED OUT BY RESETTING THE
*      CURRENT CCBLK TO EMPTY.
*
{CMP12{ZER{8,WB{{{SET FLAG FOR STATEMENT BODY{21102
{{JSR{6,EXPAN{{{GET TREE FOR STATEMENT BODY{21103
{{MOV{7,XR{13,CMSTM(XS){{STORE FOR LATER USE{21104
{{ZER{13,CMSGO(XS){{{CLEAR SUCCESS GOTO POINTER{21105
{{ZER{13,CMFGO(XS){{{CLEAR FAILURE GOTO POINTER{21106
{{ZER{13,CMCGO(XS){{{CLEAR CONDITIONAL GOTO FLAG{21107
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21108
{{BEQ{7,XL{18,=T$COL{6,CMP13{JUMP IF COLON (GOTO){21109
{{BNZ{3,CSWNO{6,CMP18{{JUMP IF NOT OPTIMIZING{21110
{{BNZ{13,CMLBL(XS){6,CMP18{{JUMP IF LABEL PRESENT{21111
{{MOV{13,CMSTM(XS){7,XR{{LOAD TREE PTR FOR STATEMENT BODY{21112
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{21113
{{BEQ{8,WA{22,=B$CMT{6,CMP18{JUMP IF CMBLK{21114
{{BGE{8,WA{22,=B$VRA{6,CMP18{JUMP IF NOT ICBLK, SCBLK, OR RCBLK{21115
{{MOV{3,R$CCB{7,XL{{LOAD PTR TO CCBLK{21116
{{MOV{19,*CCCOD{13,CCUSE(XL){{RESET USE OFFSET IN CCBLK{21117
{{MOV{19,*CCCOD{3,CWCOF{{AND IN GLOBAL{21118
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{21119
{{BRN{6,CMP01{{{GENERATE NO CODE FOR STATEMENT{21120
*
*      LOOP TO PROCESS GOTO FIELDS
*
{CMP13{MNZ{3,SCNGO{{{SET GOTO FLAG{21124
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{21125
{{BEQ{7,XL{18,=T$SMC{6,CMP31{JUMP IF NO FIELDS LEFT{21126
{{BEQ{7,XL{18,=T$SGO{6,CMP14{JUMP IF S FOR SUCCESS GOTO{21127
{{BEQ{7,XL{18,=T$FGO{6,CMP16{JUMP IF F FOR FAILURE GOTO{21128
*
*      HERE FOR UNCONDITIONAL GOTO (I.E. NOT F OR S)
*
{{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT NOT F,S{21132
{{JSR{6,SCNGF{{{SCAN OUT GOTO FIELD{21133
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY{21134
{{MOV{7,XR{13,CMFGO(XS){{ELSE SET AS FGOTO{21135
{{BRN{6,CMP15{{{MERGE WITH SGOTO CIRCUIT{21136
*
*      HERE FOR SUCCESS GOTO
*
{CMP14{JSR{6,SCNGF{{{SCAN SUCCESS GOTO FIELD{21140
{{MOV{18,=NUM01{13,CMCGO(XS){{SET CONDITIONAL GOTO FLAG{21141
*
*      UNCONTIONAL GOTO MERGES HERE
*
{CMP15{BNZ{13,CMSGO(XS){6,CMP17{{ERROR IF SGOTO ALREADY GIVEN{21145
{{MOV{7,XR{13,CMSGO(XS){{ELSE SET SGOTO{21146
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT GOTO FIELD{21147
*
*      HERE FOR FAILURE GOTO
*
{CMP16{JSR{6,SCNGF{{{SCAN GOTO FIELD{21151
{{MOV{18,=NUM01{13,CMCGO(XS){{SET CONDITONAL GOTO FLAG{21152
{{BNZ{13,CMFGO(XS){6,CMP17{{ERROR IF FGOTO ALREADY GIVEN{21153
{{MOV{7,XR{13,CMFGO(XS){{ELSE STORE FGOTO POINTER{21154
{{BRN{6,CMP13{{{LOOP BACK FOR NEXT FIELD{21155
{{EJC{{{{{21156
*
*      CMPIL (CONTINUED)
*
*      HERE FOR DUPLICATED GOTO FIELD
*
{CMP17{ERB{1,218{26,Syntax error: Duplicated goto field{{{21162
*
*      HERE TO GENERATE CODE
*
{CMP18{ZER{3,SCNSE{{{STOP POSITIONAL ERROR FLAGS{21166
{{MOV{13,CMSTM(XS){7,XR{{LOAD TREE PTR FOR STATEMENT BODY{21167
{{ZER{8,WB{{{COLLECTABLE VALUE FOR WB FOR CDGVL{21168
{{ZER{8,WC{{{RESET CONSTANT FLAG FOR CDGVL{21169
{{JSR{6,EXPAP{{{TEST FOR PATTERN MATCH{21170
{{PPM{6,CMP19{{{JUMP IF NOT PATTERN MATCH{21171
{{MOV{21,=OPMS${13,CMOPN(XR){{ELSE SET PATTERN MATCH POINTER{21172
{{MOV{18,=C$PMT{13,CMTYP(XR){{{21173
*
*      HERE AFTER DEALING WITH SPECIAL PATTERN MATCH CASE
*
{CMP19{JSR{6,CDGVL{{{GENERATE CODE FOR BODY OF STATEMENT{21177
{{MOV{13,CMSGO(XS){7,XR{{LOAD SGOTO POINTER{21178
{{MOV{7,XR{8,WA{{COPY IT{21179
{{BZE{7,XR{6,CMP21{{JUMP IF NO SUCCESS GOTO{21180
{{ZER{13,CMSOC(XS){{{CLEAR SUCCESS OFFSET FILLIN PTR{21181
{{BHI{7,XR{3,STATE{6,CMP20{JUMP IF COMPLEX GOTO{21182
*
*      HERE FOR SIMPLE SUCCESS GOTO (LABEL)
*
{{ADD{19,*VRTRA{8,WA{{POINT TO VRTRA FIELD AS REQUIRED{21186
{{JSR{6,CDWRD{{{GENERATE SUCCESS GOTO{21187
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{21188
*
*      HERE FOR COMPLEX SUCCESS GOTO
*
{CMP20{BEQ{7,XR{13,CMFGO(XS){6,CMP22{NO CODE IF SAME AS FGOTO{21192
{{ZER{8,WB{{{ELSE SET OK VALUE FOR CDGVL IN WB{21193
{{JSR{6,CDGCG{{{GENERATE CODE FOR SUCCESS GOTO{21194
{{BRN{6,CMP22{{{JUMP TO DEAL WITH FGOTO{21195
*
*      HERE FOR NO SUCCESS GOTO
*
{CMP21{MOV{3,CWCOF{13,CMSOC(XS){{SET SUCCESS FILL IN OFFSET{21199
{{MOV{21,=OCER${8,WA{{POINT TO COMPILE ERROR CALL{21200
{{JSR{6,CDWRD{{{GENERATE AS TEMPORARY VALUE{21201
{{EJC{{{{{21202
*
*      CMPIL (CONTINUED)
*
*      HERE TO DEAL WITH FAILURE GOTO
*
{CMP22{MOV{13,CMFGO(XS){7,XR{{LOAD FAILURE GOTO POINTER{21208
{{MOV{7,XR{8,WA{{COPY IT{21209
{{ZER{13,CMFFC(XS){{{SET NO FILL IN REQUIRED YET{21210
{{BZE{7,XR{6,CMP23{{JUMP IF NO FAILURE GOTO GIVEN{21211
{{ADD{19,*VRTRA{8,WA{{POINT TO VRTRA FIELD IN CASE{21212
{{BLO{7,XR{3,STATE{6,CMPSE{JUMP TO GEN IF SIMPLE FGOTO{21213
*
*      HERE FOR COMPLEX FAILURE GOTO
*
{{MOV{3,CWCOF{8,WB{{SAVE OFFSET TO O$GOF CALL{21217
{{MOV{21,=OGOF${8,WA{{POINT TO FAILURE GOTO CALL{21218
{{JSR{6,CDWRD{{{GENERATE{21219
{{MOV{21,=OFIF${8,WA{{POINT TO FAIL IN FAIL WORD{21220
{{JSR{6,CDWRD{{{GENERATE{21221
{{JSR{6,CDGCG{{{GENERATE CODE FOR FAILURE GOTO{21222
{{MOV{8,WB{8,WA{{COPY OFFSET TO O$GOF FOR CDFAL{21223
{{MOV{22,=B$CDC{8,WB{{SET COMPLEX CASE CDTYP{21224
{{BRN{6,CMP25{{{JUMP TO BUILD CDBLK{21225
*
*      HERE IF NO FAILURE GOTO GIVEN
*
{CMP23{MOV{21,=OUNF${8,WA{{LOAD UNEXPECTED FAILURE CALL IN CAS{21229
{{MOV{3,CSWFL{8,WC{{GET -NOFAIL FLAG{21230
{{ORB{13,CMCGO(XS){8,WC{{CHECK IF CONDITIONAL GOTO{21231
{{ZRB{8,WC{6,CMPSE{{JUMP IF -NOFAIL AND NO COND. GOTO{21232
{{MNZ{13,CMFFC(XS){{{ELSE SET FILL IN FLAG{21233
{{MOV{21,=OCER${8,WA{{AND SET COMPILE ERROR FOR TEMPORARY{21234
*
*      MERGE HERE WITH CDFAL VALUE IN WA, SIMPLE CDBLK
*      ALSO SPECIAL ENTRY AFTER STATEMENT ERROR
*
{CMPSE{MOV{22,=B$CDS{8,WB{{SET CDTYP FOR SIMPLE CASE{21239
{{EJC{{{{{21240
*
*      CMPIL (CONTINUED)
*
*      MERGE HERE TO BUILD CDBLK
*
*      (WA)                  CDFAL VALUE TO BE GENERATED
*      (WB)                  CDTYP VALUE TO BE GENERATED
*
*      AT THIS STAGE, WE CHOP OFF AN APPROPRIATE CHUNK OF THE
*      CURRENT CCBLK AND CONVERT IT INTO A CDBLK. THE REMAINDER
*      OF THE CCBLK IS REFORMATTED TO BE THE NEW CCBLK.
*
{CMP25{MOV{3,R$CCB{7,XR{{POINT TO CCBLK{21253
{{MOV{13,CMLBL(XS){7,XL{{GET POSSIBLE LABEL POINTER{21254
{{BZE{7,XL{6,CMP26{{SKIP IF NO LABEL{21255
{{ZER{13,CMLBL(XS){{{CLEAR FLAG FOR NEXT STATEMENT{21256
{{MOV{7,XR{13,VRLBL(XL){{PUT CDBLK PTR IN VRBLK LABEL FIELD{21257
*
*      MERGE AFTER DOING LABEL
*
{CMP26{MOV{8,WB{9,(XR){{SET TYPE WORD FOR NEW CDBLK{21261
{{MOV{8,WA{13,CDFAL(XR){{SET FAILURE WORD{21262
{{MOV{7,XR{7,XL{{COPY POINTER TO CCBLK{21263
{{MOV{13,CCUSE(XR){8,WB{{LOAD LENGTH GEN (= NEW CDLEN){21264
{{MOV{13,CCLEN(XR){8,WC{{LOAD TOTAL CCBLK LENGTH{21265
{{ADD{8,WB{7,XL{{POINT PAST CDBLK{21266
{{SUB{8,WB{8,WC{{GET LENGTH LEFT FOR CHOP OFF{21267
{{MOV{22,=B$CCT{9,(XL){{SET TYPE CODE FOR NEW CCBLK AT END{21268
{{MOV{19,*CCCOD{13,CCUSE(XL){{SET INITIAL CODE OFFSET{21269
{{MOV{19,*CCCOD{3,CWCOF{{REINITIALISE CWCOF{21270
{{MOV{8,WC{13,CCLEN(XL){{SET NEW LENGTH{21271
{{MOV{7,XL{3,R$CCB{{SET NEW CCBLK POINTER{21272
{{ZER{13,CCSLN(XL){{{INITIALIZE NEW LINE NUMBER{21274
{{MOV{3,CMPLN{13,CDSLN(XR){{SET LINE NUMBER IN OLD BLOCK{21275
{{MOV{3,CMPSN{13,CDSTM(XR){{SET STATEMENT NUMBER{21277
{{ICV{3,CMPSN{{{BUMP STATEMENT NUMBER{21278
*
*      SET POINTERS IN PREVIOUS CODE BLOCK AS REQUIRED
*
{{MOV{13,CMPCD(XS){7,XL{{LOAD PTR TO PREVIOUS CDBLK{21282
{{BZE{13,CMFFP(XS){6,CMP27{{JUMP IF NO FAILURE FILL IN REQUIRED{21283
{{MOV{7,XR{13,CDFAL(XL){{ELSE SET FAILURE PTR IN PREVIOUS{21284
*
*      HERE TO DEAL WITH SUCCESS FORWARD POINTER
*
{CMP27{MOV{13,CMSOP(XS){8,WA{{LOAD SUCCESS OFFSET{21288
{{BZE{8,WA{6,CMP28{{JUMP IF NO FILL IN REQUIRED{21289
{{ADD{8,WA{7,XL{{ELSE POINT TO FILL IN LOCATION{21290
{{MOV{7,XR{9,(XL){{STORE FORWARD POINTER{21291
{{ZER{7,XL{{{CLEAR GARBAGE XL VALUE{21292
{{EJC{{{{{21293
*
*      CMPIL (CONTINUED)
*
*      NOW SET FILL IN POINTERS FOR THIS STATEMENT
*
{CMP28{MOV{13,CMFFC(XS){13,CMFFP(XS){{COPY FAILURE FILL IN FLAG{21299
{{MOV{13,CMSOC(XS){13,CMSOP(XS){{COPY SUCCESS FILL IN OFFSET{21300
{{MOV{7,XR{13,CMPCD(XS){{SAVE PTR TO THIS CDBLK{21301
{{BNZ{13,CMTRA(XS){6,CMP29{{JUMP IF INITIAL ENTRY ALREADY SET{21302
{{MOV{7,XR{13,CMTRA(XS){{ELSE SET PTR HERE AS DEFAULT{21303
*
*      HERE AFTER COMPILING ONE STATEMENT
*
{CMP29{BLT{3,STAGE{18,=STGCE{6,CMP01{JUMP IF NOT END LINE JUST DONE{21307
{{BZE{3,CSWLS{6,CMP30{{SKIP IF -NOLIST{21308
{{JSR{6,LISTR{{{LIST LAST LINE{21309
*
*      RETURN
*
{CMP30{MOV{13,CMTRA(XS){7,XR{{LOAD INITIAL ENTRY CDBLK POINTER{21313
{{ADD{19,*CMNEN{7,XS{{POP WORK LOCATIONS OFF STACK{21314
{{EXI{{{{AND RETURN TO CMPIL CALLER{21315
*
*      HERE AT END OF GOTO FIELD
*
{CMP31{MOV{13,CMFGO(XS){8,WB{{GET FAIL GOTO{21319
{{ORB{13,CMSGO(XS){8,WB{{OR IN SUCCESS GOTO{21320
{{BNZ{8,WB{6,CMP18{{OK IF NON-NULL FIELD{21321
{{ERB{1,219{26,Syntax error: Empty goto field{{{21322
*
*      CONTROL CARD FOUND
*
{CMP32{ICV{8,WB{{{POINT PAST CH$MN{21326
{{JSR{6,CNCRD{{{PROCESS CONTROL CARD{21327
{{ZER{3,SCNSE{{{CLEAR START OF ELEMENT LOC.{21328
{{BRN{6,CMPCE{{{LOOP FOR NEXT STATEMENT{21329
{{ENP{{{{END PROCEDURE CMPIL{21330
{{EJC{{{{{21331
*
*      CNCRD -- CONTROL CARD PROCESSOR
*
*      CALLED TO DEAL WITH CONTROL CARDS
*
*      R$CIM                 POINTS TO CURRENT IMAGE
*      (WB)                  OFFSET TO 1ST CHAR OF CONTROL CARD
*      JSR  CNCRD            CALL TO PROCESS CONTROL CARDS
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{CNCRD{PRC{25,E{1,0{{ENTRY POINT{21342
{{MOV{8,WB{3,SCNPT{{OFFSET FOR CONTROL CARD SCAN{21343
{{MOV{18,=CCNOC{8,WA{{NUMBER OF CHARS FOR COMPARISON{21344
{{CTW{8,WA{1,0{{CONVERT TO WORD COUNT{21345
{{MOV{8,WA{3,CNSWC{{SAVE WORD COUNT{21346
*
*      LOOP HERE IF MORE THAN ONE CONTROL CARD
*
{CNC01{BGE{3,SCNPT{3,SCNIL{6,CNC09{RETURN IF END OF IMAGE{21350
{{MOV{3,R$CIM{7,XR{{POINT TO IMAGE{21351
{{PLC{7,XR{3,SCNPT{{CHAR PTR FOR FIRST CHAR{21352
{{LCH{8,WA{10,(XR)+{{GET FIRST CHAR{21353
{{FLC{8,WA{{{FOLD TO UPPER CASE{21355
{{BEQ{8,WA{18,=CH$LI{6,CNC07{SPECIAL CASE OF -INXXX{21357
{CNC0A{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21358
{{JSR{6,SCANE{{{SCAN CARD NAME{21359
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21360
{{BNZ{7,XL{6,CNC06{{FAIL UNLESS CONTROL CARD NAME{21361
{{MOV{18,=CCNOC{8,WA{{NO. OF CHARS TO BE COMPARED{21362
{{BLT{13,SCLEN(XR){8,WA{6,CNC08{FAIL IF TOO FEW CHARS{21364
{{MOV{7,XR{7,XL{{POINT TO CONTROL CARD NAME{21368
{{ZER{8,WB{{{ZERO OFFSET FOR SUBSTRING{21369
{{JSR{6,SBSTR{{{EXTRACT SUBSTRING FOR COMPARISON{21370
{{MOV{13,SCLEN(XR){8,WA{{RELOAD LENGTH{21372
{{JSR{6,FLSTG{{{FOLD TO UPPER CASE{21373
{{MOV{7,XR{3,CNSCC{{KEEP CONTROL CARD SUBSTRING PTR{21375
{{MOV{21,=CCNMS{7,XR{{POINT TO LIST OF STANDARD NAMES{21376
{{ZER{8,WB{{{INITIALISE NAME OFFSET{21377
{{LCT{8,WC{18,=CC$NC{{NUMBER OF STANDARD NAMES{21378
*
*      TRY TO MATCH NAME
*
{CNC02{MOV{3,CNSCC{7,XL{{POINT TO NAME{21382
{{LCT{8,WA{3,CNSWC{{COUNTER FOR INNER LOOP{21383
{{BRN{6,CNC04{{{JUMP INTO LOOP{21384
*
*      INNER LOOP TO MATCH CARD NAME CHARS
*
{CNC03{ICA{7,XR{{{BUMP STANDARD NAMES PTR{21388
{{ICA{7,XL{{{BUMP NAME POINTER{21389
*
*      HERE TO INITIATE THE LOOP
*
{CNC04{CNE{13,SCHAR(XL){9,(XR){6,CNC05{COMP. UP TO CFP$C CHARS AT ONCE{21393
{{BCT{8,WA{6,CNC03{{LOOP IF MORE WORDS TO COMPARE{21394
{{EJC{{{{{21395
*
*      CNCRD (CONTINUED)
*
*      MATCHED - BRANCH ON CARD OFFSET
*
{{MOV{8,WB{7,XL{{GET NAME OFFSET{21401
{{BSW{7,XL{2,CC$NC{6,CNC08{SWITCH{21403
{{IFF{2,CC$CA{6,CNC37{{-CASE{21442
{{IFF{2,CC$DO{6,CNC10{{-DOUBLE{21442
{{IFF{1,2{6,CNC08{{{21442
{{IFF{2,CC$DU{6,CNC11{{-DUMP{21442
{{IFF{2,CC$CP{6,CNC41{{-COPY{21442
{{IFF{2,CC$EJ{6,CNC12{{-EJECT{21442
{{IFF{2,CC$ER{6,CNC13{{-ERRORS{21442
{{IFF{2,CC$EX{6,CNC14{{-EXECUTE{21442
{{IFF{2,CC$FA{6,CNC15{{-FAIL{21442
{{IFF{2,CC$IN{6,CNC41{{-INCLUDE{21442
{{IFF{2,CC$LN{6,CNC44{{-LINE{21442
{{IFF{2,CC$LI{6,CNC16{{-LIST{21442
{{IFF{2,CC$NR{6,CNC17{{-NOERRORS{21442
{{IFF{2,CC$NX{6,CNC18{{-NOEXECUTE{21442
{{IFF{2,CC$NF{6,CNC19{{-NOFAIL{21442
{{IFF{2,CC$NL{6,CNC20{{-NOLIST{21442
{{IFF{2,CC$NO{6,CNC21{{-NOOPT{21442
{{IFF{2,CC$NP{6,CNC22{{-NOPRINT{21442
{{IFF{2,CC$OP{6,CNC24{{-OPTIMISE{21442
{{IFF{2,CC$PR{6,CNC25{{-PRINT{21442
{{IFF{2,CC$SI{6,CNC27{{-SINGLE{21442
{{IFF{2,CC$SP{6,CNC28{{-SPACE{21442
{{IFF{2,CC$ST{6,CNC31{{-STITLE{21442
{{IFF{2,CC$TI{6,CNC32{{-TITLE{21442
{{IFF{2,CC$TR{6,CNC36{{-TRACE{21442
{{ESW{{{{END SWITCH{21442
*
*      NOT MATCHED YET. ALIGN STD NAMES PTR AND TRY AGAIN
*
{CNC05{ICA{7,XR{{{BUMP STANDARD NAMES PTR{21446
{{BCT{8,WA{6,CNC05{{LOOP{21447
{{ICV{8,WB{{{BUMP NAMES OFFSET{21448
{{BCT{8,WC{6,CNC02{{CONTINUE IF MORE NAMES{21449
{{BRN{6,CNC08{{{IGNORE UNRECOGNIZED CONTROL CARD{21451
*
*      INVALID CONTROL CARD NAME
*
{CNC06{ERB{1,247{26,Invalid control statement{{{21456
*
*      SPECIAL PROCESSING FOR -INXXX
*
{CNC07{LCH{8,WA{10,(XR)+{{GET NEXT CHAR{21460
{{FLC{8,WA{{{FOLD TO UPPER CASE{21462
{{BNE{8,WA{18,=CH$LN{6,CNC0A{IF NOT LETTER N{21464
{{LCH{8,WA{9,(XR){{GET THIRD CHAR{21465
{{BLT{8,WA{18,=CH$D0{6,CNC0A{IF NOT DIGIT{21466
{{BGT{8,WA{18,=CH$D9{6,CNC0A{IF NOT DIGIT{21467
{{ADD{18,=NUM02{3,SCNPT{{BUMP OFFSET PAST -IN{21468
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -IN{21469
{{MOV{7,XR{11,-(XS){{STACK SCANNED ITEM{21470
{{JSR{6,GTSMI{{{CHECK IF INTEGER{21471
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21472
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{21473
{{MOV{7,XR{3,CSWIN{{KEEP INTEGER{21474
{{EJC{{{{{21475
*
*      CNCRD (CONTINUED)
*
*      CHECK FOR MORE CONTROL CARDS BEFORE RETURNING
*
{CNC08{MOV{3,SCNPT{8,WA{{PRESERVE IN CASE XEQ TIME COMPILE{21481
{{JSR{6,SCANE{{{LOOK FOR COMMA{21482
{{BEQ{7,XL{18,=T$CMA{6,CNC01{LOOP IF COMMA FOUND{21483
{{MOV{8,WA{3,SCNPT{{RESTORE SCNPT IN CASE XEQ TIME{21484
*
*      RETURN POINT
*
{CNC09{EXI{{{{RETURN{21488
*
*      -DOUBLE
*
{CNC10{MNZ{3,CSWDB{{{SET SWITCH{21492
{{BRN{6,CNC08{{{MERGE{21493
*
*      -DUMP
*      THIS IS USED FOR SYSTEM DEBUGGING . IT HAS THE EFFECT OF
*      PRODUCING A CORE DUMP AT COMPILATION TIME
*
{CNC11{JSR{6,SYSDM{{{CALL DUMPER{21499
{{BRN{6,CNC09{{{FINISHED{21500
*
*      -EJECT
*
{CNC12{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{21504
{{JSR{6,PRTPS{{{EJECT{21505
{{JSR{6,LISTT{{{LIST TITLE{21506
{{BRN{6,CNC09{{{FINISHED{21507
*
*      -ERRORS
*
{CNC13{ZER{3,CSWER{{{CLEAR SWITCH{21511
{{BRN{6,CNC08{{{MERGE{21512
*
*      -EXECUTE
*
{CNC14{ZER{3,CSWEX{{{CLEAR SWITCH{21516
{{BRN{6,CNC08{{{MERGE{21517
*
*      -FAIL
*
{CNC15{MNZ{3,CSWFL{{{SET SWITCH{21521
{{BRN{6,CNC08{{{MERGE{21522
*
*      -LIST
*
{CNC16{MNZ{3,CSWLS{{{SET SWITCH{21526
{{BEQ{3,STAGE{18,=STGIC{6,CNC08{DONE IF COMPILE TIME{21527
*
*      LIST CODE LINE IF EXECUTE TIME COMPILE
*
{{ZER{3,LSTPF{{{PERMIT LISTING{21531
{{JSR{6,LISTR{{{LIST LINE{21532
{{BRN{6,CNC08{{{MERGE{21533
{{EJC{{{{{21534
*
*      CNCRD (CONTINUED)
*
*      -NOERRORS
*
{CNC17{MNZ{3,CSWER{{{SET SWITCH{21540
{{BRN{6,CNC08{{{MERGE{21541
*
*      -NOEXECUTE
*
{CNC18{MNZ{3,CSWEX{{{SET SWITCH{21545
{{BRN{6,CNC08{{{MERGE{21546
*
*      -NOFAIL
*
{CNC19{ZER{3,CSWFL{{{CLEAR SWITCH{21550
{{BRN{6,CNC08{{{MERGE{21551
*
*      -NOLIST
*
{CNC20{ZER{3,CSWLS{{{CLEAR SWITCH{21555
{{BRN{6,CNC08{{{MERGE{21556
*
*      -NOOPTIMISE
*
{CNC21{MNZ{3,CSWNO{{{SET SWITCH{21560
{{BRN{6,CNC08{{{MERGE{21561
*
*      -NOPRINT
*
{CNC22{ZER{3,CSWPR{{{CLEAR SWITCH{21565
{{BRN{6,CNC08{{{MERGE{21566
*
*      -OPTIMISE
*
{CNC24{ZER{3,CSWNO{{{CLEAR SWITCH{21570
{{BRN{6,CNC08{{{MERGE{21571
*
*      -PRINT
*
{CNC25{MNZ{3,CSWPR{{{SET SWITCH{21575
{{BRN{6,CNC08{{{MERGE{21576
{{EJC{{{{{21577
*
*      CNCRD (CONTINUED)
*
*      -SINGLE
*
{CNC27{ZER{3,CSWDB{{{CLEAR SWITCH{21583
{{BRN{6,CNC08{{{MERGE{21584
*
*      -SPACE
*
{CNC28{BZE{3,CSWLS{6,CNC09{{RETURN IF -NOLIST{21588
{{JSR{6,SCANE{{{SCAN INTEGER AFTER -SPACE{21589
{{MOV{18,=NUM01{8,WC{{1 SPACE IN CASE{21590
{{BEQ{7,XR{18,=T$SMC{6,CNC29{JUMP IF NO INTEGER{21591
{{MOV{7,XR{11,-(XS){{STACK IT{21592
{{JSR{6,GTSMI{{{CHECK INTEGER{21593
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21594
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR LARGE{21595
{{BNZ{8,WC{6,CNC29{{JUMP IF NON ZERO{21596
{{MOV{18,=NUM01{8,WC{{ELSE 1 SPACE{21597
*
*      MERGE WITH COUNT OF LINES TO SKIP
*
{CNC29{ADD{8,WC{3,LSTLC{{BUMP LINE COUNT{21601
{{LCT{8,WC{8,WC{{CONVERT TO LOOP COUNTER{21602
{{BLT{3,LSTLC{3,LSTNP{6,CNC30{JUMP IF FITS ON PAGE{21603
{{JSR{6,PRTPS{{{EJECT{21604
{{JSR{6,LISTT{{{LIST TITLE{21605
{{BRN{6,CNC09{{{MERGE{21606
*
*      SKIP LINES
*
{CNC30{JSR{6,PRTNL{{{PRINT A BLANK{21610
{{BCT{8,WC{6,CNC30{{LOOP{21611
{{BRN{6,CNC09{{{MERGE{21612
{{EJC{{{{{21613
*
*      CNCRD (CONTINUED)
*
*      -STITL
*
{CNC31{MOV{20,=R$STL{3,CNR$T{{PTR TO R$STL{21619
{{BRN{6,CNC33{{{MERGE{21620
*
*      -TITLE
*
{CNC32{MOV{21,=NULLS{3,R$STL{{CLEAR SUBTITLE{21624
{{MOV{20,=R$TTL{3,CNR$T{{PTR TO R$TTL{21625
*
*      COMMON PROCESSING FOR -TITLE, -STITL
*
{CNC33{MOV{21,=NULLS{7,XR{{NULL IN CASE NEEDED{21629
{{MNZ{3,CNTTL{{{SET FLAG FOR NEXT LISTR CALL{21630
{{MOV{18,=CCOFS{8,WB{{OFFSET TO TITLE/SUBTITLE{21631
{{MOV{3,SCNIL{8,WA{{INPUT IMAGE LENGTH{21632
{{BLO{8,WA{8,WB{6,CNC34{JUMP IF NO CHARS LEFT{21633
{{SUB{8,WB{8,WA{{NO OF CHARS TO EXTRACT{21634
{{MOV{3,R$CIM{7,XL{{POINT TO IMAGE{21635
{{JSR{6,SBSTR{{{GET TITLE/SUBTITLE{21636
*
*      STORE TITLE/SUBTITLE
*
{CNC34{MOV{3,CNR$T{7,XL{{POINT TO STORAGE LOCATION{21640
{{MOV{7,XR{9,(XL){{STORE TITLE/SUBTITLE{21641
{{BEQ{7,XL{20,=R$STL{6,CNC09{RETURN IF STITL{21642
{{BNZ{3,PRECL{6,CNC09{{RETURN IF EXTENDED LISTING{21643
{{BZE{3,PRICH{6,CNC09{{RETURN IF REGULAR PRINTER{21644
{{MOV{13,SCLEN(XR){7,XL{{GET LENGTH OF TITLE{21645
{{MOV{7,XL{8,WA{{COPY IT{21646
{{BZE{7,XL{6,CNC35{{JUMP IF NULL{21647
{{ADD{18,=NUM10{7,XL{{INCREMENT{21648
{{BHI{7,XL{3,PRLEN{6,CNC09{USE DEFAULT LSTP0 VAL IF TOO LONG{21649
{{ADD{18,=NUM04{8,WA{{POINT JUST PAST TITLE{21650
*
*      STORE OFFSET TO PAGE NN MESSAGE FOR SHORT TITLE
*
{CNC35{MOV{8,WA{3,LSTPO{{STORE OFFSET{21654
{{BRN{6,CNC09{{{RETURN{21655
*
*      -TRACE
*      PROVIDED FOR SYSTEM DEBUGGING.  TOGGLES THE SYSTEM LABEL
*      TRACE SWITCH AT COMPILE TIME
*
{CNC36{JSR{6,SYSTT{{{TOGGLE SWITCH{21661
{{BRN{6,CNC08{{{MERGE{21662
*
*      -CASE
*      SETS VALUE OF KVCAS SO THAT NAMES ARE FOLDED OR NOT
*      DURING COMPILATION.
*
{CNC37{JSR{6,SCANE{{{SCAN INTEGER AFTER -CASE{21669
{{ZER{8,WC{{{GET 0 IN CASE NONE THERE{21670
{{BEQ{7,XL{18,=T$SMC{6,CNC38{SKIP IF NO INTEGER{21671
{{MOV{7,XR{11,-(XS){{STACK IT{21672
{{JSR{6,GTSMI{{{CHECK INTEGER{21673
{{PPM{6,CNC06{{{FAIL IF NOT INTEGER{21674
{{PPM{6,CNC06{{{FAIL IF NEGATIVE OR TOO LARGE{21675
{CNC38{MOV{8,WC{3,KVCAS{{STORE NEW CASE VALUE{21676
{{BRN{6,CNC09{{{MERGE{21677
*
*      -INCLUDE
*
{CNC41{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21700
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{21701
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21702
{{BNE{7,XL{18,=T$CON{6,CNC06{IF NOT CONSTANT{21703
{{BNE{9,(XR){22,=B$SCL{6,CNC06{IF NOT STRING CONSTANT{21704
{{MOV{7,XR{3,R$IFN{{SAVE FILE NAME{21705
{{MOV{3,R$INC{7,XL{{EXAMINE INCLUDE FILE NAME TABLE{21706
{{ZER{8,WB{{{LOOKUP BY VALUE{21707
{{JSR{6,TFIND{{{DO LOOKUP{21708
{{PPM{{{{NEVER FAILS{21709
{{BEQ{7,XR{21,=INTON{6,CNC09{IGNORE IF ALREADY IN TABLE{21710
{{MNZ{8,WB{{{SET FOR TRIM{21711
{{MOV{3,R$IFN{7,XR{{FILE NAME{21712
{{JSR{6,TRIMR{{{REMOVE TRAILING BLANKS{21713
{{MOV{3,R$INC{7,XL{{INCLUDE FILE NAME TABLE{21714
{{MNZ{8,WB{{{LOOKUP BY NAME THIS TIME{21715
{{JSR{6,TFIND{{{DO LOOKUP{21716
{{PPM{{{{NEVER FAILS{21717
{{MOV{21,=INTON{13,TEVAL(XL){{MAKE TABLE VALUE INTEGER 1{21718
{{ICV{3,CNIND{{{INCREASE NESTING LEVEL{21719
{{MOV{3,CNIND{8,WA{{LOAD NEW NEST LEVEL{21720
{{BGT{8,WA{18,=CCINM{6,CNC42{FAIL IF EXCESSIVE NESTING{21721
*
*      RECORD THE NAME AND LINE NUMBER OF THE CURRENT INPUT FILE
*
{{MOV{3,R$IFA{7,XL{{ARRAY OF NESTED FILE NAMES{21726
{{ADD{18,=VCVLB{8,WA{{COMPUTE OFFSET IN WORDS{21727
{{WTB{8,WA{{{CONVERT TO BYTES{21728
{{ADD{8,WA{7,XL{{POINT TO ELEMENT{21729
{{MOV{3,R$SFC{9,(XL){{RECORD CURRENT FILE NAME{21730
{{MOV{8,WA{7,XL{{PRESERVE NESTING BYTE OFFSET{21731
{{MTI{3,RDNLN{{{FETCH SOURCE LINE NUMBER AS INTEGER{21732
{{JSR{6,ICBLD{{{CONVERT TO ICBLK{21733
{{ADD{3,R$IFL{7,XL{{ENTRY IN NESTED LINE NUMBER ARRAY{21734
{{MOV{7,XR{9,(XL){{RECORD IN ARRAY{21735
*
*      HERE TO SWITCH TO INCLUDE FILE NAMED IN R$IFN
*
{{MOV{3,CSWIN{8,WA{{MAX READ LENGTH{21740
{{MOV{3,R$IFN{7,XL{{INCLUDE FILE NAME{21741
{{JSR{6,ALOCS{{{GET BUFFER FOR COMPLETE FILE NAME{21742
{{JSR{6,SYSIF{{{OPEN INCLUDE FILE{21743
{{PPM{6,CNC43{{{COULD NOT OPEN{21744
*
*      MAKE NOTE OF THE COMPLETE FILE NAME FOR ERROR MESSAGES
*
{{ZER{8,WB{{{DO NOT TRIM TRAILING BLANKS{21749
{{JSR{6,TRIMR{{{ADJUST SCBLK FOR ACTUAL LENGTH{21750
{{MOV{7,XR{3,R$SFC{{SAVE PTR TO FILE NAME{21751
{{MTI{3,CMPSN{{{CURRENT STATEMENT AS INTEGER{21752
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{21753
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{21754
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{21755
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{21756
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{21757
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{21758
{{ZER{3,RDNLN{{{RESTART LINE COUNTER FOR NEW FILE{21762
{{BEQ{3,STAGE{18,=STGIC{6,CNC09{IF INITIAL COMPILE{21763
{{BNE{3,CNIND{18,=NUM01{6,CNC09{IF NOT FIRST EXECUTE-TIME NESTING{21764
*
*      HERE FOR -INCLUDE DURING EXECUTE-TIME COMPILE
*
{{MOV{3,R$CIM{3,R$ICI{{REMEMBER CODE ARGUMENT STRING{21768
{{MOV{3,SCNPT{3,CNSPT{{SAVE POSITION IN STRING{21769
{{MOV{3,SCNIL{3,CNSIL{{AND LENGTH OF STRING{21770
{{BRN{6,CNC09{{{ALL DONE, MERGE{21771
*
*      HERE FOR EXCESSIVE INCLUDE FILE NESTING
*
{CNC42{ERB{1,284{26,Excessively nested INCLUDE files{{{21775
*
*      HERE IF INCLUDE FILE COULD NOT BE OPENED
*
{CNC43{MOV{7,XR{3,DNAMP{{RELEASE ALLOCATED SCBLK{21779
{{ERB{1,285{26,INCLUDE file cannot be opened{{{21780
*
*
*      -LINE N FILENAME
*
{CNC44{JSR{6,SCANE{{{SCAN INTEGER AFTER -LINE{21787
{{BNE{7,XL{18,=T$CON{6,CNC06{JUMP IF NO LINE NUMBER{21788
{{BNE{9,(XR){22,=B$ICL{6,CNC06{JUMP IF NOT INTEGER{21789
{{LDI{13,ICVAL(XR){{{FETCH INTEGER LINE NUMBER{21790
{{ILE{6,CNC06{{{ERROR IF NEGATIVE OR ZERO{21791
{{BEQ{3,STAGE{18,=STGIC{6,CNC45{SKIP IF INITIAL COMPILE{21792
{{MFI{3,CMPLN{{{SET DIRECTLY FOR OTHER COMPILES{21793
{{BRN{6,CNC46{{{NO NEED TO SET RDNLN{21794
{CNC45{SBI{4,INTV1{{{ADJUST NUMBER BY ONE{21795
{{MFI{3,RDNLN{{{SAVE LINE NUMBER{21796
{CNC46{MNZ{3,SCNCC{{{SET FLAG FOR SCANE{21798
{{JSR{6,SCANE{{{SCAN QUOTED FILE NAME{21799
{{ZER{3,SCNCC{{{CLEAR SCANE FLAG{21800
{{BEQ{7,XL{18,=T$SMC{6,CNC47{DONE IF NO FILE NAME{21801
{{BNE{7,XL{18,=T$CON{6,CNC06{ERROR IF NOT CONSTANT{21802
{{BNE{9,(XR){22,=B$SCL{6,CNC06{IF NOT STRING CONSTANT{21803
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{21804
{{BRN{6,CNC09{{{MERGE{21805
*
*      HERE IF FILE NAME NOT PRESENT
*
{CNC47{DCV{3,SCNPT{{{SET TO RESCAN THE TERMINATOR{21809
{{BRN{6,CNC09{{{MERGE{21810
{{ENP{{{{END PROCEDURE CNCRD{21815
{{EJC{{{{{21816
*
*      DFFNC -- DEFINE FUNCTION
*
*      DFFNC IS CALLED WHENEVER A NEW FUNCTION IS ASSIGNED TO
*      A VARIABLE. IT DEALS WITH EXTERNAL FUNCTION USE COUNTS.
*
*      (XR)                  POINTER TO VRBLK
*      (XL)                  POINTER TO NEW FUNCTION BLOCK
*      JSR  DFFNC            CALL TO DEFINE FUNCTION
*      (WA,WB)               DESTROYED
*
{DFFNC{PRC{25,E{1,0{{ENTRY POINT{21898
{{BNE{9,(XL){22,=B$EFC{6,DFFN1{SKIP IF NEW FUNCTION NOT EXTERNAL{21901
{{ICV{13,EFUSE(XL){{{ELSE INCREMENT ITS USE COUNT{21902
*
*      HERE AFTER DEALING WITH NEW FUNCTION USE COUNT
*
{DFFN1{MOV{7,XR{8,WA{{SAVE VRBLK POINTER{21906
{{MOV{13,VRFNC(XR){7,XR{{LOAD OLD FUNCTION POINTER{21907
{{BNE{9,(XR){22,=B$EFC{6,DFFN2{JUMP IF OLD FUNCTION NOT EXTERNAL{21908
{{MOV{13,EFUSE(XR){8,WB{{ELSE GET USE COUNT{21909
{{DCV{8,WB{{{DECREMENT{21910
{{MOV{8,WB{13,EFUSE(XR){{STORE DECREMENTED VALUE{21911
{{BNZ{8,WB{6,DFFN2{{JUMP IF USE COUNT STILL NON-ZERO{21912
{{JSR{6,SYSUL{{{ELSE CALL SYSTEM UNLOAD FUNCTION{21913
*
*      HERE AFTER DEALING WITH OLD FUNCTION USE COUNT
*
{DFFN2{MOV{8,WA{7,XR{{RESTORE VRBLK POINTER{21917
{{MOV{7,XL{8,WA{{COPY FUNCTION BLOCK PTR{21919
{{BLT{7,XR{20,=R$YYY{6,DFFN3{SKIP CHECKS IF OPSYN OP DEFINITION{21920
{{BNZ{13,VRLEN(XR){6,DFFN3{{JUMP IF NOT SYSTEM VARIABLE{21921
*
*      FOR SYSTEM VARIABLE, CHECK FOR ILLEGAL REDEFINITION
*
{{MOV{13,VRSVP(XR){7,XL{{POINT TO SVBLK{21925
{{MOV{13,SVBIT(XL){8,WB{{LOAD BIT INDICATORS{21926
{{ANB{4,BTFNC{8,WB{{IS IT A SYSTEM FUNCTION{21927
{{ZRB{8,WB{6,DFFN3{{REDEF OK IF NOT{21928
{{ERB{1,248{26,Attempted redefinition of system function{{{21929
*
*      HERE IF REDEFINITION IS PERMITTED
*
{DFFN3{MOV{8,WA{13,VRFNC(XR){{STORE NEW FUNCTION POINTER{21933
{{MOV{8,WA{7,XL{{RESTORE FUNCTION BLOCK POINTER{21934
{{EXI{{{{RETURN TO DFFNC CALLER{21935
{{ENP{{{{END PROCEDURE DFFNC{21936
{{EJC{{{{{21937
*
*      DTACH -- DETACH I/O ASSOCIATED NAMES
*
*      DETACHES TRBLKS FROM I/O ASSOCIATED VARIABLES, REMOVES
*      ENTRY FROM IOCHN CHAIN ATTACHED TO FILEARG1 VRBLK AND MAY
*      REMOVE VRBLK ACCESS AND STORE TRAPS.
*      INPUT, OUTPUT, TERMINAL ARE HANDLED SPECIALLY.
*
*      (XL)                  I/O ASSOC. VBL NAME BASE PTR
*      (WA)                  OFFSET TO NAME
*      JSR  DTACH            CALL FOR DETACH OPERATION
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{DTACH{PRC{25,E{1,0{{ENTRY POINT{21951
{{MOV{7,XL{3,DTCNB{{STORE NAME BASE (GBCOL NOT CALLED){21952
{{ADD{8,WA{7,XL{{POINT TO NAME LOCATION{21953
{{MOV{7,XL{3,DTCNM{{STORE IT{21954
*
*      LOOP TO SEARCH FOR I/O TRBLK
*
{DTCH1{MOV{7,XL{7,XR{{COPY NAME POINTER{21958
*
*      CONTINUE AFTER BLOCK DELETION
*
{DTCH2{MOV{9,(XL){7,XL{{POINT TO NEXT VALUE{21962
{{BNE{9,(XL){22,=B$TRT{6,DTCH6{JUMP AT CHAIN END{21963
{{MOV{13,TRTYP(XL){8,WA{{GET TRAP BLOCK TYPE{21964
{{BEQ{8,WA{18,=TRTIN{6,DTCH3{JUMP IF INPUT{21965
{{BEQ{8,WA{18,=TRTOU{6,DTCH3{JUMP IF OUTPUT{21966
{{ADD{19,*TRNXT{7,XL{{POINT TO NEXT LINK{21967
{{BRN{6,DTCH1{{{LOOP{21968
*
*      DELETE AN OLD ASSOCIATION
*
{DTCH3{MOV{13,TRVAL(XL){9,(XR){{DELETE TRBLK{21972
{{MOV{7,XL{8,WA{{DUMP XL ...{21973
{{MOV{7,XR{8,WB{{... AND XR{21974
{{MOV{13,TRTRF(XL){7,XL{{POINT TO TRTRF TRAP BLOCK{21975
{{BZE{7,XL{6,DTCH5{{JUMP IF NO IOCHN{21976
{{BNE{9,(XL){22,=B$TRT{6,DTCH5{JUMP IF INPUT, OUTPUT, TERMINAL{21977
*
*      LOOP TO SEARCH IOCHN CHAIN FOR NAME PTR
*
{DTCH4{MOV{7,XL{7,XR{{REMEMBER LINK PTR{21981
{{MOV{13,TRTRF(XL){7,XL{{POINT TO NEXT LINK{21982
{{BZE{7,XL{6,DTCH5{{JUMP IF END OF CHAIN{21983
{{MOV{13,IONMB(XL){8,WC{{GET NAME BASE{21984
{{ADD{13,IONMO(XL){8,WC{{ADD OFFSET{21985
{{BNE{8,WC{3,DTCNM{6,DTCH4{LOOP IF NO MATCH{21986
{{MOV{13,TRTRF(XL){13,TRTRF(XR){{REMOVE NAME FROM CHAIN{21987
{{EJC{{{{{21988
*
*      DTACH (CONTINUED)
*
*      PREPARE TO RESUME I/O TRBLK SCAN
*
{DTCH5{MOV{8,WA{7,XL{{RECOVER XL ...{21994
{{MOV{8,WB{7,XR{{... AND XR{21995
{{ADD{19,*TRVAL{7,XL{{POINT TO VALUE FIELD{21996
{{BRN{6,DTCH2{{{CONTINUE{21997
*
*      EXIT POINT
*
{DTCH6{MOV{3,DTCNB{7,XR{{POSSIBLE VRBLK PTR{22001
{{JSR{6,SETVR{{{RESET VRBLK IF NECESSARY{22002
{{EXI{{{{RETURN{22003
{{ENP{{{{END PROCEDURE DTACH{22004
{{EJC{{{{{22005
*
*      DTYPE -- GET DATATYPE NAME
*
*      (XR)                  OBJECT WHOSE DATATYPE IS REQUIRED
*      JSR  DTYPE            CALL TO GET DATATYPE
*      (XR)                  RESULT DATATYPE
*
{DTYPE{PRC{25,E{1,0{{ENTRY POINT{22013
{{BEQ{9,(XR){22,=B$PDT{6,DTYP1{JUMP IF PROG.DEFINED{22014
{{MOV{9,(XR){7,XR{{LOAD TYPE WORD{22015
{{LEI{7,XR{{{GET ENTRY POINT ID (BLOCK CODE){22016
{{WTB{7,XR{{{CONVERT TO BYTE OFFSET{22017
{{MOV{14,SCNMT(XR){7,XR{{LOAD TABLE ENTRY{22018
{{EXI{{{{EXIT TO DTYPE CALLER{22019
*
*      HERE IF PROGRAM DEFINED
*
{DTYP1{MOV{13,PDDFP(XR){7,XR{{POINT TO DFBLK{22023
{{MOV{13,DFNAM(XR){7,XR{{GET DATATYPE NAME FROM DFBLK{22024
{{EXI{{{{RETURN TO DTYPE CALLER{22025
{{ENP{{{{END PROCEDURE DTYPE{22026
{{EJC{{{{{22027
*
*      DUMPR -- PRINT DUMP OF STORAGE
*
*      (XR)                  DUMP ARGUMENT (SEE BELOW)
*      JSR  DUMPR            CALL TO PRINT DUMP
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      THE DUMP ARGUMENT HAS THE FOLLOWING SIGNIFICANCE
*
*      DMARG = 0             NO DUMP PRINTED
*      DMARG = 1             PARTIAL DUMP (NAT VARS, KEYWORDS)
*      DMARG = 2             FULL DUMP (ARRAYS, TABLES, ETC.)
*      DMARG = 3             FULL DUMP + NULL VARIABLES
*      DMARG GE 4            CORE DUMP
*
*      SINCE DUMPR SCRAMBLES STORE, IT IS NOT PERMISSIBLE TO
*      COLLECT IN MID-DUMP. HENCE A COLLECT IS DONE INITIALLY
*      AND THEN IF STORE RUNS OUT AN ERROR MESSAGE IS PRODUCED.
*
{DUMPR{PRC{25,E{1,0{{ENTRY POINT{22048
{{BZE{7,XR{6,DMP28{{SKIP DUMP IF ARGUMENT IS ZERO{22049
{{BGT{7,XR{18,=NUM03{6,DMP29{JUMP IF CORE DUMP REQUIRED{22050
{{ZER{7,XL{{{CLEAR XL{22051
{{ZER{8,WB{{{ZERO MOVE OFFSET{22052
{{MOV{7,XR{3,DMARG{{SAVE DUMP ARGUMENT{22053
{{JSR{6,GBCOL{{{COLLECT GARBAGE{22057
{{JSR{6,PRTPG{{{EJECT PRINTER{22058
{{MOV{21,=DMHDV{7,XR{{POINT TO HEADING FOR VARIABLES{22059
{{JSR{6,PRTST{{{PRINT IT{22060
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{22061
{{JSR{6,PRTNL{{{AND PRINT A BLANK LINE{22062
*
*      FIRST ALL NATURAL VARIABLE BLOCKS (VRBLK) WHOSE VALUES
*      ARE NON-NULL ARE LINKED IN LEXICAL ORDER USING DMVCH AS
*      THE CHAIN HEAD AND CHAINING THROUGH THE VRGET FIELDS.
*      NOTE THAT THIS SCRAMBLES STORE IF THE PROCESS IS
*      INTERRUPTED BEFORE COMPLETION E.G. BY EXCEEDING TIME  OR
*      PRINT LIMITS. SINCE THE SUBSEQUENT CORE DUMPS AND
*      FAILURES IF EXECUTION IS RESUMED ARE VERY CONFUSING, THE
*      EXECUTION TIME ERROR ROUTINE CHECKS FOR THIS EVENT AND
*      ATTEMPTS AN UNSCRAMBLE. SIMILAR PRECAUTIONS SHOULD BE
*      OBSERVED IF TRANSLATE TIME DUMPING IS IMPLEMENTED.
*
{{ZER{3,DMVCH{{{SET NULL CHAIN TO START{22075
{{MOV{3,HSHTB{8,WA{{POINT TO HASH TABLE{22076
*
*      LOOP THROUGH HEADERS IN HASH TABLE
*
{DMP00{MOV{8,WA{7,XR{{COPY HASH BUCKET POINTER{22080
{{ICA{8,WA{{{BUMP POINTER{22081
{{SUB{19,*VRNXT{7,XR{{SET OFFSET TO MERGE{22082
*
*      LOOP THROUGH VRBLKS ON ONE CHAIN
*
{DMP01{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON CHAIN{22086
{{BZE{7,XR{6,DMP09{{JUMP IF END OF THIS HASH CHAIN{22087
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK POINTER{22088
{{EJC{{{{{22089
*
*      DUMPR (CONTINUED)
*
*      LOOP TO FIND VALUE AND SKIP IF NULL
*
{DMP02{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE{22095
{{BEQ{3,DMARG{18,=NUM03{6,DMP2A{SKIP NULL VALUE CHECK IF DUMP(3){22096
{{BEQ{7,XL{21,=NULLS{6,DMP01{LOOP FOR NEXT VRBLK IF NULL VALUE{22097
{DMP2A{BEQ{9,(XL){22,=B$TRT{6,DMP02{LOOP BACK IF VALUE IS TRAPPED{22098
*
*      NON-NULL VALUE, PREPARE TO SEARCH CHAIN
*
{{MOV{7,XR{8,WC{{SAVE VRBLK POINTER{22102
{{ADD{19,*VRSOF{7,XR{{ADJUST PTR TO BE LIKE SCBLK PTR{22103
{{BNZ{13,SCLEN(XR){6,DMP03{{JUMP IF NON-SYSTEM VARIABLE{22104
{{MOV{13,VRSVO(XR){7,XR{{ELSE LOAD PTR TO NAME IN SVBLK{22105
*
*      HERE WITH NAME POINTER FOR NEW BLOCK IN XR
*
{DMP03{MOV{7,XR{8,WB{{SAVE POINTER TO CHARS{22109
{{MOV{8,WA{3,DMPSV{{SAVE HASH BUCKET POINTER{22110
{{MOV{20,=DMVCH{8,WA{{POINT TO CHAIN HEAD{22111
*
*      LOOP TO SEARCH CHAIN FOR CORRECT INSERTION POINT
*
{DMP04{MOV{8,WA{3,DMPCH{{SAVE CHAIN POINTER{22115
{{MOV{8,WA{7,XL{{COPY IT{22116
{{MOV{9,(XL){7,XR{{LOAD POINTER TO NEXT ENTRY{22117
{{BZE{7,XR{6,DMP08{{JUMP IF END OF CHAIN TO INSERT{22118
{{ADD{19,*VRSOF{7,XR{{ELSE GET NAME PTR FOR CHAINED VRBLK{22119
{{BNZ{13,SCLEN(XR){6,DMP05{{JUMP IF NOT SYSTEM VARIABLE{22120
{{MOV{13,VRSVO(XR){7,XR{{ELSE POINT TO NAME IN SVBLK{22121
*
*      HERE PREPARE TO COMPARE THE NAMES
*
*      (WA)                  SCRATCH
*      (WB)                  POINTER TO STRING OF ENTERING VRBLK
*      (WC)                  POINTER TO ENTERING VRBLK
*      (XR)                  POINTER TO STRING OF CURRENT BLOCK
*      (XL)                  SCRATCH
*
{DMP05{MOV{8,WB{7,XL{{POINT TO ENTERING VRBLK STRING{22131
{{MOV{13,SCLEN(XL){8,WA{{LOAD ITS LENGTH{22132
{{PLC{7,XL{{{POINT TO CHARS OF ENTERING STRING{22133
{{BHI{8,WA{13,SCLEN(XR){6,DMP06{JUMP IF ENTERING LENGTH HIGH{22156
{{PLC{7,XR{{{ELSE POINT TO CHARS OF OLD STRING{22157
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW IS LLT OLD{22158
{{BRN{6,DMP08{{{OR IF LEQ (WE HAD SHORTER LENGTH){22159
*
*      HERE WHEN NEW LENGTH IS LONGER THAN OLD LENGTH
*
{DMP06{MOV{13,SCLEN(XR){8,WA{{LOAD SHORTER LENGTH{22163
{{PLC{7,XR{{{POINT TO CHARS OF OLD STRING{22164
{{CMC{6,DMP08{6,DMP07{{COMPARE, INSERT IF NEW ONE LOW{22165
{{EJC{{{{{22166
*
*      DUMPR (CONTINUED)
*
*      HERE WE MOVE OUT ON THE CHAIN
*
{DMP07{MOV{3,DMPCH{7,XL{{COPY CHAIN POINTER{22172
{{MOV{9,(XL){8,WA{{MOVE TO NEXT ENTRY ON CHAIN{22174
{{BRN{6,DMP04{{{LOOP BACK{22175
*
*      HERE AFTER LOCATING THE PROPER INSERTION POINT
*
{DMP08{MOV{3,DMPCH{7,XL{{COPY CHAIN POINTER{22179
{{MOV{3,DMPSV{8,WA{{RESTORE HASH BUCKET POINTER{22180
{{MOV{8,WC{7,XR{{RESTORE VRBLK POINTER{22181
{{MOV{9,(XL){13,VRGET(XR){{LINK VRBLK TO REST OF CHAIN{22182
{{MOV{7,XR{9,(XL){{LINK VRBLK INTO CURRENT CHAIN LOC{22183
{{BRN{6,DMP01{{{LOOP BACK FOR NEXT VRBLK{22184
*
*      HERE AFTER PROCESSING ALL VRBLKS ON ONE CHAIN
*
{DMP09{BNE{8,WA{3,HSHTE{6,DMP00{LOOP BACK IF MORE BUCKETS TO GO{22188
*
*      LOOP TO GENERATE DUMP OF NATURAL VARIABLE VALUES
*
{DMP10{MOV{3,DMVCH{7,XR{{LOAD POINTER TO NEXT ENTRY ON CHAIN{22192
{{BZE{7,XR{6,DMP11{{JUMP IF END OF CHAIN{22193
{{MOV{9,(XR){3,DMVCH{{ELSE UPDATE CHAIN PTR TO NEXT ENTRY{22194
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{22195
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER (NAME BASE){22196
{{MOV{19,*VRVAL{8,WA{{SET OFFSET FOR VRBLK NAME{22197
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{22198
{{BRN{6,DMP10{{{LOOP BACK TILL ALL PRINTED{22199
*
*      PREPARE TO PRINT KEYWORDS
*
{DMP11{JSR{6,PRTNL{{{PRINT BLANK LINE{22203
{{JSR{6,PRTNL{{{AND ANOTHER{22204
{{MOV{21,=DMHDK{7,XR{{POINT TO KEYWORD HEADING{22205
{{JSR{6,PRTST{{{PRINT HEADING{22206
{{JSR{6,PRTNL{{{END LINE{22207
{{JSR{6,PRTNL{{{PRINT ONE BLANK LINE{22208
{{MOV{21,=VDMKW{7,XL{{POINT TO LIST OF KEYWORD SVBLK PTRS{22209
{{EJC{{{{{22210
*
*      DUMPR (CONTINUED)
*
*      LOOP TO DUMP KEYWORD VALUES
*
{DMP12{MOV{10,(XL)+{7,XR{{LOAD NEXT SVBLK PTR FROM TABLE{22216
{{BZE{7,XR{6,DMP13{{JUMP IF END OF LIST{22217
{{BEQ{7,XR{18,=NUM01{6,DMP12{&COMPARE IGNORED IF NOT IMPLEMENTED{22219
{{MOV{18,=CH$AM{8,WA{{LOAD AMPERSAND{22221
{{JSR{6,PRTCH{{{PRINT AMPERSAND{22222
{{JSR{6,PRTST{{{PRINT KEYWORD NAME{22223
{{MOV{13,SVLEN(XR){8,WA{{LOAD NAME LENGTH FROM SVBLK{22224
{{CTB{8,WA{2,SVCHS{{GET LENGTH OF NAME{22225
{{ADD{8,WA{7,XR{{POINT TO SVKNM FIELD{22226
{{MOV{9,(XR){3,DMPKN{{STORE IN DUMMY KVBLK{22227
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK-EQUAL-BLANK{22228
{{JSR{6,PRTST{{{PRINT IT{22229
{{MOV{7,XL{3,DMPSV{{SAVE TABLE POINTER{22230
{{MOV{20,=DMPKB{7,XL{{POINT TO DUMMY KVBLK{22231
{{MOV{22,=B$KVT{9,(XL){{BUILD TYPE WORD{22232
{{MOV{21,=TRBKV{13,KVVAR(XL){{BUILD PTR TO DUMMY TRACE BLOCK{22233
{{MOV{19,*KVVAR{8,WA{{SET ZERO OFFSET{22234
{{JSR{6,ACESS{{{GET KEYWORD VALUE{22235
{{PPM{{{{FAILURE IS IMPOSSIBLE{22236
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{22237
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{22238
{{MOV{3,DMPSV{7,XL{{RESTORE TABLE POINTER{22239
{{BRN{6,DMP12{{{LOOP BACK TILL ALL PRINTED{22240
*
*      HERE AFTER COMPLETING PARTIAL DUMP
*
{DMP13{BEQ{3,DMARG{18,=NUM01{6,DMP27{EXIT IF PARTIAL DUMP COMPLETE{22244
{{MOV{3,DNAMB{7,XR{{ELSE POINT TO FIRST DYNAMIC BLOCK{22245
*
*      LOOP THROUGH BLOCKS IN DYNAMIC STORAGE
*
{DMP14{BEQ{7,XR{3,DNAMP{6,DMP27{JUMP IF END OF USED REGION{22249
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF BLOCK{22250
{{BEQ{8,WA{22,=B$VCT{6,DMP16{JUMP IF VECTOR{22251
{{BEQ{8,WA{22,=B$ART{6,DMP17{JUMP IF ARRAY{22252
{{BEQ{8,WA{22,=B$PDT{6,DMP18{JUMP IF PROGRAM DEFINED{22253
{{BEQ{8,WA{22,=B$TBT{6,DMP19{JUMP IF TABLE{22254
*
*      MERGE HERE TO MOVE TO NEXT BLOCK
*
{DMP15{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{22262
{{ADD{8,WA{7,XR{{POINT PAST THIS BLOCK{22263
{{BRN{6,DMP14{{{LOOP BACK FOR NEXT BLOCK{22264
{{EJC{{{{{22265
*
*      DUMPR (CONTINUED)
*
*      HERE FOR VECTOR
*
{DMP16{MOV{19,*VCVLS{8,WB{{SET OFFSET TO FIRST VALUE{22271
{{BRN{6,DMP19{{{JUMP TO MERGE{22272
*
*      HERE FOR ARRAY
*
{DMP17{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO ARPRO FIELD{22276
{{ICA{8,WB{{{BUMP TO GET OFFSET TO VALUES{22277
{{BRN{6,DMP19{{{JUMP TO MERGE{22278
*
*      HERE FOR PROGRAM DEFINED
*
{DMP18{MOV{19,*PDFLD{8,WB{{POINT TO VALUES, MERGE{22282
*
*      HERE FOR TABLE (OTHERS MERGE)
*
{DMP19{BZE{13,IDVAL(XR){6,DMP15{{IGNORE BLOCK IF ZERO ID VALUE{22286
{{JSR{6,BLKLN{{{ELSE GET BLOCK LENGTH{22287
{{MOV{7,XR{7,XL{{COPY BLOCK POINTER{22288
{{MOV{8,WA{3,DMPSV{{SAVE LENGTH{22289
{{MOV{8,WB{8,WA{{COPY OFFSET TO FIRST VALUE{22290
{{JSR{6,PRTNL{{{PRINT BLANK LINE{22291
{{MOV{8,WA{3,DMPSA{{PRESERVE OFFSET{22292
{{JSR{6,PRTVL{{{PRINT BLOCK VALUE (FOR TITLE){22293
{{MOV{3,DMPSA{8,WA{{RECOVER OFFSET{22294
{{JSR{6,PRTNL{{{END PRINT LINE{22295
{{BEQ{9,(XR){22,=B$TBT{6,DMP22{JUMP IF TABLE{22296
{{DCA{8,WA{{{POINT BEFORE FIRST WORD{22297
*
*      LOOP TO PRINT CONTENTS OF ARRAY, VECTOR, OR PROGRAM DEF
*
{DMP20{MOV{7,XL{7,XR{{COPY BLOCK POINTER{22301
{{ICA{8,WA{{{BUMP OFFSET{22302
{{ADD{8,WA{7,XR{{POINT TO NEXT VALUE{22303
{{BEQ{8,WA{3,DMPSV{6,DMP14{EXIT IF END (XR PAST BLOCK){22304
{{SUB{19,*VRVAL{7,XR{{SUBTRACT OFFSET TO MERGE INTO LOOP{22305
*
*      LOOP TO FIND VALUE AND IGNORE NULLS
*
{DMP21{MOV{13,VRVAL(XR){7,XR{{LOAD NEXT VALUE{22309
{{BEQ{3,DMARG{18,=NUM03{6,DMP2B{SKIP NULL VALUE CHECK IF DUMP(3){22310
{{BEQ{7,XR{21,=NULLS{6,DMP20{LOOP BACK IF NULL VALUE{22311
{DMP2B{BEQ{9,(XR){22,=B$TRT{6,DMP21{LOOP BACK IF TRAPPED{22312
{{JSR{6,PRTNV{{{ELSE PRINT NAME = VALUE{22313
{{BRN{6,DMP20{{{LOOP BACK FOR NEXT FIELD{22314
{{EJC{{{{{22315
*
*      DUMPR (CONTINUED)
*
*      HERE TO DUMP A TABLE
*
{DMP22{MOV{19,*TBBUK{8,WC{{SET OFFSET TO FIRST BUCKET{22321
{{MOV{19,*TEVAL{8,WA{{SET NAME OFFSET FOR ALL TEBLKS{22322
*
*      LOOP THROUGH TABLE BUCKETS
*
{DMP23{MOV{7,XL{11,-(XS){{SAVE TBBLK POINTER{22326
{{ADD{8,WC{7,XL{{POINT TO NEXT BUCKET HEADER{22327
{{ICA{8,WC{{{BUMP BUCKET OFFSET{22328
{{SUB{19,*TENXT{7,XL{{SUBTRACT OFFSET TO MERGE INTO LOOP{22329
*
*      LOOP TO PROCESS TEBLKS ON ONE CHAIN
*
{DMP24{MOV{13,TENXT(XL){7,XL{{POINT TO NEXT TEBLK{22333
{{BEQ{7,XL{9,(XS){6,DMP26{JUMP IF END OF CHAIN{22334
{{MOV{7,XL{7,XR{{ELSE COPY TEBLK POINTER{22335
*
*      LOOP TO FIND VALUE AND IGNORE IF NULL
*
{DMP25{MOV{13,TEVAL(XR){7,XR{{LOAD NEXT VALUE{22339
{{BEQ{7,XR{21,=NULLS{6,DMP24{IGNORE IF NULL VALUE{22340
{{BEQ{9,(XR){22,=B$TRT{6,DMP25{LOOP BACK IF TRAPPED{22341
{{MOV{8,WC{3,DMPSV{{ELSE SAVE OFFSET POINTER{22342
{{JSR{6,PRTNV{{{PRINT NAME = VALUE{22343
{{MOV{3,DMPSV{8,WC{{RELOAD OFFSET{22344
{{BRN{6,DMP24{{{LOOP BACK FOR NEXT TEBLK{22345
*
*      HERE TO MOVE TO NEXT HASH CHAIN
*
{DMP26{MOV{10,(XS)+{7,XL{{RESTORE TBBLK POINTER{22349
{{BNE{8,WC{13,TBLEN(XL){6,DMP23{LOOP BACK IF MORE BUCKETS TO GO{22350
{{MOV{7,XL{7,XR{{ELSE COPY TABLE POINTER{22351
{{ADD{8,WC{7,XR{{POINT TO FOLLOWING BLOCK{22352
{{BRN{6,DMP14{{{LOOP BACK TO PROCESS NEXT BLOCK{22353
*
*      HERE AFTER COMPLETING DUMP
*
{DMP27{JSR{6,PRTPG{{{EJECT PRINTER{22357
*
*      MERGE HERE IF NO DUMP GIVEN (DMARG=0)
*
{DMP28{EXI{{{{RETURN TO DUMP CALLER{22361
*
*      CALL SYSTEM CORE DUMP ROUTINE
*
{DMP29{JSR{6,SYSDM{{{CALL IT{22365
{{BRN{6,DMP28{{{RETURN{22366
{{ENP{{{{END PROCEDURE DUMPR{22402
{{EJC{{{{{22403
*
*      ERMSG -- PRINT ERROR CODE AND ERROR MESSAGE
*
*      KVERT                 ERROR CODE
*      JSR  ERMSG            CALL TO PRINT MESSAGE
*      (XR,XL,WA,WB,WC,IA)   DESTROYED
*
{ERMSG{PRC{25,E{1,0{{ENTRY POINT{22411
{{MOV{3,KVERT{8,WA{{LOAD ERROR CODE{22412
{{MOV{21,=ERMMS{7,XR{{POINT TO ERROR MESSAGE /ERROR/{22413
{{JSR{6,PRTST{{{PRINT IT{22414
{{JSR{6,ERTEX{{{GET ERROR MESSAGE TEXT{22415
{{ADD{18,=THSND{8,WA{{BUMP ERROR CODE FOR PRINT{22416
{{MTI{8,WA{{{FAIL CODE IN INT ACC{22417
{{MOV{3,PROFS{8,WB{{SAVE CURRENT BUFFER POSITION{22418
{{JSR{6,PRTIN{{{PRINT CODE (NOW HAVE ERROR1XXX){22419
{{MOV{3,PRBUF{7,XL{{POINT TO PRINT BUFFER{22420
{{PSC{7,XL{8,WB{{POINT TO THE 1{22421
{{MOV{18,=CH$BL{8,WA{{LOAD A BLANK{22422
{{SCH{8,WA{9,(XL){{STORE BLANK OVER 1 (ERROR XXX){22423
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{22424
{{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{22425
{{MOV{7,XR{8,WA{{KEEP ERROR TEXT{22426
{{MOV{21,=ERMNS{7,XR{{POINT TO / -- /{22427
{{JSR{6,PRTST{{{PRINT IT{22428
{{MOV{8,WA{7,XR{{GET ERROR TEXT AGAIN{22429
{{JSR{6,PRTST{{{PRINT ERROR MESSAGE TEXT{22430
{{JSR{6,PRTIS{{{PRINT LINE{22431
{{JSR{6,PRTIS{{{PRINT BLANK LINE{22432
{{EXI{{{{RETURN TO ERMSG CALLER{22433
{{ENP{{{{END PROCEDURE ERMSG{22434
{{EJC{{{{{22435
*
*      ERTEX -- GET ERROR MESSAGE TEXT
*
*      (WA)                  ERROR CODE
*      JSR  ERTEX            CALL TO GET ERROR TEXT
*      (XR)                  PTR TO ERROR TEXT IN DYNAMIC
*      (R$ETX)               COPY OF PTR TO ERROR TEXT
*      (XL,WC,IA)            DESTROYED
*
{ERTEX{PRC{25,E{1,0{{ENTRY POINT{22445
{{MOV{8,WA{3,ERTWA{{SAVE WA{22446
{{MOV{8,WB{3,ERTWB{{SAVE WB{22447
{{JSR{6,SYSEM{{{GET FAILURE MESSAGE TEXT{22448
{{MOV{7,XR{7,XL{{COPY POINTER TO IT{22449
{{MOV{13,SCLEN(XR){8,WA{{GET LENGTH OF STRING{22450
{{BZE{8,WA{6,ERT02{{JUMP IF NULL{22451
{{ZER{8,WB{{{OFFSET OF ZERO{22452
{{JSR{6,SBSTR{{{COPY INTO DYNAMIC STORE{22453
{{MOV{7,XR{3,R$ETX{{STORE FOR RELOCATION{22454
*
*      RETURN
*
{ERT01{MOV{3,ERTWB{8,WB{{RESTORE WB{22458
{{MOV{3,ERTWA{8,WA{{RESTORE WA{22459
{{EXI{{{{RETURN TO CALLER{22460
*
*      RETURN ERRTEXT CONTENTS INSTEAD OF NULL
*
{ERT02{MOV{3,R$ETX{7,XR{{GET ERRTEXT{22464
{{BRN{6,ERT01{{{RETURN{22465
{{ENP{{{{{22466
{{EJC{{{{{22467
*
*      EVALI -- EVALUATE INTEGER ARGUMENT
*
*      EVALI IS USED BY PATTERN PRIMITIVES LEN,TAB,RTAB,POS,RPOS
*      WHEN THEIR ARGUMENT IS AN EXPRESSION VALUE.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALI            CALL TO EVALUATE INTEGER
*      PPM  LOC              TRANSFER LOC FOR NON-INTEGER ARG
*      PPM  LOC              TRANSFER LOC FOR OUT OF RANGE ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH INTEGER ARGUMENT
*      (WC,XL,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS THE INTEGER ARGUMENT
*      IN PARM1 AND THE PROPER SUCCESSOR POINTER IN PTHEN.
*      THIS ALLOWS MERGING WITH THE NORMAL (INTEGER ARG) CASE.
*
{EVALI{PRC{25,R{1,4{{ENTRY POINT (RECURSIVE){22489
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{22490
{{PPM{6,EVLI1{{{JUMP ON FAILURE{22491
{{MOV{7,XL{11,-(XS){{STACK RESULT FOR GTSMI{22492
{{MOV{13,PTHEN(XR){7,XL{{LOAD SUCCESSOR POINTER{22493
{{MOV{7,XR{3,EVLIO{{SAVE ORIGINAL NODE POINTER{22494
{{MOV{8,WC{3,EVLIF{{ZERO IF SIMPLE ARGUMENT{22495
{{JSR{6,GTSMI{{{CONVERT ARG TO SMALL INTEGER{22496
{{PPM{6,EVLI2{{{JUMP IF NOT INTEGER{22497
{{PPM{6,EVLI3{{{JUMP IF OUT OF RANGE{22498
{{MOV{7,XR{3,EVLIV{{STORE RESULT IN SPECIAL DUMMY NODE{22499
{{MOV{20,=EVLIN{7,XR{{POINT TO DUMMY NODE WITH RESULT{22500
{{MOV{22,=P$LEN{9,(XR){{DUMMY PATTERN BLOCK PCODE{22501
{{MOV{7,XL{13,PTHEN(XR){{STORE SUCCESSOR POINTER{22502
{{EXI{1,4{{{TAKE SUCCESSFUL EXIT{22503
*
*      HERE IF EVALUATION FAILS
*
{EVLI1{EXI{1,3{{{TAKE FAILURE RETURN{22507
*
*      HERE IF ARGUMENT IS NOT INTEGER
*
{EVLI2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{22511
*
*      HERE IF ARGUMENT IS OUT OF RANGE
*
{EVLI3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{22515
{{ENP{{{{END PROCEDURE EVALI{22516
{{EJC{{{{{22517
*
*      EVALP -- EVALUATE EXPRESSION DURING PATTERN MATCH
*
*      EVALP IS USED TO EVALUATE AN EXPRESSION (BY VALUE) DURING
*      A PATTERN MATCH. THE EFFECT IS LIKE EVALX, BUT PATTERN
*      VARIABLES ARE STACKED AND RESTORED IF NECESSARY.
*
*      EVALP ALSO DIFFERS FROM EVALX IN THAT IF THE RESULT IS
*      AN EXPRESSION IT IS REEVALUATED. THIS OCCURS REPEATEDLY.
*
*      TO SUPPORT OPTIMIZATION OF POS AND RPOS, EVALP USES WC
*      TO SIGNAL THE CALLER FOR THE CASE OF A SIMPLE VRBLK
*      THAT IS NOT AN EXPRESSION AND IS NOT TRAPPED.  BECAUSE
*      THIS CASE CANNOT HAVE ANY SIDE EFFECTS, OPTIMIZATION IS
*      POSSIBLE.
*
*      (XR)                  NODE POINTER
*      (WB)                  PATTERN MATCH CURSOR
*      JSR  EVALP            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XL)                  RESULT
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WC)                  ZERO IF SIMPLE VRBLK, ELSE NON-ZERO
*      (XR,WB)               DESTROYED (FAILURE CASE ONLY)
*      (RA)                  DESTROYED
*
*      THE EXPRESSION POINTER IS STORED IN PARM1 OF THE NODE
*
*      CONTROL RETURNS TO FAILP ON FAILURE OF EVALUATION
*
{EVALP{PRC{25,R{1,1{{ENTRY POINT (RECURSIVE){22548
{{MOV{13,PARM1(XR){7,XL{{LOAD EXPRESSION POINTER{22549
{{BEQ{9,(XL){22,=B$EXL{6,EVLP1{JUMP IF EXBLK CASE{22550
*
*      HERE FOR CASE OF SEBLK
*
*      WE CAN GIVE A FAST RETURN IF THE VALUE OF THE VRBLK IS
*      NOT AN EXPRESSION AND IS NOT TRAPPED.
*
{{MOV{13,SEVAR(XL){7,XL{{LOAD VRBLK POINTER{22557
{{MOV{13,VRVAL(XL){7,XL{{LOAD VALUE OF VRBLK{22558
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF VALUE{22559
{{BHI{8,WA{22,=B$T$${6,EVLP3{JUMP IF NOT SEBLK, TRBLK OR EXBLK{22560
*
*      HERE FOR EXBLK OR SEBLK WITH EXPR VALUE OR TRAPPED VALUE
*
{EVLP1{CHK{{{{CHECK FOR STACK SPACE{22564
{{MOV{7,XR{11,-(XS){{STACK NODE POINTER{22565
{{MOV{8,WB{11,-(XS){{STACK CURSOR{22566
{{MOV{3,R$PMS{11,-(XS){{STACK SUBJECT STRING POINTER{22567
{{MOV{3,PMSSL{11,-(XS){{STACK SUBJECT STRING LENGTH{22568
{{MOV{3,PMDFL{11,-(XS){{STACK DOT FLAG{22569
{{MOV{3,PMHBS{11,-(XS){{STACK HISTORY STACK BASE POINTER{22570
{{MOV{13,PARM1(XR){7,XR{{LOAD EXPRESSION POINTER{22571
{{EJC{{{{{22572
*
*      EVALP (CONTINUED)
*
*      LOOP BACK HERE TO REEVALUATE EXPRESSION RESULT
*
{EVLP2{ZER{8,WB{{{SET FLAG FOR BY VALUE{22578
{{JSR{6,EVALX{{{EVALUATE EXPRESSION{22579
{{PPM{6,EVLP4{{{JUMP ON FAILURE{22580
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF VALUE{22581
{{BLO{8,WA{22,=B$E$${6,EVLP2{LOOP BACK TO REEVALUATE EXPRESSION{22582
*
*      HERE TO RESTORE PATTERN VALUES AFTER SUCCESSFUL EVAL
*
{{MOV{7,XR{7,XL{{COPY RESULT POINTER{22586
{{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{22587
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{22588
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{22589
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{22590
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{22591
{{MOV{10,(XS)+{7,XR{{RESTORE NODE POINTER{22592
{{MOV{7,XR{8,WC{{NON-ZERO FOR SIMPLE VRBLK{22593
{{EXI{{{{RETURN TO EVALP CALLER{22594
*
*      HERE TO RETURN AFTER SIMPLE VRBLK CASE
*
{EVLP3{ZER{8,WC{{{SIMPLE VRBLK, NO SIDE EFFECTS{22598
{{EXI{{{{RETURN TO EVALP CALLER{22599
*
*      HERE FOR FAILURE DURING EVALUATION
*
{EVLP4{MOV{10,(XS)+{3,PMHBS{{RESTORE HISTORY STACK BASE POINTER{22603
{{MOV{10,(XS)+{3,PMDFL{{RESTORE DOT FLAG{22604
{{MOV{10,(XS)+{3,PMSSL{{RESTORE SUBJECT STRING LENGTH{22605
{{MOV{10,(XS)+{3,R$PMS{{RESTORE SUBJECT STRING POINTER{22606
{{ADD{19,*NUM02{7,XS{{REMOVE NODE PTR, CURSOR{22607
{{EXI{1,1{{{TAKE FAILURE EXIT{22608
{{ENP{{{{END PROCEDURE EVALP{22609
{{EJC{{{{{22610
*
*      EVALS -- EVALUATE STRING ARGUMENT
*
*      EVALS IS USED BY SPAN, ANY, NOTANY, BREAK, BREAKX WHEN
*      THEY ARE PASSED AN EXPRESSION ARGUMENT.
*
*      (XR)                  NODE POINTER
*      (WB)                  CURSOR
*      JSR  EVALS            CALL TO EVALUATE STRING
*      PPM  LOC              TRANSFER LOC FOR NON-STRING ARG
*      PPM  LOC              TRANSFER LOC FOR EVALUATION FAILURE
*      PPM  LOC              TRANSFER LOC FOR SUCCESSFUL EVAL
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XR)                  PTR TO NODE WITH PARMS SET
*      (XL,WC,RA)            DESTROYED
*
*      ON RETURN, THE NODE POINTED TO HAS A CHARACTER TABLE
*      POINTER IN PARM1 AND A BIT MASK IN PARM2. THE PROPER
*      SUCCESSOR IS STORED IN PTHEN OF THIS NODE. THUS IT IS
*      OK FOR MERGING WITH THE NORMAL (MULTI-CHAR STRING) CASE.
*
{EVALS{PRC{25,R{1,3{{ENTRY POINT (RECURSIVE){22632
{{JSR{6,EVALP{{{EVALUATE EXPRESSION{22633
{{PPM{6,EVLS1{{{JUMP IF EVALUATION FAILS{22634
{{MOV{13,PTHEN(XR){11,-(XS){{SAVE SUCCESSOR POINTER{22635
{{MOV{8,WB{11,-(XS){{SAVE CURSOR{22636
{{MOV{7,XL{11,-(XS){{STACK RESULT PTR FOR PATST{22637
{{ZER{8,WB{{{DUMMY PCODE FOR ONE CHAR STRING{22638
{{ZER{8,WC{{{DUMMY PCODE FOR EXPRESSION ARG{22639
{{MOV{22,=P$BRK{7,XL{{APPROPRIATE PCODE FOR OUR USE{22640
{{JSR{6,PATST{{{CALL ROUTINE TO BUILD NODE{22641
{{PPM{6,EVLS2{{{JUMP IF NOT STRING{22642
{{MOV{10,(XS)+{8,WB{{RESTORE CURSOR{22643
{{MOV{10,(XS)+{13,PTHEN(XR){{STORE SUCCESSOR POINTER{22644
{{EXI{1,3{{{TAKE SUCCESS RETURN{22645
*
*      HERE IF EVALUATION FAILS
*
{EVLS1{EXI{1,2{{{TAKE FAILURE RETURN{22649
*
*      HERE IF ARGUMENT IS NOT STRING
*
{EVLS2{ADD{19,*NUM02{7,XS{{POP SUCCESSOR AND CURSOR{22653
{{EXI{1,1{{{TAKE NON-STRING ERROR EXIT{22654
{{ENP{{{{END PROCEDURE EVALS{22655
{{EJC{{{{{22656
*
*      EVALX -- EVALUATE EXPRESSION
*
*      EVALX IS CALLED TO EVALUATE AN EXPRESSION
*
*      (XR)                  POINTER TO EXBLK OR SEBLK
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      JSR  EVALX            CALL TO EVALUATE EXPRESSION
*      PPM  LOC              TRANSFER LOC IF EVALUATION FAILS
*      (XR)                  RESULT IF CALLED BY VALUE
*      (XL,WA)               RESULT NAME BASE,OFFSET IF BY NAME
*      (XR)                  DESTROYED (NAME CASE ONLY)
*      (XL,WA)               DESTROYED (VALUE CASE ONLY)
*      (WB,WC,RA)            DESTROYED
*
{EVALX{PRC{25,R{1,1{{ENTRY POINT, RECURSIVE{22672
{{BEQ{9,(XR){22,=B$EXL{6,EVLX2{JUMP IF EXBLK CASE{22673
*
*      HERE FOR SEBLK
*
{{MOV{13,SEVAR(XR){7,XL{{LOAD VRBLK POINTER (NAME BASE){22677
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{22678
{{BNZ{8,WB{6,EVLX1{{JUMP IF CALLED BY NAME{22679
{{JSR{6,ACESS{{{CALL ROUTINE TO ACCESS VALUE{22680
{{PPM{6,EVLX9{{{JUMP IF FAILURE ON ACCESS{22681
*
*      MERGE HERE TO EXIT FOR SEBLK CASE
*
{EVLX1{EXI{{{{RETURN TO EVALX CALLER{22685
{{EJC{{{{{22686
*
*      EVALX (CONTINUED)
*
*      HERE FOR FULL EXPRESSION (EXBLK) CASE
*
*      IF AN ERROR OCCURS IN THE EXPRESSION CODE AT EXECUTION
*      TIME, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*      THE FOLLOWING ENTRIES ARE MADE ON THE STACK BEFORE
*      GIVING CONTROL TO THE EXPRESSION CODE
*
*                            EVALX RETURN POINT
*                            SAVED VALUE OF R$COD
*                            CODE POINTER (-R$COD)
*                            SAVED VALUE OF FLPTR
*                            0 IF BY VALUE, 1 IF BY NAME
*      FLPTR --------------- *EXFLC, FAIL OFFSET IN EXBLK
*
{EVLX2{SCP{8,WC{{{GET CODE POINTER{22705
{{MOV{3,R$COD{8,WA{{LOAD CODE BLOCK POINTER{22706
{{SUB{8,WA{8,WC{{GET CODE POINTER AS OFFSET{22707
{{MOV{8,WA{11,-(XS){{STACK OLD CODE BLOCK POINTER{22708
{{MOV{8,WC{11,-(XS){{STACK RELATIVE CODE OFFSET{22709
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{22710
{{MOV{8,WB{11,-(XS){{STACK NAME/VALUE INDICATOR{22711
{{MOV{19,*EXFLC{11,-(XS){{STACK NEW FAIL OFFSET{22712
{{MOV{3,FLPTR{3,GTCEF{{KEEP IN CASE OF ERROR{22713
{{MOV{3,R$COD{3,R$GTC{{KEEP CODE BLOCK POINTER SIMILARLY{22714
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{22715
{{MOV{7,XR{3,R$COD{{SET NEW CODE BLOCK POINTER{22716
{{MOV{3,KVSTN{13,EXSTM(XR){{REMEMBER STMNT NUMBER{22717
{{ADD{19,*EXCOD{7,XR{{POINT TO FIRST CODE WORD{22718
{{LCP{7,XR{{{SET CODE POINTER{22719
{{BNE{3,STAGE{18,=STGXT{6,EVLX0{JUMP IF NOT EXECUTION TIME{22720
{{MOV{18,=STGEE{3,STAGE{{EVALUATING EXPRESSION{22721
*
*      HERE TO EXECUTE FIRST CODE WORD OF EXPRESSION
*
{EVLX0{ZER{7,XL{{{CLEAR GARBAGE XL{22725
{{LCW{7,XR{{{LOAD FIRST CODE WORD{22726
{{BRI{9,(XR){{{EXECUTE IT{22727
{{EJC{{{{{22728
*
*      EVALX (CONTINUED)
*
*      COME HERE IF SUCCESSFUL RETURN BY VALUE (SEE O$RVL)
*
{EVLX3{MOV{10,(XS)+{7,XR{{LOAD VALUE{22734
{{BZE{12,1(XS){6,EVLX5{{JUMP IF CALLED BY VALUE{22735
{{ERB{1,249{26,Expression evaluated by name returned value{{{22736
*
*      HERE FOR EXPRESSION RETURNING BY NAME (SEE O$RNM)
*
{EVLX4{MOV{10,(XS)+{8,WA{{LOAD NAME OFFSET{22740
{{MOV{10,(XS)+{7,XL{{LOAD NAME BASE{22741
{{BNZ{12,1(XS){6,EVLX5{{JUMP IF CALLED BY NAME{22742
{{JSR{6,ACESS{{{ELSE ACCESS VALUE FIRST{22743
{{PPM{6,EVLX6{{{JUMP IF FAILURE DURING ACCESS{22744
*
*      HERE AFTER LOADING CORRECT RESULT INTO XR OR XL,WA
*
{EVLX5{ZER{8,WB{{{NOTE SUCCESSFUL{22748
{{BRN{6,EVLX7{{{MERGE{22749
*
*      HERE FOR FAILURE IN EXPRESSION EVALUATION (SEE O$FEX)
*
{EVLX6{MNZ{8,WB{{{NOTE UNSUCCESSFUL{22753
*
*      RESTORE ENVIRONMENT
*
{EVLX7{BNE{3,STAGE{18,=STGEE{6,EVLX8{SKIP IF WAS NOT PREVIOUSLY XT{22757
{{MOV{18,=STGXT{3,STAGE{{EXECUTE TIME{22758
*
*      MERGE WITH STAGE SET UP
*
{EVLX8{ADD{19,*NUM02{7,XS{{POP NAME/VALUE INDICATOR, *EXFAL{22762
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{22763
{{MOV{10,(XS)+{8,WC{{LOAD CODE OFFSET{22764
{{ADD{9,(XS){8,WC{{MAKE CODE POINTER ABSOLUTE{22765
{{MOV{10,(XS)+{3,R$COD{{RESTORE OLD CODE BLOCK POINTER{22766
{{LCP{8,WC{{{RESTORE OLD CODE POINTER{22767
{{BZE{8,WB{6,EVLX1{{JUMP FOR SUCCESSFUL RETURN{22768
*
*      MERGE HERE FOR FAILURE IN SEBLK CASE
*
{EVLX9{EXI{1,1{{{TAKE FAILURE EXIT{22772
{{ENP{{{{END OF PROCEDURE EVALX{22773
{{EJC{{{{{22774
*
*      EXBLD -- BUILD EXBLK
*
*      EXBLD IS USED TO BUILD AN EXPRESSION BLOCK FROM THE
*      CODE COMPILED MOST RECENTLY IN THE CURRENT CCBLK.
*
*      (XL)                  OFFSET IN CCBLK TO START OF CODE
*      (WB)                  INTEGER IN RANGE 0 LE N LE MXLEN
*      JSR  EXBLD            CALL TO BUILD EXBLK
*      (XR)                  PTR TO CONSTRUCTED EXBLK
*      (WA,WB,XL)            DESTROYED
*
{EXBLD{PRC{25,E{1,0{{ENTRY POINT{22787
{{MOV{7,XL{8,WA{{COPY OFFSET TO START OF CODE{22788
{{SUB{19,*EXCOD{8,WA{{CALC REDUCTION IN OFFSET IN EXBLK{22789
{{MOV{8,WA{11,-(XS){{STACK FOR LATER{22790
{{MOV{3,CWCOF{8,WA{{LOAD FINAL OFFSET{22791
{{SUB{7,XL{8,WA{{COMPUTE LENGTH OF CODE{22792
{{ADD{19,*EXSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{22793
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR EXBLK{22794
{{MOV{7,XR{11,-(XS){{SAVE POINTER TO EXBLK{22795
{{MOV{22,=B$EXL{13,EXTYP(XR){{STORE TYPE WORD{22796
{{ZER{13,EXSTM(XR){{{ZEROISE STMNT NUMBER FIELD{22797
{{MOV{3,CMPLN{13,EXSLN(XR){{SET LINE NUMBER FIELD{22799
{{MOV{8,WA{13,EXLEN(XR){{STORE LENGTH{22801
{{MOV{21,=OFEX${13,EXFLC(XR){{STORE FAILURE WORD{22802
{{ADD{19,*EXSI${7,XR{{SET XR FOR MVW{22803
{{MOV{7,XL{3,CWCOF{{RESET OFFSET TO START OF CODE{22804
{{ADD{3,R$CCB{7,XL{{POINT TO START OF CODE{22805
{{SUB{19,*EXSI${8,WA{{LENGTH OF CODE TO MOVE{22806
{{MOV{8,WA{11,-(XS){{STACK LENGTH OF CODE{22807
{{MVW{{{{MOVE CODE TO EXBLK{22808
{{MOV{10,(XS)+{8,WA{{GET LENGTH OF CODE{22809
{{BTW{8,WA{{{CONVERT BYTE COUNT TO WORD COUNT{22810
{{LCT{8,WA{8,WA{{PREPARE COUNTER FOR LOOP{22811
{{MOV{9,(XS){7,XL{{COPY EXBLK PTR, DONT UNSTACK{22812
{{ADD{19,*EXCOD{7,XL{{POINT TO CODE ITSELF{22813
{{MOV{12,1(XS){8,WB{{GET REDUCTION IN OFFSET{22814
*
*      THIS LOOP SEARCHES FOR NEGATION AND SELECTION CODE SO
*      THAT THE OFFSETS COMPUTED WHILST CODE WAS IN CODE BLOCK
*      CAN BE TRANSFORMED TO REDUCED VALUES APPLICABLE IN AN
*      EXBLK.
*
{EXBL1{MOV{10,(XL)+{7,XR{{GET NEXT CODE WORD{22821
{{BEQ{7,XR{21,=OSLA${6,EXBL3{JUMP IF SELECTION FOUND{22822
{{BEQ{7,XR{21,=ONTA${6,EXBL3{JUMP IF NEGATION FOUND{22823
{{BCT{8,WA{6,EXBL1{{LOOP TO END OF CODE{22824
*
*      NO SELECTION FOUND OR MERGE TO EXIT ON TERMINATION
*
{EXBL2{MOV{10,(XS)+{7,XR{{POP EXBLK PTR INTO XR{22828
{{MOV{10,(XS)+{7,XL{{POP REDUCTION CONSTANT{22829
{{EXI{{{{RETURN TO CALLER{22830
{{EJC{{{{{22831
*
*      EXBLD (CONTINUED)
*
*      SELECTION OR NEGATION FOUND
*      REDUCE THE OFFSETS AS NEEDED. OFFSETS OCCUR IN WORDS
*      FOLLOWING CODE WORDS -
*           =ONTA$, =OSLA$, =OSLB$, =OSLC$
*
{EXBL3{SUB{8,WB{10,(XL)+{{ADJUST OFFSET{22840
{{BCT{8,WA{6,EXBL4{{DECREMENT COUNT{22841
*
{EXBL4{BCT{8,WA{6,EXBL5{{DECREMENT COUNT{22843
*
*      CONTINUE SEARCH FOR MORE OFFSETS
*
{EXBL5{MOV{10,(XL)+{7,XR{{GET NEXT CODE WORD{22847
{{BEQ{7,XR{21,=OSLA${6,EXBL3{JUMP IF OFFSET FOUND{22848
{{BEQ{7,XR{21,=OSLB${6,EXBL3{JUMP IF OFFSET FOUND{22849
{{BEQ{7,XR{21,=OSLC${6,EXBL3{JUMP IF OFFSET FOUND{22850
{{BEQ{7,XR{21,=ONTA${6,EXBL3{JUMP IF OFFSET FOUND{22851
{{BCT{8,WA{6,EXBL5{{LOOP{22852
{{BRN{6,EXBL2{{{MERGE TO RETURN{22853
{{ENP{{{{END PROCEDURE EXBLD{22854
{{EJC{{{{{22855
*
*      EXPAN -- ANALYZE EXPRESSION
*
*      THE EXPRESSION ANALYZER (EXPAN) PROCEDURE IS USED TO SCAN
*      AN EXPRESSION AND CONVERT IT INTO A TREE REPRESENTATION.
*      SEE THE DESCRIPTION OF CMBLK IN THE STRUCTURES SECTION
*      FOR DETAILED FORMAT OF TREE BLOCKS.
*
*      THE ANALYZER USES A SIMPLE PRECEDENCE SCHEME IN WHICH
*      OPERANDS AND OPERATORS ARE PLACED ON A SINGLE STACK
*      AND CONDENSATIONS ARE MADE WHEN LOW PRECEDENCE OPERATORS
*      ARE STACKED AFTER A HIGHER PRECEDENCE OPERATOR. A GLOBAL
*      VARIABLE (IN WB) KEEPS TRACK OF THE LEVEL AS FOLLOWS.
*
*      0    SCANNING OUTER LEVEL OF STATEMENT OR EXPRESSION
*      1    SCANNING OUTER LEVEL OF NORMAL GOTO
*      2    SCANNING OUTER LEVEL OF DIRECT GOTO
*      3    SCANNING INSIDE ARRAY BRACKETS
*      4    SCANNING INSIDE GROUPING PARENTHESES
*      5    SCANNING INSIDE FUNCTION PARENTHESES
*
*      THIS VARIABLE IS SAVED ON THE STACK ON ENCOUNTERING A
*      GROUPING AND RESTORED AT THE END OF THE GROUPING.
*
*      ANOTHER GLOBAL VARIABLE (IN WC) COUNTS THE NUMBER OF
*      ITEMS AT ONE GROUPING LEVEL AND IS INCREMENTED FOR EACH
*      COMMA ENCOUNTERED. IT IS STACKED WITH THE LEVEL INDICATOR
*
*      THE SCAN IS CONTROLLED BY A THREE STATE FINITE MACHINE.
*      A GLOBAL VARIABLE STORED IN WA IS THE CURRENT STATE.
*
*      WA=0                  NOTHING SCANNED AT THIS LEVEL
*      WA=1                  OPERAND EXPECTED
*      WA=2                  OPERATOR EXPECTED
*
*      (WB)                  CALL TYPE (SEE BELOW)
*      JSR  EXPAN            CALL TO ANALYZE EXPRESSION
*      (XR)                  POINTER TO RESULTING TREE
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      THE ENTRY VALUE OF WB INDICATES THE CALL TYPE AS FOLLOWS.
*
*      0    SCANNING EITHER THE MAIN BODY OF A STATEMENT OR THE
*           TEXT OF AN EXPRESSION (FROM EVAL CALL). VALID
*           TERMINATORS ARE COLON, SEMICOLON. THE RESCAN FLAG IS
*           SET TO RETURN THE TERMINATOR ON THE NEXT SCANE CALL.
*
*      1    SCANNING A NORMAL GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT PAREN.
*
*      2    SCANNING A DIRECT GOTO. THE ONLY VALID
*           TERMINATOR IS A RIGHT BRACKET.
{{EJC{{{{{22908
*
*      EXPAN (CONTINUED)
*
*      ENTRY POINT
*
{EXPAN{PRC{25,E{1,0{{ENTRY POINT{22914
{{ZER{11,-(XS){{{SET TOP OF STACK INDICATOR{22915
{{ZER{8,WA{{{SET INITIAL STATE TO ZERO{22916
{{ZER{8,WC{{{ZERO COUNTER VALUE{22917
*
*      LOOP HERE FOR SUCCESSIVE ENTRIES
*
{EXP01{JSR{6,SCANE{{{SCAN NEXT ELEMENT{22921
{{ADD{8,WA{7,XL{{ADD STATE TO SYNTAX CODE{22922
{{BSW{7,XL{2,T$NES{{SWITCH ON ELEMENT TYPE/STATE{22923
{{IFF{2,T$UO0{6,EXP27{{UNOP, S=0{22960
{{IFF{2,T$UO1{6,EXP27{{UNOP, S=1{22960
{{IFF{2,T$UO2{6,EXP04{{UNOP, S=2{22960
{{IFF{2,T$LP0{6,EXP06{{LEFT PAREN, S=0{22960
{{IFF{2,T$LP1{6,EXP06{{LEFT PAREN, S=1{22960
{{IFF{2,T$LP2{6,EXP04{{LEFT PAREN, S=2{22960
{{IFF{2,T$LB0{6,EXP08{{LEFT BRKT, S=0{22960
{{IFF{2,T$LB1{6,EXP08{{LEFT BRKT, S=1{22960
{{IFF{2,T$LB2{6,EXP09{{LEFT BRKT, S=2{22960
{{IFF{2,T$CM0{6,EXP02{{COMMA, S=0{22960
{{IFF{2,T$CM1{6,EXP05{{COMMA, S=1{22960
{{IFF{2,T$CM2{6,EXP11{{COMMA, S=2{22960
{{IFF{2,T$FN0{6,EXP10{{FUNCTION, S=0{22960
{{IFF{2,T$FN1{6,EXP10{{FUNCTION, S=1{22960
{{IFF{2,T$FN2{6,EXP04{{FUNCTION, S=2{22960
{{IFF{2,T$VA0{6,EXP03{{VARIABLE, S=0{22960
{{IFF{2,T$VA1{6,EXP03{{VARIABLE, STATE ONE{22960
{{IFF{2,T$VA2{6,EXP04{{VARIABLE, S=2{22960
{{IFF{2,T$CO0{6,EXP03{{CONSTANT, S=0{22960
{{IFF{2,T$CO1{6,EXP03{{CONSTANT, S=1{22960
{{IFF{2,T$CO2{6,EXP04{{CONSTANT, S=2{22960
{{IFF{2,T$BO0{6,EXP05{{BINOP, S=0{22960
{{IFF{2,T$BO1{6,EXP05{{BINOP, S=1{22960
{{IFF{2,T$BO2{6,EXP26{{BINOP, S=2{22960
{{IFF{2,T$RP0{6,EXP02{{RIGHT PAREN, S=0{22960
{{IFF{2,T$RP1{6,EXP05{{RIGHT PAREN, S=1{22960
{{IFF{2,T$RP2{6,EXP12{{RIGHT PAREN, S=2{22960
{{IFF{2,T$RB0{6,EXP02{{RIGHT BRKT, S=0{22960
{{IFF{2,T$RB1{6,EXP05{{RIGHT BRKT, S=1{22960
{{IFF{2,T$RB2{6,EXP18{{RIGHT BRKT, S=2{22960
{{IFF{2,T$CL0{6,EXP02{{COLON, S=0{22960
{{IFF{2,T$CL1{6,EXP05{{COLON, S=1{22960
{{IFF{2,T$CL2{6,EXP19{{COLON, S=2{22960
{{IFF{2,T$SM0{6,EXP02{{SEMICOLON, S=0{22960
{{IFF{2,T$SM1{6,EXP05{{SEMICOLON, S=1{22960
{{IFF{2,T$SM2{6,EXP19{{SEMICOLON, S=2{22960
{{ESW{{{{END SWITCH ON ELEMENT TYPE/STATE{22960
{{EJC{{{{{22961
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RBR,RPR,COL,SMC,CMA IN STATE 0
*
*      SET TO RESCAN THE TERMINATOR ENCOUNTERED AND CREATE
*      A NULL CONSTANT (CASE OF OMITTED NULL)
*
{EXP02{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{22970
{{MOV{21,=NULLS{7,XR{{POINT TO NULL, MERGE{22971
*
*      HERE FOR VAR OR CON IN STATES 0,1
*
*      STACK THE VARIABLE/CONSTANT AND SET STATE=2
*
{EXP03{MOV{7,XR{11,-(XS){{STACK POINTER TO OPERAND{22977
{{MOV{18,=NUM02{8,WA{{SET STATE 2{22978
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{22979
*
*      HERE FOR VAR,CON,LPR,FNC,UOP IN STATE 2
*
*      WE RESCAN THE ELEMENT AND CREATE A CONCATENATION OPERATOR
*      THIS IS THE CASE OF THE BLANK CONCATENATION OPERATOR.
*
{EXP04{MNZ{3,SCNRS{{{SET TO RESCAN ELEMENT{22986
{{MOV{21,=OPDVC{7,XR{{POINT TO CONCAT OPERATOR DV{22987
{{BZE{8,WB{6,EXP4A{{OK IF AT TOP LEVEL{22988
{{MOV{21,=OPDVP{7,XR{{ELSE POINT TO UNMISTAKABLE CONCAT.{22989
*
*      MERGE HERE WHEN XR SET UP WITH PROPER CONCATENATION DVBLK
*
{EXP4A{BNZ{3,SCNBL{6,EXP26{{MERGE BOP IF BLANKS, ELSE ERROR{22993
*      DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{{ERB{1,220{26,Syntax error: Missing operator{{{22995
*
*      HERE FOR CMA,RPR,RBR,COL,SMC,BOP(S=1) BOP(S=0)
*
*      THIS IS AN ERRONOUS CONTRUCTION
*
*EXP05 DCV  SCNSE            ADJUST START OF ELEMENT LOCATION
{EXP05{ERB{1,221{26,Syntax error: Missing operand{{{23003
*
*      HERE FOR LPR (S=0,1)
*
{EXP06{MOV{18,=NUM04{7,XL{{SET NEW LEVEL INDICATOR{23007
{{ZER{7,XR{{{SET ZERO VALUE FOR CMOPN{23008
{{EJC{{{{{23009
*
*      EXPAN (CONTINUED)
*
*      MERGE HERE TO STORE OLD LEVEL ON STACK AND START NEW ONE
*
{EXP07{MOV{7,XR{11,-(XS){{STACK CMOPN VALUE{23015
{{MOV{8,WC{11,-(XS){{STACK OLD COUNTER{23016
{{MOV{8,WB{11,-(XS){{STACK OLD LEVEL INDICATOR{23017
{{CHK{{{{CHECK FOR STACK OVERFLOW{23018
{{ZER{8,WA{{{SET NEW STATE TO ZERO{23019
{{MOV{7,XL{8,WB{{SET NEW LEVEL INDICATOR{23020
{{MOV{18,=NUM01{8,WC{{INITIALIZE NEW COUNTER{23021
{{BRN{6,EXP01{{{JUMP TO SCAN NEXT ELEMENT{23022
*
*      HERE FOR LBR (S=0,1)
*
*      THIS IS AN ILLEGAL USE OF LEFT BRACKET
*
{EXP08{ERB{1,222{26,Syntax error: Invalid use of left bracket{{{23028
*
*      HERE FOR LBR (S=2)
*
*      SET NEW LEVEL AND START TO SCAN SUBSCRIPTS
*
{EXP09{MOV{10,(XS)+{7,XR{{LOAD ARRAY PTR FOR CMOPN{23034
{{MOV{18,=NUM03{7,XL{{SET NEW LEVEL INDICATOR{23035
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{23036
*
*      HERE FOR FNC (S=0,1)
*
*      STACK OLD LEVEL AND START TO SCAN ARGUMENTS
*
{EXP10{MOV{18,=NUM05{7,XL{{SET NEW LEV INDIC (XR=VRBLK=CMOPN){23042
{{BRN{6,EXP07{{{JUMP TO STACK OLD AND START NEW{23043
*
*      HERE FOR CMA (S=2)
*
*      INCREMENT ARGUMENT COUNT AND CONTINUE
*
{EXP11{ICV{8,WC{{{INCREMENT COUNTER{23049
{{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23050
{{ZER{11,-(XS){{{SET NEW LEVEL FOR PARAMETER{23051
{{ZER{8,WA{{{SET NEW STATE{23052
{{BGT{8,WB{18,=NUM02{6,EXP01{LOOP BACK UNLESS OUTER LEVEL{23053
{{ERB{1,223{26,Syntax error: Invalid use of comma{{{23054
{{EJC{{{{{23055
*
*      EXPAN (CONTINUED)
*
*      HERE FOR RPR (S=2)
*
*      AT OUTER LEVEL IN A NORMAL GOTO THIS IS A TERMINATOR
*      OTHERWISE IT MUST TERMINATE A FUNCTION OR GROUPING
*
{EXP12{BEQ{8,WB{18,=NUM01{6,EXP20{END OF NORMAL GOTO{23064
{{BEQ{8,WB{18,=NUM05{6,EXP13{END OF FUNCTION ARGUMENTS{23065
{{BEQ{8,WB{18,=NUM04{6,EXP14{END OF GROUPING / SELECTION{23066
{{ERB{1,224{26,Syntax error: Unbalanced right parenthesis{{{23067
*
*      HERE AT END OF FUNCTION ARGUMENTS
*
{EXP13{MOV{18,=C$FNC{7,XL{{SET CMTYP VALUE FOR FUNCTION{23071
{{BRN{6,EXP15{{{JUMP TO BUILD CMBLK{23072
*
*      HERE FOR END OF GROUPING
*
{EXP14{BEQ{8,WC{18,=NUM01{6,EXP17{JUMP IF END OF GROUPING{23076
{{MOV{18,=C$SEL{7,XL{{ELSE SET CMTYP FOR SELECTION{23077
*
*      MERGE HERE TO BUILD CMBLK FOR LEVEL JUST SCANNED AND
*      TO POP UP TO THE PREVIOUS SCAN LEVEL BEFORE CONTINUING.
*
{EXP15{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23082
{{MOV{8,WC{8,WA{{COPY COUNT{23083
{{ADD{18,=CMVLS{8,WA{{ADD FOR STANDARD FIELDS AT START{23084
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{23085
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23086
{{MOV{22,=B$CMT{9,(XR){{STORE TYPE CODE FOR CMBLK{23087
{{MOV{7,XL{13,CMTYP(XR){{STORE CMBLK NODE TYPE INDICATOR{23088
{{MOV{8,WA{13,CMLEN(XR){{STORE LENGTH{23089
{{ADD{8,WA{7,XR{{POINT PAST END OF BLOCK{23090
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{23091
*
*      LOOP TO MOVE REMAINING WORDS TO CMBLK
*
{EXP16{MOV{10,(XS)+{11,-(XR){{MOVE ONE OPERAND PTR FROM STACK{23095
{{MOV{10,(XS)+{8,WB{{POP TO OLD LEVEL INDICATOR{23096
{{BCT{8,WC{6,EXP16{{LOOP TILL ALL MOVED{23097
{{EJC{{{{{23098
*
*      EXPAN (CONTINUED)
*
*      COMPLETE CMBLK AND STACK POINTER TO IT ON STACK
*
{{SUB{19,*CMVLS{7,XR{{POINT BACK TO START OF BLOCK{23104
{{MOV{10,(XS)+{8,WC{{RESTORE OLD COUNTER{23105
{{MOV{9,(XS){13,CMOPN(XR){{STORE OPERAND PTR IN CMBLK{23106
{{MOV{7,XR{9,(XS){{STACK CMBLK POINTER{23107
{{MOV{18,=NUM02{8,WA{{SET NEW STATE{23108
{{BRN{6,EXP01{{{BACK FOR NEXT ELEMENT{23109
*
*      HERE AT END OF A PARENTHESIZED EXPRESSION
*
{EXP17{JSR{6,EXPDM{{{DUMP OPERATORS AT THIS LEVEL{23113
{{MOV{10,(XS)+{7,XR{{RESTORE XR{23114
{{MOV{10,(XS)+{8,WB{{RESTORE OUTER LEVEL{23115
{{MOV{10,(XS)+{8,WC{{RESTORE OUTER COUNT{23116
{{MOV{7,XR{9,(XS){{STORE OPND OVER UNUSED CMOPN VAL{23117
{{MOV{18,=NUM02{8,WA{{SET NEW STATE{23118
{{BRN{6,EXP01{{{BACK FOR NEXT ELE8ENT{23119
*
*      HERE FOR RBR (S=2)
*
*      AT OUTER LEVEL IN A DIRECT GOTO, THIS IS A TERMINATOR.
*      OTHERWISE IT MUST TERMINATE A SUBSCRIPT LIST.
*
{EXP18{MOV{18,=C$ARR{7,XL{{SET CMTYP FOR ARRAY REFERENCE{23126
{{BEQ{8,WB{18,=NUM03{6,EXP15{JUMP TO BUILD CMBLK IF END ARRAYREF{23127
{{BEQ{8,WB{18,=NUM02{6,EXP20{JUMP IF END OF DIRECT GOTO{23128
{{ERB{1,225{26,Syntax error: Unbalanced right bracket{{{23129
{{EJC{{{{{23130
*
*      EXPAN (CONTINUED)
*
*      HERE FOR COL,SMC (S=2)
*
*      ERROR UNLESS TERMINATING STATEMENT BODY AT OUTER LEVEL
*
{EXP19{MNZ{3,SCNRS{{{RESCAN TERMINATOR{23138
{{MOV{8,WB{7,XL{{COPY LEVEL INDICATOR{23139
{{BSW{7,XL{1,6{{SWITCH ON LEVEL INDICATOR{23140
{{IFF{1,0{6,EXP20{{NORMAL OUTER LEVEL{23147
{{IFF{1,1{6,EXP22{{FAIL IF NORMAL GOTO{23147
{{IFF{1,2{6,EXP23{{FAIL IF DIRECT GOTO{23147
{{IFF{1,3{6,EXP24{{FAIL ARRAY BRACKETS{23147
{{IFF{1,4{6,EXP21{{FAIL IF IN GROUPING{23147
{{IFF{1,5{6,EXP21{{FAIL FUNCTION ARGS{23147
{{ESW{{{{END SWITCH ON LEVEL{23147
*
*      HERE AT NORMAL END OF EXPRESSION
*
{EXP20{JSR{6,EXPDM{{{DUMP REMAINING OPERATORS{23151
{{MOV{10,(XS)+{7,XR{{LOAD TREE POINTER{23152
{{ICA{7,XS{{{POP OFF BOTTOM OF STACK MARKER{23153
{{EXI{{{{RETURN TO EXPAN CALLER{23154
*
*      MISSING RIGHT PAREN
*
{EXP21{ERB{1,226{26,Syntax error: Missing right paren{{{23158
*
*      MISSING RIGHT PAREN IN GOTO FIELD
*
{EXP22{ERB{1,227{26,Syntax error: Right paren missing from goto{{{23162
*
*      MISSING BRACKET IN GOTO
*
{EXP23{ERB{1,228{26,Syntax error: Right bracket missing from goto{{{23166
*
*      MISSING ARRAY BRACKET
*
{EXP24{ERB{1,229{26,Syntax error: Missing right array bracket{{{23170
{{EJC{{{{{23171
*
*      EXPAN (CONTINUED)
*
*      LOOP HERE WHEN AN OPERATOR CAUSES AN OPERATOR DUMP
*
{EXP25{MOV{7,XR{3,EXPSV{{{23177
{{JSR{6,EXPOP{{{POP ONE OPERATOR{23178
{{MOV{3,EXPSV{7,XR{{RESTORE OP DV POINTER AND MERGE{23179
*
*      HERE FOR BOP (S=2)
*
*      REMOVE OPERATORS (CONDENSE) FROM STACK UNTIL NO MORE
*      LEFT AT THIS LEVEL OR TOP ONE HAS LOWER PRECEDENCE.
*      LOOP HERE TILL THIS CONDITION IS MET.
*
{EXP26{MOV{12,1(XS){7,XL{{LOAD OPERATOR DVPTR FROM STACK{23187
{{BLE{7,XL{18,=NUM05{6,EXP27{JUMP IF BOTTOM OF STACK LEVEL{23188
{{BLT{13,DVRPR(XR){13,DVLPR(XL){6,EXP25{ELSE POP IF NEW PREC IS LO{23189
*
*      HERE FOR UOP (S=0,1)
*
*      BINARY OPERATOR MERGES AFTER PRECEDENCE CHECK
*
*      THE OPERATOR DV IS STORED ON THE STACK AND THE SCAN
*      CONTINUES AFTER SETTING THE SCAN STATE TO ONE.
*
{EXP27{MOV{7,XR{11,-(XS){{STACK OPERATOR DVPTR ON STACK{23198
{{CHK{{{{CHECK FOR STACK OVERFLOW{23199
{{MOV{18,=NUM01{8,WA{{SET NEW STATE{23200
{{BNE{7,XR{21,=OPDVS{6,EXP01{BACK FOR NEXT ELEMENT UNLESS ={23201
*
*      HERE FOR SPECIAL CASE OF BINARY =. THE SYNTAX ALLOWS A
*      NULL RIGHT ARGUMENT FOR THIS OPERATOR TO BE LEFT
*      OUT. ACCORDINGLY WE RESET TO STATE ZERO TO GET PROPER
*      ACTION ON A TERMINATOR (SUPPLY A NULL CONSTANT).
*
{{ZER{8,WA{{{SET STATE ZERO{23208
{{BRN{6,EXP01{{{JUMP FOR NEXT ELEMENT{23209
{{ENP{{{{END PROCEDURE EXPAN{23210
{{EJC{{{{{23211
*
*      EXPAP -- TEST FOR PATTERN MATCH TREE
*
*      EXPAP IS PASSED AN EXPRESSION TREE TO DETERMINE IF IT
*      IS A PATTERN MATCH. THE FOLLOWING ARE RECOGIZED AS
*      MATCHES IN THE CONTEXT OF THIS CALL.
*
*      1)   AN EXPLICIT USE OF BINARY QUESTION MARK
*      2)   A CONCATENATION
*      3)   AN ALTERNATION WHOSE LEFT OPERAND IS A CONCATENATION
*
*      (XR)                  PTR TO EXPAN TREE
*      JSR  EXPAP            CALL TO TEST FOR PATTERN MATCH
*      PPM  LOC              TRANSFER LOC IF NOT A PATTERN MATCH
*      (WA)                  DESTROYED
*      (XR)                  UNCHANGED (IF NOT MATCH)
*      (XR)                  PTR TO BINARY OPERATOR BLK IF MATCH
*
{EXPAP{PRC{25,E{1,1{{ENTRY POINT{23230
{{MOV{7,XL{11,-(XS){{SAVE XL{23231
{{BNE{9,(XR){22,=B$CMT{6,EXPP2{NO MATCH IF NOT COMPLEX{23232
{{MOV{13,CMTYP(XR){8,WA{{ELSE LOAD TYPE CODE{23233
{{BEQ{8,WA{18,=C$CNC{6,EXPP1{CONCATENATION IS A MATCH{23234
{{BEQ{8,WA{18,=C$PMT{6,EXPP1{BINARY QUESTION MARK IS A MATCH{23235
{{BNE{8,WA{18,=C$ALT{6,EXPP2{ELSE NOT MATCH UNLESS ALTERNATION{23236
*
*      HERE FOR ALTERNATION. CHANGE (A B) / C TO A QM (B / C)
*
{{MOV{13,CMLOP(XR){7,XL{{LOAD LEFT OPERAND POINTER{23240
{{BNE{9,(XL){22,=B$CMT{6,EXPP2{NOT MATCH IF LEFT OPND NOT COMPLEX{23241
{{BNE{13,CMTYP(XL){18,=C$CNC{6,EXPP2{NOT MATCH IF LEFT OP NOT CONC{23242
{{MOV{13,CMROP(XL){13,CMLOP(XR){{XR POINTS TO (B / C){23243
{{MOV{7,XR{13,CMROP(XL){{SET XL OPNDS TO A, (B / C){23244
{{MOV{7,XL{7,XR{{POINT TO THIS ALTERED NODE{23245
*
*      EXIT HERE FOR PATTERN MATCH
*
{EXPP1{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23249
{{EXI{{{{GIVE PATTERN MATCH RETURN{23250
*
*      EXIT HERE IF NOT PATTERN MATCH
*
{EXPP2{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23254
{{EXI{1,1{{{GIVE NON-MATCH RETURN{23255
{{ENP{{{{END PROCEDURE EXPAP{23256
{{EJC{{{{{23257
*
*      EXPDM -- DUMP OPERATORS AT CURRENT LEVEL (FOR EXPAN)
*
*      EXPDM USES EXPOP TO CONDENSE ALL OPERATORS AT THIS SYNTAX
*      LEVEL. THE STACK BOTTOM IS RECOGNIZED FROM THE LEVEL
*      VALUE WHICH IS SAVED ON THE TOP OF THE STACK.
*
*      JSR  EXPDM            CALL TO DUMP OPERATORS
*      (XS)                  POPPED AS REQUIRED
*      (XR,WA)               DESTROYED
*
{EXPDM{PRC{25,N{1,0{{ENTRY POINT{23269
{{MOV{7,XL{3,R$EXS{{SAVE XL VALUE{23270
*
*      LOOP TO DUMP OPERATORS
*
{EXDM1{BLE{12,1(XS){18,=NUM05{6,EXDM2{JUMP IF STACK BOTTOM (SAVED LEVEL{23274
{{JSR{6,EXPOP{{{ELSE POP ONE OPERATOR{23275
{{BRN{6,EXDM1{{{AND LOOP BACK{23276
*
*      HERE AFTER POPPING ALL OPERATORS
*
{EXDM2{MOV{3,R$EXS{7,XL{{RESTORE XL{23280
{{ZER{3,R$EXS{{{RELEASE SAVE LOCATION{23281
{{EXI{{{{RETURN TO EXPDM CALLER{23282
{{ENP{{{{END PROCEDURE EXPDM{23283
{{EJC{{{{{23284
*
*      EXPOP-- POP OPERATOR (FOR EXPAN)
*
*      EXPOP IS USED BY THE EXPAN ROUTINE TO CONDENSE ONE
*      OPERATOR FROM THE TOP OF THE SYNTAX STACK. AN APPROPRIATE
*      CMBLK IS BUILT FOR THE OPERATOR (UNARY OR BINARY) AND A
*      POINTER TO THIS CMBLK IS STACKED.
*
*      EXPOP IS ALSO USED BY SCNGF (GOTO FIELD SCAN) PROCEDURE
*
*      JSR  EXPOP            CALL TO POP OPERATOR
*      (XS)                  POPPED APPROPRIATELY
*      (XR,XL,WA)            DESTROYED
*
{EXPOP{PRC{25,N{1,0{{ENTRY POINT{23299
{{MOV{12,1(XS){7,XR{{LOAD OPERATOR DV POINTER{23300
{{BEQ{13,DVLPR(XR){18,=LLUNO{6,EXPO2{JUMP IF UNARY{23301
*
*      HERE FOR BINARY OPERATOR
*
{{MOV{19,*CMBS${8,WA{{SET SIZE OF BINARY OPERATOR CMBLK{23305
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23306
{{MOV{10,(XS)+{13,CMROP(XR){{POP AND STORE RIGHT OPERAND PTR{23307
{{MOV{10,(XS)+{7,XL{{POP AND LOAD OPERATOR DV PTR{23308
{{MOV{9,(XS){13,CMLOP(XR){{STORE LEFT OPERAND POINTER{23309
*
*      COMMON EXIT POINT
*
{EXPO1{MOV{22,=B$CMT{9,(XR){{STORE TYPE CODE FOR CMBLK{23313
{{MOV{13,DVTYP(XL){13,CMTYP(XR){{STORE CMBLK NODE TYPE CODE{23314
{{MOV{7,XL{13,CMOPN(XR){{STORE DVPTR (=PTR TO DAC O$XXX){23315
{{MOV{8,WA{13,CMLEN(XR){{STORE CMBLK LENGTH{23316
{{MOV{7,XR{9,(XS){{STORE RESULTING NODE PTR ON STACK{23317
{{EXI{{{{RETURN TO EXPOP CALLER{23318
*
*      HERE FOR UNARY OPERATOR
*
{EXPO2{MOV{19,*CMUS${8,WA{{SET SIZE OF UNARY OPERATOR CMBLK{23322
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR CMBLK{23323
{{MOV{10,(XS)+{13,CMROP(XR){{POP AND STORE OPERAND POINTER{23324
{{MOV{9,(XS){7,XL{{LOAD OPERATOR DV POINTER{23325
{{BRN{6,EXPO1{{{MERGE BACK TO EXIT{23326
{{ENP{{{{END PROCEDURE EXPOP{23327
{{EJC{{{{{23328
*
*      FILNM -- OBTAIN FILE NAME FROM STATEMENT NUMBER
*
*      FILNM TAKES A STATEMENT NUMBER AND EXAMINES THE FILE NAME
*      TABLE POINTED TO BY R$SFN TO FIND THE NAME OF THE FILE
*      CONTAINING THE GIVEN STATEMENT.  TABLE ENTRIES ARE
*      ARRANGED IN ORDER OF ASCENDING STATEMENT NUMBER (THERE
*      IS ONLY ONE HASH BUCKET IN THIS TABLE).  ELEMENTS ARE
*      ADDED TO THE TABLE EACH TIME THERE IS A CHANGE IN
*      FILE NAME, RECORDING THE THEN CURRENT STATEMENT NUMBER.
*
*      TO FIND THE FILE NAME, THE LINKED LIST OF TEBLKS IS
*      SCANNED FOR AN ELEMENT CONTAINING A SUBSCRIPT (STATEMENT
*      NUMBER) GREATER THAN THE ARGUMENT STATEMENT NUMBER, OR
*      THE END OF CHAIN.  WHEN THIS CONDITION IS MET, THE
*      PREVIOUS TEBLK CONTAINS THE DESIRED FILE NAME AS ITS
*      VALUE ENTRY.
*
*      (WC)                  STATEMENT NUMBER
*      JSR  FILNM            CALL TO OBTAIN FILE NAME
*      (XL)                  FILE NAME (SCBLK)
*      (IA)                  DESTROYED
*
{FILNM{PRC{25,E{1,0{{ENTRY POINT{23353
{{MOV{8,WB{11,-(XS){{PRESERVE WB{23354
{{BZE{8,WC{6,FILN3{{RETURN NULLS IF STNO IS ZERO{23355
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{23356
{{BZE{7,XL{6,FILN3{{IF NO TABLE{23357
{{MOV{13,TBBUK(XL){8,WB{{GET BUCKET ENTRY{23358
{{BEQ{8,WB{3,R$SFN{6,FILN3{JUMP IF NO TEBLKS ON CHAIN{23359
{{MOV{7,XR{11,-(XS){{PRESERVE XR{23360
{{MOV{8,WB{7,XR{{PREVIOUS BLOCK POINTER{23361
{{MOV{8,WC{11,-(XS){{PRESERVE STMT NUMBER{23362
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{FILN1{MOV{7,XR{7,XL{{NEXT ELEMENT TO EXAMINE{23366
{{MOV{13,TESUB(XL){7,XR{{LOAD SUBSCRIPT VALUE (AN ICBLK){23367
{{LDI{13,ICVAL(XR){{{LOAD THE STATEMENT NUMBER{23368
{{MFI{8,WC{{{CONVERT TO ADDRESS CONSTANT{23369
{{BLT{9,(XS){8,WC{6,FILN2{COMPARE ARG WITH TEBLK STMT NUMBER{23370
*
*      HERE IF DESIRED STMT NUMBER IS GE TEBLK STMT NUMBER
*
{{MOV{7,XL{8,WB{{SAVE PREVIOUS ENTRY POINTER{23374
{{MOV{13,TENXT(XL){7,XR{{POINT TO NEXT TEBLK ON CHAIN{23375
{{BNE{7,XR{3,R$SFN{6,FILN1{JUMP IF THERE IS ONE{23376
*
*      HERE IF CHAIN EXHAUSTED OR DESIRED BLOCK FOUND.
*
{FILN2{MOV{8,WB{7,XL{{PREVIOUS TEBLK{23380
{{MOV{13,TEVAL(XL){7,XL{{GET PTR TO FILE NAME SCBLK{23381
{{MOV{10,(XS)+{8,WC{{RESTORE STMT NUMBER{23382
{{MOV{10,(XS)+{7,XR{{RESTORE XR{23383
{{MOV{10,(XS)+{8,WB{{RESTORE WB{23384
{{EXI{{{{{23385
*
*      NO TABLE OR NO TABLE ENTRIES
*
{FILN3{MOV{10,(XS)+{8,WB{{RESTORE WB{23389
{{MOV{21,=NULLS{7,XL{{RETURN NULL STRING{23390
{{EXI{{{{{23391
{{ENP{{{{{23392
{{EJC{{{{{23393
*
*
*      FLSTG -- FOLD STRING TO UPPER CASE
*
*      FLSTG FOLDS A CHARACTER STRING CONTAINING LOWER CASE
*      CHARACCTERS TO ONE CONTAINING UPPER CASE CHARACTERS.
*      FOLDING IS ONLY DONE IF &CASE (KVCAS) IS NOT ZERO.
*
*      (XR)                  STRING ARGUMENT
*      (WA)                  LENGTH OF STRING
*      JSR  FLSTG            CALL TO FOLD STRING
*      (XR)                  RESULT STRING (POSSIBLY ORIGINAL)
*      (WC)                  DESTROYED
*
{FLSTG{PRC{25,E{1,0{{ENTRY POINT{23410
{{BZE{3,KVCAS{6,FST99{{SKIP IF &CASE IS 0{23411
{{MOV{7,XL{11,-(XS){{SAVE XL ACROSS CALL{23412
{{MOV{7,XR{11,-(XS){{SAVE ORIGINAL SCBLK PTR{23413
{{JSR{6,ALOCS{{{ALLOCATE NEW STRING BLOCK{23414
{{MOV{9,(XS){7,XL{{POINT TO ORIGINAL SCBLK{23415
{{MOV{7,XR{11,-(XS){{SAVE POINTER TO NEW SCBLK{23416
{{PLC{7,XL{{{POINT TO ORIGINAL CHARS{23417
{{PSC{7,XR{{{POINT TO NEW CHARS{23418
{{ZER{11,-(XS){{{INIT DID FOLD FLAG{23419
{{LCT{8,WC{8,WC{{LOAD LOOP COUNTER{23420
{FST01{LCH{8,WA{10,(XL)+{{LOAD CHARACTER{23421
{{BLT{8,WA{18,=CH$$A{6,FST02{SKIP IF LESS THAN LC A{23422
{{BGT{8,WA{18,=CH$$${6,FST02{SKIP IF GREATER THAN LC Z{23423
{{FLC{8,WA{{{FOLD CHARACTER TO UPPER CASE{23424
{{MNZ{9,(XS){{{SET DID FOLD CHARACTER FLAG{23425
{FST02{SCH{8,WA{10,(XR)+{{STORE (POSSIBLY FOLDED) CHARACTER{23426
{{BCT{8,WC{6,FST01{{LOOP THRU ENTIRE STRING{23427
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{23428
{{MOV{10,(XS)+{7,XR{{SEE IF ANY CHANGE{23429
{{BNZ{7,XR{6,FST10{{SKIP IF FOLDING DONE (NO CHANGE){23430
{{MOV{10,(XS)+{3,DNAMP{{DO NOT NEED NEW SCBLK{23431
{{MOV{10,(XS)+{7,XR{{RETURN ORIGINAL SCBLK{23432
{{BRN{6,FST20{{{MERGE BELOW{23433
{FST10{MOV{10,(XS)+{7,XR{{RETURN NEW SCBLK{23434
{{ICA{7,XS{{{THROW AWAY ORIGINAL SCBLK POINTER{23435
{FST20{MOV{13,SCLEN(XR){8,WA{{RELOAD STRING LENGTH{23436
{{MOV{10,(XS)+{7,XL{{RESTORE XL{23437
{FST99{EXI{{{{RETURN{23438
{{ENP{{{{{23439
{{EJC{{{{{23440
*
*      GBCOL -- PERFORM GARBAGE COLLECTION
*
*      GBCOL PERFORMS A GARBAGE COLLECTION ON THE DYNAMIC REGION
*      ALL BLOCKS WHICH ARE NO LONGER IN USE ARE ELIMINATED
*      BY MOVING BLOCKS WHICH ARE IN USE DOWN AND RESETTING
*      DNAMP, THE POINTER TO THE NEXT AVAILABLE LOCATION.
*
*      (WB)                  MOVE OFFSET (SEE BELOW)
*      JSR  GBCOL            CALL TO COLLECT GARBAGE
*      (XR)                  DESTROYED
*
*      THE FOLLOWING CONDITIONS MUST BE MET AT THE TIME WHEN
*      GBCOL IS CALLED.
*
*      1)   ALL POINTERS TO BLOCKS IN THE DYNAMIC AREA MUST BE
*           ACCESSIBLE TO THE GARBAGE COLLECTOR. THIS MEANS
*           THAT THEY MUST OCCUR IN ONE OF THE FOLLOWING.
*
*           A)               MAIN STACK, WITH CURRENT TOP
*                            ELEMENT BEING INDICATED BY XS
*
*           B)               IN RELOCATABLE FIELDS OF VRBLKS.
*
*           C)               IN REGISTER XL AT THE TIME OF CALL
*
*           E)               IN THE SPECIAL REGION OF WORKING
*                            STORAGE WHERE NAMES BEGIN WITH R$.
*
*      2)   ALL POINTERS MUST POINT TO THE START OF BLOCKS WITH
*           THE SOLE EXCEPTION OF THE CONTENTS OF THE CODE
*           POINTER REGISTER WHICH POINTS INTO THE R$COD BLOCK.
*
*      3)   NO LOCATION WHICH APPEARS TO CONTAIN A POINTER
*           INTO THE DYNAMIC REGION MAY OCCUR UNLESS IT IS IN
*           FACT A POINTER TO THE START OF THE BLOCK. HOWEVER
*           POINTERS OUTSIDE THIS AREA MAY OCCUR AND WILL
*           NOT BE CHANGED BY THE GARBAGE COLLECTOR.
*           IT IS ESPECIALLY IMPORTANT TO MAKE SURE THAT XL
*           DOES NOT CONTAIN A GARBAGE VALUE FROM SOME PROCESS
*           CARRIED OUT BEFORE THE CALL TO THE COLLECTOR.
*
*      GBCOL HAS THE CAPABILITY OF MOVING THE FINAL COMPACTED
*      RESULT UP IN MEMORY (WITH ADDRESSES ADJUSTED ACCORDINGLY)
*      THIS IS USED TO ADD SPACE TO THE STATIC REGION. THE
*      ENTRY VALUE OF WB IS THE NUMBER OF BYTES TO MOVE UP.
*      THE CALLER MUST GUARANTEE THAT THERE IS ENOUGH ROOM.
*      FURTHERMORE THE VALUE IN WB IF IT IS NON-ZERO, MUST BE AT
*      LEAST 256 SO THAT THE MWB INSTRUCTION CONDITIONS ARE MET.
{{EJC{{{{{23495
*
*      GBCOL (CONTINUED)
*
*      THE ALGORITHM, WHICH IS A MODIFICATION OF THE LISP-2
*      GARBAGE COLLECTOR DEVISED BY R.DEWAR AND K.BELCHER
*      TAKES THREE PASSES AS FOLLOWS.
*
*      1)   ALL POINTERS IN MEMORY ARE SCANNED AND BLOCKS IN USE
*           DETERMINED FROM THIS SCAN. NOTE THAT THIS PROCEDURE
*           IS RECURSIVE AND USES THE MAIN STACK FOR LINKAGE.
*           THE MARKING PROCESS IS THUS SIMILAR TO THAT USED IN
*           A STANDARD LISP COLLECTOR. HOWEVER THE METHOD OF
*           ACTUALLY MARKING THE BLOCKS IS DIFFERENT.
*
*           THE FIRST FIELD OF A BLOCK NORMALLY CONTAINS A
*           CODE ENTRY POINT POINTER. SUCH AN ENTRY POINTER
*           CAN BE DISTINGUISHED FROM THE ADDRESS OF ANY POINTER
*           TO BE PROCESSED BY THE COLLECTOR. DURING GARBAGE
*           COLLECTION, THIS WORD IS USED TO BUILD A BACK CHAIN
*           OF POINTERS THROUGH FIELDS WHICH POINT TO THE BLOCK.
*           THE END OF THE CHAIN IS MARKED BY THE OCCURENCE
*           OF THE WORD WHICH USED TO BE IN THE FIRST WORD OF
*           THE BLOCK. THIS BACKCHAIN SERVES BOTH AS A MARK
*           INDICATING THAT THE BLOCK IS IN USE AND AS A LIST OF
*           REFERENCES FOR THE RELOCATION PHASE.
*
*      2)   STORAGE IS SCANNED SEQUENTIALLY TO DISCOVER WHICH
*           BLOCKS ARE CURRENTLY IN USE AS INDICATED BY THE
*           PRESENCE OF A BACKCHAIN. TWO POINTERS ARE MAINTAINED
*           ONE SCANS THROUGH LOOKING AT EACH BLOCK. THE OTHER
*           IS INCREMENTED ONLY FOR BLOCKS FOUND TO BE IN USE.
*           IN THIS WAY, THE EVENTUAL LOCATION OF EACH BLOCK CAN
*           BE DETERMINED WITHOUT ACTUALLY MOVING ANY BLOCKS.
*           AS EACH BLOCK WHICH IS IN USE IS PROCESSED, THE BACK
*           CHAIN IS USED TO RESET ALL POINTERS WHICH POINT TO
*           THIS BLOCK TO CONTAIN ITS NEW ADDRESS, I.E. THE
*           ADDRESS IT WILL OCCUPY AFTER THE BLOCKS ARE MOVED.
*           THE FIRST WORD OF THE BLOCK, TAKEN FROM THE END OF
*           THE CHAIN IS RESTORED AT THIS POINT.
*
*           DURING PASS 2, THE COLLECTOR BUILDS BLOCKS WHICH
*           DESCRIBE THE REGIONS OF STORAGE WHICH ARE TO BE
*           MOVED IN THE THIRD PASS. THERE IS ONE DESCRIPTOR FOR
*           EACH CONTIGUOUS SET OF GOOD BLOCKS. THE DESCRIPTOR
*           IS BUILT JUST BEHIND THE BLOCK TO BE MOVED AND
*           CONTAINS A POINTER TO THE NEXT BLOCK AND THE NUMBER
*           OF WORDS TO BE MOVED.
*
*      3)   IN THE THIRD AND FINAL PASS, THE MOVE DESCRIPTOR
*           BLOCKS BUILT IN PASS TWO ARE USED TO ACTUALLY MOVE
*           THE BLOCKS DOWN TO THE BOTTOM OF THE DYNAMIC REGION.
*           THE COLLECTION IS THEN COMPLETE AND THE NEXT
*           AVAILABLE LOCATION POINTER IS RESET.
{{EJC{{{{{23549
*
*      GBCOL (CONTINUED)
*
{{EJC{{{{{23631
*
*      GBCOL (CONTINUED)
*
{GBCOL{PRC{25,E{1,0{{ENTRY POINT{23635
{{BNZ{3,DMVCH{6,GBC14{{FAIL IF IN MID-DUMP{23636
{{MNZ{3,GBCFL{{{NOTE GBCOL ENTERED{23637
{{MOV{8,WA{3,GBSVA{{SAVE ENTRY WA{23638
{{MOV{8,WB{3,GBSVB{{SAVE ENTRY WB{23639
{{MOV{8,WC{3,GBSVC{{SAVE ENTRY WC{23640
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{23641
{{SCP{8,WA{{{GET CODE POINTER VALUE{23642
{{SUB{3,R$COD{8,WA{{MAKE RELATIVE{23643
{{LCP{8,WA{{{AND RESTORE{23644
*
*      INFORM SYSGC THAT COLLECTION TO COMMENCE
*
{{MNZ{7,XR{{{NON-ZERO FLAGS START OF COLLECTION{23663
{{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23664
{{MOV{3,DNAMP{8,WB{{NEXT AVAILABLE LOCATION{23665
{{MOV{3,DNAME{8,WC{{LAST AVAILABLE LOCATION + 1{23666
{{JSR{6,SYSGC{{{INFORM OF COLLECTION{23667
*
*      PROCESS STACK ENTRIES
*
{{MOV{7,XS{7,XR{{POINT TO STACK FRONT{23672
{{MOV{3,STBAS{7,XL{{POINT PAST END OF STACK{23673
{{BGE{7,XL{7,XR{6,GBC00{OK IF D-STACK{23674
{{MOV{7,XL{7,XR{{REVERSE IF ...{23675
{{MOV{7,XS{7,XL{{... U-STACK{23676
*
*      PROCESS THE STACK
*
{GBC00{JSR{6,GBCPF{{{PROCESS POINTERS ON STACK{23680
*
*      PROCESS SPECIAL WORK LOCATIONS
*
{{MOV{20,=R$AAA{7,XR{{POINT TO START OF RELOCATABLE LOCS{23684
{{MOV{20,=R$YYY{7,XL{{POINT PAST END OF RELOCATABLE LOCS{23685
{{JSR{6,GBCPF{{{PROCESS WORK FIELDS{23686
*
*      PREPARE TO PROCESS VARIABLE BLOCKS
*
{{MOV{3,HSHTB{8,WA{{POINT TO FIRST HASH SLOT POINTER{23690
*
*      LOOP THROUGH HASH SLOTS
*
{GBC01{MOV{8,WA{7,XL{{POINT TO NEXT SLOT{23694
{{ICA{8,WA{{{BUMP BUCKET POINTER{23695
{{MOV{8,WA{3,GBCNM{{SAVE BUCKET POINTER{23696
{{EJC{{{{{23697
*
*      GBCOL (CONTINUED)
*
*      LOOP THROUGH VARIABLES ON ONE HASH CHAIN
*
{GBC02{MOV{9,(XL){7,XR{{LOAD PTR TO NEXT VRBLK{23703
{{BZE{7,XR{6,GBC03{{JUMP IF END OF CHAIN{23704
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK POINTER{23705
{{ADD{19,*VRVAL{7,XR{{POINT TO FIRST RELOC FLD{23706
{{ADD{19,*VRNXT{7,XL{{POINT PAST LAST (AND TO LINK PTR){23707
{{JSR{6,GBCPF{{{PROCESS RELOC FIELDS IN VRBLK{23708
{{BRN{6,GBC02{{{LOOP BACK FOR NEXT BLOCK{23709
*
*      HERE AT END OF ONE HASH CHAIN
*
{GBC03{MOV{3,GBCNM{8,WA{{RESTORE BUCKET POINTER{23713
{{BNE{8,WA{3,HSHTE{6,GBC01{LOOP BACK IF MORE BUCKETS TO GO{23714
{{EJC{{{{{23715
*
*      GBCOL (CONTINUED)
*
*      NOW WE ARE READY TO START PASS TWO. REGISTERS ARE USED
*      AS FOLLOWS IN PASS TWO.
*
*      (XR)                  SCANS THROUGH ALL BLOCKS
*      (WC)                  POINTER TO EVENTUAL LOCATION
*
*      THE MOVE DESCRIPTION BLOCKS BUILT IN THIS PASS HAVE
*      THE FOLLOWING FORMAT.
*
*      WORD 1                POINTER TO NEXT MOVE BLOCK,
*                            ZERO IF END OF CHAIN OF BLOCKS
*
*      WORD 2                LENGTH OF BLOCKS TO BE MOVED IN
*                            BYTES. SET TO THE ADDRESS OF THE
*                            FIRST BYTE WHILE ACTUALLY SCANNING
*                            THE BLOCKS.
*
*      THE FIRST ENTRY ON THIS CHAIN IS A SPECIAL ENTRY
*      CONSISTING OF THE TWO WORDS GBCNM AND GBCNS. AFTER
*      BUILDING THE CHAIN OF MOVE DESCRIPTORS, GBCNM POINTS TO
*      THE FIRST REAL MOVE BLOCK, AND GBCNS IS THE LENGTH OF
*      BLOCKS IN USE AT THE START OF STORAGE WHICH NEED NOT
*      BE MOVED SINCE THEY ARE IN THE CORRECT POSITION.
*
{{MOV{3,DNAMB{7,XR{{POINT TO FIRST BLOCK{23779
{{MOV{7,XR{8,WC{{SET AS FIRST EVENTUAL LOCATION{23781
{{ADD{3,GBSVB{8,WC{{ADD OFFSET FOR EVENTUAL MOVE UP{23782
{{ZER{3,GBCNM{{{CLEAR INITIAL FORWARD POINTER{23783
{{MOV{20,=GBCNM{3,GBCLM{{INITIALIZE PTR TO LAST MOVE BLOCK{23784
{{MOV{7,XR{3,GBCNS{{INITIALIZE FIRST ADDRESS{23785
*
*      LOOP THROUGH A SERIES OF BLOCKS IN USE
*
{GBC05{BEQ{7,XR{3,DNAMP{6,GBC07{JUMP IF END OF USED REGION{23789
{{MOV{9,(XR){8,WA{{ELSE GET FIRST WORD{23790
{{BOD{8,WA{6,GBC07{{JUMP IF ENTRY POINTER (UNUSED){23792
*
*      HERE FOR BLOCK IN USE, LOOP TO RELOCATE REFERENCES
*
{GBC06{MOV{8,WA{7,XL{{COPY POINTER{23800
{{MOV{9,(XL){8,WA{{LOAD FORWARD POINTER{23801
{{MOV{8,WC{9,(XL){{RELOCATE REFERENCE{23802
{{BEV{8,WA{6,GBC06{{LOOP BACK IF NOT END OF CHAIN{23804
{{EJC{{{{{23809
*
*      GBCOL (CONTINUED)
*
*      AT END OF CHAIN, RESTORE FIRST WORD AND BUMP PAST
*
{{MOV{8,WA{9,(XR){{RESTORE FIRST WORD{23815
{{JSR{6,BLKLN{{{GET LENGTH OF THIS BLOCK{23816
{{ADD{8,WA{7,XR{{BUMP ACTUAL POINTER{23817
{{ADD{8,WA{8,WC{{BUMP EVENTUAL POINTER{23818
{{BRN{6,GBC05{{{LOOP BACK FOR NEXT BLOCK{23819
*
*      HERE AT END OF A SERIES OF BLOCKS IN USE
*
{GBC07{MOV{7,XR{8,WA{{COPY POINTER PAST LAST BLOCK{23823
{{MOV{3,GBCLM{7,XL{{POINT TO PREVIOUS MOVE BLOCK{23824
{{SUB{12,1(XL){8,WA{{SUBTRACT STARTING ADDRESS{23825
{{MOV{8,WA{12,1(XL){{STORE LENGTH OF BLOCK TO BE MOVED{23826
*
*      LOOP THROUGH A SERIES OF BLOCKS NOT IN USE
*
{GBC08{BEQ{7,XR{3,DNAMP{6,GBC10{JUMP IF END OF USED REGION{23830
{{MOV{9,(XR){8,WA{{ELSE LOAD FIRST WORD OF NEXT BLOCK{23831
{{BEV{8,WA{6,GBC09{{JUMP IF IN USE{23833
{{JSR{6,BLKLN{{{ELSE GET LENGTH OF NEXT BLOCK{23838
{{ADD{8,WA{7,XR{{PUSH POINTER{23839
{{BRN{6,GBC08{{{AND LOOP BACK{23840
*
*      HERE FOR A BLOCK IN USE AFTER PROCESSING A SERIES OF
*      BLOCKS WHICH WERE NOT IN USE, BUILD NEW MOVE BLOCK.
*
{GBC09{SUB{19,*NUM02{7,XR{{POINT 2 WORDS BEHIND FOR MOVE BLOCK{23845
{{MOV{3,GBCLM{7,XL{{POINT TO PREVIOUS MOVE BLOCK{23846
{{MOV{7,XR{9,(XL){{SET FORWARD PTR IN PREVIOUS BLOCK{23847
{{ZER{9,(XR){{{ZERO FORWARD PTR OF NEW BLOCK{23848
{{MOV{7,XR{3,GBCLM{{REMEMBER ADDRESS OF THIS BLOCK{23849
{{MOV{7,XR{7,XL{{COPY PTR TO MOVE BLOCK{23850
{{ADD{19,*NUM02{7,XR{{POINT BACK TO BLOCK IN USE{23851
{{MOV{7,XR{12,1(XL){{STORE STARTING ADDRESS{23852
{{BRN{6,GBC06{{{JUMP TO PROCESS BLOCK IN USE{23853
{{EJC{{{{{23854
*
*      GBCOL (CONTINUED)
*
*      HERE FOR PASS THREE -- ACTUALLY MOVE THE BLOCKS DOWN
*
*      (XL)                  POINTER TO OLD LOCATION
*      (XR)                  POINTER TO NEW LOCATION
*
{GBC10{MOV{3,DNAMB{7,XR{{POINT TO START OF STORAGE{23866
{{ADD{3,GBCNS{7,XR{{BUMP PAST UNMOVED BLOCKS AT START{23868
*
*      LOOP THROUGH MOVE DESCRIPTORS
*
{GBC11{MOV{3,GBCNM{7,XL{{POINT TO NEXT MOVE BLOCK{23872
{{BZE{7,XL{6,GBC12{{JUMP IF END OF CHAIN{23873
{{MOV{10,(XL)+{3,GBCNM{{MOVE POINTER DOWN CHAIN{23874
{{MOV{10,(XL)+{8,WA{{GET LENGTH TO MOVE{23875
{{MVW{{{{PERFORM MOVE{23876
{{BRN{6,GBC11{{{LOOP BACK{23877
*
*      NOW TEST FOR MOVE UP
*
{GBC12{MOV{7,XR{3,DNAMP{{SET NEXT AVAILABLE LOC PTR{23881
{{MOV{3,GBSVB{8,WB{{RELOAD MOVE OFFSET{23882
{{BZE{8,WB{6,GBC13{{JUMP IF NO MOVE REQUIRED{23883
{{MOV{7,XR{7,XL{{ELSE COPY OLD TOP OF CORE{23884
{{ADD{8,WB{7,XR{{POINT TO NEW TOP OF CORE{23885
{{MOV{7,XR{3,DNAMP{{SAVE NEW TOP OF CORE POINTER{23886
{{MOV{7,XL{8,WA{{COPY OLD TOP{23887
{{SUB{3,DNAMB{8,WA{{MINUS OLD BOTTOM = LENGTH{23888
{{ADD{8,WB{3,DNAMB{{BUMP BOTTOM TO GET NEW VALUE{23889
{{MWB{{{{PERFORM MOVE (BACKWARDS){23890
*
*      MERGE HERE TO EXIT
*
{GBC13{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{23894
{{MOV{7,XR{3,GBCFL{{NOTE EXIT FROM GBCOL{23895
{{MOV{3,DNAMB{8,WA{{START OF DYNAMIC AREA{23897
{{MOV{3,DNAMP{8,WB{{NEXT AVAILABLE LOCATION{23898
{{MOV{3,DNAME{8,WC{{LAST AVAILABLE LOCATION + 1{23899
{{JSR{6,SYSGC{{{INFORM SYSGC OF COMPLETION{23900
{{MOV{3,GBSVA{8,WA{{RESTORE WA{23925
{{MOV{3,GBSVB{8,WB{{RESTORE WB{23926
{{SCP{8,WC{{{GET CODE POINTER{23927
{{ADD{3,R$COD{8,WC{{MAKE ABSOLUTE AGAIN{23928
{{LCP{8,WC{{{AND REPLACE ABSOLUTE VALUE{23929
{{MOV{3,GBSVC{8,WC{{RESTORE WC{23930
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{23931
{{ICV{3,GBCNT{{{INCREMENT COUNT OF COLLECTIONS{23932
{{EXI{{{{EXIT TO GBCOL CALLER{23933
*
*      GARBAGE COLLECTION NOT ALLOWED WHILST DUMPING
*
{GBC14{ICV{3,ERRFT{{{FATAL ERROR{23937
{{ERB{1,250{26,Insufficient memory to complete dump{{{23938
{{ENP{{{{END PROCEDURE GBCOL{23939
{{EJC{{{{{23940
*
*      GBCPF -- PROCESS FIELDS FOR GARBAGE COLLECTOR
*
*      THIS PROCEDURE IS USED BY THE GARBAGE COLLECTOR TO
*      PROCESS FIELDS IN PASS ONE. SEE GBCOL FOR FULL DETAILS.
*
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (XL)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  GBCPF            CALL TO PROCESS FIELDS
*      (XR,WA,WB,WC,IA)      DESTROYED
*
*      NOTE THAT ALTHOUGH THIS PROCEDURE USES A RECURSIVE
*      APPROACH, IT CONTROLS ITS OWN STACK AND IS NOT RECURSIVE.
*
{GBCPF{PRC{25,E{1,0{{ENTRY POINT{23955
{{ZER{11,-(XS){{{SET ZERO TO MARK BOTTOM OF STACK{23956
{{MOV{7,XL{11,-(XS){{SAVE END POINTER{23957
*
*      MERGE HERE TO GO DOWN A LEVEL AND START A NEW LOOP
*
*      1(XS)                 NEXT LVL FIELD PTR (0 AT OUTER LVL)
*      0(XS)                 PTR PAST LAST FIELD TO PROCESS
*      (XR)                  PTR TO FIRST FIELD TO PROCESS
*
*      LOOP TO PROCESS SUCCESSIVE FIELDS
*
{GPF01{MOV{9,(XR){7,XL{{LOAD FIELD CONTENTS{23967
{{MOV{7,XR{8,WC{{SAVE FIELD POINTER{23968
{{BOD{7,XL{6,GPF2A{{JUMP IF NOT PTR INTO DYNAMIC AREA{23970
{{BLT{7,XL{3,DNAMB{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{23972
{{BGE{7,XL{3,DNAMP{6,GPF2A{JUMP IF NOT PTR INTO DYNAMIC AREA{23973
*
*      HERE WE HAVE A PTR TO A BLOCK IN THE DYNAMIC AREA.
*      LINK THIS FIELD ONTO THE REFERENCE BACKCHAIN.
*
{{MOV{9,(XL){8,WA{{LOAD PTR TO CHAIN (OR ENTRY PTR){23978
{{MOV{7,XR{9,(XL){{SET THIS FIELD AS NEW HEAD OF CHAIN{23982
{{MOV{8,WA{9,(XR){{SET FORWARD POINTER{23983
*
*      NOW SEE IF THIS BLOCK HAS BEEN PROCESSED BEFORE
*
{GPF1A{BOD{8,WA{6,GPF03{{JUMP IF NOT ALREADY PROCESSED{23988
*
*      HERE TO RESTORE POINTER IN XR TO FIELD JUST PROCESSED
*
{GPF02{MOV{8,WC{7,XR{{RESTORE FIELD POINTER{23996
*
*      HERE TO MOVE TO NEXT FIELD
*
{GPF2A{ICA{7,XR{{{BUMP TO NEXT FIELD{24000
{{BNE{7,XR{9,(XS){6,GPF01{LOOP BACK IF MORE TO GO{24001
{{EJC{{{{{24002
*
*      GBCPF (CONTINUED)
*
*      HERE WE POP UP A LEVEL AFTER FINISHING A BLOCK
*
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER PAST END{24008
{{MOV{10,(XS)+{7,XR{{RESTORE BLOCK POINTER{24009
{{BNZ{7,XR{6,GPF2A{{CONTINUE LOOP UNLESS OUTER LEVL{24010
{{EXI{{{{RETURN TO CALLER IF OUTER LEVEL{24011
*
*      HERE TO PROCESS AN ACTIVE BLOCK WHICH HAS NOT BEEN DONE
*
{GPF03{MOV{7,XL{7,XR{{COPY BLOCK POINTER{24032
{{MOV{8,WA{7,XL{{COPY FIRST WORD OF BLOCK{24034
{{LEI{7,XL{{{LOAD ENTRY POINT ID (BL$XX){24035
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO GPF02 HERE TO CONTINUE TO NEXT FLD.
*
{{BSW{7,XL{2,BL$$${{SWITCH ON BLOCK TYPE{24040
{{IFF{2,BL$AR{6,GPF06{{ARBLK{24078
{{IFF{2,BL$CD{6,GPF19{{CDBLK{24078
{{IFF{2,BL$EX{6,GPF17{{EXBLK{24078
{{IFF{2,BL$IC{6,GPF02{{ICBLK{24078
{{IFF{2,BL$NM{6,GPF10{{NMBLK{24078
{{IFF{2,BL$P0{6,GPF10{{P0BLK{24078
{{IFF{2,BL$P1{6,GPF12{{P1BLK{24078
{{IFF{2,BL$P2{6,GPF12{{P2BLK{24078
{{IFF{2,BL$RC{6,GPF02{{RCBLK{24078
{{IFF{2,BL$SC{6,GPF02{{SCBLK{24078
{{IFF{2,BL$SE{6,GPF02{{SEBLK{24078
{{IFF{2,BL$TB{6,GPF08{{TBBLK{24078
{{IFF{2,BL$VC{6,GPF08{{VCBLK{24078
{{IFF{2,BL$XN{6,GPF02{{XNBLK{24078
{{IFF{2,BL$XR{6,GPF09{{XRBLK{24078
{{IFF{2,BL$BC{6,GPF02{{BCBLK - DUMMY TO FILL OUT IFFS{24078
{{IFF{2,BL$PD{6,GPF13{{PDBLK{24078
{{IFF{2,BL$TR{6,GPF16{{TRBLK{24078
{{IFF{2,BL$BF{6,GPF02{{BFBLK{24078
{{IFF{2,BL$CC{6,GPF07{{CCBLK{24078
{{IFF{2,BL$CM{6,GPF04{{CMBLK{24078
{{IFF{2,BL$CT{6,GPF02{{CTBLK{24078
{{IFF{2,BL$DF{6,GPF02{{DFBLK{24078
{{IFF{2,BL$EF{6,GPF02{{EFBLK{24078
{{IFF{2,BL$EV{6,GPF10{{EVBLK{24078
{{IFF{2,BL$FF{6,GPF11{{FFBLK{24078
{{IFF{2,BL$KV{6,GPF02{{KVBLK{24078
{{IFF{2,BL$PF{6,GPF14{{PFBLK{24078
{{IFF{2,BL$TE{6,GPF15{{TEBLK{24078
{{ESW{{{{END OF JUMP TABLE{24078
{{EJC{{{{{24079
*
*      GBCPF (CONTINUED)
*
*      CMBLK
*
{GPF04{MOV{13,CMLEN(XR){8,WA{{LOAD LENGTH{24085
{{MOV{19,*CMTYP{8,WB{{SET OFFSET{24086
*
*      HERE TO PUSH DOWN TO NEW LEVEL
*
*      (WC)                  FIELD PTR AT PREVIOUS LEVEL
*      (XR)                  PTR TO NEW BLOCK
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
{GPF05{ADD{7,XR{8,WA{{POINT PAST LAST RELOC FIELD{24095
{{ADD{8,WB{7,XR{{POINT TO FIRST RELOC FIELD{24096
{{MOV{8,WC{11,-(XS){{STACK OLD FIELD POINTER{24097
{{MOV{8,WA{11,-(XS){{STACK NEW LIMIT POINTER{24098
{{CHK{{{{CHECK FOR STACK OVERFLOW{24099
{{BRN{6,GPF01{{{IF OK, BACK TO PROCESS{24100
*
*      ARBLK
*
{GPF06{MOV{13,ARLEN(XR){8,WA{{LOAD LENGTH{24104
{{MOV{13,AROFS(XR){8,WB{{SET OFFSET TO 1ST RELOC FLD (ARPRO){24105
{{BRN{6,GPF05{{{ALL SET{24106
*
*      CCBLK
*
{GPF07{MOV{13,CCUSE(XR){8,WA{{SET LENGTH IN USE{24110
{{MOV{19,*CCUSE{8,WB{{1ST WORD (MAKE SURE AT LEAST ONE){24111
{{BRN{6,GPF05{{{ALL SET{24112
{{EJC{{{{{24113
*
*      GBCPF (CONTINUED)
*
*      CDBLK
*
{GPF19{MOV{13,CDLEN(XR){8,WA{{LOAD LENGTH{24120
{{MOV{19,*CDFAL{8,WB{{SET OFFSET{24121
{{BRN{6,GPF05{{{JUMP BACK{24122
*
*      TBBLK, VCBLK
*
{GPF08{MOV{13,OFFS2(XR){8,WA{{LOAD LENGTH{24129
{{MOV{19,*OFFS3{8,WB{{SET OFFSET{24130
{{BRN{6,GPF05{{{JUMP BACK{24131
*
*      XRBLK
*
{GPF09{MOV{13,XRLEN(XR){8,WA{{LOAD LENGTH{24135
{{MOV{19,*XRPTR{8,WB{{SET OFFSET{24136
{{BRN{6,GPF05{{{JUMP BACK{24137
*
*      EVBLK, NMBLK, P0BLK
*
{GPF10{MOV{19,*OFFS2{8,WA{{POINT PAST SECOND FIELD{24141
{{MOV{19,*OFFS1{8,WB{{OFFSET IS ONE (ONLY RELOC FLD IS 2){24142
{{BRN{6,GPF05{{{ALL SET{24143
*
*      FFBLK
*
{GPF11{MOV{19,*FFOFS{8,WA{{SET LENGTH{24147
{{MOV{19,*FFNXT{8,WB{{SET OFFSET{24148
{{BRN{6,GPF05{{{ALL SET{24149
*
*      P1BLK, P2BLK
*
{GPF12{MOV{19,*PARM2{8,WA{{LENGTH (PARM2 IS NON-RELOCATABLE){24153
{{MOV{19,*PTHEN{8,WB{{SET OFFSET{24154
{{BRN{6,GPF05{{{ALL SET{24155
{{EJC{{{{{24156
*
*      GBCPF (CONTINUED)
*
*      PDBLK
*
{GPF13{MOV{13,PDDFP(XR){7,XL{{LOAD PTR TO DFBLK{24162
{{MOV{13,DFPDL(XL){8,WA{{GET PDBLK LENGTH{24163
{{MOV{19,*PDFLD{8,WB{{SET OFFSET{24164
{{BRN{6,GPF05{{{ALL SET{24165
*
*      PFBLK
*
{GPF14{MOV{19,*PFARG{8,WA{{LENGTH PAST LAST RELOC{24169
{{MOV{19,*PFCOD{8,WB{{OFFSET TO FIRST RELOC{24170
{{BRN{6,GPF05{{{ALL SET{24171
*
*      TEBLK
*
{GPF15{MOV{19,*TESI${8,WA{{SET LENGTH{24175
{{MOV{19,*TESUB{8,WB{{AND OFFSET{24176
{{BRN{6,GPF05{{{ALL SET{24177
*
*      TRBLK
*
{GPF16{MOV{19,*TRSI${8,WA{{SET LENGTH{24181
{{MOV{19,*TRVAL{8,WB{{AND OFFSET{24182
{{BRN{6,GPF05{{{ALL SET{24183
*
*      EXBLK
*
{GPF17{MOV{13,EXLEN(XR){8,WA{{LOAD LENGTH{24187
{{MOV{19,*EXFLC{8,WB{{SET OFFSET{24188
{{BRN{6,GPF05{{{JUMP BACK{24189
{{ENP{{{{END PROCEDURE GBCPF{24199
{{EJC{{{{{24200
*
*      GTARR -- GET ARRAY
*
*      GTARR IS PASSED AN OBJECT AND RETURNS AN ARRAY IF POSSIBL
*
*      (XR)                  VALUE TO BE CONVERTED
*      (WA)                  0 TO PLACE TABLE ADDRESSES IN ARRAY
*                            NON-ZERO FOR KEYS/VALUES IN ARRAY
*      JSR  GTARR            CALL TO GET ARRAY
*      PPM  LOC              TRANSFER LOC FOR ALL NULL TABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING ARRAY
*      (XL,WA,WB,WC)         DESTROYED
*
{GTARR{PRC{25,E{1,2{{ENTRY POINT{24215
{{MOV{8,WA{3,GTAWA{{SAVE WA INDICATOR{24216
{{MOV{9,(XR){8,WA{{LOAD TYPE WORD{24217
{{BEQ{8,WA{22,=B$ART{6,GTAR8{EXIT IF ALREADY AN ARRAY{24218
{{BEQ{8,WA{22,=B$VCT{6,GTAR8{EXIT IF ALREADY AN ARRAY{24219
{{BNE{8,WA{22,=B$TBT{6,GTA9A{ELSE FAIL IF NOT A TABLE (SGD02){24220
*
*      HERE WE CONVERT A TABLE TO AN ARRAY
*
{{MOV{7,XR{11,-(XS){{REPLACE TBBLK POINTER ON STACK{24224
{{ZER{7,XR{{{SIGNAL FIRST PASS{24225
{{ZER{8,WB{{{ZERO NON-NULL ELEMENT COUNT{24226
*
*      THE FOLLOWING CODE IS EXECUTED TWICE. ON THE FIRST PASS,
*      SIGNALLED BY XR=0, THE NUMBER OF NON-NULL ELEMENTS IN
*      THE TABLE IS COUNTED IN WB. IN THE SECOND PASS, WHERE
*      XR IS A POINTER INTO THE ARBLK, THE NAME AND VALUE ARE
*      ENTERED INTO THE CURRENT ARBLK LOCATION PROVIDED GTAWA
*      IS NON-ZERO.  IF GTAWA IS ZERO, THE ADDRESS OF THE TEBLK
*      IS ENTERED INTO THE ARBLK TWICE (C3.762).
*
{GTAR1{MOV{9,(XS){7,XL{{POINT TO TABLE{24236
{{ADD{13,TBLEN(XL){7,XL{{POINT PAST LAST BUCKET{24237
{{SUB{19,*TBBUK{7,XL{{SET FIRST BUCKET OFFSET{24238
{{MOV{7,XL{8,WA{{COPY ADJUSTED POINTER{24239
*
*      LOOP THROUGH BUCKETS IN TABLE BLOCK
*      NEXT THREE LINES OF CODE RELY ON TENXT HAVING A VALUE
*      1 LESS THAN TBBUK.
*
{GTAR2{MOV{8,WA{7,XL{{COPY BUCKET POINTER{24245
{{DCA{8,WA{{{DECREMENT BUCKET POINTER{24246
*
*      LOOP THROUGH TEBLKS ON ONE BUCKET CHAIN
*
{GTAR3{MOV{13,TENXT(XL){7,XL{{POINT TO NEXT TEBLK{24250
{{BEQ{7,XL{9,(XS){6,GTAR6{JUMP IF CHAIN END (TBBLK PTR){24251
{{MOV{7,XL{3,CNVTP{{ELSE SAVE TEBLK POINTER{24252
*
*      LOOP TO FIND VALUE DOWN TRBLK CHAIN
*
{GTAR4{MOV{13,TEVAL(XL){7,XL{{LOAD VALUE{24256
{{BEQ{9,(XL){22,=B$TRT{6,GTAR4{LOOP TILL VALUE FOUND{24257
{{MOV{7,XL{8,WC{{COPY VALUE{24258
{{MOV{3,CNVTP{7,XL{{RESTORE TEBLK POINTER{24259
{{EJC{{{{{24260
*
*      GTARR (CONTINUED)
*
*      NOW CHECK FOR NULL AND TEST CASES
*
{{BEQ{8,WC{21,=NULLS{6,GTAR3{LOOP BACK TO IGNORE NULL VALUE{24266
{{BNZ{7,XR{6,GTAR5{{JUMP IF SECOND PASS{24267
{{ICV{8,WB{{{FOR THE FIRST PASS, BUMP COUNT{24268
{{BRN{6,GTAR3{{{AND LOOP BACK FOR NEXT TEBLK{24269
*
*      HERE IN SECOND PASS
*
{GTAR5{BZE{3,GTAWA{6,GTA5A{{JUMP IF ADDRESS WANTED{24273
{{MOV{13,TESUB(XL){10,(XR)+{{STORE SUBSCRIPT NAME{24274
{{MOV{8,WC{10,(XR)+{{STORE VALUE IN ARBLK{24275
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{24276
*
*      HERE TO RECORD TEBLK ADDRESS IN ARBLK.  THIS ALLOWS
*      A SORT ROUTINE TO SORT BY ASCENDING ADDRESS.
*
{GTA5A{MOV{7,XL{10,(XR)+{{STORE TEBLK ADDRESS IN NAME{24281
{{MOV{7,XL{10,(XR)+{{AND VALUE SLOTS{24282
{{BRN{6,GTAR3{{{LOOP BACK FOR NEXT TEBLK{24283
*
*      HERE AFTER SCANNING TEBLKS ON ONE CHAIN
*
{GTAR6{BNE{8,WA{9,(XS){6,GTAR2{LOOP BACK IF MORE BUCKETS TO GO{24287
{{BNZ{7,XR{6,GTAR7{{ELSE JUMP IF SECOND PASS{24288
*
*      HERE AFTER COUNTING NON-NULL ELEMENTS
*
{{BZE{8,WB{6,GTAR9{{FAIL IF NO NON-NULL ELEMENTS{24292
{{MOV{8,WB{8,WA{{ELSE COPY COUNT{24293
{{ADD{8,WB{8,WA{{DOUBLE (TWO WORDS/ELEMENT){24294
{{ADD{18,=ARVL2{8,WA{{ADD SPACE FOR STANDARD FIELDS{24295
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{24296
{{BGT{8,WA{3,MXLEN{6,GTA9B{ERROR IF TOO LONG FOR ARRAY{24297
{{JSR{6,ALLOC{{{ELSE ALLOCATE SPACE FOR ARBLK{24298
{{MOV{22,=B$ART{9,(XR){{STORE TYPE WORD{24299
{{ZER{13,IDVAL(XR){{{ZERO ID FOR THE MOMENT{24300
{{MOV{8,WA{13,ARLEN(XR){{STORE LENGTH{24301
{{MOV{18,=NUM02{13,ARNDM(XR){{SET DIMENSIONS = 2{24302
{{LDI{4,INTV1{{{GET INTEGER ONE{24303
{{STI{13,ARLBD(XR){{{STORE AS LBD 1{24304
{{STI{13,ARLB2(XR){{{STORE AS LBD 2{24305
{{LDI{4,INTV2{{{LOAD INTEGER TWO{24306
{{STI{13,ARDM2(XR){{{STORE AS DIM 2{24307
{{MTI{8,WB{{{GET ELEMENT COUNT AS INTEGER{24308
{{STI{13,ARDIM(XR){{{STORE AS DIM 1{24309
{{ZER{13,ARPR2(XR){{{ZERO PROTOTYPE FIELD FOR NOW{24310
{{MOV{19,*ARPR2{13,AROFS(XR){{SET OFFSET FIELD (SIGNAL PASS 2){24311
{{MOV{7,XR{8,WB{{SAVE ARBLK POINTER{24312
{{ADD{19,*ARVL2{7,XR{{POINT TO FIRST ELEMENT LOCATION{24313
{{BRN{6,GTAR1{{{JUMP BACK TO FILL IN ELEMENTS{24314
{{EJC{{{{{24315
*
*      GTARR (CONTINUED)
*
*      HERE AFTER FILLING IN ELEMENT VALUES
*
{GTAR7{MOV{8,WB{7,XR{{RESTORE ARBLK POINTER{24321
{{MOV{8,WB{9,(XS){{STORE AS RESULT{24322
*
*      NOW WE NEED THE ARRAY PROTOTYPE WHICH IS OF THE FORM NN,2
*      THIS IS OBTAINED BY BUILDING THE STRING FOR NN02 AND
*      CHANGING THE ZERO TO A COMMA BEFORE STORING IT.
*
{{LDI{13,ARDIM(XR){{{GET NUMBER OF ELEMENTS (NN){24328
{{MLI{4,INTVH{{{MULTIPLY BY 100{24329
{{ADI{4,INTV2{{{ADD 2 (NN02){24330
{{JSR{6,ICBLD{{{BUILD INTEGER{24331
{{MOV{7,XR{11,-(XS){{STORE PTR FOR GTSTG{24332
{{JSR{6,GTSTG{{{CONVERT TO STRING{24333
{{PPM{{{{CONVERT FAIL IS IMPOSSIBLE{24334
{{MOV{7,XR{7,XL{{COPY STRING POINTER{24335
{{MOV{10,(XS)+{7,XR{{RELOAD ARBLK POINTER{24336
{{MOV{7,XL{13,ARPR2(XR){{STORE PROTOTYPE PTR (NN02){24337
{{SUB{18,=NUM02{8,WA{{ADJUST LENGTH TO POINT TO ZERO{24338
{{PSC{7,XL{8,WA{{POINT TO ZERO{24339
{{MOV{18,=CH$CM{8,WB{{LOAD A COMMA{24340
{{SCH{8,WB{9,(XL){{STORE A COMMA OVER THE ZERO{24341
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{24342
*
*      NORMAL RETURN
*
{GTAR8{EXI{{{{RETURN TO CALLER{24346
*
*      NULL TABLE NON-CONVERSION RETURN
*
{GTAR9{MOV{10,(XS)+{7,XR{{RESTORE STACK FOR CONV ERR (SGD02){24350
{{EXI{1,1{{{RETURN{24351
*
*      IMPOSSIBLE CONVERSION RETURN
*
{GTA9A{EXI{1,2{{{RETURN{24355
*
*      ARRAY SIZE TOO LARGE
*
{GTA9B{ERB{1,260{26,Conversion array size exceeds maximum permitted{{{24359
{{ENP{{{{PROCEDURE GTARR{24360
{{EJC{{{{{24361
*
*      GTCOD -- CONVERT TO CODE
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTCOD            CALL TO CONVERT TO CODE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING CDBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTCOD{PRC{25,E{1,1{{ENTRY POINT{24375
{{BEQ{9,(XR){22,=B$CDS{6,GTCD1{JUMP IF ALREADY CODE{24376
{{BEQ{9,(XR){22,=B$CDC{6,GTCD1{JUMP IF ALREADY CODE{24377
*
*      HERE WE MUST GENERATE A CDBLK BY COMPILATION
*
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24381
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24382
{{PPM{6,GTCD2{{{JUMP IF NON-CONVERTIBLE{24383
{{MOV{3,FLPTR{3,GTCEF{{SAVE FAIL PTR IN CASE OF ERROR{24384
{{MOV{3,R$COD{3,R$GTC{{ALSO SAVE CODE PTR{24385
{{MOV{7,XR{3,R$CIM{{ELSE SET IMAGE POINTER{24386
{{MOV{8,WA{3,SCNIL{{SET IMAGE LENGTH{24387
{{ZER{3,SCNPT{{{SET SCAN POINTER{24388
{{MOV{18,=STGXC{3,STAGE{{SET STAGE FOR EXECUTE COMPILE{24389
{{MOV{3,CMPSN{3,LSTSN{{IN CASE LISTR CALLED{24390
{{ICV{3,CMPLN{{{BUMP LINE NUMBER{24392
{{JSR{6,CMPIL{{{COMPILE STRING{24394
{{MOV{18,=STGXT{3,STAGE{{RESET STAGE FOR EXECUTE TIME{24395
{{ZER{3,R$CIM{{{CLEAR IMAGE{24396
*
*      MERGE HERE IF NO CONVERT REQUIRED
*
{GTCD1{EXI{{{{GIVE NORMAL GTCOD RETURN{24400
*
*      HERE IF UNCONVERTIBLE
*
{GTCD2{EXI{1,1{{{GIVE ERROR RETURN{24404
{{ENP{{{{END PROCEDURE GTCOD{24405
{{EJC{{{{{24406
*
*      GTEXP -- CONVERT TO EXPRESSION
*
*      (WB)                  0 IF BY VALUE, 1 IF BY NAME
*      (XR)                  INPUT VALUE TO BE CONVERTED
*      JSR  GTEXP            CALL TO CONVERT TO EXPRESSION
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT EXBLK OR SEBLK
*      (XL,WA,WB,WC,RA)      DESTROYED
*
*      IF A SPITBOL ERROR OCCURS DURING COMPILATION OR PRE-
*      EVALUATION, CONTROL IS PASSED VIA ERROR SECTION TO EXFAL
*      WITHOUT RETURNING TO THIS ROUTINE.
*
{GTEXP{PRC{25,E{1,1{{ENTRY POINT{24423
{{BLO{9,(XR){22,=B$E$${6,GTEX1{JUMP IF ALREADY AN EXPRESSION{24424
{{MOV{7,XR{11,-(XS){{STORE ARGUMENT FOR GTSTG{24425
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24426
{{PPM{6,GTEX2{{{JUMP IF UNCONVERTIBLE{24427
*
*      CHECK THE LAST CHARACTER OF THE STRING FOR COLON OR
*      SEMICOLON.  THESE CHARACTERS CAN LEGITIMATELY END AN
*      EXPRESSION IN OPEN CODE, SO EXPAN WILL NOT DETECT THEM
*      AS ERRORS, BUT THEY ARE INVALID AS TERMINATORS FOR A
*      STRING THAT IS BEING CONVERTED TO EXPRESSION FORM.
*
{{MOV{7,XR{7,XL{{COPY INPUT STRING POINTER{24435
{{PLC{7,XL{8,WA{{POINT ONE PAST THE STRING END{24436
{{LCH{7,XL{11,-(XL){{FETCH THE LAST CHARACTER{24437
{{BEQ{7,XL{18,=CH$CL{6,GTEX2{ERROR IF IT IS A SEMICOLON{24438
{{BEQ{7,XL{18,=CH$SM{6,GTEX2{OR IF IT IS A COLON{24439
*
*      HERE WE CONVERT A STRING BY COMPILATION
*
{{MOV{7,XR{3,R$CIM{{SET INPUT IMAGE POINTER{24443
{{ZER{3,SCNPT{{{SET SCAN POINTER{24444
{{MOV{8,WA{3,SCNIL{{SET INPUT IMAGE LENGTH{24445
{{MOV{8,WB{11,-(XS){{SAVE VALUE/NAME FLAG{24447
{{ZER{8,WB{{{SET CODE FOR NORMAL SCAN{24449
{{MOV{3,FLPTR{3,GTCEF{{SAVE FAIL PTR IN CASE OF ERROR{24450
{{MOV{3,R$COD{3,R$GTC{{ALSO SAVE CODE PTR{24451
{{MOV{18,=STGEV{3,STAGE{{ADJUST STAGE FOR COMPILE{24452
{{MOV{18,=T$UOK{3,SCNTP{{INDICATE UNARY OPERATOR ACCEPTABLE{24453
{{JSR{6,EXPAN{{{BUILD TREE FOR EXPRESSION{24454
{{ZER{3,SCNRS{{{RESET RESCAN FLAG{24455
{{MOV{10,(XS)+{8,WA{{RESTORE VALUE/NAME FLAG{24457
{{BNE{3,SCNPT{3,SCNIL{6,GTEX2{ERROR IF NOT END OF IMAGE{24459
{{ZER{8,WB{{{SET OK VALUE FOR CDGEX CALL{24460
{{MOV{7,XR{7,XL{{COPY TREE POINTER{24461
{{JSR{6,CDGEX{{{BUILD EXPRESSION BLOCK{24462
{{ZER{3,R$CIM{{{CLEAR POINTER{24463
{{MOV{18,=STGXT{3,STAGE{{RESTORE STAGE FOR EXECUTE TIME{24464
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTEX1{EXI{{{{RETURN TO GTEXP CALLER{24468
*
*      HERE IF UNCONVERTIBLE
*
{GTEX2{EXI{1,1{{{TAKE ERROR EXIT{24472
{{ENP{{{{END PROCEDURE GTEXP{24473
{{EJC{{{{{24474
*
*      GTINT -- GET INTEGER VALUE
*
*      GTINT IS PASSED AN OBJECT AND RETURNS AN INTEGER AFTER
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  VALUE TO BE CONVERTED
*      JSR  GTINT            CALL TO CONVERT TO INTEGER
*      PPM  LOC              TRANSFER LOC FOR CONVERT IMPOSSIBLE
*      (XR)                  RESULTING INTEGER
*      (WC,RA)               DESTROYED
*      (WA,WB)               DESTROYED (ONLY ON CONVERSION ERR)
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTINT{PRC{25,E{1,1{{ENTRY POINT{24489
{{BEQ{9,(XR){22,=B$ICL{6,GTIN2{JUMP IF ALREADY AN INTEGER{24490
{{MOV{8,WA{3,GTINA{{ELSE SAVE WA{24491
{{MOV{8,WB{3,GTINB{{SAVE WB{24492
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{24493
{{PPM{6,GTIN3{{{JUMP IF UNCONVERTIBLE{24494
{{BEQ{8,WA{22,=B$ICL{6,GTIN1{JUMP IF INTEGER{24497
*
*      HERE WE CONVERT A REAL TO INTEGER
*
{{LDR{13,RCVAL(XR){{{LOAD REAL VALUE{24501
{{RTI{6,GTIN3{{{CONVERT TO INTEGER (ERR IF OVFLOW){24502
{{JSR{6,ICBLD{{{IF OK BUILD ICBLK{24503
*
*      HERE AFTER SUCCESSFUL CONVERSION TO INTEGER
*
{GTIN1{MOV{3,GTINA{8,WA{{RESTORE WA{24508
{{MOV{3,GTINB{8,WB{{RESTORE WB{24509
*
*      COMMON EXIT POINT
*
{GTIN2{EXI{{{{RETURN TO GTINT CALLER{24513
*
*      HERE ON CONVERSION ERROR
*
{GTIN3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{24517
{{ENP{{{{END PROCEDURE GTINT{24518
{{EJC{{{{{24519
*
*      GTNUM -- GET NUMERIC VALUE
*
*      GTNUM IS GIVEN AN OBJECT AND RETURNS EITHER AN INTEGER
*      OR A REAL, PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTNUM            CALL TO CONVERT TO NUMERIC
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULT (INT OR REAL)
*      (WA)                  FIRST WORD OF RESULT BLOCK
*      (WB,WC,RA)            DESTROYED
*      (XR)                  UNCHANGED (ON CONVERT ERROR)
*
{GTNUM{PRC{25,E{1,1{{ENTRY POINT{24534
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{24535
{{BEQ{8,WA{22,=B$ICL{6,GTN34{JUMP IF INTEGER (NO CONVERSION){24536
{{BEQ{8,WA{22,=B$RCL{6,GTN34{JUMP IF REAL (NO CONVERSION){24539
*
*      AT THIS POINT THE ONLY POSSIBILITY IS TO CONVERT A STRING
*      TO AN INTEGER OR REAL AS APPROPRIATE.
*
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT IN CASE CONVERT ERR{24545
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24546
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24548
{{PPM{6,GTN36{{{JUMP IF UNCONVERTIBLE{24552
*
*      INITIALIZE NUMERIC CONVERSION
*
{{LDI{4,INTV0{{{INITIALIZE INTEGER RESULT TO ZERO{24556
{{BZE{8,WA{6,GTN32{{JUMP TO EXIT WITH ZERO IF NULL{24557
{{LCT{8,WA{8,WA{{SET BCT COUNTER FOR FOLLOWING LOOPS{24558
{{ZER{3,GTNNF{{{TENTATIVELY INDICATE RESULT +{24559
{{STI{3,GTNEX{{{INITIALISE EXPONENT TO ZERO{24562
{{ZER{3,GTNSC{{{ZERO SCALE IN CASE REAL{24563
{{ZER{3,GTNDF{{{RESET FLAG FOR DEC POINT FOUND{24564
{{ZER{3,GTNRD{{{RESET FLAG FOR DIGITS FOUND{24565
{{LDR{4,REAV0{{{ZERO REAL ACCUM IN CASE REAL{24566
{{PLC{7,XR{{{POINT TO ARGUMENT CHARACTERS{24568
*
*      MERGE BACK HERE AFTER IGNORING LEADING BLANK
*
{GTN01{LCH{8,WB{10,(XR)+{{LOAD FIRST CHARACTER{24572
{{BLT{8,WB{18,=CH$D0{6,GTN02{JUMP IF NOT DIGIT{24573
{{BLE{8,WB{18,=CH$D9{6,GTN06{JUMP IF FIRST CHAR IS A DIGIT{24574
{{EJC{{{{{24575
*
*      GTNUM (CONTINUED)
*
*      HERE IF FIRST DIGIT IS NON-DIGIT
*
{GTN02{BNE{8,WB{18,=CH$BL{6,GTN03{JUMP IF NON-BLANK{24581
{GTNA2{BCT{8,WA{6,GTN01{{ELSE DECR COUNT AND LOOP BACK{24582
{{BRN{6,GTN07{{{JUMP TO RETURN ZERO IF ALL BLANKS{24583
*
*      HERE FOR FIRST CHARACTER NON-BLANK, NON-DIGIT
*
{GTN03{BEQ{8,WB{18,=CH$PL{6,GTN04{JUMP IF PLUS SIGN{24587
{{BEQ{8,WB{18,=CH$HT{6,GTNA2{HORIZONTAL TAB EQUIV TO BLANK{24589
{{BNE{8,WB{18,=CH$MN{6,GTN12{JUMP IF NOT MINUS (MAY BE REAL){24597
{{MNZ{3,GTNNF{{{IF MINUS SIGN, SET NEGATIVE FLAG{24599
*
*      MERGE HERE AFTER PROCESSING SIGN
*
{GTN04{BCT{8,WA{6,GTN05{{JUMP IF CHARS LEFT{24603
{{BRN{6,GTN36{{{ELSE ERROR{24604
*
*      LOOP TO FETCH CHARACTERS OF AN INTEGER
*
{GTN05{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24608
{{BLT{8,WB{18,=CH$D0{6,GTN08{JUMP IF NOT A DIGIT{24609
{{BGT{8,WB{18,=CH$D9{6,GTN08{JUMP IF NOT A DIGIT{24610
*
*      MERGE HERE FOR FIRST DIGIT
*
{GTN06{STI{3,GTNSI{{{SAVE CURRENT VALUE{24614
{{CVM{6,GTN35{{{CURRENT*10-(NEW DIG) JUMP IF OVFLOW{24618
{{MNZ{3,GTNRD{{{SET DIGIT READ FLAG{24619
{{BCT{8,WA{6,GTN05{{ELSE LOOP BACK IF MORE CHARS{24621
*
*      HERE TO EXIT WITH CONVERTED INTEGER VALUE
*
{GTN07{BNZ{3,GTNNF{6,GTN32{{JUMP IF NEGATIVE (ALL SET){24625
{{NGI{{{{ELSE NEGATE{24626
{{INO{6,GTN32{{{JUMP IF NO OVERFLOW{24627
{{BRN{6,GTN36{{{ELSE SIGNAL ERROR{24628
{{EJC{{{{{24629
*
*      GTNUM (CONTINUED)
*
*      HERE FOR A NON-DIGIT CHARACTER WHILE ATTEMPTING TO
*      CONVERT AN INTEGER, CHECK FOR TRAILING BLANKS OR REAL.
*
{GTN08{BEQ{8,WB{18,=CH$BL{6,GTNA9{JUMP IF A BLANK{24636
{{BEQ{8,WB{18,=CH$HT{6,GTNA9{JUMP IF HORIZONTAL TAB{24638
{{ITR{{{{ELSE CONVERT INTEGER TO REAL{24646
{{NGR{{{{NEGATE TO GET POSITIVE VALUE{24647
{{BRN{6,GTN12{{{JUMP TO TRY FOR REAL{24648
*
*      HERE WE SCAN OUT BLANKS TO END OF STRING
*
{GTN09{LCH{8,WB{10,(XR)+{{GET NEXT CHAR{24653
{{BEQ{8,WB{18,=CH$HT{6,GTNA9{JUMP IF HORIZONTAL TAB{24655
{{BNE{8,WB{18,=CH$BL{6,GTN36{ERROR IF NON-BLANK{24660
{GTNA9{BCT{8,WA{6,GTN09{{LOOP BACK IF MORE CHARS TO CHECK{24661
{{BRN{6,GTN07{{{RETURN INTEGER IF ALL BLANKS{24662
*
*      LOOP TO COLLECT MANTISSA OF REAL
*
{GTN10{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24668
{{BLT{8,WB{18,=CH$D0{6,GTN12{JUMP IF NON-NUMERIC{24669
{{BGT{8,WB{18,=CH$D9{6,GTN12{JUMP IF NON-NUMERIC{24670
*
*      MERGE HERE TO COLLECT FIRST REAL DIGIT
*
{GTN11{SUB{18,=CH$D0{8,WB{{CONVERT DIGIT TO NUMBER{24674
{{MLR{4,REAVT{{{MULTIPLY REAL BY 10.0{24675
{{ROV{6,GTN36{{{CONVERT ERROR IF OVERFLOW{24676
{{STR{3,GTNSR{{{SAVE RESULT{24677
{{MTI{8,WB{{{GET NEW DIGIT AS INTEGER{24678
{{ITR{{{{CONVERT NEW DIGIT TO REAL{24679
{{ADR{3,GTNSR{{{ADD TO GET NEW TOTAL{24680
{{ADD{3,GTNDF{3,GTNSC{{INCREMENT SCALE IF AFTER DEC POINT{24681
{{MNZ{3,GTNRD{{{SET DIGIT FOUND FLAG{24682
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{24683
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24684
{{EJC{{{{{24685
*
*      GTNUM (CONTINUED)
*
*      HERE IF NON-DIGIT FOUND WHILE COLLECTING A REAL
*
{GTN12{BNE{8,WB{18,=CH$DT{6,GTN13{JUMP IF NOT DEC POINT{24691
{{BNZ{3,GTNDF{6,GTN36{{IF DEC POINT, ERROR IF ONE ALREADY{24692
{{MOV{18,=NUM01{3,GTNDF{{ELSE SET FLAG FOR DEC POINT{24693
{{BCT{8,WA{6,GTN10{{LOOP BACK IF MORE CHARS{24694
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24695
*
*      HERE IF NOT DECIMAL POINT
*
{GTN13{BEQ{8,WB{18,=CH$LE{6,GTN15{JUMP IF E FOR EXPONENT{24699
{{BEQ{8,WB{18,=CH$LD{6,GTN15{JUMP IF D FOR EXPONENT{24700
{{BEQ{8,WB{18,=CH$$E{6,GTN15{JUMP IF E FOR EXPONENT{24702
{{BEQ{8,WB{18,=CH$$D{6,GTN15{JUMP IF D FOR EXPONENT{24703
*
*      HERE CHECK FOR TRAILING BLANKS
*
{GTN14{BEQ{8,WB{18,=CH$BL{6,GTNB4{JUMP IF BLANK{24708
{{BEQ{8,WB{18,=CH$HT{6,GTNB4{JUMP IF HORIZONTAL TAB{24710
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{24715
*
{GTNB4{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{24717
{{BCT{8,WA{6,GTN14{{LOOP BACK TO CHECK IF MORE{24718
{{BRN{6,GTN22{{{ELSE JUMP TO SCALE{24719
*
*      HERE TO READ AND PROCESS AN EXPONENT
*
{GTN15{ZER{3,GTNES{{{SET EXPONENT SIGN POSITIVE{24723
{{LDI{4,INTV0{{{INITIALIZE EXPONENT TO ZERO{24724
{{MNZ{3,GTNDF{{{RESET NO DEC POINT INDICATION{24725
{{BCT{8,WA{6,GTN16{{JUMP SKIPPING PAST E OR D{24726
{{BRN{6,GTN36{{{ERROR IF NULL EXPONENT{24727
*
*      CHECK FOR EXPONENT SIGN
*
{GTN16{LCH{8,WB{10,(XR)+{{LOAD FIRST EXPONENT CHARACTER{24731
{{BEQ{8,WB{18,=CH$PL{6,GTN17{JUMP IF PLUS SIGN{24732
{{BNE{8,WB{18,=CH$MN{6,GTN19{ELSE JUMP IF NOT MINUS SIGN{24733
{{MNZ{3,GTNES{{{SET SIGN NEGATIVE IF MINUS SIGN{24734
*
*      MERGE HERE AFTER PROCESSING EXPONENT SIGN
*
{GTN17{BCT{8,WA{6,GTN18{{JUMP IF CHARS LEFT{24738
{{BRN{6,GTN36{{{ELSE ERROR{24739
*
*      LOOP TO CONVERT EXPONENT DIGITS
*
{GTN18{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{24743
{{EJC{{{{{24744
*
*      GTNUM (CONTINUED)
*
*      MERGE HERE FOR FIRST EXPONENT DIGIT
*
{GTN19{BLT{8,WB{18,=CH$D0{6,GTN20{JUMP IF NOT DIGIT{24750
{{BGT{8,WB{18,=CH$D9{6,GTN20{JUMP IF NOT DIGIT{24751
{{CVM{6,GTN36{{{ELSE CURRENT*10, SUBTRACT NEW DIGIT{24752
{{BCT{8,WA{6,GTN18{{LOOP BACK IF MORE CHARS{24753
{{BRN{6,GTN21{{{JUMP IF EXPONENT FIELD IS EXHAUSTED{24754
*
*      HERE TO CHECK FOR TRAILING BLANKS AFTER EXPONENT
*
{GTN20{BEQ{8,WB{18,=CH$BL{6,GTNC0{JUMP IF BLANK{24758
{{BEQ{8,WB{18,=CH$HT{6,GTNC0{JUMP IF HORIZONTAL TAB{24760
{{BRN{6,GTN36{{{ERROR IF NON-BLANK{24765
*
{GTNC0{LCH{8,WB{10,(XR)+{{GET NEXT CHARACTER{24767
{{BCT{8,WA{6,GTN20{{LOOP BACK TILL ALL BLANKS SCANNED{24768
*
*      MERGE HERE AFTER COLLECTING EXPONENT
*
{GTN21{STI{3,GTNEX{{{SAVE COLLECTED EXPONENT{24772
{{BNZ{3,GTNES{6,GTN22{{JUMP IF IT WAS NEGATIVE{24773
{{NGI{{{{ELSE COMPLEMENT{24774
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24775
{{STI{3,GTNEX{{{AND STORE POSITIVE EXPONENT{24776
*
*      MERGE HERE WITH EXPONENT (0 IF NONE GIVEN)
*
{GTN22{BZE{3,GTNRD{6,GTN36{{ERROR IF NOT DIGITS COLLECTED{24780
{{BZE{3,GTNDF{6,GTN36{{ERROR IF NO EXPONENT OR DEC POINT{24781
{{MTI{3,GTNSC{{{ELSE LOAD SCALE AS INTEGER{24782
{{SBI{3,GTNEX{{{SUBTRACT EXPONENT{24783
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24784
{{ILT{6,GTN26{{{JUMP IF WE MUST SCALE UP{24785
*
*      HERE WE HAVE A NEGATIVE EXPONENT, SO SCALE DOWN
*
{{MFI{8,WA{6,GTN36{{LOAD SCALE FACTOR, ERR IF OVFLOW{24789
*
*      LOOP TO SCALE DOWN IN STEPS OF 10**10
*
{GTN23{BLE{8,WA{18,=NUM10{6,GTN24{JUMP IF 10 OR LESS TO GO{24793
{{DVR{4,REATT{{{ELSE DIVIDE BY 10**10{24794
{{SUB{18,=NUM10{8,WA{{DECREMENT SCALE{24795
{{BRN{6,GTN23{{{AND LOOP BACK{24796
{{EJC{{{{{24797
*
*      GTNUM (CONTINUED)
*
*      HERE SCALE REST OF WAY FROM POWERS OF TEN TABLE
*
{GTN24{BZE{8,WA{6,GTN30{{JUMP IF SCALED{24803
{{LCT{8,WB{18,=CFP$R{{ELSE GET INDEXING FACTOR{24804
{{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{24805
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{24806
*
*      LOOP TO POINT TO POWERS OF TEN TABLE ENTRY
*
{GTN25{ADD{8,WA{7,XR{{BUMP POINTER{24810
{{BCT{8,WB{6,GTN25{{ONCE FOR EACH VALUE WORD{24811
{{DVR{9,(XR){{{SCALE DOWN AS REQUIRED{24812
{{BRN{6,GTN30{{{AND JUMP{24813
*
*      COME HERE TO SCALE RESULT UP (POSITIVE EXPONENT)
*
{GTN26{NGI{{{{GET ABSOLUTE VALUE OF EXPONENT{24817
{{IOV{6,GTN36{{{ERROR IF OVERFLOW{24818
{{MFI{8,WA{6,GTN36{{ACQUIRE SCALE, ERROR IF OVFLOW{24819
*
*      LOOP TO SCALE UP IN STEPS OF 10**10
*
{GTN27{BLE{8,WA{18,=NUM10{6,GTN28{JUMP IF 10 OR LESS TO GO{24823
{{MLR{4,REATT{{{ELSE MULTIPLY BY 10**10{24824
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{24825
{{SUB{18,=NUM10{8,WA{{ELSE DECREMENT SCALE{24826
{{BRN{6,GTN27{{{AND LOOP BACK{24827
*
*      HERE TO SCALE UP REST OF WAY WITH TABLE
*
{GTN28{BZE{8,WA{6,GTN30{{JUMP IF SCALED{24831
{{LCT{8,WB{18,=CFP$R{{ELSE GET INDEXING FACTOR{24832
{{MOV{21,=REAV1{7,XR{{POINT TO POWERS OF TEN TABLE{24833
{{WTB{8,WA{{{CONVERT REMAINING SCALE TO BYTE OFS{24834
*
*      LOOP TO POINT TO PROPER ENTRY IN POWERS OF TEN TABLE
*
{GTN29{ADD{8,WA{7,XR{{BUMP POINTER{24838
{{BCT{8,WB{6,GTN29{{ONCE FOR EACH WORD IN VALUE{24839
{{MLR{9,(XR){{{SCALE UP{24840
{{ROV{6,GTN36{{{ERROR IF OVERFLOW{24841
{{EJC{{{{{24842
*
*      GTNUM (CONTINUED)
*
*      HERE WITH REAL VALUE SCALED AND READY EXCEPT FOR SIGN
*
{GTN30{BZE{3,GTNNF{6,GTN31{{JUMP IF POSITIVE{24848
{{NGR{{{{ELSE NEGATE{24849
*
*      HERE WITH PROPERLY SIGNED REAL VALUE IN (RA)
*
{GTN31{JSR{6,RCBLD{{{BUILD REAL BLOCK{24853
{{BRN{6,GTN33{{{MERGE TO EXIT{24854
*
*      HERE WITH PROPERLY SIGNED INTEGER VALUE IN (IA)
*
{GTN32{JSR{6,ICBLD{{{BUILD ICBLK{24859
*
*      REAL MERGES HERE
*
{GTN33{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF RESULT BLOCK{24863
{{ICA{7,XS{{{POP ARGUMENT OFF STACK{24864
*
*      COMMON EXIT POINT
*
{GTN34{EXI{{{{RETURN TO GTNUM CALLER{24868
*
*      COME HERE IF OVERFLOW OCCURS DURING COLLECTION OF INTEGER
*      HAVE TO RESTORE WB WHICH CVM MAY HAVE DESTROYED.
*
{GTN35{LCH{8,WB{11,-(XR){{RELOAD CURRENT CHARACTER{24875
{{LCH{8,WB{10,(XR)+{{BUMP CHARACTER POINTER{24876
{{LDI{3,GTNSI{{{RELOAD INTEGER SO FAR{24877
{{ITR{{{{CONVERT TO REAL{24878
{{NGR{{{{MAKE VALUE POSITIVE{24879
{{BRN{6,GTN11{{{MERGE WITH REAL CIRCUIT{24880
*
*      HERE FOR UNCONVERTIBLE TO STRING OR CONVERSION ERROR
*
{GTN36{MOV{10,(XS)+{7,XR{{RELOAD ORIGINAL ARGUMENT{24885
{{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{24886
{{ENP{{{{END PROCEDURE GTNUM{24887
{{EJC{{{{{24888
*
*      GTNVR -- CONVERT TO NATURAL VARIABLE
*
*      GTNVR LOCATES A VARIABLE BLOCK (VRBLK) GIVEN EITHER AN
*      APPROPRIATE NAME (NMBLK) OR A NON-NULL STRING (SCBLK).
*
*      (XR)                  ARGUMENT
*      JSR  GTNVR            CALL TO CONVERT TO NATURAL VARIABLE
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO VRBLK
*      (WA,WB)               DESTROYED (CONVERSION ERROR ONLY)
*      (WC)                  DESTROYED
*
{GTNVR{PRC{25,E{1,1{{ENTRY POINT{24902
{{BNE{9,(XR){22,=B$NML{6,GNV02{JUMP IF NOT NAME{24903
{{MOV{13,NMBAS(XR){7,XR{{ELSE LOAD NAME BASE IF NAME{24904
{{BLO{7,XR{3,STATE{6,GNV07{SKIP IF VRBLK (IN STATIC REGION){24905
*
*      COMMON ERROR EXIT
*
{GNV01{EXI{1,1{{{TAKE CONVERT-ERROR EXIT{24909
*
*      HERE IF NOT NAME
*
{GNV02{MOV{8,WA{3,GNVSA{{SAVE WA{24913
{{MOV{8,WB{3,GNVSB{{SAVE WB{24914
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{24915
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{24916
{{PPM{6,GNV01{{{JUMP IF CONVERSION ERROR{24917
{{BZE{8,WA{6,GNV01{{NULL STRING IS AN ERROR{24918
{{JSR{6,FLSTG{{{FOLD LOWER CASE TO UPPER CASE{24920
{{MOV{7,XL{11,-(XS){{SAVE XL{24922
{{MOV{7,XR{11,-(XS){{STACK STRING PTR FOR LATER{24923
{{MOV{7,XR{8,WB{{COPY STRING POINTER{24924
{{ADD{19,*SCHAR{8,WB{{POINT TO CHARACTERS OF STRING{24925
{{MOV{8,WB{3,GNVST{{SAVE POINTER TO CHARACTERS{24926
{{MOV{8,WA{8,WB{{COPY LENGTH{24927
{{CTW{8,WB{1,0{{GET NUMBER OF WORDS IN NAME{24928
{{MOV{8,WB{3,GNVNW{{SAVE FOR LATER{24929
{{JSR{6,HASHS{{{COMPUTE HASH INDEX FOR STRING{24930
{{RMI{3,HSHNB{{{COMPUTE HASH OFFSET BY TAKING MOD{24931
{{MFI{8,WC{{{GET AS OFFSET{24932
{{WTB{8,WC{{{CONVERT OFFSET TO BYTES{24933
{{ADD{3,HSHTB{8,WC{{POINT TO PROPER HASH CHAIN{24934
{{SUB{19,*VRNXT{8,WC{{SUBTRACT OFFSET TO MERGE INTO LOOP{24935
{{EJC{{{{{24936
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH HASH CHAIN
*
{GNV03{MOV{8,WC{7,XL{{COPY HASH CHAIN POINTER{24942
{{MOV{13,VRNXT(XL){7,XL{{POINT TO NEXT VRBLK ON CHAIN{24943
{{BZE{7,XL{6,GNV08{{JUMP IF END OF CHAIN{24944
{{MOV{7,XL{8,WC{{SAVE POINTER TO THIS VRBLK{24945
{{BNZ{13,VRLEN(XL){6,GNV04{{JUMP IF NOT SYSTEM VARIABLE{24946
{{MOV{13,VRSVP(XL){7,XL{{ELSE POINT TO SVBLK{24947
{{SUB{19,*VRSOF{7,XL{{ADJUST OFFSET FOR MERGE{24948
*
*      MERGE HERE WITH STRING PTR (LIKE VRBLK) IN XL
*
{GNV04{BNE{8,WA{13,VRLEN(XL){6,GNV03{BACK FOR NEXT VRBLK IF LENGTHS NE{24952
{{ADD{19,*VRCHS{7,XL{{ELSE POINT TO CHARS OF CHAIN ENTRY{24953
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{24954
{{MOV{3,GNVST{7,XR{{POINT TO CHARS OF NEW NAME{24955
*
*      LOOP TO COMPARE CHARACTERS OF THE TWO NAMES
*
{GNV05{CNE{9,(XR){9,(XL){6,GNV03{JUMP IF NO MATCH FOR NEXT VRBLK{24959
{{ICA{7,XR{{{BUMP NEW NAME POINTER{24960
{{ICA{7,XL{{{BUMP VRBLK IN CHAIN NAME POINTER{24961
{{BCT{8,WB{6,GNV05{{ELSE LOOP TILL ALL COMPARED{24962
{{MOV{8,WC{7,XR{{WE HAVE FOUND A MATCH, GET VRBLK{24963
*
*      EXIT POINT AFTER FINDING VRBLK OR BUILDING NEW ONE
*
{GNV06{MOV{3,GNVSA{8,WA{{RESTORE WA{24967
{{MOV{3,GNVSB{8,WB{{RESTORE WB{24968
{{ICA{7,XS{{{POP STRING POINTER{24969
{{MOV{10,(XS)+{7,XL{{RESTORE XL{24970
*
*      COMMON EXIT POINT
*
{GNV07{EXI{{{{RETURN TO GTNVR CALLER{24974
*
*      NOT FOUND, PREPARE TO SEARCH SYSTEM VARIABLE TABLE
*
{GNV08{ZER{7,XR{{{CLEAR GARBAGE XR POINTER{24978
{{MOV{8,WC{3,GNVHE{{SAVE PTR TO END OF HASH CHAIN{24979
{{BGT{8,WA{18,=NUM09{6,GNV14{CANNOT BE SYSTEM VAR IF LENGTH GT 9{24980
{{MOV{8,WA{7,XL{{ELSE COPY LENGTH{24981
{{WTB{7,XL{{{CONVERT TO BYTE OFFSET{24982
{{MOV{14,VSRCH(XL){7,XL{{POINT TO FIRST SVBLK OF THIS LENGTH{24983
{{EJC{{{{{24984
*
*      GTNVR (CONTINUED)
*
*      LOOP TO SEARCH ENTRIES IN STANDARD VARIABLE TABLE
*
{GNV09{MOV{7,XL{3,GNVSP{{SAVE TABLE POINTER{24990
{{MOV{10,(XL)+{8,WC{{LOAD SVBIT BIT STRING{24991
{{MOV{10,(XL)+{8,WB{{LOAD LENGTH FROM TABLE ENTRY{24992
{{BNE{8,WA{8,WB{6,GNV14{JUMP IF END OF RIGHT LENGTH ENTRIES{24993
{{LCT{8,WB{3,GNVNW{{GET WORD COUNTER TO CONTROL LOOP{24994
{{MOV{3,GNVST{7,XR{{POINT TO CHARS OF NEW NAME{24995
*
*      LOOP TO CHECK FOR MATCHING NAMES
*
{GNV10{CNE{9,(XR){9,(XL){6,GNV11{JUMP IF NAME MISMATCH{24999
{{ICA{7,XR{{{ELSE BUMP NEW NAME POINTER{25000
{{ICA{7,XL{{{BUMP SVBLK POINTER{25001
{{BCT{8,WB{6,GNV10{{ELSE LOOP UNTIL ALL CHECKED{25002
*
*      HERE WE HAVE A MATCH IN THE STANDARD VARIABLE TABLE
*
{{ZER{8,WC{{{SET VRLEN VALUE ZERO{25006
{{MOV{19,*VRSI${8,WA{{SET STANDARD SIZE{25007
{{BRN{6,GNV15{{{JUMP TO BUILD VRBLK{25008
*
*      HERE IF NO MATCH WITH TABLE ENTRY IN SVBLKS TABLE
*
{GNV11{ICA{7,XL{{{BUMP PAST WORD OF CHARS{25012
{{BCT{8,WB{6,GNV11{{LOOP BACK IF MORE TO GO{25013
{{RSH{8,WC{2,SVNBT{{REMOVE UNINTERESTING BITS{25014
*
*      LOOP TO BUMP TABLE PTR FOR EACH FLAGGED WORD
*
{GNV12{MOV{4,BITS1{8,WB{{LOAD BIT TO TEST{25018
{{ANB{8,WC{8,WB{{TEST FOR WORD PRESENT{25019
{{ZRB{8,WB{6,GNV13{{JUMP IF NOT PRESENT{25020
{{ICA{7,XL{{{ELSE BUMP TABLE POINTER{25021
*
*      HERE AFTER DEALING WITH ONE WORD (ONE BIT)
*
{GNV13{RSH{8,WC{1,1{{REMOVE BIT ALREADY PROCESSED{25025
{{NZB{8,WC{6,GNV12{{LOOP BACK IF MORE BITS TO TEST{25026
{{BRN{6,GNV09{{{ELSE LOOP BACK FOR NEXT SVBLK{25027
*
*      HERE IF NOT SYSTEM VARIABLE
*
{GNV14{MOV{8,WA{8,WC{{COPY VRLEN VALUE{25031
{{MOV{18,=VRCHS{8,WA{{LOAD STANDARD SIZE -CHARS{25032
{{ADD{3,GNVNW{8,WA{{ADJUST FOR CHARS OF NAME{25033
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{25034
{{EJC{{{{{25035
*
*      GTNVR (CONTINUED)
*
*      MERGE HERE TO BUILD VRBLK
*
{GNV15{JSR{6,ALOST{{{ALLOCATE SPACE FOR VRBLK (STATIC){25041
{{MOV{7,XR{8,WB{{SAVE VRBLK POINTER{25042
{{MOV{21,=STNVR{7,XL{{POINT TO MODEL VARIABLE BLOCK{25043
{{MOV{19,*VRLEN{8,WA{{SET LENGTH OF STANDARD FIELDS{25044
{{MVW{{{{SET INITIAL FIELDS OF NEW BLOCK{25045
{{MOV{3,GNVHE{7,XL{{LOAD POINTER TO END OF HASH CHAIN{25046
{{MOV{8,WB{13,VRNXT(XL){{ADD NEW BLOCK TO END OF CHAIN{25047
{{MOV{8,WC{10,(XR)+{{SET VRLEN FIELD, BUMP PTR{25048
{{MOV{3,GNVNW{8,WA{{GET LENGTH IN WORDS{25049
{{WTB{8,WA{{{CONVERT TO LENGTH IN BYTES{25050
{{BZE{8,WC{6,GNV16{{JUMP IF SYSTEM VARIABLE{25051
*
*      HERE FOR NON-SYSTEM VARIABLE -- SET CHARS OF NAME
*
{{MOV{9,(XS){7,XL{{POINT BACK TO STRING NAME{25055
{{ADD{19,*SCHAR{7,XL{{POINT TO CHARS OF NAME{25056
{{MVW{{{{MOVE CHARACTERS INTO PLACE{25057
{{MOV{8,WB{7,XR{{RESTORE VRBLK POINTER{25058
{{BRN{6,GNV06{{{JUMP BACK TO EXIT{25059
*
*      HERE FOR SYSTEM VARIABLE CASE TO FILL IN FIELDS WHERE
*      NECESSARY FROM THE FIELDS PRESENT IN THE SVBLK.
*
{GNV16{MOV{3,GNVSP{7,XL{{LOAD POINTER TO SVBLK{25064
{{MOV{7,XL{9,(XR){{SET SVBLK PTR IN VRBLK{25065
{{MOV{8,WB{7,XR{{RESTORE VRBLK POINTER{25066
{{MOV{13,SVBIT(XL){8,WB{{LOAD BIT INDICATORS{25067
{{ADD{19,*SVCHS{7,XL{{POINT TO CHARACTERS OF NAME{25068
{{ADD{8,WA{7,XL{{POINT PAST CHARACTERS{25069
*
*      SKIP PAST KEYWORD NUMBER (SVKNM) IF PRESENT
*
{{MOV{4,BTKNM{8,WC{{LOAD TEST BIT{25073
{{ANB{8,WB{8,WC{{AND TO TEST{25074
{{ZRB{8,WC{6,GNV17{{JUMP IF NO KEYWORD NUMBER{25075
{{ICA{7,XL{{{ELSE BUMP POINTER{25076
{{EJC{{{{{25077
*
*      GTNVR (CONTINUED)
*
*      HERE TEST FOR FUNCTION (SVFNC AND SVNAR)
*
{GNV17{MOV{4,BTFNC{8,WC{{GET TEST BIT{25083
{{ANB{8,WB{8,WC{{AND TO TEST{25084
{{ZRB{8,WC{6,GNV18{{SKIP IF NO SYSTEM FUNCTION{25085
{{MOV{7,XL{13,VRFNC(XR){{ELSE POINT VRFNC TO SVFNC FIELD{25086
{{ADD{19,*NUM02{7,XL{{AND BUMP PAST SVFNC, SVNAR FIELDS{25087
*
*      NOW TEST FOR LABEL (SVLBL)
*
{GNV18{MOV{4,BTLBL{8,WC{{GET TEST BIT{25091
{{ANB{8,WB{8,WC{{AND TO TEST{25092
{{ZRB{8,WC{6,GNV19{{JUMP IF BIT IS OFF (NO SYSTEM LABL){25093
{{MOV{7,XL{13,VRLBL(XR){{ELSE POINT VRLBL TO SVLBL FIELD{25094
{{ICA{7,XL{{{BUMP PAST SVLBL FIELD{25095
*
*      NOW TEST FOR VALUE (SVVAL)
*
{GNV19{MOV{4,BTVAL{8,WC{{LOAD TEST BIT{25099
{{ANB{8,WB{8,WC{{AND TO TEST{25100
{{ZRB{8,WC{6,GNV06{{ALL DONE IF NO VALUE{25101
{{MOV{9,(XL){13,VRVAL(XR){{ELSE SET INITIAL VALUE{25102
{{MOV{22,=B$VRE{13,VRSTO(XR){{SET ERROR STORE ACCESS{25103
{{BRN{6,GNV06{{{MERGE BACK TO EXIT TO CALLER{25104
{{ENP{{{{END PROCEDURE GTNVR{25105
{{EJC{{{{{25106
*
*      GTPAT -- GET PATTERN
*
*      GTPAT IS PASSED AN OBJECT IN (XR) AND RETURNS A
*      PATTERN AFTER PERFORMING ANY NECESSARY CONVERSIONS
*
*      (XR)                  INPUT ARGUMENT
*      JSR  GTPAT            CALL TO CONVERT TO PATTERN
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  RESULTING PATTERN
*      (WA)                  DESTROYED
*      (WB)                  DESTROYED (ONLY ON CONVERT ERROR)
*      (XR)                  UNCHANGED (ONLY ON CONVERT ERROR)
*
{GTPAT{PRC{25,E{1,1{{ENTRY POINT{25121
{{BHI{9,(XR){22,=P$AAA{6,GTPT5{JUMP IF PATTERN ALREADY{25122
*
*      HERE IF NOT PATTERN, TRY FOR STRING
*
{{MOV{8,WB{3,GTPSB{{SAVE WB{25126
{{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{25127
{{JSR{6,GTSTG{{{CONVERT ARGUMENT TO STRING{25128
{{PPM{6,GTPT2{{{JUMP IF IMPOSSIBLE{25129
*
*      HERE WE HAVE A STRING
*
{{BNZ{8,WA{6,GTPT1{{JUMP IF NON-NULL{25133
*
*      HERE FOR NULL STRING. GENERATE POINTER TO NULL PATTERN.
*
{{MOV{21,=NDNTH{7,XR{{POINT TO NOTHEN NODE{25137
{{BRN{6,GTPT4{{{JUMP TO EXIT{25138
{{EJC{{{{{25139
*
*      GTPAT (CONTINUED)
*
*      HERE FOR NON-NULL STRING
*
{GTPT1{MOV{22,=P$STR{8,WB{{LOAD PCODE FOR MULTI-CHAR STRING{25145
{{BNE{8,WA{18,=NUM01{6,GTPT3{JUMP IF MULTI-CHAR STRING{25146
*
*      HERE FOR ONE CHARACTER STRING, SHARE ONE CHARACTER ANY
*
{{PLC{7,XR{{{POINT TO CHARACTER{25150
{{LCH{8,WA{9,(XR){{LOAD CHARACTER{25151
{{MOV{8,WA{7,XR{{SET AS PARM1{25152
{{MOV{22,=P$ANS{8,WB{{POINT TO PCODE FOR 1-CHAR ANY{25153
{{BRN{6,GTPT3{{{JUMP TO BUILD NODE{25154
*
*      HERE IF ARGUMENT IS NOT CONVERTIBLE TO STRING
*
{GTPT2{MOV{22,=P$EXA{8,WB{{SET PCODE FOR EXPRESSION IN CASE{25158
{{BLO{9,(XR){22,=B$E$${6,GTPT3{JUMP TO BUILD NODE IF EXPRESSION{25159
*
*      HERE WE HAVE AN ERROR (CONVERSION IMPOSSIBLE)
*
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25163
*
*      MERGE HERE TO BUILD NODE FOR STRING OR EXPRESSION
*
{GTPT3{JSR{6,PBILD{{{CALL ROUTINE TO BUILD PATTERN NODE{25167
*
*      COMMON EXIT AFTER SUCCESSFUL CONVERSION
*
{GTPT4{MOV{3,GTPSB{8,WB{{RESTORE WB{25171
*
*      MERGE HERE TO EXIT OF NO CONVERSION REQUIRED
*
{GTPT5{EXI{{{{RETURN TO GTPAT CALLER{25175
{{ENP{{{{END PROCEDURE GTPAT{25176
{{EJC{{{{{25179
*
*      GTREA -- GET REAL VALUE
*
*      GTREA IS PASSED AN OBJECT AND RETURNS A REAL VALUE
*      PERFORMING ANY NECESSARY CONVERSIONS.
*
*      (XR)                  OBJECT TO BE CONVERTED
*      JSR  GTREA            CALL TO CONVERT OBJECT TO REAL
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING REAL
*      (WA,WB,WC,RA)         DESTROYED
*      (XR)                  UNCHANGED (CONVERT ERROR ONLY)
*
{GTREA{PRC{25,E{1,1{{ENTRY POINT{25193
{{MOV{9,(XR){8,WA{{GET FIRST WORD OF BLOCK{25194
{{BEQ{8,WA{22,=B$RCL{6,GTRE2{JUMP IF REAL{25195
{{JSR{6,GTNUM{{{ELSE CONVERT ARGUMENT TO NUMERIC{25196
{{PPM{6,GTRE3{{{JUMP IF UNCONVERTIBLE{25197
{{BEQ{8,WA{22,=B$RCL{6,GTRE2{JUMP IF REAL WAS RETURNED{25198
*
*      HERE FOR CASE OF AN INTEGER TO CONVERT TO REAL
*
{GTRE1{LDI{13,ICVAL(XR){{{LOAD INTEGER{25202
{{ITR{{{{CONVERT TO REAL{25203
{{JSR{6,RCBLD{{{BUILD RCBLK{25204
*
*      EXIT WITH REAL
*
{GTRE2{EXI{{{{RETURN TO GTREA CALLER{25208
*
*      HERE ON CONVERSION ERROR
*
{GTRE3{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25212
{{ENP{{{{END PROCEDURE GTREA{25213
{{EJC{{{{{25215
*
*      GTSMI -- GET SMALL INTEGER
*
*      GTSMI IS PASSED A SNOBOL OBJECT AND RETURNS AN ADDRESS
*      INTEGER IN THE RANGE (0 LE N LE DNAMB). SUCH A VALUE CAN
*      ONLY BE DERIVED FROM AN INTEGER IN THE APPROPRIATE RANGE.
*      SMALL INTEGERS NEVER APPEAR AS SNOBOL VALUES. HOWEVER,
*      THEY ARE USED INTERNALLY FOR A VARIETY OF PURPOSES.
*
*      -(XS)                 ARGUMENT TO CONVERT (ON STACK)
*      JSR  GTSMI            CALL TO CONVERT TO SMALL INTEGER
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER
*      PPM  LOC              TRANSFER LOC FOR LT 0, GT DNAMB
*      (XR,WC)               RESULTING SMALL INT (TWO COPIES)
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (WA,WB)               DESTROYED (ON CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSMI{PRC{25,N{1,2{{ENTRY POINT{25235
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT{25236
{{BEQ{9,(XR){22,=B$ICL{6,GTSM1{SKIP IF ALREADY AN INTEGER{25237
*
*      HERE IF NOT AN INTEGER
*
{{JSR{6,GTINT{{{CONVERT ARGUMENT TO INTEGER{25241
{{PPM{6,GTSM2{{{JUMP IF CONVERT IS IMPOSSIBLE{25242
*
*      MERGE HERE WITH INTEGER
*
{GTSM1{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{25246
{{MFI{8,WC{6,GTSM3{{MOVE AS ONE WORD, JUMP IF OVFLOW{25247
{{BGT{8,WC{3,MXLEN{6,GTSM3{OR IF TOO SMALL{25248
{{MOV{8,WC{7,XR{{COPY RESULT TO XR{25249
{{EXI{{{{RETURN TO GTSMI CALLER{25250
*
*      HERE IF UNCONVERTIBLE TO INTEGER
*
{GTSM2{EXI{1,1{{{TAKE NON-INTEGER ERROR EXIT{25254
*
*      HERE IF OUT OF RANGE
*
{GTSM3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{25258
{{ENP{{{{END PROCEDURE GTSMI{25259
{{EJC{{{{{25260
*
*      GTSTG -- GET STRING
*
*      GTSTG IS PASSED AN OBJECT AND RETURNS A STRING WITH
*      ANY NECESSARY CONVERSIONS PERFORMED.
*
*      -(XS)                 INPUT ARGUMENT (ON STACK)
*      JSR  GTSTG            CALL TO CONVERT TO STRING
*      PPM  LOC              TRANSFER LOC IF CONVERT IMPOSSIBLE
*      (XR)                  POINTER TO RESULTING STRING
*      (WA)                  LENGTH OF STRING IN CHARACTERS
*      (XS)                  POPPED
*      (RA)                  DESTROYED
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTSTG{PRC{25,N{1,1{{ENTRY POINT{25326
{{MOV{10,(XS)+{7,XR{{LOAD ARGUMENT, POP STACK{25327
{{BEQ{9,(XR){22,=B$SCL{6,GTS30{JUMP IF ALREADY A STRING{25328
*
*      HERE IF NOT A STRING ALREADY
*
{GTS01{MOV{7,XR{11,-(XS){{RESTACK ARGUMENT IN CASE ERROR{25332
{{MOV{7,XL{11,-(XS){{SAVE XL{25333
{{MOV{8,WB{3,GTSVB{{SAVE WB{25334
{{MOV{8,WC{3,GTSVC{{SAVE WC{25335
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{25336
{{BEQ{8,WA{22,=B$ICL{6,GTS05{JUMP TO CONVERT INTEGER{25337
{{BEQ{8,WA{22,=B$RCL{6,GTS10{JUMP TO CONVERT REAL{25340
{{BEQ{8,WA{22,=B$NML{6,GTS03{JUMP TO CONVERT NAME{25342
*
*      HERE ON CONVERSION ERROR
*
{GTS02{MOV{10,(XS)+{7,XL{{RESTORE XL{25350
{{MOV{10,(XS)+{7,XR{{RELOAD INPUT ARGUMENT{25351
{{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25352
{{EJC{{{{{25353
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A NAME (ONLY POSSIBLE IF NATURAL VAR)
*
{GTS03{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{25359
{{BHI{7,XL{3,STATE{6,GTS02{ERROR IF NOT NATURAL VAR (STATIC){25360
{{ADD{19,*VRSOF{7,XL{{ELSE POINT TO POSSIBLE STRING NAME{25361
{{MOV{13,SCLEN(XL){8,WA{{LOAD LENGTH{25362
{{BNZ{8,WA{6,GTS04{{JUMP IF NOT SYSTEM VARIABLE{25363
{{MOV{13,VRSVO(XL){7,XL{{ELSE POINT TO SVBLK{25364
{{MOV{13,SVLEN(XL){8,WA{{AND LOAD NAME LENGTH{25365
*
*      MERGE HERE WITH STRING IN XR, LENGTH IN WA
*
{GTS04{ZER{8,WB{{{SET OFFSET TO ZERO{25369
{{JSR{6,SBSTR{{{USE SBSTR TO COPY STRING{25370
{{BRN{6,GTS29{{{JUMP TO EXIT{25371
*
*      COME HERE TO CONVERT AN INTEGER
*
{GTS05{LDI{13,ICVAL(XR){{{LOAD INTEGER VALUE{25375
{{MOV{18,=NUM01{3,GTSSF{{SET SIGN FLAG NEGATIVE{25383
{{ILT{6,GTS06{{{SKIP IF INTEGER IS NEGATIVE{25384
{{NGI{{{{ELSE NEGATE INTEGER{25385
{{ZER{3,GTSSF{{{AND RESET NEGATIVE FLAG{25386
{{EJC{{{{{25387
*
*      GTSTG (CONTINUED)
*
*      HERE WITH SIGN FLAG SET AND SIGN FORCED NEGATIVE AS
*      REQUIRED BY THE CVD INSTRUCTION.
*
{GTS06{MOV{3,GTSWK{7,XR{{POINT TO RESULT WORK AREA{25394
{{MOV{18,=NSTMX{8,WB{{INITIALIZE COUNTER TO MAX LENGTH{25395
{{PSC{7,XR{8,WB{{PREPARE TO STORE (RIGHT-LEFT){25396
*
*      LOOP TO CONVERT DIGITS INTO WORK AREA
*
{GTS07{CVD{{{{CONVERT ONE DIGIT INTO WA{25400
{{SCH{8,WA{11,-(XR){{STORE IN WORK AREA{25401
{{DCV{8,WB{{{DECREMENT COUNTER{25402
{{INE{6,GTS07{{{LOOP IF MORE DIGITS TO GO{25403
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25404
*
*      MERGE HERE AFTER CONVERTING INTEGER OR REAL INTO WORK
*      AREA. WB IS SET TO NSTMX - (NUMBER OF CHARS IN RESULT).
*
{GTS08{MOV{18,=NSTMX{8,WA{{GET MAX NUMBER OF CHARACTERS{25410
{{SUB{8,WB{8,WA{{COMPUTE LENGTH OF RESULT{25411
{{MOV{8,WA{7,XL{{REMEMBER LENGTH FOR MOVE LATER ON{25412
{{ADD{3,GTSSF{8,WA{{ADD ONE FOR NEGATIVE SIGN IF NEEDED{25413
{{JSR{6,ALOCS{{{ALLOCATE STRING FOR RESULT{25414
{{MOV{7,XR{8,WC{{SAVE RESULT POINTER FOR THE MOMENT{25415
{{PSC{7,XR{{{POINT TO CHARS OF RESULT BLOCK{25416
{{BZE{3,GTSSF{6,GTS09{{SKIP IF POSITIVE{25417
{{MOV{18,=CH$MN{8,WA{{ELSE LOAD NEGATIVE SIGN{25418
{{SCH{8,WA{10,(XR)+{{AND STORE IT{25419
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{25420
*
*      HERE AFTER DEALING WITH SIGN
*
{GTS09{MOV{7,XL{8,WA{{RECALL LENGTH TO MOVE{25424
{{MOV{3,GTSWK{7,XL{{POINT TO RESULT WORK AREA{25425
{{PLC{7,XL{8,WB{{POINT TO FIRST RESULT CHARACTER{25426
{{MVC{{{{MOVE CHARS TO RESULT STRING{25427
{{MOV{8,WC{7,XR{{RESTORE RESULT POINTER{25428
{{BRN{6,GTS29{{{JUMP TO EXIT{25431
{{EJC{{{{{25432
*
*      GTSTG (CONTINUED)
*
*      HERE TO CONVERT A REAL
*
{GTS10{LDR{13,RCVAL(XR){{{LOAD REAL{25438
{{MOV{18,=NSTMR{8,WA{{MAX NUMBER OF RESULT CHARS{25440
{{ZER{7,XL{{{CLEAR DUD VALUE{25441
{{JSR{6,ALOCS{{{ALLOCATE RESULT AREA{25442
{{MOV{18,=CFP$S{8,WA{{SIGNIFICANT DIGITS TO PRODUCE{25443
{{ZER{8,WB{{{CONVERSION TYPE{25444
{{JSR{6,SYSCR{{{CONVERT REAL TO STRING{25445
{{MOV{8,WA{13,SCLEN(XR){{STORE RESULT SIZE{25446
{{ZER{8,WB{{{NO TRAILING BLANKS TO REMOVE{25447
{{JSR{6,TRIMR{{{DISCARD EXCESS MEMORY{25448
*
*      EXIT POINT AFTER SUCCESSFUL CONVERSION
*
{GTS29{MOV{10,(XS)+{7,XL{{RESTORE XL{25641
{{ICA{7,XS{{{POP ARGUMENT{25642
{{MOV{3,GTSVB{8,WB{{RESTORE WB{25643
{{MOV{3,GTSVC{8,WC{{RESTORE WC{25644
*
*      MERGE HERE IF NO CONVERSION REQUIRED
*
{GTS30{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{25648
{{EXI{{{{RETURN TO CALLER{25649
*
*      HERE TO RETURN STRING FOR REAL ZERO
*
{GTS31{MOV{21,=SCRE0{7,XL{{POINT TO STRING{25655
{{MOV{18,=NUM02{8,WA{{2 CHARS{25656
{{ZER{8,WB{{{ZERO OFFSET{25657
{{JSR{6,SBSTR{{{COPY STRING{25658
{{BRN{6,GTS29{{{RETURN{25659
{{ENP{{{{END PROCEDURE GTSTG{25686
{{EJC{{{{{25687
*
*      GTVAR -- GET VARIABLE FOR I/O/TRACE ASSOCIATION
*
*      GTVAR IS USED TO POINT TO AN ACTUAL VARIABLE LOCATION
*      FOR THE DETACH,INPUT,OUTPUT,TRACE,STOPTR SYSTEM FUNCTIONS
*
*      (XR)                  ARGUMENT TO FUNCTION
*      JSR  GTVAR            CALL TO LOCATE VARIABLE POINTER
*      PPM  LOC              TRANSFER LOC IF NOT OK VARIABLE
*      (XL,WA)               NAME BASE,OFFSET OF VARIABLE
*      (XR,RA)               DESTROYED
*      (WB,WC)               DESTROYED (CONVERT ERROR ONLY)
*      (XR)                  INPUT ARG (CONVERT ERROR ONLY)
*
{GTVAR{PRC{25,E{1,1{{ENTRY POINT{25702
{{BNE{9,(XR){22,=B$NML{6,GTVR2{JUMP IF NOT A NAME{25703
{{MOV{13,NMOFS(XR){8,WA{{ELSE LOAD NAME OFFSET{25704
{{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{25705
{{BEQ{9,(XL){22,=B$EVT{6,GTVR1{ERROR IF EXPRESSION VARIABLE{25706
{{BNE{9,(XL){22,=B$KVT{6,GTVR3{ALL OK IF NOT KEYWORD VARIABLE{25707
*
*      HERE ON CONVERSION ERROR
*
{GTVR1{EXI{1,1{{{TAKE CONVERT ERROR EXIT{25711
*
*      HERE IF NOT A NAME, TRY CONVERT TO NATURAL VARIABLE
*
{GTVR2{MOV{8,WC{3,GTVRC{{SAVE WC{25715
{{JSR{6,GTNVR{{{LOCATE VRBLK IF POSSIBLE{25716
{{PPM{6,GTVR1{{{JUMP IF CONVERT ERROR{25717
{{MOV{7,XR{7,XL{{ELSE COPY VRBLK NAME BASE{25718
{{MOV{19,*VRVAL{8,WA{{AND SET OFFSET{25719
{{MOV{3,GTVRC{8,WC{{RESTORE WC{25720
*
*      HERE FOR NAME OBTAINED
*
{GTVR3{BHI{7,XL{3,STATE{6,GTVR4{ALL OK IF NOT NATURAL VARIABLE{25724
{{BEQ{13,VRSTO(XL){22,=B$VRE{6,GTVR1{ERROR IF PROTECTED VARIABLE{25725
*
*      COMMON EXIT POINT
*
{GTVR4{EXI{{{{RETURN TO CALLER{25729
{{ENP{{{{END PROCEDURE GTVAR{25730
{{EJC{{{{{25731
*
*      HASHS -- COMPUTE HASH INDEX FOR STRING
*
*      HASHS IS USED TO CONVERT A STRING TO A UNIQUE INTEGER
*      VALUE. THE RESULTING HASH VALUE IS A POSITIVE INTEGER
*      IN THE RANGE 0 TO CFP$M
*
*      (XR)                  STRING TO BE HASHED
*      JSR  HASHS            CALL TO HASH STRING
*      (IA)                  HASH VALUE
*      (XR,WB,WC)            DESTROYED
*
*      THE HASH FUNCTION USED IS AS FOLLOWS.
*
*      START WITH THE LENGTH OF THE STRING (SGD07)
*
*      TAKE THE FIRST E$HNW WORDS OF THE CHARACTERS FROM
*      THE STRING OR ALL THE WORDS IF FEWER THAN E$HNW.
*
*      COMPUTE THE EXCLUSIVE OR OF ALL THESE WORDS TREATING
*      THEM AS ONE WORD BIT STRING VALUES.
*
*      MOVE THE RESULT AS AN INTEGER WITH THE MTI INSTRUCTION.
*
{HASHS{PRC{25,E{1,0{{ENTRY POINT{25756
{{MOV{13,SCLEN(XR){8,WC{{LOAD STRING LENGTH IN CHARACTERS{25757
{{MOV{8,WC{8,WB{{INITIALIZE WITH LENGTH{25758
{{BZE{8,WC{6,HSHS3{{JUMP IF NULL STRING{25759
{{ZGB{8,WB{{{CORRECT BYTE ORDERING IF NECESSARY{25760
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS OF CHARS{25761
{{ADD{19,*SCHAR{7,XR{{POINT TO CHARACTERS OF STRING{25762
{{BLO{8,WC{18,=E$HNW{6,HSHS1{USE WHOLE STRING IF SHORT{25763
{{MOV{18,=E$HNW{8,WC{{ELSE SET TO INVOLVE FIRST E$HNW WDS{25764
*
*      HERE WITH COUNT OF WORDS TO CHECK IN WC
*
{HSHS1{LCT{8,WC{8,WC{{SET COUNTER TO CONTROL LOOP{25768
*
*      LOOP TO COMPUTE EXCLUSIVE OR
*
{HSHS2{XOB{10,(XR)+{8,WB{{EXCLUSIVE OR NEXT WORD OF CHARS{25772
{{BCT{8,WC{6,HSHS2{{LOOP TILL ALL PROCESSED{25773
*
*      MERGE HERE WITH EXCLUSIVE OR IN WB
*
{HSHS3{ZGB{8,WB{{{ZEROISE UNDEFINED BITS{25777
{{ANB{4,BITSM{8,WB{{ENSURE IN RANGE 0 TO CFP$M{25778
{{MTI{8,WB{{{MOVE RESULT AS INTEGER{25779
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{25780
{{EXI{{{{RETURN TO HASHS CALLER{25781
{{ENP{{{{END PROCEDURE HASHS{25782
{{EJC{{{{{25783
*
*      ICBLD -- BUILD INTEGER BLOCK
*
*      (IA)                  INTEGER VALUE FOR ICBLK
*      JSR  ICBLD            CALL TO BUILD INTEGER BLOCK
*      (XR)                  POINTER TO RESULT ICBLK
*      (WA)                  DESTROYED
*
{ICBLD{PRC{25,E{1,0{{ENTRY POINT{25792
{{MFI{7,XR{6,ICBL1{{COPY SMALL INTEGERS{25793
{{BLE{7,XR{18,=NUM02{6,ICBL3{JUMP IF 0,1 OR 2{25794
*
*      CONSTRUCT ICBLK
*
{ICBL1{MOV{3,DNAMP{7,XR{{LOAD POINTER TO NEXT AVAILABLE LOC{25798
{{ADD{19,*ICSI${7,XR{{POINT PAST NEW ICBLK{25799
{{BLO{7,XR{3,DNAME{6,ICBL2{JUMP IF THERE IS ROOM{25800
{{MOV{19,*ICSI${8,WA{{ELSE LOAD LENGTH OF ICBLK{25801
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{25802
{{ADD{8,WA{7,XR{{POINT PAST BLOCK TO MERGE{25803
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{ICBL2{MOV{7,XR{3,DNAMP{{SET NEW POINTER{25807
{{SUB{19,*ICSI${7,XR{{POINT BACK TO START OF BLOCK{25808
{{MOV{22,=B$ICL{9,(XR){{STORE TYPE WORD{25809
{{STI{13,ICVAL(XR){{{STORE INTEGER VALUE IN ICBLK{25810
{{EXI{{{{RETURN TO ICBLD CALLER{25811
*
*      OPTIMISE BY NOT BUILDING ICBLKS FOR SMALL INTEGERS
*
{ICBL3{WTB{7,XR{{{CONVERT INTEGER TO OFFSET{25815
{{MOV{14,INTAB(XR){7,XR{{POINT TO PRE-BUILT ICBLK{25816
{{EXI{{{{RETURN{25817
{{ENP{{{{END PROCEDURE ICBLD{25818
{{EJC{{{{{25819
*
*      IDENT -- COMPARE TWO VALUES
*
*      IDENT COMPARES TWO VALUES IN THE SENSE OF THE IDENT
*      DIFFER FUNCTIONS AVAILABLE AT THE SNOBOL LEVEL.
*
*      (XR)                  FIRST ARGUMENT
*      (XL)                  SECOND ARGUMENT
*      JSR  IDENT            CALL TO COMPARE ARGUMENTS
*      PPM  LOC              TRANSFER LOC IF IDENT
*      (NORMAL RETURN IF DIFFER)
*      (XR,XL,WC,RA)         DESTROYED
*
{IDENT{PRC{25,E{1,1{{ENTRY POINT{25833
{{BEQ{7,XR{7,XL{6,IDEN7{JUMP IF SAME POINTER (IDENT){25834
{{MOV{9,(XR){8,WC{{ELSE LOAD ARG 1 TYPE WORD{25835
{{BNE{8,WC{9,(XL){6,IDEN1{DIFFER IF ARG 2 TYPE WORD DIFFER{25837
{{BEQ{8,WC{22,=B$SCL{6,IDEN2{JUMP IF STRINGS{25841
{{BEQ{8,WC{22,=B$ICL{6,IDEN4{JUMP IF INTEGERS{25842
{{BEQ{8,WC{22,=B$RCL{6,IDEN5{JUMP IF REALS{25845
{{BEQ{8,WC{22,=B$NML{6,IDEN6{JUMP IF NAMES{25847
*
*      FOR ALL OTHER DATATYPES, MUST BE DIFFER IF XR NE XL
*
*      MERGE HERE FOR DIFFER
*
{IDEN1{EXI{{{{TAKE DIFFER EXIT{25890
*
*      HERE FOR STRINGS, IDENT ONLY IF LENGTHS AND CHARS SAME
*
{IDEN2{MOV{13,SCLEN(XR){8,WC{{LOAD ARG 1 LENGTH{25894
{{BNE{8,WC{13,SCLEN(XL){6,IDEN1{DIFFER IF LENGTHS DIFFER{25895
*
*      BUFFER AND STRING COMPARISONS MERGE HERE
*
{IDN2A{ADD{19,*SCHAR{7,XR{{POINT TO CHARS OF ARG 1{25899
{{ADD{19,*SCHAR{7,XL{{POINT TO CHARS OF ARG 2{25900
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN STRINGS{25901
{{LCT{8,WC{8,WC{{SET LOOP COUNTER{25902
*
*      LOOP TO COMPARE CHARACTERS. NOTE THAT WC CANNOT BE ZERO
*      SINCE ALL NULL STRINGS POINT TO NULLS AND GIVE XL=XR.
*
{IDEN3{CNE{9,(XR){9,(XL){6,IDEN8{DIFFER IF CHARS DO NOT MATCH{25907
{{ICA{7,XR{{{ELSE BUMP ARG ONE POINTER{25908
{{ICA{7,XL{{{BUMP ARG TWO POINTER{25909
{{BCT{8,WC{6,IDEN3{{LOOP BACK TILL ALL CHECKED{25910
{{EJC{{{{{25911
*
*      IDENT (CONTINUED)
*
*      HERE TO EXIT FOR CASE OF TWO IDENT STRINGS
*
{{ZER{7,XL{{{CLEAR GARBAGE VALUE IN XL{25917
{{ZER{7,XR{{{CLEAR GARBAGE VALUE IN XR{25918
{{EXI{1,1{{{TAKE IDENT EXIT{25919
*
*      HERE FOR INTEGERS, IDENT IF SAME VALUES
*
{IDEN4{LDI{13,ICVAL(XR){{{LOAD ARG 1{25923
{{SBI{13,ICVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{25924
{{IOV{6,IDEN1{{{DIFFER IF OVERFLOW{25925
{{INE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{25926
{{EXI{1,1{{{TAKE IDENT EXIT{25927
*
*      HERE FOR REALS, IDENT IF SAME VALUES
*
{IDEN5{LDR{13,RCVAL(XR){{{LOAD ARG 1{25933
{{SBR{13,RCVAL(XL){{{SUBTRACT ARG 2 TO COMPARE{25934
{{ROV{6,IDEN1{{{DIFFER IF OVERFLOW{25935
{{RNE{6,IDEN1{{{DIFFER IF RESULT IS NOT ZERO{25936
{{EXI{1,1{{{TAKE IDENT EXIT{25937
*
*      HERE FOR NAMES, IDENT IF BASES AND OFFSETS SAME
*
{IDEN6{BNE{13,NMOFS(XR){13,NMOFS(XL){6,IDEN1{DIFFER IF DIFFERENT OFFSET{25942
{{BNE{13,NMBAS(XR){13,NMBAS(XL){6,IDEN1{DIFFER IF DIFFERENT BASE{25943
*
*      MERGE HERE TO SIGNAL IDENT FOR IDENTICAL POINTERS
*
{IDEN7{EXI{1,1{{{TAKE IDENT EXIT{25947
*
*      HERE FOR DIFFER STRINGS
*
{IDEN8{ZER{7,XR{{{CLEAR GARBAGE PTR IN XR{25951
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{25952
{{EXI{{{{RETURN TO CALLER (DIFFER){25953
{{ENP{{{{END PROCEDURE IDENT{25954
{{EJC{{{{{25955
*
*      INOUT - USED TO INITIALISE INPUT AND OUTPUT VARIABLES
*
*      (XL)                  POINTER TO VBL NAME STRING
*      (WB)                  TRBLK TYPE
*      JSR  INOUT            CALL TO PERFORM INITIALISATION
*      (XL)                  VRBLK PTR
*      (XR)                  TRBLK PTR
*      (WA,WC)               DESTROYED
*
*      NOTE THAT TRTER (= TRTRF) FIELD OF STANDARD I/O VARIABLES
*      POINTS TO CORRESPONDING SVBLK NOT TO A TRBLK AS IS THE
*      CASE FOR ORDINARY VARIABLES.
*
{INOUT{PRC{25,E{1,0{{ENTRY POINT{25970
{{MOV{8,WB{11,-(XS){{STACK TRBLK TYPE{25971
{{MOV{13,SCLEN(XL){8,WA{{GET NAME LENGTH{25972
{{ZER{8,WB{{{POINT TO START OF NAME{25973
{{JSR{6,SBSTR{{{BUILD A PROPER SCBLK{25974
{{JSR{6,GTNVR{{{BUILD VRBLK{25975
{{PPM{{{{NO ERROR RETURN{25976
{{MOV{7,XR{8,WC{{SAVE VRBLK POINTER{25977
{{MOV{10,(XS)+{8,WB{{GET TRTER FIELD{25978
{{ZER{7,XL{{{ZERO TRFPT{25979
{{JSR{6,TRBLD{{{BUILD TRBLK{25980
{{MOV{8,WC{7,XL{{RECALL VRBLK POINTER{25981
{{MOV{13,VRSVP(XL){13,TRTER(XR){{STORE SVBLK POINTER{25982
{{MOV{7,XR{13,VRVAL(XL){{STORE TRBLK PTR IN VRBLK{25983
{{MOV{22,=B$VRA{13,VRGET(XL){{SET TRAPPED ACCESS{25984
{{MOV{22,=B$VRV{13,VRSTO(XL){{SET TRAPPED STORE{25985
{{EXI{{{{RETURN TO CALLER{25986
{{ENP{{{{END PROCEDURE INOUT{25987
{{EJC{{{{{25988
*
*      INSTA - USED TO INITIALIZE STRUCTURES IN STATIC REGION
*
*      (XR)                  POINTER TO STARTING STATIC LOCATION
*      JSR  INSTA            CALL TO INITIALIZE STATIC STRUCTURE
*      (XR)                  PTR TO NEXT FREE STATIC LOCATION
*      (WA,WB,WC)            DESTROYED
*
*      NOTE THAT THIS PROCEDURE ESTABLISHES THE POINTERS
*      PRBUF, GTSWK, AND KVALP.
*
{INSTA{PRC{25,E{1,0{{ENTRY POINT{26167
*
*      INITIALIZE PRINT BUFFER WITH BLANK WORDS
*
{{MOV{3,PRLEN{8,WC{{NO. OF CHARS IN PRINT BFR{26171
{{MOV{7,XR{3,PRBUF{{PRINT BFR IS PUT AT STATIC START{26172
{{MOV{22,=B$SCL{10,(XR)+{{STORE STRING TYPE CODE{26173
{{MOV{8,WC{10,(XR)+{{AND STRING LENGTH{26174
{{CTW{8,WC{1,0{{GET NUMBER OF WORDS IN BUFFER{26175
{{MOV{8,WC{3,PRLNW{{STORE FOR BUFFER CLEAR{26176
{{LCT{8,WC{8,WC{{WORDS TO CLEAR{26177
*
*      LOOP TO CLEAR BUFFER
*
{INST1{MOV{4,NULLW{10,(XR)+{{STORE BLANK{26181
{{BCT{8,WC{6,INST1{{LOOP{26182
*
*      ALLOCATE WORK AREA FOR GTSTG CONVERSION PROCEDURE
*
{{MOV{18,=NSTMX{8,WA{{GET MAX NUM CHARS IN OUTPUT NUMBER{26186
{{CTB{8,WA{2,SCSI${{NO OF BYTES NEEDED{26187
{{MOV{7,XR{3,GTSWK{{STORE BFR ADRS{26188
{{ADD{8,WA{7,XR{{BUMP FOR WORK BFR{26189
*
*      BUILD ALPHABET STRING FOR ALPHABET KEYWORD AND REPLACE
*
{{MOV{7,XR{3,KVALP{{SAVE ALPHABET POINTER{26193
{{MOV{22,=B$SCL{9,(XR){{STRING BLK TYPE{26194
{{MOV{18,=CFP$A{8,WC{{NO OF CHARS IN ALPHABET{26195
{{MOV{8,WC{13,SCLEN(XR){{STORE AS STRING LENGTH{26196
{{MOV{8,WC{8,WB{{COPY CHAR COUNT{26197
{{CTB{8,WB{2,SCSI${{NO. OF BYTES NEEDED{26198
{{ADD{7,XR{8,WB{{CURRENT END ADDRESS FOR STATIC{26199
{{MOV{8,WB{8,WA{{SAVE ADRS PAST ALPHABET STRING{26200
{{LCT{8,WC{8,WC{{LOOP COUNTER{26201
{{PSC{7,XR{{{POINT TO CHARS OF STRING{26202
{{ZER{8,WB{{{SET INITIAL CHARACTER VALUE{26203
*
*      LOOP TO ENTER CHARACTER CODES IN ORDER
*
{INST2{SCH{8,WB{10,(XR)+{{STORE NEXT CODE{26207
{{ICV{8,WB{{{BUMP CODE VALUE{26208
{{BCT{8,WC{6,INST2{{LOOP TILL ALL STORED{26209
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{26210
{{MOV{8,WA{7,XR{{RETURN CURRENT STATIC PTR{26211
{{EXI{{{{RETURN TO CALLER{26212
{{ENP{{{{END PROCEDURE INSTA{26213
{{EJC{{{{{26214
*
*      IOFCB -- GET INPUT/OUTPUT FCBLK POINTER
*
*      USED BY ENDFILE, EJECT AND REWIND TO FIND THE FCBLK
*      (IF ANY) CORRESPONDING TO THEIR ARGUMENT.
*
*      -(XS)                 ARGUMENT
*      JSR  IOFCB            CALL TO FIND FCBLK
*      PPM  LOC              ARG IS AN UNSUITABLE NAME
*      PPM  LOC              ARG IS NULL STRING
*      PPM  LOC              ARG FILE NOT FOUND
*      (XS)                  POPPED
*      (XL)                  PTR TO FILEARG1 VRBLK
*      (XR)                  ARGUMENT
*      (WA)                  FCBLK PTR OR 0
*      (WB,WC)               DESTROYED
*
{IOFCB{PRC{25,N{1,3{{ENTRY POINT{26232
{{JSR{6,GTSTG{{{GET ARG AS STRING{26233
{{PPM{6,IOFC2{{{FAIL{26234
{{MOV{7,XR{7,XL{{COPY STRING PTR{26235
{{JSR{6,GTNVR{{{GET AS NATURAL VARIABLE{26236
{{PPM{6,IOFC3{{{FAIL IF NULL{26237
{{MOV{7,XL{8,WB{{COPY STRING POINTER AGAIN{26238
{{MOV{7,XR{7,XL{{COPY VRBLK PTR FOR RETURN{26239
{{ZER{8,WA{{{IN CASE NO TRBLK FOUND{26240
*
*      LOOP TO FIND FILE ARG1 TRBLK
*
{IOFC1{MOV{13,VRVAL(XR){7,XR{{GET POSSIBLE TRBLK PTR{26244
{{BNE{9,(XR){22,=B$TRT{6,IOFC4{FAIL IF END OF CHAIN{26245
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOFC1{LOOP IF NOT FILE ARG TRBLK{26246
{{MOV{13,TRFPT(XR){8,WA{{GET FCBLK PTR{26247
{{MOV{8,WB{7,XR{{COPY ARG{26248
{{EXI{{{{RETURN{26249
*
*      FAIL RETURN
*
{IOFC2{EXI{1,1{{{FAIL{26253
*
*      NULL ARG
*
{IOFC3{EXI{1,2{{{NULL ARG RETURN{26257
*
*      FILE NOT FOUND
*
{IOFC4{EXI{1,3{{{FILE NOT FOUND RETURN{26261
{{ENP{{{{END PROCEDURE IOFCB{26262
{{EJC{{{{{26263
*
*      IOPPF -- PROCESS FILEARG2 FOR IOPUT
*
*      (R$XSC)               FILEARG2 PTR
*      JSR  IOPPF            CALL TO PROCESS FILEARG2
*      (XL)                  FILEARG1 PTR
*      (XR)                  FILE ARG2 PTR
*      -(XS)...-(XS)         FIELDS EXTRACTED FROM FILEARG2
*      (WC)                  NO. OF FIELDS EXTRACTED
*      (WB)                  INPUT/OUTPUT FLAG
*      (WA)                  FCBLK PTR OR 0
*
{IOPPF{PRC{25,N{1,0{{ENTRY POINT{26276
{{ZER{8,WB{{{TO COUNT FIELDS EXTRACTED{26277
*
*      LOOP TO EXTRACT FIELDS
*
{IOPP1{MOV{18,=IODEL{7,XL{{GET DELIMITER{26281
{{MOV{7,XL{8,WC{{COPY IT{26282
{{ZER{8,WA{{{RETAIN LEADING BLANKS IN FILEARG2{26283
{{JSR{6,XSCAN{{{GET NEXT FIELD{26284
{{MOV{7,XR{11,-(XS){{STACK IT{26285
{{ICV{8,WB{{{INCREMENT COUNT{26286
{{BNZ{8,WA{6,IOPP1{{LOOP{26287
{{MOV{8,WB{8,WC{{COUNT OF FIELDS{26288
{{MOV{3,IOPTT{8,WB{{I/O MARKER{26289
{{MOV{3,R$IOF{8,WA{{FCBLK PTR OR 0{26290
{{MOV{3,R$IO2{7,XR{{FILE ARG2 PTR{26291
{{MOV{3,R$IO1{7,XL{{FILEARG1{26292
{{EXI{{{{RETURN{26293
{{ENP{{{{END PROCEDURE IOPPF{26294
{{EJC{{{{{26295
*
*      IOPUT -- ROUTINE USED BY INPUT AND OUTPUT
*
*      IOPUT SETS UP INPUT/OUTPUT  ASSOCIATIONS. IT BUILDS
*      SUCH TRACE AND FILE CONTROL BLOCKS AS ARE NECESSARY AND
*      CALLS SYSFC,SYSIO TO PERFORM CHECKS ON THE
*      ARGUMENTS AND TO OPEN THE FILES.
*
*         +-----------+   +---------------+       +-----------+
*      +-.I           I   I               I------.I   =B$XRT  I
*      I  +-----------+   +---------------+       +-----------+
*      I  /           /        (R$FCB)            I    *4     I
*      I  /           /                           +-----------+
*      I  +-----------+   +---------------+       I           I-
*      I  I   NAME    +--.I    =B$TRT     I       +-----------+
*      I  /           /   +---------------+       I           I
*      I   (FIRST ARG)    I =TRTIN/=TRTOU I       +-----------+
*      I                  +---------------+             I
*      I                  I     VALUE     I             I
*      I                  +---------------+             I
*      I                  I(TRTRF) 0   OR I--+          I
*      I                  +---------------+  I          I
*      I                  I(TRFPT) 0   OR I----+        I
*      I                  +---------------+  I I        I
*      I                     (I/O TRBLK)     I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+                      I I        I
*      I  I           I                      I I        I
*      I  +-----------+   +---------------+  I I        I
*      I  I           +--.I    =B$TRT     I.-+ I        I
*      I  +-----------+   +---------------+    I        I
*      I  /           /   I    =TRTFC     I    I        I
*      I  /           /   +---------------+    I        I
*      I    (FILEARG1     I     VALUE     I    I        I
*      I         VRBLK)   +---------------+    I        I
*      I                  I(TRTRF) 0   OR I--+ I        .
*      I                  +---------------+  I .  +-----------+
*      I                  I(TRFPT) 0   OR I------./   FCBLK   /
*      I                  +---------------+  I    +-----------+
*      I                       (TRTRF)       I
*      I                                     I
*      I                                     I
*      I                  +---------------+  I
*      I                  I    =B$XRT     I.-+
*      I                  +---------------+
*      I                  I      *5       I
*      I                  +---------------+
*      +------------------I               I
*                         +---------------+       +-----------+
*                         I(TRTRF) O   OR I------.I  =B$XRT   I
*                         +---------------+       +-----------+
*                         I  NAME OFFSET  I       I    ETC    I
*                         +---------------+
*                           (IOCHN - CHAIN OF NAME POINTERS)
{{EJC{{{{{26351
*
*      IOPUT (CONTINUED)
*
*      NO ADDITIONAL TRAP BLOCKS ARE USED FOR STANDARD INPUT/OUT
*      FILES. OTHERWISE AN I/O TRAP BLOCK IS ATTACHED TO SECOND
*      ARG (FILEARG1) VRBLK. SEE DIAGRAM ABOVE FOR DETAILS OF
*      THE STRUCTURE BUILT.
*
*      -(XS)                 1ST ARG (VBL TO BE ASSOCIATED)
*      -(XS)                 2ND ARG (FILE ARG1)
*      -(XS)                 3RD ARG (FILE ARG2)
*      (WB)                  0 FOR INPUT, 3 FOR OUTPUT ASSOC.
*      JSR  IOPUT            CALL FOR INPUT/OUTPUT ASSOCIATION
*      PPM  LOC              3RD ARG NOT A STRING
*      PPM  LOC              2ND ARG NOT A SUITABLE NAME
*      PPM  LOC              1ST ARG NOT A SUITABLE NAME
*      PPM  LOC              INAPPROPRIATE FILE SPEC FOR I/O
*      PPM  LOC              I/O FILE DOES NOT EXIST
*      PPM  LOC              I/O FILE CANNOT BE READ/WRITTEN
*      PPM  LOC              I/O FCBLK CURRENTLY IN USE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC)      DESTROYED
*
{IOPUT{PRC{25,N{1,7{{ENTRY POINT{26375
{{ZER{3,R$IOT{{{IN CASE NO TRTRF BLOCK USED{26376
{{ZER{3,R$IOF{{{IN CASE NO FCBLK ALOCATED{26377
{{ZER{3,R$IOP{{{IN CASE SYSIO FAILS{26378
{{MOV{8,WB{3,IOPTT{{STORE I/O TRACE TYPE{26379
{{JSR{6,XSCNI{{{PREPARE TO SCAN FILEARG2{26380
{{PPM{6,IOP13{{{FAIL{26381
{{PPM{6,IOPA0{{{NULL FILE ARG2{26382
*
{IOPA0{MOV{7,XR{3,R$IO2{{KEEP FILE ARG2{26384
{{MOV{8,WA{7,XL{{COPY LENGTH{26385
{{JSR{6,GTSTG{{{CONVERT FILEARG1 TO STRING{26386
{{PPM{6,IOP14{{{FAIL{26387
{{MOV{7,XR{3,R$IO1{{KEEP FILEARG1 PTR{26388
{{JSR{6,GTNVR{{{CONVERT TO NATURAL VARIABLE{26389
{{PPM{6,IOP00{{{JUMP IF NULL{26390
{{BRN{6,IOP04{{{JUMP TO PROCESS NON-NULL ARGS{26391
*
*      NULL FILEARG1
*
{IOP00{BZE{7,XL{6,IOP01{{SKIP IF BOTH ARGS NULL{26395
{{JSR{6,IOPPF{{{PROCESS FILEARG2{26396
{{JSR{6,SYSFC{{{CALL FOR FILEARG2 CHECK{26397
{{PPM{6,IOP16{{{FAIL{26398
{{PPM{6,IOP26{{{FAIL{26399
{{BRN{6,IOP11{{{COMPLETE FILE ASSOCIATION{26400
{{EJC{{{{{26401
*
*      IOPUT (CONTINUED)
*
*      HERE WITH 0 OR FCBLK PTR IN (XL)
*
{IOP01{MOV{3,IOPTT{8,WB{{GET TRACE TYPE{26407
{{MOV{3,R$IOT{7,XR{{GET 0 OR TRTRF PTR{26408
{{JSR{6,TRBLD{{{BUILD TRBLK{26409
{{MOV{7,XR{8,WC{{COPY TRBLK POINTER{26410
{{MOV{10,(XS)+{7,XR{{GET VARIABLE FROM STACK{26411
{{MOV{8,WC{11,-(XS){{MAKE TRBLK COLLECTABLE{26412
{{JSR{6,GTVAR{{{POINT TO VARIABLE{26413
{{PPM{6,IOP15{{{FAIL{26414
{{MOV{10,(XS)+{8,WC{{RECOVER TRBLK POINTER{26415
{{MOV{7,XL{3,R$ION{{SAVE NAME POINTER{26416
{{MOV{7,XL{7,XR{{COPY NAME POINTER{26417
{{ADD{8,WA{7,XR{{POINT TO VARIABLE{26418
{{SUB{19,*VRVAL{7,XR{{SUBTRACT OFFSET,MERGE INTO LOOP{26419
*
*      LOOP TO END OF TRBLK CHAIN IF ANY
*
{IOP02{MOV{7,XR{7,XL{{COPY BLK PTR{26423
{{MOV{13,VRVAL(XR){7,XR{{LOAD PTR TO NEXT TRBLK{26424
{{BNE{9,(XR){22,=B$TRT{6,IOP03{JUMP IF NOT TRAPPED{26425
{{BNE{13,TRTYP(XR){3,IOPTT{6,IOP02{LOOP IF NOT SAME ASSOCN{26426
{{MOV{13,TRNXT(XR){7,XR{{GET VALUE AND DELETE OLD TRBLK{26427
*
*      IOPUT (CONTINUED)
*
*      STORE NEW ASSOCIATION
*
{IOP03{MOV{8,WC{13,VRVAL(XL){{LINK TO THIS TRBLK{26433
{{MOV{8,WC{7,XL{{COPY POINTER{26434
{{MOV{7,XR{13,TRNXT(XL){{STORE VALUE IN TRBLK{26435
{{MOV{3,R$ION{7,XR{{RESTORE POSSIBLE VRBLK POINTER{26436
{{MOV{8,WA{8,WB{{KEEP OFFSET TO NAME{26437
{{JSR{6,SETVR{{{IF VRBLK, SET VRGET,VRSTO{26438
{{MOV{3,R$IOT{7,XR{{GET 0 OR TRTRF PTR{26439
{{BNZ{7,XR{6,IOP19{{JUMP IF TRTRF BLOCK EXISTS{26440
{{EXI{{{{RETURN TO CALLER{26441
*
*      NON STANDARD FILE
*      SEE IF AN FCBLK HAS ALREADY BEEN ALLOCATED.
*
{IOP04{ZER{8,WA{{{IN CASE NO FCBLK FOUND{26446
{{EJC{{{{{26447
*
*      IOPUT (CONTINUED)
*
*      SEARCH POSSIBLE TRBLK CHAIN TO PICK UP THE FCBLK
*
{IOP05{MOV{7,XR{8,WB{{REMEMBER BLK PTR{26453
{{MOV{13,VRVAL(XR){7,XR{{CHAIN ALONG{26454
{{BNE{9,(XR){22,=B$TRT{6,IOP06{JUMP IF END OF TRBLK CHAIN{26455
{{BNE{13,TRTYP(XR){18,=TRTFC{6,IOP05{LOOP IF MORE TO GO{26456
{{MOV{7,XR{3,R$IOT{{POINT TO FILE ARG1 TRBLK{26457
{{MOV{13,TRFPT(XR){8,WA{{GET FCBLK PTR FROM TRBLK{26458
*
*      WA = 0 OR FCBLK PTR
*      WB = PTR TO PRECEDING BLK TO WHICH ANY TRTRF BLOCK
*           FOR FILE ARG1 MUST BE CHAINED.
*
{IOP06{MOV{8,WA{3,R$IOF{{KEEP POSSIBLE FCBLK PTR{26464
{{MOV{8,WB{3,R$IOP{{KEEP PRECEDING BLK PTR{26465
{{JSR{6,IOPPF{{{PROCESS FILEARG2{26466
{{JSR{6,SYSFC{{{SEE IF FCBLK REQUIRED{26467
{{PPM{6,IOP16{{{FAIL{26468
{{PPM{6,IOP26{{{FAIL{26469
{{BZE{8,WA{6,IOP12{{SKIP IF NO NEW FCBLK WANTED{26470
{{BLT{8,WC{18,=NUM02{6,IOP6A{JUMP IF FCBLK IN DYNAMIC{26471
{{JSR{6,ALOST{{{GET IT IN STATIC{26472
{{BRN{6,IOP6B{{{SKIP{26473
*
*      OBTAIN FCBLK IN DYNAMIC
*
{IOP6A{JSR{6,ALLOC{{{GET SPACE FOR FCBLK{26477
*
*      MERGE
*
{IOP6B{MOV{7,XR{7,XL{{POINT TO FCBLK{26481
{{MOV{8,WA{8,WB{{COPY ITS LENGTH{26482
{{BTW{8,WB{{{GET COUNT AS WORDS (SGD APR80){26483
{{LCT{8,WB{8,WB{{LOOP COUNTER{26484
*
*      CLEAR FCBLK
*
{IOP07{ZER{10,(XR)+{{{CLEAR A WORD{26488
{{BCT{8,WB{6,IOP07{{LOOP{26489
{{BEQ{8,WC{18,=NUM02{6,IOP09{SKIP IF IN STATIC - DONT SET FIELDS{26490
{{MOV{22,=B$XNT{9,(XL){{STORE XNBLK CODE IN CASE{26491
{{MOV{8,WA{12,1(XL){{STORE LENGTH{26492
{{BNZ{8,WC{6,IOP09{{JUMP IF XNBLK WANTED{26493
{{MOV{22,=B$XRT{9,(XL){{XRBLK CODE REQUESTED{26494
*
{{EJC{{{{{26496
*      IOPUT (CONTINUED)
*
*      COMPLETE FCBLK INITIALISATION
*
{IOP09{MOV{3,R$IOT{7,XR{{GET POSSIBLE TRBLK PTR{26501
{{MOV{7,XL{3,R$IOF{{STORE FCBLK PTR{26502
{{BNZ{7,XR{6,IOP10{{JUMP IF TRBLK ALREADY FOUND{26503
*
*      A NEW TRBLK IS NEEDED
*
{{MOV{18,=TRTFC{8,WB{{TRTYP FOR FCBLK TRAP BLK{26507
{{JSR{6,TRBLD{{{MAKE THE BLOCK{26508
{{MOV{7,XR{3,R$IOT{{COPY TRTRF PTR{26509
{{MOV{3,R$IOP{7,XL{{POINT TO PRECEDING BLK{26510
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{COPY VALUE FIELD TO TRBLK{26511
{{MOV{7,XR{13,VRVAL(XL){{LINK NEW TRBLK INTO CHAIN{26512
{{MOV{7,XL{7,XR{{POINT TO PREDECESSOR BLK{26513
{{JSR{6,SETVR{{{SET TRACE INTERCEPTS{26514
{{MOV{13,VRVAL(XR){7,XR{{RECOVER TRBLK PTR{26515
{{BRN{6,IOP1A{{{STORE FCBLK PTR{26516
*
*      HERE IF EXISTING TRBLK
*
{IOP10{ZER{3,R$IOP{{{DO NOT RELEASE IF SYSIO FAILS{26520
*
*      XR IS PTR TO TRBLK, XL IS FCBLK PTR OR 0
*
{IOP1A{MOV{3,R$IOF{13,TRFPT(XR){{STORE FCBLK PTR{26524
*
*      CALL SYSIO TO COMPLETE FILE ACCESSING
*
{IOP11{MOV{3,R$IOF{8,WA{{COPY FCBLK PTR OR 0{26528
{{MOV{3,IOPTT{8,WB{{GET INPUT/OUTPUT FLAG{26529
{{MOV{3,R$IO2{7,XR{{GET FILE ARG2{26530
{{MOV{3,R$IO1{7,XL{{GET FILE ARG1{26531
{{JSR{6,SYSIO{{{ASSOCIATE TO THE FILE{26532
{{PPM{6,IOP17{{{FAIL{26533
{{PPM{6,IOP18{{{FAIL{26534
{{BNZ{3,R$IOT{6,IOP01{{NOT STD INPUT IF NON-NULL TRTRF BLK{26535
{{BNZ{3,IOPTT{6,IOP01{{JUMP IF OUTPUT{26536
{{BZE{8,WC{6,IOP01{{NO CHANGE TO STANDARD READ LENGTH{26537
{{MOV{8,WC{3,CSWIN{{STORE NEW READ LENGTH FOR STD FILE{26538
{{BRN{6,IOP01{{{MERGE TO FINISH THE TASK{26539
*
*      SYSFC MAY HAVE RETURNED A POINTER TO A PRIVATE FCBLK
*
{IOP12{BNZ{7,XL{6,IOP09{{JUMP IF PRIVATE FCBLK{26543
{{BRN{6,IOP11{{{FINISH THE ASSOCIATION{26544
*
*      FAILURE RETURNS
*
{IOP13{EXI{1,1{{{3RD ARG NOT A STRING{26548
{IOP14{EXI{1,2{{{2ND ARG UNSUITABLE{26549
{IOP15{ICA{7,XS{{{DISCARD TRBLK POINTER{26550
{{EXI{1,3{{{1ST ARG UNSUITABLE{26551
{IOP16{EXI{1,4{{{FILE SPEC WRONG{26552
{IOP26{EXI{1,7{{{FCBLK IN USE{26553
*
*      I/O FILE DOES NOT EXIST
*
{IOP17{MOV{3,R$IOP{7,XR{{IS THERE A TRBLK TO RELEASE{26557
{{BZE{7,XR{6,IOPA7{{IF NOT{26558
{{MOV{13,VRVAL(XR){7,XL{{POINT TO TRBLK{26559
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{UNSPLICE IT{26560
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{26561
{IOPA7{EXI{1,5{{{I/O FILE DOES NOT EXIST{26562
*
*      I/O FILE CANNOT BE READ/WRITTEN
*
{IOP18{MOV{3,R$IOP{7,XR{{IS THERE A TRBLK TO RELEASE{26566
{{BZE{7,XR{6,IOPA7{{IF NOT{26567
{{MOV{13,VRVAL(XR){7,XL{{POINT TO TRBLK{26568
{{MOV{13,VRVAL(XL){13,VRVAL(XR){{UNSPLICE IT{26569
{{JSR{6,SETVR{{{ADJUST TRACE INTERCEPTS{26570
{IOPA8{EXI{1,6{{{I/O FILE CANNOT BE READ/WRITTEN{26571
{{EJC{{{{{26572
*
*      IOPUT (CONTINUED)
*
*      ADD TO IOCHN CHAIN OF ASSOCIATED VARIABLES UNLESS
*      ALREADY PRESENT.
*
{IOP19{MOV{3,R$ION{8,WC{{WC = NAME BASE, WB = NAME OFFSET{26579
*
*      SEARCH LOOP
*
{IOP20{MOV{13,TRTRF(XR){7,XR{{NEXT LINK OF CHAIN{26583
{{BZE{7,XR{6,IOP21{{NOT FOUND{26584
{{BNE{8,WC{13,IONMB(XR){6,IOP20{NO MATCH{26585
{{BEQ{8,WB{13,IONMO(XR){6,IOP22{EXIT IF MATCHED{26586
{{BRN{6,IOP20{{{LOOP{26587
*
*      NOT FOUND
*
{IOP21{MOV{19,*NUM05{8,WA{{SPACE NEEDED{26591
{{JSR{6,ALLOC{{{GET IT{26592
{{MOV{22,=B$XRT{9,(XR){{STORE XRBLK CODE{26593
{{MOV{8,WA{12,1(XR){{STORE LENGTH{26594
{{MOV{8,WC{13,IONMB(XR){{STORE NAME BASE{26595
{{MOV{8,WB{13,IONMO(XR){{STORE NAME OFFSET{26596
{{MOV{3,R$IOT{7,XL{{POINT TO TRTRF BLK{26597
{{MOV{13,TRTRF(XL){8,WA{{GET PTR FIELD CONTENTS{26598
{{MOV{7,XR{13,TRTRF(XL){{STORE PTR TO NEW BLOCK{26599
{{MOV{8,WA{13,TRTRF(XR){{COMPLETE THE LINKING{26600
*
*      INSERT FCBLK ON FCBLK CHAIN FOR SYSEJ, SYSXI
*
{IOP22{BZE{3,R$IOF{6,IOP25{{SKIP IF NO FCBLK{26604
{{MOV{3,R$FCB{7,XL{{PTR TO HEAD OF EXISTING CHAIN{26605
*
*      SEE IF FCBLK ALREADY ON CHAIN
*
{IOP23{BZE{7,XL{6,IOP24{{NOT ON IF END OF CHAIN{26609
{{BEQ{12,3(XL){3,R$IOF{6,IOP25{DONT DUPLICATE IF FIND IT{26610
{{MOV{12,2(XL){7,XL{{GET NEXT LINK{26611
{{BRN{6,IOP23{{{LOOP{26612
*
*      NOT FOUND SO ADD AN ENTRY FOR THIS FCBLK
*
{IOP24{MOV{19,*NUM04{8,WA{{SPACE NEEDED{26616
{{JSR{6,ALLOC{{{GET IT{26617
{{MOV{22,=B$XRT{9,(XR){{STORE BLOCK CODE{26618
{{MOV{8,WA{12,1(XR){{STORE LENGTH{26619
{{MOV{3,R$FCB{12,2(XR){{STORE PREVIOUS LINK IN THIS NODE{26620
{{MOV{3,R$IOF{12,3(XR){{STORE FCBLK PTR{26621
{{MOV{7,XR{3,R$FCB{{INSERT NODE INTO FCBLK CHAIN{26622
*
*      RETURN
*
{IOP25{EXI{{{{RETURN TO CALLER{26626
{{ENP{{{{END PROCEDURE IOPUT{26627
{{EJC{{{{{26628
*
*      KTREX -- EXECUTE KEYWORD TRACE
*
*      KTREX IS USED TO EXECUTE A POSSIBLE KEYWORD TRACE. IT
*      INCLUDES THE TEST ON TRACE AND TESTS FOR TRACE ACTIVE.
*
*      (XL)                  PTR TO TRBLK (OR 0 IF UNTRACED)
*      JSR  KTREX            CALL TO EXECUTE KEYWORD TRACE
*      (XL,WA,WB,WC)         DESTROYED
*      (RA)                  DESTROYED
*
{KTREX{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){26640
{{BZE{7,XL{6,KTRX3{{IMMEDIATE EXIT IF KEYWORD UNTRACED{26641
{{BZE{3,KVTRA{6,KTRX3{{IMMEDIATE EXIT IF TRACE = 0{26642
{{DCV{3,KVTRA{{{ELSE DECREMENT TRACE{26643
{{MOV{7,XR{11,-(XS){{SAVE XR{26644
{{MOV{7,XL{7,XR{{COPY TRBLK POINTER{26645
{{MOV{13,TRKVR(XR){7,XL{{LOAD VRBLK POINTER (NMBAS){26646
{{MOV{19,*VRVAL{8,WA{{SET NAME OFFSET{26647
{{BZE{13,TRFNC(XR){6,KTRX1{{JUMP IF PRINT TRACE{26648
{{JSR{6,TRXEQ{{{ELSE EXECUTE FULL TRACE{26649
{{BRN{6,KTRX2{{{AND JUMP TO EXIT{26650
*
*      HERE FOR PRINT TRACE
*
{KTRX1{MOV{7,XL{11,-(XS){{STACK VRBLK PTR FOR KWNAM{26654
{{MOV{8,WA{11,-(XS){{STACK OFFSET FOR KWNAM{26655
{{JSR{6,PRTSN{{{PRINT STATEMENT NUMBER{26656
{{MOV{18,=CH$AM{8,WA{{LOAD AMPERSAND{26657
{{JSR{6,PRTCH{{{PRINT AMPERSAND{26658
{{JSR{6,PRTNM{{{PRINT KEYWORD NAME{26659
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK-EQUAL-BLANK{26660
{{JSR{6,PRTST{{{PRINT BLANK-EQUAL-BLANK{26661
{{JSR{6,KWNAM{{{GET KEYWORD PSEUDO-VARIABLE NAME{26662
{{MOV{7,XR{3,DNAMP{{RESET PTR TO DELETE KVBLK{26663
{{JSR{6,ACESS{{{GET KEYWORD VALUE{26664
{{PPM{{{{FAILURE IS IMPOSSIBLE{26665
{{JSR{6,PRTVL{{{PRINT KEYWORD VALUE{26666
{{JSR{6,PRTNL{{{TERMINATE PRINT LINE{26667
*
*      HERE TO EXIT AFTER COMPLETING TRACE
*
{KTRX2{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{26671
*
*      MERGE HERE TO EXIT IF NO TRACE REQUIRED
*
{KTRX3{EXI{{{{RETURN TO KTREX CALLER{26675
{{ENP{{{{END PROCEDURE KTREX{26676
{{EJC{{{{{26677
*
*      KWNAM -- GET PSEUDO-VARIABLE NAME FOR KEYWORD
*
*      1(XS)                 NAME BASE FOR VRBLK
*      0(XS)                 OFFSET (SHOULD BE *VRVAL)
*      JSR  KWNAM            CALL TO GET PSEUDO-VARIABLE NAME
*      (XS)                  POPPED TWICE
*      (XL,WA)               RESULTING PSEUDO-VARIABLE NAME
*      (XR,WA,WB)            DESTROYED
*
{KWNAM{PRC{25,N{1,0{{ENTRY POINT{26688
{{ICA{7,XS{{{IGNORE NAME OFFSET{26689
{{MOV{10,(XS)+{7,XR{{LOAD NAME BASE{26690
{{BGE{7,XR{3,STATE{6,KWNM1{JUMP IF NOT NATURAL VARIABLE NAME{26691
{{BNZ{13,VRLEN(XR){6,KWNM1{{ERROR IF NOT SYSTEM VARIABLE{26692
{{MOV{13,VRSVP(XR){7,XR{{ELSE POINT TO SVBLK{26693
{{MOV{13,SVBIT(XR){8,WA{{LOAD BIT MASK{26694
{{ANB{4,BTKNM{8,WA{{AND WITH KEYWORD BIT{26695
{{ZRB{8,WA{6,KWNM1{{ERROR IF NO KEYWORD ASSOCIATION{26696
{{MOV{13,SVLEN(XR){8,WA{{ELSE LOAD NAME LENGTH IN CHARACTERS{26697
{{CTB{8,WA{2,SVCHS{{COMPUTE OFFSET TO FIELD WE WANT{26698
{{ADD{8,WA{7,XR{{POINT TO SVKNM FIELD{26699
{{MOV{9,(XR){8,WB{{LOAD SVKNM VALUE{26700
{{MOV{19,*KVSI${8,WA{{SET SIZE OF KVBLK{26701
{{JSR{6,ALLOC{{{ALLOCATE KVBLK{26702
{{MOV{22,=B$KVT{9,(XR){{STORE TYPE WORD{26703
{{MOV{8,WB{13,KVNUM(XR){{STORE KEYWORD NUMBER{26704
{{MOV{21,=TRBKV{13,KVVAR(XR){{SET DUMMY TRBLK POINTER{26705
{{MOV{7,XR{7,XL{{COPY KVBLK POINTER{26706
{{MOV{19,*KVVAR{8,WA{{SET PROPER OFFSET{26707
{{EXI{{{{RETURN TO KVNAM CALLER{26708
*
*      HERE IF NOT KEYWORD NAME
*
{KWNM1{ERB{1,251{26,Keyword operand is not name of defined keyword{{{26712
{{ENP{{{{END PROCEDURE KWNAM{26713
{{EJC{{{{{26714
*
*      LCOMP-- COMPARE TWO STRINGS LEXICALLY
*
*      1(XS)                 FIRST ARGUMENT
*      0(XS)                 SECOND ARGUMENT
*      JSR  LCOMP            CALL TO COMPARE ARUMENTS
*      PPM  LOC              TRANSFER LOC FOR ARG1 NOT STRING
*      PPM  LOC              TRANSFER LOC FOR ARG2 NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARG1 LLT ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LEQ ARG2
*      PPM  LOC              TRANSFER LOC IF ARG1 LGT ARG2
*      (THE NORMAL RETURN IS NEVER TAKEN)
*      (XS)                  POPPED TWICE
*      (XR,XL)               DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
{LCOMP{PRC{25,N{1,5{{ENTRY POINT{26731
{{JSR{6,GTSTG{{{CONVERT SECOND ARG TO STRING{26733
{{PPM{6,LCMP6{{{JUMP IF SECOND ARG NOT STRING{26737
{{MOV{7,XR{7,XL{{ELSE SAVE POINTER{26738
{{MOV{8,WA{8,WC{{AND LENGTH{26739
{{JSR{6,GTSTG{{{CONVERT FIRST ARGUMENT TO STRING{26741
{{PPM{6,LCMP5{{{JUMP IF NOT STRING{26745
{{MOV{8,WA{8,WB{{SAVE ARG 1 LENGTH{26746
{{PLC{7,XR{{{POINT TO CHARS OF ARG 1{26747
{{PLC{7,XL{{{POINT TO CHARS OF ARG 2{26748
{{BLO{8,WA{8,WC{6,LCMP1{JUMP IF ARG 1 LENGTH IS SMALLER{26760
{{MOV{8,WC{8,WA{{ELSE SET ARG 2 LENGTH AS SMALLER{26761
*
*      HERE WITH SMALLER LENGTH IN (WA)
*
{LCMP1{BZE{8,WA{6,LCMP7{{IF NULL STRING, COMPARE LENGTHS{26765
{{CMC{6,LCMP4{6,LCMP3{{COMPARE STRINGS, JUMP IF UNEQUAL{26766
{LCMP7{BNE{8,WB{8,WC{6,LCMP2{IF EQUAL, JUMP IF LENGTHS UNEQUAL{26767
{{EXI{1,4{{{ELSE IDENTICAL STRINGS, LEQ EXIT{26768
{{EJC{{{{{26769
*
*      LCOMP (CONTINUED)
*
*      HERE IF INITIAL STRINGS IDENTICAL, BUT LENGTHS UNEQUAL
*
{LCMP2{BHI{8,WB{8,WC{6,LCMP4{JUMP IF ARG 1 LENGTH GT ARG 2 LENG{26775
*
*      HERE IF FIRST ARG LLT SECOND ARG
*
{LCMP3{EXI{1,3{{{TAKE LLT EXIT{26780
*
*      HERE IF FIRST ARG LGT SECOND ARG
*
{LCMP4{EXI{1,5{{{TAKE LGT EXIT{26784
*
*      HERE IF FIRST ARG IS NOT A STRING
*
{LCMP5{EXI{1,1{{{TAKE BAD FIRST ARG EXIT{26788
*
*      HERE FOR SECOND ARG NOT A STRING
*
{LCMP6{EXI{1,2{{{TAKE BAD SECOND ARG ERROR EXIT{26792
{{ENP{{{{END PROCEDURE LCOMP{26793
{{EJC{{{{{26794
*
*      LISTR -- LIST SOURCE LINE
*
*      LISTR IS USED TO LIST A SOURCE LINE DURING THE INITIAL
*      COMPILATION. IT IS CALLED FROM SCANE AND SCANL.
*
*      JSR  LISTR            CALL TO LIST LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL LOCATIONS USED BY LISTR
*
*      CNTTL                 FLAG FOR -TITLE, -STITL
*
*      ERLST                 IF LISTING ON ACCOUNT OF AN ERROR
*
*      LSTID                 INCLUDE DEPTH OF CURRENT IMAGE
*
*      LSTLC                 COUNT LINES ON CURRENT PAGE
*
*      LSTNP                 MAX NUMBER OF LINES/PAGE
*
*      LSTPF                 SET NON-ZERO IF THE CURRENT SOURCE
*                            LINE HAS BEEN LISTED, ELSE ZERO.
*
*      LSTPG                 COMPILER LISTING PAGE NUMBER
*
*      LSTSN                 SET IF STMNT NUM TO BE LISTED
*
*      R$CIM                 POINTER TO CURRENT INPUT LINE.
*
*      R$TTL                 TITLE FOR SOURCE LISTING
*
*      R$STL                 PTR TO SUB-TITLE STRING
*
*      ENTRY POINT
*
{LISTR{PRC{25,E{1,0{{ENTRY POINT{26833
{{BNZ{3,CNTTL{6,LIST5{{JUMP IF -TITLE OR -STITL{26834
{{BNZ{3,LSTPF{6,LIST4{{IMMEDIATE EXIT IF ALREADY LISTED{26835
{{BGE{3,LSTLC{3,LSTNP{6,LIST6{JUMP IF NO ROOM{26836
*
*      HERE AFTER PRINTING TITLE (IF NEEDED)
*
{LIST0{MOV{3,R$CIM{7,XR{{LOAD POINTER TO CURRENT IMAGE{26840
{{BZE{7,XR{6,LIST4{{JUMP IF NO IMAGE TO PRINT{26841
{{PLC{7,XR{{{POINT TO CHARACTERS{26842
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{26843
{{MOV{3,LSTSN{7,XR{{LOAD STATEMENT NUMBER{26844
{{BZE{7,XR{6,LIST2{{JUMP IF NO STATEMENT NUMBER{26845
{{MTI{7,XR{{{ELSE GET STMNT NUMBER AS INTEGER{26846
{{BNE{3,STAGE{18,=STGIC{6,LIST1{SKIP IF EXECUTE TIME{26847
{{BEQ{8,WA{18,=CH$AS{6,LIST2{NO STMNT NUMBER LIST IF COMMENT{26848
{{BEQ{8,WA{18,=CH$MN{6,LIST2{NO STMNT NO. IF CONTROL CARD{26849
*
*      PRINT STATEMENT NUMBER
*
{LIST1{JSR{6,PRTIN{{{ELSE PRINT STATEMENT NUMBER{26853
{{ZER{3,LSTSN{{{AND CLEAR FOR NEXT TIME IN{26854
*
*      HERE TO TEST FOR PRINTING INCLUDE DEPTH
*
{LIST2{MOV{3,LSTID{7,XR{{INCLUDE DEPTH OF IMAGE{26859
{{BZE{7,XR{6,LIST8{{IF NOT FROM AN INCLUDE FILE{26860
{{MOV{18,=STNPD{8,WA{{POSITION FOR START OF STATEMENT{26861
{{SUB{18,=NUM03{8,WA{{POSITION TO PLACE INCLUDE DEPTH{26862
{{MOV{8,WA{3,PROFS{{SET AS STARTING POSITION{26863
{{MTI{7,XR{{{INCLUDE DEPTH AS INTEGER{26864
{{JSR{6,PRTIN{{{PRINT INCLUDE DEPTH{26865
{{EJC{{{{{26866
*
*      LISTR (CONTINUED)
*
*      HERE AFTER PRINTING STATEMENT NUMBER AND INCLUDE DEPTH
*
{LIST8{MOV{18,=STNPD{3,PROFS{{POINT PAST STATEMENT NUMBER{26872
{{MOV{3,R$CIM{7,XR{{LOAD POINTER TO CURRENT IMAGE{26882
{{JSR{6,PRTST{{{PRINT IT{26883
{{ICV{3,LSTLC{{{BUMP LINE COUNTER{26884
{{BNZ{3,ERLST{6,LIST3{{JUMP IF ERROR COPY TO INT.CH.{26885
{{JSR{6,PRTNL{{{TERMINATE LINE{26886
{{BZE{3,CSWDB{6,LIST3{{JUMP IF -SINGLE MODE{26887
{{JSR{6,PRTNL{{{ELSE ADD A BLANK LINE{26888
{{ICV{3,LSTLC{{{AND BUMP LINE COUNTER{26889
*
*      HERE AFTER PRINTING SOURCE IMAGE
*
{LIST3{MNZ{3,LSTPF{{{SET FLAG FOR LINE PRINTED{26893
*
*      MERGE HERE TO EXIT
*
{LIST4{EXI{{{{RETURN TO LISTR CALLER{26897
*
*      PRINT TITLE AFTER -TITLE OR -STITL CARD
*
{LIST5{ZER{3,CNTTL{{{CLEAR FLAG{26901
*
*      EJECT TO NEW PAGE AND LIST TITLE
*
{LIST6{JSR{6,PRTPS{{{EJECT{26905
{{BZE{3,PRICH{6,LIST7{{SKIP IF LISTING TO REGULAR PRINTER{26906
{{BEQ{3,R$TTL{21,=NULLS{6,LIST0{TERMINAL LISTING OMITS NULL TITLE{26907
*
*      LIST TITLE
*
{LIST7{JSR{6,LISTT{{{LIST TITLE{26911
{{BRN{6,LIST0{{{MERGE{26912
{{ENP{{{{END PROCEDURE LISTR{26913
{{EJC{{{{{26914
*
*      LISTT -- LIST TITLE AND SUBTITLE
*
*      USED DURING COMPILATION TO PRINT PAGE HEADING
*
*      JSR  LISTT            CALL TO LIST TITLE
*      (XR,WA)               DESTROYED
*
{LISTT{PRC{25,E{1,0{{ENTRY POINT{26923
{{MOV{3,R$TTL{7,XR{{POINT TO SOURCE LISTING TITLE{26924
{{JSR{6,PRTST{{{PRINT TITLE{26925
{{MOV{3,LSTPO{3,PROFS{{SET OFFSET{26926
{{MOV{21,=LSTMS{7,XR{{SET PAGE MESSAGE{26927
{{JSR{6,PRTST{{{PRINT PAGE MESSAGE{26928
{{ICV{3,LSTPG{{{BUMP PAGE NUMBER{26929
{{MTI{3,LSTPG{{{LOAD PAGE NUMBER AS INTEGER{26930
{{JSR{6,PRTIN{{{PRINT PAGE NUMBER{26931
{{JSR{6,PRTNL{{{TERMINATE TITLE LINE{26932
{{ADD{18,=NUM02{3,LSTLC{{COUNT TITLE LINE AND BLANK LINE{26933
*
*      PRINT SUB-TITLE (IF ANY)
*
{{MOV{3,R$STL{7,XR{{LOAD POINTER TO SUB-TITLE{26937
{{BZE{7,XR{6,LSTT1{{JUMP IF NO SUB-TITLE{26938
{{JSR{6,PRTST{{{ELSE PRINT SUB-TITLE{26939
{{JSR{6,PRTNL{{{TERMINATE LINE{26940
{{ICV{3,LSTLC{{{BUMP LINE COUNT{26941
*
*      RETURN POINT
*
{LSTT1{JSR{6,PRTNL{{{PRINT A BLANK LINE{26945
{{EXI{{{{RETURN TO CALLER{26946
{{ENP{{{{END PROCEDURE LISTT{26947
{{EJC{{{{{26948
*
*      NEWFN -- RECORD NEW SOURCE FILE NAME
*
*      NEWFN IS USED AFTER SWITCHING TO A NEW INCLUDE FILE, OR
*      AFTER A -LINE STATEMENT WHICH CONTAINS A FILE NAME.
*
*      (XR)                  FILE NAME SCBLK
*      JSR  NEWFN
*      (WA,WB,WC,XL,XR,RA)   DESTROYED
*
*      ON RETURN, THE TABLE THAT MAPS STATEMENT NUMBERS TO FILE
*      NAMES HAS BEEN UPDATED TO INCLUDE THIS NEW FILE NAME AND
*      THE CURRENT STATEMENT NUMBER.  THE ENTRY IS MADE ONLY IF
*      THE FILE NAME HAD CHANGED FROM ITS PREVIOUS VALUE.
*
{NEWFN{PRC{25,E{1,0{{ENTRY POINT{26965
{{MOV{7,XR{11,-(XS){{SAVE NEW NAME{26966
{{MOV{3,R$SFC{7,XL{{LOAD PREVIOUS NAME{26967
{{JSR{6,IDENT{{{CHECK FOR EQUALITY{26968
{{PPM{6,NWFN1{{{JUMP IF IDENTICAL{26969
{{MOV{10,(XS)+{7,XR{{DIFFERENT, RESTORE NAME{26970
{{MOV{7,XR{3,R$SFC{{RECORD CURRENT FILE NAME{26971
{{MOV{3,CMPSN{8,WB{{GET CURRENT STATEMENT{26972
{{MTI{8,WB{{{CONVERT TO INTEGER{26973
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{26974
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{26975
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{26976
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{26977
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{26978
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{26979
{{EXI{{{{{26980
*
*     HERE IF NEW NAME AND OLD NAME IDENTICAL
*
{NWFN1{ICA{7,XS{{{POP STACK{26984
{{EXI{{{{{26985
{{EJC{{{{{26986
*
*      NEXTS -- ACQUIRE NEXT SOURCE IMAGE
*
*      NEXTS IS USED TO ACQUIRE THE NEXT SOURCE IMAGE AT COMPILE
*      TIME. IT ASSUMES THAT A PRIOR CALL TO READR HAS INPUT
*      A LINE IMAGE (SEE PROCEDURE READR). BEFORE THE CURRENT
*      IMAGE IS FINALLY LOST IT MAY BE LISTED HERE.
*
*      JSR  NEXTS            CALL TO ACQUIRE NEXT INPUT LINE
*      (XR,XL,WA,WB,WC)      DESTROYED
*
*      GLOBAL VALUES AFFECTED
*
*      LSTID                 INCLUDE DEPTH OF NEXT IMAGE
*
*      R$CNI                 ON INPUT, NEXT IMAGE. ON
*                            EXIT RESET TO ZERO
*
*      R$CIM                 ON EXIT, SET TO POINT TO IMAGE
*
*      RDCLN                 CURRENT LN SET FROM NEXT LINE NUM
*
*      SCNIL                 INPUT IMAGE LENGTH ON EXIT
*
*      SCNSE                 RESET TO ZERO ON EXIT
*
*      LSTPF                 SET ON EXIT IF LINE IS LISTED
*
{NEXTS{PRC{25,E{1,0{{ENTRY POINT{27018
{{BZE{3,CSWLS{6,NXTS2{{JUMP IF -NOLIST{27019
{{MOV{3,R$CIM{7,XR{{POINT TO IMAGE{27020
{{BZE{7,XR{6,NXTS2{{JUMP IF NO IMAGE{27021
{{PLC{7,XR{{{GET CHAR PTR{27022
{{LCH{8,WA{9,(XR){{GET FIRST CHAR{27023
{{BNE{8,WA{18,=CH$MN{6,NXTS1{JUMP IF NOT CTRL CARD{27024
{{BZE{3,CSWPR{6,NXTS2{{JUMP IF -NOPRINT{27025
*
*      HERE TO CALL LISTER
*
{NXTS1{JSR{6,LISTR{{{LIST LINE{27029
*
*      HERE AFTER POSSIBLE LISTING
*
{NXTS2{MOV{3,R$CNI{7,XR{{POINT TO NEXT IMAGE{27033
{{MOV{7,XR{3,R$CIM{{SET AS NEXT IMAGE{27034
{{MOV{3,RDNLN{3,RDCLN{{SET AS CURRENT LINE NUMBER{27035
{{MOV{3,CNIND{3,LSTID{{SET AS CURRENT INCLUDE DEPTH{27037
{{ZER{3,R$CNI{{{CLEAR NEXT IMAGE POINTER{27039
{{MOV{13,SCLEN(XR){8,WA{{GET INPUT IMAGE LENGTH{27040
{{MOV{3,CSWIN{8,WB{{GET MAX ALLOWABLE LENGTH{27041
{{BLO{8,WA{8,WB{6,NXTS3{SKIP IF NOT TOO LONG{27042
{{MOV{8,WB{8,WA{{ELSE TRUNCATE{27043
*
*      HERE WITH LENGTH IN (WA)
*
{NXTS3{MOV{8,WA{3,SCNIL{{USE AS RECORD LENGTH{27047
{{ZER{3,SCNSE{{{RESET SCNSE{27048
{{ZER{3,LSTPF{{{SET LINE NOT LISTED YET{27049
{{EXI{{{{RETURN TO NEXTS CALLER{27050
{{ENP{{{{END PROCEDURE NEXTS{27051
{{EJC{{{{{27052
*
*      PATIN -- PATTERN CONSTRUCTION FOR LEN,POS,RPOS,TAB,RTAB
*
*      THESE PATTERN TYPES ALL GENERATE A SIMILAR NODE TYPE. SO
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE FUNCTIONS.
*
*      (WA)                  PCODE FOR EXPRESSION ARG CASE
*      (WB)                  PCODE FOR INTEGER ARG CASE
*      JSR  PATIN            CALL TO BUILD PATTERN NODE
*      PPM  LOC              TRANSFER LOC FOR NOT INTEGER OR EXP
*      PPM  LOC              TRANSFER LOC FOR INT OUT OF RANGE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL,WA,WB,WC,IA)      DESTROYED
*
{PATIN{PRC{25,N{1,2{{ENTRY POINT{27068
{{MOV{8,WA{7,XL{{PRESERVE EXPRESSION ARG PCODE{27069
{{JSR{6,GTSMI{{{TRY TO CONVERT ARG AS SMALL INTEGER{27070
{{PPM{6,PTIN2{{{JUMP IF NOT INTEGER{27071
{{PPM{6,PTIN3{{{JUMP IF OUT OF RANGE{27072
*
*      COMMON SUCCESSFUL EXIT POINT
*
{PTIN1{JSR{6,PBILD{{{BUILD PATTERN NODE{27076
{{EXI{{{{RETURN TO CALLER{27077
*
*      HERE IF ARGUMENT IS NOT AN INTEGER
*
{PTIN2{MOV{7,XL{8,WB{{COPY EXPR ARG CASE PCODE{27081
{{BLO{9,(XR){22,=B$E$${6,PTIN1{ALL OK IF EXPRESSION ARG{27082
{{EXI{1,1{{{ELSE TAKE ERROR EXIT FOR WRONG TYPE{27083
*
*      HERE FOR ERROR OF OUT OF RANGE INTEGER ARGUMENT
*
{PTIN3{EXI{1,2{{{TAKE OUT-OF-RANGE ERROR EXIT{27087
{{ENP{{{{END PROCEDURE PATIN{27088
{{EJC{{{{{27089
*
*      PATST -- PATTERN CONSTRUCTION FOR ANY,NOTANY,
*               BREAK,SPAN AND BREAKX PATTERN FUNCTIONS.
*
*      THESE PATTERN FUNCTIONS BUILD SIMILAR TYPES OF NODES AND
*      THE CONSTRUCTION CODE IS SHARED. SEE FUNCTIONS SECTION
*      FOR ACTUAL ENTRY POINTS FOR THESE FIVE PATTERN FUNCTIONS.
*
*      0(XS)                 STRING ARGUMENT
*      (WB)                  PCODE FOR ONE CHAR ARGUMENT
*      (XL)                  PCODE FOR MULTI-CHAR ARGUMENT
*      (WC)                  PCODE FOR EXPRESSION ARGUMENT
*      JSR  PATST            CALL TO BUILD NODE
*      PPM  LOC              IF NOT STRING OR EXPR (OR NULL)
*      (XS)                  POPPED PAST STRING ARGUMENT
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (XL)                  DESTROYED
*      (WA,WB,WC,RA)         DESTROYED
*
*      NOTE THAT THERE IS A SPECIAL CALL TO PATST IN THE EVALS
*      PROCEDURE WITH A SLIGHTLY DIFFERENT FORM. SEE EVALS
*      FOR DETAILS OF THE FORM OF THIS CALL.
*
{PATST{PRC{25,N{1,1{{ENTRY POINT{27113
{{JSR{6,GTSTG{{{CONVERT ARGUMENT AS STRING{27114
{{PPM{6,PATS7{{{JUMP IF NOT STRING{27115
{{BZE{8,WA{6,PATS7{{JUMP IF NULL STRING (CATSPAW){27116
{{BNE{8,WA{18,=NUM01{6,PATS2{JUMP IF NOT ONE CHAR STRING{27117
*
*      HERE FOR ONE CHAR STRING CASE
*
{{BZE{8,WB{6,PATS2{{TREAT AS MULTI-CHAR IF EVALS CALL{27121
{{PLC{7,XR{{{POINT TO CHARACTER{27122
{{LCH{7,XR{9,(XR){{LOAD CHARACTER{27123
*
*      COMMON EXIT POINT AFTER SUCCESSFUL CONSTRUCTION
*
{PATS1{JSR{6,PBILD{{{CALL ROUTINE TO BUILD NODE{27127
{{EXI{{{{RETURN TO PATST CALLER{27128
{{EJC{{{{{27129
*
*      PATST (CONTINUED)
*
*      HERE FOR MULTI-CHARACTER STRING CASE
*
{PATS2{MOV{7,XL{11,-(XS){{SAVE MULTI-CHAR PCODE{27135
{{MOV{3,CTMSK{8,WC{{LOAD CURRENT MASK BIT{27136
{{BEQ{7,XR{3,R$CTS{6,PATS6{JUMP IF SAME AS LAST STRING C3.738{27137
{{MOV{7,XR{11,-(XS){{SAVE STRING POINTER{27138
{{LSH{8,WC{1,1{{SHIFT TO NEXT POSITION{27139
{{NZB{8,WC{6,PATS4{{SKIP IF POSITION LEFT IN THIS TBL{27140
*
*      HERE WE MUST ALLOCATE A NEW CHARACTER TABLE
*
{{MOV{19,*CTSI${8,WA{{SET SIZE OF CTBLK{27144
{{JSR{6,ALLOC{{{ALLOCATE CTBLK{27145
{{MOV{7,XR{3,R$CTP{{STORE PTR TO NEW CTBLK{27146
{{MOV{22,=B$CTT{10,(XR)+{{STORE TYPE CODE, BUMP PTR{27147
{{LCT{8,WB{18,=CFP$A{{SET NUMBER OF WORDS TO CLEAR{27148
{{MOV{4,BITS0{8,WC{{LOAD ALL ZERO BITS{27149
*
*      LOOP TO CLEAR ALL BITS IN TABLE TO ZEROS
*
{PATS3{MOV{8,WC{10,(XR)+{{MOVE WORD OF ZERO BITS{27153
{{BCT{8,WB{6,PATS3{{LOOP TILL ALL CLEARED{27154
{{MOV{4,BITS1{8,WC{{SET INITIAL BIT POSITION{27155
*
*      MERGE HERE WITH BIT POSITION AVAILABLE
*
{PATS4{MOV{8,WC{3,CTMSK{{SAVE PARM2 (NEW BIT POSITION){27159
{{MOV{10,(XS)+{7,XL{{RESTORE POINTER TO ARGUMENT STRING{27160
{{MOV{7,XL{3,R$CTS{{SAVE FOR NEXT TIME   C3.738{27161
{{MOV{13,SCLEN(XL){8,WB{{LOAD STRING LENGTH{27162
{{BZE{8,WB{6,PATS6{{JUMP IF NULL STRING CASE{27163
{{LCT{8,WB{8,WB{{ELSE SET LOOP COUNTER{27164
{{PLC{7,XL{{{POINT TO CHARACTERS IN ARGUMENT{27165
{{EJC{{{{{27166
*
*      PATST (CONTINUED)
*
*      LOOP TO SET BITS IN COLUMN OF TABLE
*
{PATS5{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{27172
{{WTB{8,WA{{{CONVERT TO BYTE OFFSET{27173
{{MOV{3,R$CTP{7,XR{{POINT TO CTBLK{27174
{{ADD{8,WA{7,XR{{POINT TO CTBLK ENTRY{27175
{{MOV{8,WC{8,WA{{COPY BIT MASK{27176
{{ORB{13,CTCHS(XR){8,WA{{OR IN BITS ALREADY SET{27177
{{MOV{8,WA{13,CTCHS(XR){{STORE RESULTING BIT STRING{27178
{{BCT{8,WB{6,PATS5{{LOOP TILL ALL BITS SET{27179
*
*      COMPLETE PROCESSING FOR MULTI-CHAR STRING CASE
*
{PATS6{MOV{3,R$CTP{7,XR{{LOAD CTBLK PTR AS PARM1 FOR PBILD{27183
{{ZER{7,XL{{{CLEAR GARBAGE PTR IN XL{27184
{{MOV{10,(XS)+{8,WB{{LOAD PCODE FOR MULTI-CHAR STR CASE{27185
{{BRN{6,PATS1{{{BACK TO EXIT (WC=BITSTRING=PARM2){27186
*
*      HERE IF ARGUMENT IS NOT A STRING
*
*      NOTE THAT THE CALL FROM EVALS CANNOT PASS AN EXPRESSION
*      SINCE EVALP ALWAYS REEVALUATES EXPRESSIONS.
*
{PATS7{MOV{8,WC{8,WB{{SET PCODE FOR EXPRESSION ARGUMENT{27193
{{BLO{9,(XR){22,=B$E$${6,PATS1{JUMP TO EXIT IF EXPRESSION ARG{27194
{{EXI{1,1{{{ELSE TAKE WRONG TYPE ERROR EXIT{27195
{{ENP{{{{END PROCEDURE PATST{27196
{{EJC{{{{{27197
*
*      PBILD -- BUILD PATTERN NODE
*
*      (XR)                  PARM1 (ONLY IF REQUIRED)
*      (WB)                  PCODE FOR NODE
*      (WC)                  PARM2 (ONLY IF REQUIRED)
*      JSR  PBILD            CALL TO BUILD NODE
*      (XR)                  POINTER TO CONSTRUCTED NODE
*      (WA)                  DESTROYED
*
{PBILD{PRC{25,E{1,0{{ENTRY POINT{27208
{{MOV{7,XR{11,-(XS){{STACK POSSIBLE PARM1{27209
{{MOV{8,WB{7,XR{{COPY PCODE{27210
{{LEI{7,XR{{{LOAD ENTRY POINT ID (BL$PX){27211
{{BEQ{7,XR{18,=BL$P1{6,PBLD1{JUMP IF ONE PARAMETER{27212
{{BEQ{7,XR{18,=BL$P0{6,PBLD3{JUMP IF NO PARAMETERS{27213
*
*      HERE FOR TWO PARAMETER CASE
*
{{MOV{19,*PCSI${8,WA{{SET SIZE OF P2BLK{27217
{{JSR{6,ALLOC{{{ALLOCATE BLOCK{27218
{{MOV{8,WC{13,PARM2(XR){{STORE SECOND PARAMETER{27219
{{BRN{6,PBLD2{{{MERGE WITH ONE PARM CASE{27220
*
*      HERE FOR ONE PARAMETER CASE
*
{PBLD1{MOV{19,*PBSI${8,WA{{SET SIZE OF P1BLK{27224
{{JSR{6,ALLOC{{{ALLOCATE NODE{27225
*
*      MERGE HERE FROM TWO PARM CASE
*
{PBLD2{MOV{9,(XS){13,PARM1(XR){{STORE FIRST PARAMETER{27229
{{BRN{6,PBLD4{{{MERGE WITH NO PARAMETER CASE{27230
*
*      HERE FOR CASE OF NO PARAMETERS
*
{PBLD3{MOV{19,*PASI${8,WA{{SET SIZE OF P0BLK{27234
{{JSR{6,ALLOC{{{ALLOCATE NODE{27235
*
*      MERGE HERE FROM OTHER CASES
*
{PBLD4{MOV{8,WB{9,(XR){{STORE PCODE{27239
{{ICA{7,XS{{{POP FIRST PARAMETER{27240
{{MOV{21,=NDNTH{13,PTHEN(XR){{SET NOTHEN SUCCESSOR POINTER{27241
{{EXI{{{{RETURN TO PBILD CALLER{27242
{{ENP{{{{END PROCEDURE PBILD{27243
{{EJC{{{{{27244
*
*      PCONC -- CONCATENATE TWO PATTERNS
*
*      (XL)                  PTR TO RIGHT PATTERN
*      (XR)                  PTR TO LEFT PATTERN
*      JSR  PCONC            CALL TO CONCATENATE PATTERNS
*      (XR)                  PTR TO CONCATENATED PATTERN
*      (XL,WA,WB,WC)         DESTROYED
*
*
*      TO CONCATENATE TWO PATTERNS, ALL SUCCESSORS IN THE LEFT
*      PATTERN WHICH POINT TO THE NOTHEN NODE MUST BE CHANGED TO
*      POINT TO THE RIGHT PATTERN. HOWEVER, THIS MODIFICATION
*      MUST BE PERFORMED ON A COPY OF THE LEFT ARGUMENT RATHER
*      THAN THE LEFT ARGUMENT ITSELF, SINCE THE LEFT ARGUMENT
*      MAY BE POINTED TO BY SOME OTHER VARIABLE VALUE.
*
*      ACCORDINGLY, IT IS NECESSARY TO COPY THE LEFT ARGUMENT.
*      THIS IS NOT A TRIVIAL PROCESS SINCE WE MUST AVOID COPYING
*      NODES MORE THAN ONCE AND THE PATTERN IS A GRAPH STRUCTURE
*      THE FOLLOWING ALGORITHM IS EMPLOYED.
*
*      THE STACK IS USED TO STORE A LIST OF NODES WHICH
*      HAVE ALREADY BEEN COPIED. THE FORMAT OF THE ENTRIES ON
*      THIS LIST CONSISTS OF A TWO WORD BLOCK. THE FIRST WORD
*      IS THE OLD ADDRESS AND THE SECOND WORD IS THE ADDRESS
*      OF THE COPY. THIS LIST IS SEARCHED BY THE PCOPY
*      ROUTINE TO AVOID MAKING DUPLICATE COPIES. A TRICK IS
*      USED TO ACCOMPLISH THE CONCATENATION AT THE SAME TIME.
*      A SPECIAL ENTRY IS MADE TO START WITH ON THE STACK. THIS
*      ENTRY RECORDS THAT THE NOTHEN NODE HAS BEEN COPIED
*      ALREADY AND THE ADDRESS OF ITS COPY IS THE RIGHT PATTERN.
*      THIS AUTOMATICALLY PERFORMS THE CORRECT REPLACEMENTS.
*
{PCONC{PRC{25,E{1,0{{ENTRY POINT{27279
{{ZER{11,-(XS){{{MAKE ROOM FOR ONE ENTRY AT BOTTOM{27280
{{MOV{7,XS{8,WC{{STORE POINTER TO START OF LIST{27281
{{MOV{21,=NDNTH{11,-(XS){{STACK NOTHEN NODE AS OLD NODE{27282
{{MOV{7,XL{11,-(XS){{STORE RIGHT ARG AS COPY OF NOTHEN{27283
{{MOV{7,XS{7,XT{{INITIALIZE POINTER TO STACK ENTRIES{27284
{{JSR{6,PCOPY{{{COPY FIRST NODE OF LEFT ARG{27285
{{MOV{8,WA{12,2(XT){{STORE AS RESULT UNDER LIST{27286
{{EJC{{{{{27287
*
*      PCONC (CONTINUED)
*
*      THE FOLLOWING LOOP SCANS ENTRIES IN THE LIST AND MAKES
*      SURE THAT THEIR SUCCESSORS HAVE BEEN COPIED.
*
{PCNC1{BEQ{7,XT{7,XS{6,PCNC2{JUMP IF ALL ENTRIES PROCESSED{27294
{{MOV{11,-(XT){7,XR{{ELSE LOAD NEXT OLD ADDRESS{27295
{{MOV{13,PTHEN(XR){7,XR{{LOAD POINTER TO SUCCESSOR{27296
{{JSR{6,PCOPY{{{COPY SUCCESSOR NODE{27297
{{MOV{11,-(XT){7,XR{{LOAD POINTER TO NEW NODE (COPY){27298
{{MOV{8,WA{13,PTHEN(XR){{STORE PTR TO NEW SUCCESSOR{27299
*
*      NOW CHECK FOR SPECIAL CASE OF ALTERNATION NODE WHERE
*      PARM1 POINTS TO A NODE AND MUST BE COPIED LIKE PTHEN.
*
{{BNE{9,(XR){22,=P$ALT{6,PCNC1{LOOP BACK IF NOT{27304
{{MOV{13,PARM1(XR){7,XR{{ELSE LOAD POINTER TO ALTERNATIVE{27305
{{JSR{6,PCOPY{{{COPY IT{27306
{{MOV{9,(XT){7,XR{{RESTORE PTR TO NEW NODE{27307
{{MOV{8,WA{13,PARM1(XR){{STORE PTR TO COPIED ALTERNATIVE{27308
{{BRN{6,PCNC1{{{LOOP BACK FOR NEXT ENTRY{27309
*
*      HERE AT END OF COPY PROCESS
*
{PCNC2{MOV{8,WC{7,XS{{RESTORE STACK POINTER{27313
{{MOV{10,(XS)+{7,XR{{LOAD POINTER TO COPY{27314
{{EXI{{{{RETURN TO PCONC CALLER{27315
{{ENP{{{{END PROCEDURE PCONC{27316
{{EJC{{{{{27317
*
*      PCOPY -- COPY A PATTERN NODE
*
*      PCOPY IS CALLED FROM THE PCONC PROCEDURE TO COPY A SINGLE
*      PATTERN NODE. THE COPY IS ONLY CARRIED OUT IF THE NODE
*      HAS NOT BEEN COPIED ALREADY.
*
*      (XR)                  POINTER TO NODE TO BE COPIED
*      (XT)                  PTR TO CURRENT LOC IN COPY LIST
*      (WC)                  POINTER TO LIST OF COPIED NODES
*      JSR  PCOPY            CALL TO COPY A NODE
*      (WA)                  POINTER TO COPY
*      (WB,XR)               DESTROYED
*
{PCOPY{PRC{25,N{1,0{{ENTRY POINT{27332
{{MOV{7,XT{8,WB{{SAVE XT{27333
{{MOV{8,WC{7,XT{{POINT TO START OF LIST{27334
*
*      LOOP TO SEARCH LIST OF NODES COPIED ALREADY
*
{PCOP1{DCA{7,XT{{{POINT TO NEXT ENTRY ON LIST{27338
{{BEQ{7,XR{9,(XT){6,PCOP2{JUMP IF MATCH{27339
{{DCA{7,XT{{{ELSE SKIP OVER COPIED ADDRESS{27340
{{BNE{7,XT{7,XS{6,PCOP1{LOOP BACK IF MORE TO TEST{27341
*
*      HERE IF NOT IN LIST, PERFORM COPY
*
{{MOV{9,(XR){8,WA{{LOAD FIRST WORD OF BLOCK{27345
{{JSR{6,BLKLN{{{GET LENGTH OF BLOCK{27346
{{MOV{7,XR{7,XL{{SAVE POINTER TO OLD NODE{27347
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR COPY{27348
{{MOV{7,XL{11,-(XS){{STORE OLD ADDRESS ON LIST{27349
{{MOV{7,XR{11,-(XS){{STORE NEW ADDRESS ON LIST{27350
{{CHK{{{{CHECK FOR STACK OVERFLOW{27351
{{MVW{{{{MOVE WORDS FROM OLD BLOCK TO COPY{27352
{{MOV{9,(XS){8,WA{{LOAD POINTER TO COPY{27353
{{BRN{6,PCOP3{{{JUMP TO EXIT{27354
*
*      HERE IF WE FIND ENTRY IN LIST
*
{PCOP2{MOV{11,-(XT){8,WA{{LOAD ADDRESS OF COPY FROM LIST{27358
*
*      COMMON EXIT POINT
*
{PCOP3{MOV{8,WB{7,XT{{RESTORE XT{27362
{{EXI{{{{RETURN TO PCOPY CALLER{27363
{{ENP{{{{END PROCEDURE PCOPY{27364
{{EJC{{{{{27365
*
*      PRFLR -- PRINT PROFILE
*      PRFLR IS CALLED TO PRINT THE CONTENTS OF THE PROFILE
*      TABLE IN A FAIRLY READABLE TABULAR FORMAT.
*
*      JSR  PRFLR            CALL TO PRINT PROFILE
*      (WA,IA)               DESTROYED
*
{PRFLR{PRC{25,E{1,0{{{27376
{{BZE{3,PFDMP{6,PRFL4{{NO PRINTING IF NO PROFILING DONE{27377
{{MOV{7,XR{11,-(XS){{PRESERVE ENTRY XR{27378
{{MOV{8,WB{3,PFSVW{{AND ALSO WB{27379
{{JSR{6,PRTPG{{{EJECT{27380
{{MOV{21,=PFMS1{7,XR{{LOAD MSG /PROGRAM PROFILE/{27381
{{JSR{6,PRTST{{{AND PRINT IT{27382
{{JSR{6,PRTNL{{{FOLLOWED BY NEWLINE{27383
{{JSR{6,PRTNL{{{AND ANOTHER{27384
{{MOV{21,=PFMS2{7,XR{{POINT TO FIRST HDR{27385
{{JSR{6,PRTST{{{PRINT IT{27386
{{JSR{6,PRTNL{{{NEW LINE{27387
{{MOV{21,=PFMS3{7,XR{{SECOND HDR{27388
{{JSR{6,PRTST{{{PRINT IT{27389
{{JSR{6,PRTNL{{{NEW LINE{27390
{{JSR{6,PRTNL{{{AND ANOTHER BLANK LINE{27391
{{ZER{8,WB{{{INITIAL STMT COUNT{27392
{{MOV{3,PFTBL{7,XR{{POINT TO TABLE ORIGIN{27393
{{ADD{19,*XNDTA{7,XR{{BIAS PAST XNBLK HEADER (SGD07){27394
*
*      LOOP HERE TO PRINT SUCCESSIVE ENTRIES
*
{PRFL1{ICV{8,WB{{{BUMP STMT NR{27398
{{LDI{9,(XR){{{LOAD NR OF EXECUTIONS{27399
{{IEQ{6,PRFL3{{{NO PRINTING IF ZERO{27400
{{MOV{18,=PFPD1{3,PROFS{{POINT WHERE TO PRINT{27401
{{JSR{6,PRTIN{{{AND PRINT IT{27402
{{ZER{3,PROFS{{{BACK TO START OF LINE{27403
{{MTI{8,WB{{{LOAD STMT NR{27404
{{JSR{6,PRTIN{{{PRINT IT THERE{27405
{{MOV{18,=PFPD2{3,PROFS{{AND PAD PAST COUNT{27406
{{LDI{13,CFP$I(XR){{{LOAD TOTAL EXEC TIME{27407
{{JSR{6,PRTIN{{{PRINT THAT TOO{27408
{{LDI{13,CFP$I(XR){{{RELOAD TIME{27409
{{MLI{4,INTTH{{{CONVERT TO MICROSEC{27410
{{IOV{6,PRFL2{{{OMIT NEXT BIT IF OVERFLOW{27411
{{DVI{9,(XR){{{DIVIDE BY EXECUTIONS{27412
{{MOV{18,=PFPD3{3,PROFS{{PAD LAST PRINT{27413
{{JSR{6,PRTIN{{{AND PRINT MCSEC/EXECN{27414
*
*      MERGE AFTER PRINTING TIME
*
{PRFL2{JSR{6,PRTNL{{{THATS ANOTHER LINE{27418
*
*      HERE TO GO TO NEXT ENTRY
*
{PRFL3{ADD{19,*PF$I2{7,XR{{BUMP INDEX PTR (SGD07){27422
{{BLT{8,WB{3,PFNTE{6,PRFL1{LOOP IF MORE STMTS{27423
{{MOV{10,(XS)+{7,XR{{RESTORE CALLERS XR{27424
{{MOV{3,PFSVW{8,WB{{AND WB TOO{27425
*
*      HERE TO EXIT
*
{PRFL4{EXI{{{{RETURN{27429
{{ENP{{{{END OF PRFLR{27430
{{EJC{{{{{27431
*
*      PRFLU -- UPDATE AN ENTRY IN THE PROFILE TABLE
*
*      ON ENTRY, KVSTN CONTAINS NR OF STMT TO PROFILE
*
*      JSR  PRFLU            CALL TO UPDATE ENTRY
*      (IA)                  DESTROYED
*
{PRFLU{PRC{25,E{1,0{{{27440
{{BNZ{3,PFFNC{6,PFLU4{{SKIP IF JUST ENTERED FUNCTION{27441
{{MOV{7,XR{11,-(XS){{PRESERVE ENTRY XR{27442
{{MOV{8,WA{3,PFSVW{{SAVE WA (SGD07){27443
{{BNZ{3,PFTBL{6,PFLU2{{BRANCH IF TABLE ALLOCATED{27444
*
*      HERE IF SPACE FOR PROFILE TABLE NOT YET ALLOCATED.
*      CALCULATE SIZE NEEDED, ALLOCATE A STATIC XNBLK, AND
*      INITIALIZE IT ALL TO ZERO.
*      THE TIME TAKEN FOR THIS WILL BE ATTRIBUTED TO THE CURRENT
*      STATEMENT (ASSIGNMENT TO KEYWD PROFILE), BUT SINCE THE
*      TIMING FOR THIS STATEMENT IS UP THE POLE ANYWAY, THIS
*      DOESNT REALLY MATTER...
*
{{SUB{18,=NUM01{3,PFNTE{{ADJUST FOR EXTRA COUNT (SGD07){27454
{{MTI{4,PFI2A{{{CONVRT ENTRY SIZE TO INT{27455
{{STI{3,PFSTE{{{AND STORE SAFELY FOR LATER{27456
{{MTI{3,PFNTE{{{LOAD TABLE LENGTH AS INTEGER{27457
{{MLI{3,PFSTE{{{MULTIPLY BY ENTRY SIZE{27458
{{MFI{8,WA{{{GET BACK ADDRESS-STYLE{27459
{{ADD{18,=NUM02{8,WA{{ADD ON 2 WORD OVERHEAD{27460
{{WTB{8,WA{{{CONVERT THE WHOLE LOT TO BYTES{27461
{{JSR{6,ALOST{{{GIMME THE SPACE{27462
{{MOV{7,XR{3,PFTBL{{SAVE BLOCK POINTER{27463
{{MOV{22,=B$XNT{10,(XR)+{{PUT BLOCK TYPE AND ...{27464
{{MOV{8,WA{10,(XR)+{{... LENGTH INTO HEADER{27465
{{MFI{8,WA{{{GET BACK NR OF WDS IN DATA AREA{27466
{{LCT{8,WA{8,WA{{LOAD THE COUNTER{27467
*
*      LOOP HERE TO ZERO THE BLOCK DATA
*
{PFLU1{ZER{10,(XR)+{{{BLANK A WORD{27471
{{BCT{8,WA{6,PFLU1{{AND ALLLLLLL THE REST{27472
*
*      END OF ALLOCATION. MERGE BACK INTO ROUTINE
*
{PFLU2{MTI{3,KVSTN{{{LOAD NR OF STMT JUST ENDED{27476
{{SBI{4,INTV1{{{MAKE INTO INDEX OFFSET{27477
{{MLI{3,PFSTE{{{MAKE OFFSET OF TABLE ENTRY{27478
{{MFI{8,WA{{{CONVERT TO ADDRESS{27479
{{WTB{8,WA{{{GET AS BAUS{27480
{{ADD{19,*NUM02{8,WA{{OFFSET INCLUDES TABLE HEADER{27481
{{MOV{3,PFTBL{7,XR{{GET TABLE START{27482
{{BGE{8,WA{13,NUM01(XR){6,PFLU3{IF OUT OF TABLE, SKIP IT{27483
{{ADD{8,WA{7,XR{{ELSE POINT TO ENTRY{27484
{{LDI{9,(XR){{{GET NR OF EXECUTIONS SO FAR{27485
{{ADI{4,INTV1{{{NUDGE UP ONE{27486
{{STI{9,(XR){{{AND PUT BACK{27487
{{JSR{6,SYSTM{{{GET TIME NOW{27488
{{STI{3,PFETM{{{STASH ENDING TIME{27489
{{SBI{3,PFSTM{{{SUBTRACT START TIME{27490
{{ADI{13,CFP$I(XR){{{ADD CUMULATIVE TIME SO FAR{27491
{{STI{13,CFP$I(XR){{{AND PUT BACK NEW TOTAL{27492
{{LDI{3,PFETM{{{LOAD END TIME OF THIS STMT ...{27493
{{STI{3,PFSTM{{{... WHICH IS START TIME OF NEXT{27494
*
*      MERGE HERE TO EXIT
*
{PFLU3{MOV{10,(XS)+{7,XR{{RESTORE CALLERS XR{27498
{{MOV{3,PFSVW{8,WA{{RESTORE SAVED REG{27499
{{EXI{{{{AND RETURN{27500
*
*      HERE IF PROFILE IS SUPPRESSED BECAUSE A PROGRAM DEFINED
*      FUNCTION IS ABOUT TO BE ENTERED, AND SO THE CURRENT STMT
*      HAS NOT YET FINISHED
*
{PFLU4{ZER{3,PFFNC{{{RESET THE CONDITION FLAG{27506
{{EXI{{{{AND IMMEDIATE RETURN{27507
{{ENP{{{{END OF PROCEDURE PRFLU{27508
{{EJC{{{{{27509
*
*      PRPAR - PROCESS PRINT PARAMETERS
*
*      (WC)                  IF NONZERO ASSOCIATE TERMINAL ONLY
*      JSR  PRPAR            CALL TO PROCESS PRINT PARAMETERS
*      (XL,XR,WA,WB,WC)      DESTROYED
*
*      SINCE MEMORY ALLOCATION IS UNDECIDED ON INITIAL CALL,
*      TERMINAL CANNOT BE ASSOCIATED. THE ENTRY WITH WC NON-ZERO
*      IS PROVIDED SO A LATER CALL CAN BE MADE TO COMPLETE THIS.
*
{PRPAR{PRC{25,E{1,0{{ENTRY POINT{27522
{{BNZ{8,WC{6,PRPA8{{JUMP TO ASSOCIATE TERMINAL{27523
{{JSR{6,SYSPP{{{GET PRINT PARAMETERS{27524
{{BNZ{8,WB{6,PRPA1{{JUMP IF LINES/PAGE SPECIFIED{27525
{{MOV{18,=CFP$M{8,WB{{ELSE USE A LARGE VALUE{27526
{{RSH{8,WB{1,1{{BUT NOT TOO LARGE{27527
*
*      STORE LINE COUNT/PAGE
*
{PRPA1{MOV{8,WB{3,LSTNP{{STORE NUMBER OF LINES/PAGE{27531
{{MOV{8,WB{3,LSTLC{{PRETEND PAGE IS FULL INITIALLY{27532
{{ZER{3,LSTPG{{{CLEAR PAGE NUMBER{27533
{{MOV{3,PRLEN{8,WB{{GET PRIOR LENGTH IF ANY{27534
{{BZE{8,WB{6,PRPA2{{SKIP IF NO LENGTH{27535
{{BGT{8,WA{8,WB{6,PRPA3{SKIP STORING IF TOO BIG{27536
*
*      STORE PRINT BUFFER LENGTH
*
{PRPA2{MOV{8,WA{3,PRLEN{{STORE VALUE{27540
*
*      PROCESS BITS OPTIONS
*
{PRPA3{MOV{4,BITS3{8,WB{{BIT 3 MASK{27544
{{ANB{8,WC{8,WB{{GET -NOLIST BIT{27545
{{ZRB{8,WB{6,PRPA4{{SKIP IF CLEAR{27546
{{ZER{3,CSWLS{{{SET -NOLIST{27547
*
*      CHECK IF FAIL REPORTS GOTO INTERACTIVE CHANNEL
*
{PRPA4{MOV{4,BITS1{8,WB{{BIT 1 MASK{27551
{{ANB{8,WC{8,WB{{GET BIT{27552
{{MOV{8,WB{3,ERICH{{STORE INT. CHAN. ERROR FLAG{27553
{{MOV{4,BITS2{8,WB{{BIT 2 MASK{27554
{{ANB{8,WC{8,WB{{GET BIT{27555
{{MOV{8,WB{3,PRICH{{FLAG FOR STD PRINTER ON INT. CHAN.{27556
{{MOV{4,BITS4{8,WB{{BIT 4 MASK{27557
{{ANB{8,WC{8,WB{{GET BIT{27558
{{MOV{8,WB{3,CPSTS{{FLAG FOR COMPILE STATS SUPPRESSN.{27559
{{MOV{4,BITS5{8,WB{{BIT 5 MASK{27560
{{ANB{8,WC{8,WB{{GET BIT{27561
{{MOV{8,WB{3,EXSTS{{FLAG FOR EXEC STATS SUPPRESSION{27562
{{EJC{{{{{27563
*
*      PRPAR (CONTINUED)
*
{{MOV{4,BITS6{8,WB{{BIT 6 MASK{27567
{{ANB{8,WC{8,WB{{GET BIT{27568
{{MOV{8,WB{3,PRECL{{EXTENDED/COMPACT LISTING FLAG{27569
{{SUB{18,=NUM08{8,WA{{POINT 8 CHARS FROM LINE END{27570
{{ZRB{8,WB{6,PRPA5{{JUMP IF NOT EXTENDED{27571
{{MOV{8,WA{3,LSTPO{{STORE FOR LISTING PAGE HEADINGS{27572
*
*       CONTINUE OPTION PROCESSING
*
{PRPA5{MOV{4,BITS7{8,WB{{BIT 7 MASK{27576
{{ANB{8,WC{8,WB{{GET BIT 7{27577
{{MOV{8,WB{3,CSWEX{{SET -NOEXECUTE IF NON-ZERO{27578
{{MOV{4,BIT10{8,WB{{BIT 10 MASK{27579
{{ANB{8,WC{8,WB{{GET BIT 10{27580
{{MOV{8,WB{3,HEADP{{PRETEND PRINTED TO OMIT HEADERS{27581
{{MOV{4,BITS9{8,WB{{BIT 9 MASK{27582
{{ANB{8,WC{8,WB{{GET BIT 9{27583
{{MOV{8,WB{3,PRSTO{{KEEP IT AS STD LISTING OPTION{27584
{{MOV{8,WC{8,WB{{COPY FLAGS{27586
{{RSH{8,WB{1,12{{RIGHT JUSTIFY BIT 13{27587
{{ANB{4,BITS1{8,WB{{GET BIT{27588
{{MOV{8,WB{3,KVCAS{{SET -CASE{27589
{{MOV{4,BIT12{8,WB{{BIT 12 MASK{27591
{{ANB{8,WC{8,WB{{GET BIT 12{27592
{{MOV{8,WB{3,CSWER{{KEEP IT AS ERRORS/NOERRORS OPTION{27593
{{ZRB{8,WB{6,PRPA6{{SKIP IF CLEAR{27594
{{MOV{3,PRLEN{8,WA{{GET PRINT BUFFER LENGTH{27595
{{SUB{18,=NUM08{8,WA{{POINT 8 CHARS FROM LINE END{27596
{{MOV{8,WA{3,LSTPO{{STORE PAGE OFFSET{27597
*
*      CHECK FOR -PRINT/-NOPRINT
*
{PRPA6{MOV{4,BIT11{8,WB{{BIT 11 MASK{27601
{{ANB{8,WC{8,WB{{GET BIT 11{27602
{{MOV{8,WB{3,CSWPR{{SET -PRINT IF NON-ZERO{27603
*
*      CHECK FOR TERMINAL
*
{{ANB{4,BITS8{8,WC{{SEE IF TERMINAL TO BE ACTIVATED{27607
{{BNZ{8,WC{6,PRPA8{{JUMP IF TERMINAL REQUIRED{27608
{{BZE{3,INITR{6,PRPA9{{JUMP IF NO TERMINAL TO DETACH{27609
{{MOV{21,=V$TER{7,XL{{PTR TO /TERMINAL/{27610
{{JSR{6,GTNVR{{{GET VRBLK POINTER{27611
{{PPM{{{{CANT FAIL{27612
{{MOV{21,=NULLS{13,VRVAL(XR){{CLEAR VALUE OF TERMINAL{27613
{{JSR{6,SETVR{{{REMOVE ASSOCIATION{27614
{{BRN{6,PRPA9{{{RETURN{27615
*
*      ASSOCIATE TERMINAL
*
{PRPA8{MNZ{3,INITR{{{NOTE TERMINAL ASSOCIATED{27619
{{BZE{3,DNAMB{6,PRPA9{{CANT IF MEMORY NOT ORGANISED{27620
{{MOV{21,=V$TER{7,XL{{POINT TO TERMINAL STRING{27621
{{MOV{18,=TRTOU{8,WB{{OUTPUT TRACE TYPE{27622
{{JSR{6,INOUT{{{ATTACH OUTPUT TRBLK TO VRBLK{27623
{{MOV{7,XR{11,-(XS){{STACK TRBLK PTR{27624
{{MOV{21,=V$TER{7,XL{{POINT TO TERMINAL STRING{27625
{{MOV{18,=TRTIN{8,WB{{INPUT TRACE TYPE{27626
{{JSR{6,INOUT{{{ATTACH INPUT TRACE BLK{27627
{{MOV{10,(XS)+{13,VRVAL(XR){{ADD OUTPUT TRBLK TO CHAIN{27628
*
*      RETURN POINT
*
{PRPA9{EXI{{{{RETURN{27632
{{ENP{{{{END PROCEDURE PRPAR{27633
{{EJC{{{{{27634
*
*      PRTCH -- PRINT A CHARACTER
*
*      PRTCH IS USED TO PRINT A SINGLE CHARACTER
*
*      (WA)                  CHARACTER TO BE PRINTED
*      JSR  PRTCH            CALL TO PRINT CHARACTER
*
{PRTCH{PRC{25,E{1,0{{ENTRY POINT{27643
{{MOV{7,XR{11,-(XS){{SAVE XR{27644
{{BNE{3,PROFS{3,PRLEN{6,PRCH1{JUMP IF ROOM IN BUFFER{27645
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{27646
*
*      HERE AFTER MAKING SURE WE HAVE ROOM
*
{PRCH1{MOV{3,PRBUF{7,XR{{POINT TO PRINT BUFFER{27650
{{PSC{7,XR{3,PROFS{{POINT TO NEXT CHARACTER LOCATION{27651
{{SCH{8,WA{9,(XR){{STORE NEW CHARACTER{27652
{{CSC{7,XR{{{COMPLETE STORE CHARACTERS{27653
{{ICV{3,PROFS{{{BUMP POINTER{27654
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27655
{{EXI{{{{RETURN TO PRTCH CALLER{27656
{{ENP{{{{END PROCEDURE PRTCH{27657
{{EJC{{{{{27658
*
*      PRTIC -- PRINT TO INTERACTIVE CHANNEL
*
*      PRTIC IS CALLED TO PRINT THE CONTENTS OF THE STANDARD
*      PRINT BUFFER TO THE INTERACTIVE CHANNEL. IT IS ONLY
*      CALLED AFTER PRTST HAS SET UP THE STRING FOR PRINTING.
*      IT DOES NOT CLEAR THE BUFFER.
*
*      JSR  PRTIC            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTIC{PRC{25,E{1,0{{ENTRY POINT{27670
{{MOV{7,XR{11,-(XS){{SAVE XR{27671
{{MOV{3,PRBUF{7,XR{{POINT TO BUFFER{27672
{{MOV{3,PROFS{8,WA{{NO OF CHARS{27673
{{JSR{6,SYSPI{{{PRINT{27674
{{PPM{6,PRTC2{{{FAIL RETURN{27675
*
*      RETURN
*
{PRTC1{MOV{10,(XS)+{7,XR{{RESTORE XR{27679
{{EXI{{{{RETURN{27680
*
*      ERROR OCCURED
*
{PRTC2{ZER{3,ERICH{{{PREVENT LOOPING{27684
{{ERB{1,252{26,Error on printing to interactive channel{{{27685
{{BRN{6,PRTC1{{{RETURN{27686
{{ENP{{{{PROCEDURE PRTIC{27687
{{EJC{{{{{27688
*
*      PRTIS -- PRINT TO INTERACTIVE AND STANDARD PRINTER
*
*      PRTIS PUTS A LINE FROM THE PRINT BUFFER ONTO THE
*      INTERACTIVE CHANNEL (IF ANY) AND THE STANDARD PRINTER.
*      IT ALWAYS PRINTS TO THE STANDARD PRINTER BUT DOES
*      NOT DUPLICATE LINES IF THE STANDARD PRINTER IS
*      INTERACTIVE.  IT CLEARS DOWN THE PRINT BUFFER.
*
*      JSR  PRTIS            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTIS{PRC{25,E{1,0{{ENTRY POINT{27701
{{BNZ{3,PRICH{6,PRTS1{{JUMP IF STANDARD PRINTER IS INT.CH.{27702
{{BZE{3,ERICH{6,PRTS1{{SKIP IF NOT DOING INT. ERROR REPS.{27703
{{JSR{6,PRTIC{{{PRINT TO INTERACTIVE CHANNEL{27704
*
*      MERGE AND EXIT
*
{PRTS1{JSR{6,PRTNL{{{PRINT TO STANDARD PRINTER{27708
{{EXI{{{{RETURN{27709
{{ENP{{{{END PROCEDURE PRTIS{27710
{{EJC{{{{{27711
*
*      PRTIN -- PRINT AN INTEGER
*
*      PRTIN PRINTS THE INTEGER VALUE WHICH IS IN THE INTEGER
*      ACCUMULATOR. BLOCKS BUILT IN DYNAMIC STORAGE
*      DURING THIS PROCESS ARE IMMEDIATELY DELETED.
*
*      (IA)                  INTEGER VALUE TO BE PRINTED
*      JSR  PRTIN            CALL TO PRINT INTEGER
*      (IA,RA)               DESTROYED
*
{PRTIN{PRC{25,E{1,0{{ENTRY POINT{27723
{{MOV{7,XR{11,-(XS){{SAVE XR{27724
{{JSR{6,ICBLD{{{BUILD INTEGER BLOCK{27725
{{BLO{7,XR{3,DNAMB{6,PRTI1{JUMP IF ICBLK BELOW DYNAMIC{27726
{{BHI{7,XR{3,DNAMP{6,PRTI1{JUMP IF ABOVE DYNAMIC{27727
{{MOV{7,XR{3,DNAMP{{IMMEDIATELY DELETE IT{27728
*
*      DELETE ICBLK FROM DYNAMIC STORE
*
{PRTI1{MOV{7,XR{11,-(XS){{STACK PTR FOR GTSTG{27732
{{JSR{6,GTSTG{{{CONVERT TO STRING{27733
{{PPM{{{{CONVERT ERROR IS IMPOSSIBLE{27734
{{MOV{7,XR{3,DNAMP{{RESET POINTER TO DELETE SCBLK{27735
{{JSR{6,PRTST{{{PRINT INTEGER STRING{27736
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27737
{{EXI{{{{RETURN TO PRTIN CALLER{27738
{{ENP{{{{END PROCEDURE PRTIN{27739
{{EJC{{{{{27740
*
*      PRTMI -- PRINT MESSAGE AND INTEGER
*
*      PRTMI IS USED TO PRINT MESSAGES TOGETHER WITH AN INTEGER
*      VALUE STARTING IN COLUMN 15 (USED BY THE ROUTINES AT
*      THE END OF COMPILATION).
*
*      JSR  PRTMI            CALL TO PRINT MESSAGE AND INTEGER
*
{PRTMI{PRC{25,E{1,0{{ENTRY POINT{27750
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{27751
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{27752
{{JSR{6,PRTIN{{{PRINT INTEGER{27753
{{JSR{6,PRTNL{{{PRINT LINE{27754
{{EXI{{{{RETURN TO PRTMI CALLER{27755
{{ENP{{{{END PROCEDURE PRTMI{27756
{{EJC{{{{{27757
*
*      PRTMM -- PRINT MEMORY USED AND AVAILABLE
*
*      PRTMM IS USED TO PROVIDE MEMORY USAGE INFORMATION IN
*      BOTH THE END-OF-COMPILE AND END-OF-RUN STATISTICS.
*
*      JSR  PRTMM            CALL TO PRINT MEMORY STATS
*
{PRTMM{PRC{25,E{1,0{{{27766
{{MOV{3,DNAMP{8,WA{{NEXT AVAILABLE LOC{27767
{{SUB{3,STATB{8,WA{{MINUS START{27768
{{BTW{8,WA{{{CONVERT TO WORDS{27771
{{MTI{8,WA{{{CONVERT TO INTEGER{27773
{{MOV{21,=ENCM1{7,XR{{POINT TO /MEMORY USED (WORDS)/{27774
{{JSR{6,PRTMI{{{PRINT MESSAGE{27775
{{MOV{3,DNAME{8,WA{{END OF MEMORY{27776
{{SUB{3,DNAMP{8,WA{{MINUS NEXT AVAILABLE LOC{27777
{{BTW{8,WA{{{CONVERT TO WORDS{27780
{{MTI{8,WA{{{CONVERT TO INTEGER{27782
{{MOV{21,=ENCM2{7,XR{{POINT TO /MEMORY AVAILABLE (WORDS)/{27783
{{JSR{6,PRTMI{{{PRINT LINE{27784
{{EXI{{{{RETURN TO PRTMM CALLER{27785
{{ENP{{{{END OF PROCEDURE PRTMM{27786
{{EJC{{{{{27787
*
*      PRTMX  -- AS PRTMI WITH EXTRA COPY TO INTERACTIVE CHAN.
*
*      JSR  PRTMX            CALL FOR PRINTING
*      (WA,WB)               DESTROYED
*
{PRTMX{PRC{25,E{1,0{{ENTRY POINT{27794
{{JSR{6,PRTST{{{PRINT STRING MESSAGE{27795
{{MOV{18,=PRTMF{3,PROFS{{SET COLUMN OFFSET{27796
{{JSR{6,PRTIN{{{PRINT INTEGER{27797
{{JSR{6,PRTIS{{{PRINT LINE{27798
{{EXI{{{{RETURN{27799
{{ENP{{{{END PROCEDURE PRTMX{27800
{{EJC{{{{{27801
*
*      PRTNL -- PRINT NEW LINE (END PRINT LINE)
*
*      PRTNL PRINTS THE CONTENTS OF THE PRINT BUFFER, RESETS
*      THE BUFFER TO ALL BLANKS AND RESETS THE PRINT POINTER.
*
*      JSR  PRTNL            CALL TO PRINT LINE
*
{PRTNL{PRC{25,R{1,0{{ENTRY POINT{27810
{{BNZ{3,HEADP{6,PRNL0{{WERE HEADERS PRINTED{27811
{{JSR{6,PRTPS{{{NO - PRINT THEM{27812
*
*      CALL SYSPR
*
{PRNL0{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{27816
{{MOV{8,WA{3,PRTSA{{SAVE WA{27817
{{MOV{8,WB{3,PRTSB{{SAVE WB{27818
{{MOV{3,PRBUF{7,XR{{LOAD POINTER TO BUFFER{27819
{{MOV{3,PROFS{8,WA{{LOAD NUMBER OF CHARS IN BUFFER{27820
{{JSR{6,SYSPR{{{CALL SYSTEM PRINT ROUTINE{27821
{{PPM{6,PRNL2{{{JUMP IF FAILED{27822
{{LCT{8,WA{3,PRLNW{{LOAD LENGTH OF BUFFER IN WORDS{27823
{{ADD{19,*SCHAR{7,XR{{POINT TO CHARS OF BUFFER{27824
{{MOV{4,NULLW{8,WB{{GET WORD OF BLANKS{27825
*
*      LOOP TO BLANK BUFFER
*
{PRNL1{MOV{8,WB{10,(XR)+{{STORE WORD OF BLANKS, BUMP PTR{27829
{{BCT{8,WA{6,PRNL1{{LOOP TILL ALL BLANKED{27830
*
*      EXIT POINT
*
{{MOV{3,PRTSB{8,WB{{RESTORE WB{27834
{{MOV{3,PRTSA{8,WA{{RESTORE WA{27835
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{27836
{{ZER{3,PROFS{{{RESET PRINT BUFFER POINTER{27837
{{EXI{{{{RETURN TO PRTNL CALLER{27838
*
*      FILE FULL OR NO OUTPUT FILE FOR LOAD MODULE
*
{PRNL2{BNZ{3,PRTEF{6,PRNL3{{JUMP IF NOT FIRST TIME{27842
{{MNZ{3,PRTEF{{{MARK FIRST OCCURRENCE{27843
{{ERB{1,253{26,Print limit exceeded on standard output channel{{{27844
*
*      STOP AT ONCE
*
{PRNL3{MOV{18,=NINI8{8,WB{{ENDING CODE{27848
{{MOV{3,KVSTN{8,WA{{STATEMENT NUMBER{27849
{{MOV{3,R$FCB{7,XL{{GET FCBLK CHAIN HEAD{27850
{{JSR{6,SYSEJ{{{STOP{27851
{{ENP{{{{END PROCEDURE PRTNL{27852
{{EJC{{{{{27853
*
*      PRTNM -- PRINT VARIABLE NAME
*
*      PRTNM IS USED TO PRINT A CHARACTER REPRESENTATION OF THE
*      NAME OF A VARIABLE (NOT A VALUE OF DATATYPE NAME)
*      NAMES OF PSEUDO-VARIABLES MAY NOT BE PASSED TO PRTNM.
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNM            CALL TO PRINT NAME
*      (WB,WC,RA)            DESTROYED
*
{PRTNM{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE, SEE PRTVL){27866
{{MOV{8,WA{11,-(XS){{SAVE WA (OFFSET IS COLLECTABLE){27867
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{27868
{{MOV{7,XL{11,-(XS){{SAVE NAME BASE{27869
{{BHI{7,XL{3,STATE{6,PRN02{JUMP IF NOT NATURAL VARIABLE{27870
*
*      HERE FOR NATURAL VARIABLE NAME, RECOGNIZED BY THE FACT
*      THAT THE NAME BASE POINTS INTO THE STATIC AREA.
*
{{MOV{7,XL{7,XR{{POINT TO VRBLK{27875
{{JSR{6,PRTVN{{{PRINT NAME OF VARIABLE{27876
*
*      COMMON EXIT POINT
*
{PRN01{MOV{10,(XS)+{7,XL{{RESTORE NAME BASE{27880
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY VALUE OF XR{27881
{{MOV{10,(XS)+{8,WA{{RESTORE WA{27882
{{EXI{{{{RETURN TO PRTNM CALLER{27883
*
*      HERE FOR CASE OF NON-NATURAL VARIABLE
*
{PRN02{MOV{8,WA{8,WB{{COPY NAME OFFSET{27887
{{BNE{9,(XL){22,=B$PDT{6,PRN03{JUMP IF ARRAY OR TABLE{27888
*
*      FOR PROGRAM DEFINED DATATYPE, PRT FLD NAME, LEFT PAREN
*
{{MOV{13,PDDFP(XL){7,XR{{LOAD POINTER TO DFBLK{27892
{{ADD{8,WA{7,XR{{ADD NAME OFFSET{27893
{{MOV{13,PDFOF(XR){7,XR{{LOAD VRBLK POINTER FOR FIELD{27894
{{JSR{6,PRTVN{{{PRINT FIELD NAME{27895
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{27896
{{JSR{6,PRTCH{{{PRINT CHARACTER{27897
{{EJC{{{{{27898
*
*      PRTNM (CONTINUED)
*
*      NOW WE PRINT AN IDENTIFYING NAME FOR THE OBJECT IF ONE
*      CAN BE FOUND. THE FOLLOWING CODE SEARCHES FOR A NATURAL
*      VARIABLE WHICH CONTAINS THIS OBJECT AS VALUE. IF SUCH A
*      VARIABLE IS FOUND, ITS NAME IS PRINTED, ELSE THE VALUE
*      OF THE OBJECT (AS PRINTED BY PRTVL) IS USED INSTEAD.
*
*      FIRST WE POINT TO THE PARENT TBBLK IF THIS IS THE CASE OF
*      A TABLE ELEMENT. TO DO THIS, CHASE DOWN THE TRNXT CHAIN.
*
{PRN03{BNE{9,(XL){22,=B$TET{6,PRN04{JUMP IF WE GOT THERE (OR NOT TE){27911
{{MOV{13,TENXT(XL){7,XL{{ELSE MOVE OUT ON CHAIN{27912
{{BRN{6,PRN03{{{AND LOOP BACK{27913
*
*      NOW WE ARE READY FOR THE SEARCH. TO SPEED THINGS UP IN
*      THE CASE OF CALLS FROM DUMP WHERE THE SAME NAME BASE
*      WILL OCCUR REPEATEDLY WHILE DUMPING AN ARRAY OR TABLE,
*      WE REMEMBER THE LAST VRBLK POINTER FOUND IN PRNMV. SO
*      FIRST CHECK TO SEE IF WE HAVE THIS ONE AGAIN.
*
{PRN04{MOV{3,PRNMV{7,XR{{POINT TO VRBLK WE FOUND LAST TIME{27921
{{MOV{3,HSHTB{8,WA{{POINT TO HASH TABLE IN CASE NOT{27922
{{BRN{6,PRN07{{{JUMP INTO SEARCH FOR SPECIAL CHECK{27923
*
*      LOOP THROUGH HASH SLOTS
*
{PRN05{MOV{8,WA{7,XR{{COPY SLOT POINTER{27927
{{ICA{8,WA{{{BUMP SLOT POINTER{27928
{{SUB{19,*VRNXT{7,XR{{INTRODUCE STANDARD VRBLK OFFSET{27929
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
{PRN06{MOV{13,VRNXT(XR){7,XR{{POINT TO NEXT VRBLK ON HASH CHAIN{27933
*
*      MERGE HERE FIRST TIME TO CHECK BLOCK WE FOUND LAST TIME
*
{PRN07{MOV{7,XR{8,WC{{COPY VRBLK POINTER{27937
{{BZE{8,WC{6,PRN09{{JUMP IF CHAIN END (OR PRNMV ZERO){27938
{{EJC{{{{{27939
*
*      PRTNM (CONTINUED)
*
*      LOOP TO FIND VALUE (CHASE DOWN POSSIBLE TRBLK CHAIN)
*
{PRN08{MOV{13,VRVAL(XR){7,XR{{LOAD VALUE{27945
{{BEQ{9,(XR){22,=B$TRT{6,PRN08{LOOP IF THAT WAS A TRBLK{27946
*
*      NOW WE HAVE THE VALUE, IS THIS THE BLOCK WE WANT
*
{{BEQ{7,XR{7,XL{6,PRN10{JUMP IF THIS MATCHES THE NAME BASE{27950
{{MOV{8,WC{7,XR{{ELSE POINT BACK TO THAT VRBLK{27951
{{BRN{6,PRN06{{{AND LOOP BACK{27952
*
*      HERE TO MOVE TO NEXT HASH SLOT
*
{PRN09{BLT{8,WA{3,HSHTE{6,PRN05{LOOP BACK IF MORE TO GO{27956
{{MOV{7,XL{7,XR{{ELSE NOT FOUND, COPY VALUE POINTER{27957
{{JSR{6,PRTVL{{{PRINT VALUE{27958
{{BRN{6,PRN11{{{AND MERGE AHEAD{27959
*
*      HERE WHEN WE FIND A MATCHING ENTRY
*
{PRN10{MOV{8,WC{7,XR{{COPY VRBLK POINTER{27963
{{MOV{7,XR{3,PRNMV{{SAVE FOR NEXT TIME IN{27964
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{27965
*
*      MERGE HERE IF NO ENTRY FOUND
*
{PRN11{MOV{9,(XL){8,WC{{LOAD FIRST WORD OF NAME BASE{27969
{{BNE{8,WC{22,=B$PDT{6,PRN13{JUMP IF NOT PROGRAM DEFINED{27970
*
*      FOR PROGRAM DEFINED DATATYPE, ADD RIGHT PAREN AND EXIT
*
{{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN, MERGE{27974
*
*      MERGE HERE TO PRINT FINAL RIGHT PAREN OR BRACKET
*
{PRN12{JSR{6,PRTCH{{{PRINT FINAL CHARACTER{27978
{{MOV{8,WB{8,WA{{RESTORE NAME OFFSET{27979
{{BRN{6,PRN01{{{MERGE BACK TO EXIT{27980
{{EJC{{{{{27981
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY OR TABLE
*
{PRN13{MOV{18,=CH$BB{8,WA{{LOAD LEFT BRACKET{27987
{{JSR{6,PRTCH{{{AND PRINT IT{27988
{{MOV{9,(XS){7,XL{{RESTORE BLOCK POINTER{27989
{{MOV{9,(XL){8,WC{{LOAD TYPE WORD AGAIN{27990
{{BNE{8,WC{22,=B$TET{6,PRN15{JUMP IF NOT TABLE{27991
*
*      HERE FOR TABLE, PRINT SUBSCRIPT VALUE
*
{{MOV{13,TESUB(XL){7,XR{{LOAD SUBSCRIPT VALUE{27995
{{MOV{8,WB{7,XL{{SAVE NAME OFFSET{27996
{{JSR{6,PRTVL{{{PRINT SUBSCRIPT VALUE{27997
{{MOV{7,XL{8,WB{{RESTORE NAME OFFSET{27998
*
*      MERGE HERE FROM ARRAY CASE TO PRINT RIGHT BRACKET
*
{PRN14{MOV{18,=CH$RB{8,WA{{LOAD RIGHT BRACKET{28002
{{BRN{6,PRN12{{{MERGE BACK TO PRINT IT{28003
*
*      HERE FOR ARRAY OR VECTOR, TO PRINT SUBSCRIPT(S)
*
{PRN15{MOV{8,WB{8,WA{{COPY NAME OFFSET{28007
{{BTW{8,WA{{{CONVERT TO WORDS{28008
{{BEQ{8,WC{22,=B$ART{6,PRN16{JUMP IF ARBLK{28009
*
*      HERE FOR VECTOR
*
{{SUB{18,=VCVLB{8,WA{{ADJUST FOR STANDARD FIELDS{28013
{{MTI{8,WA{{{MOVE TO INTEGER ACCUM{28014
{{JSR{6,PRTIN{{{PRINT LINEAR SUBSCRIPT{28015
{{BRN{6,PRN14{{{MERGE BACK FOR RIGHT BRACKET{28016
{{EJC{{{{{28017
*
*      PRTNM (CONTINUED)
*
*      HERE FOR ARRAY. FIRST CALCULATE ABSOLUTE SUBSCRIPT
*      OFFSETS BY SUCCESSIVE DIVISIONS BY THE DIMENSION VALUES.
*      THIS MUST BE DONE RIGHT TO LEFT SINCE THE ELEMENTS ARE
*      STORED ROW-WISE. THE SUBSCRIPTS ARE STACKED AS INTEGERS.
*
{PRN16{MOV{13,AROFS(XL){8,WC{{LOAD LENGTH OF BOUNDS INFO{28026
{{ICA{8,WC{{{ADJUST FOR ARPRO FIELD{28027
{{BTW{8,WC{{{CONVERT TO WORDS{28028
{{SUB{8,WC{8,WA{{GET LINEAR ZERO-ORIGIN SUBSCRIPT{28029
{{MTI{8,WA{{{GET INTEGER VALUE{28030
{{LCT{8,WA{13,ARNDM(XL){{SET NUM OF DIMENSIONS AS LOOP COUNT{28031
{{ADD{13,AROFS(XL){7,XL{{POINT PAST BOUNDS INFORMATION{28032
{{SUB{19,*ARLBD{7,XL{{SET OK OFFSET FOR PROPER PTR LATER{28033
*
*      LOOP TO STACK SUBSCRIPT OFFSETS
*
{PRN17{SUB{19,*ARDMS{7,XL{{POINT TO NEXT SET OF BOUNDS{28037
{{STI{3,PRNSI{{{SAVE CURRENT OFFSET{28038
{{RMI{13,ARDIM(XL){{{GET REMAINDER ON DIVIDING BY DIMENS{28039
{{MFI{11,-(XS){{{STORE ON STACK (ONE WORD){28040
{{LDI{3,PRNSI{{{RELOAD ARGUMENT{28041
{{DVI{13,ARDIM(XL){{{DIVIDE TO GET QUOTIENT{28042
{{BCT{8,WA{6,PRN17{{LOOP TILL ALL STACKED{28043
{{ZER{7,XR{{{SET OFFSET TO FIRST SET OF BOUNDS{28044
{{LCT{8,WB{13,ARNDM(XL){{LOAD COUNT OF DIMS TO CONTROL LOOP{28045
{{BRN{6,PRN19{{{JUMP INTO PRINT LOOP{28046
*
*      LOOP TO PRINT SUBSCRIPTS FROM STACK ADJUSTING BY ADDING
*      THE APPROPRIATE LOW BOUND VALUE FROM THE ARBLK
*
{PRN18{MOV{18,=CH$CM{8,WA{{LOAD A COMMA{28051
{{JSR{6,PRTCH{{{PRINT IT{28052
*
*      MERGE HERE FIRST TIME IN (NO COMMA REQUIRED)
*
{PRN19{MTI{10,(XS)+{{{LOAD SUBSCRIPT OFFSET AS INTEGER{28056
{{ADD{7,XR{7,XL{{POINT TO CURRENT LBD{28057
{{ADI{13,ARLBD(XL){{{ADD LBD TO GET SIGNED SUBSCRIPT{28058
{{SUB{7,XR{7,XL{{POINT BACK TO START OF ARBLK{28059
{{JSR{6,PRTIN{{{PRINT SUBSCRIPT{28060
{{ADD{19,*ARDMS{7,XR{{BUMP OFFSET TO NEXT BOUNDS{28061
{{BCT{8,WB{6,PRN18{{LOOP BACK TILL ALL PRINTED{28062
{{BRN{6,PRN14{{{MERGE BACK TO PRINT RIGHT BRACKET{28063
{{ENP{{{{END PROCEDURE PRTNM{28064
{{EJC{{{{{28065
*
*      PRTNV -- PRINT NAME VALUE
*
*      PRTNV IS USED BY THE TRACE AND DUMP ROUTINES TO PRINT
*      A LINE OF THE FORM
*
*      NAME = VALUE
*
*      NOTE THAT THE NAME INVOLVED CAN NEVER BE A PSEUDO-VAR
*
*      (XL)                  NAME BASE
*      (WA)                  NAME OFFSET
*      JSR  PRTNV            CALL TO PRINT NAME = VALUE
*      (WB,WC,RA)            DESTROYED
*
{PRTNV{PRC{25,E{1,0{{ENTRY POINT{28081
{{JSR{6,PRTNM{{{PRINT ARGUMENT NAME{28082
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{28083
{{MOV{8,WA{11,-(XS){{SAVE NAME OFFSET (COLLECTABLE){28084
{{MOV{21,=TMBEB{7,XR{{POINT TO BLANK EQUAL BLANK{28085
{{JSR{6,PRTST{{{PRINT IT{28086
{{MOV{7,XL{7,XR{{COPY NAME BASE{28087
{{ADD{8,WA{7,XR{{POINT TO VALUE{28088
{{MOV{9,(XR){7,XR{{LOAD VALUE POINTER{28089
{{JSR{6,PRTVL{{{PRINT VALUE{28090
{{JSR{6,PRTNL{{{TERMINATE LINE{28091
{{MOV{10,(XS)+{8,WA{{RESTORE NAME OFFSET{28092
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{28093
{{EXI{{{{RETURN TO CALLER{28094
{{ENP{{{{END PROCEDURE PRTNV{28095
{{EJC{{{{{28096
*
*      PRTPG  -- PRINT A PAGE THROW
*
*      PRINTS A PAGE THROW OR A FEW BLANK LINES ON THE STANDARD
*      LISTING CHANNEL DEPENDING ON THE LISTING OPTIONS CHOSEN.
*
*      JSR  PRTPG            CALL FOR PAGE EJECT
*
{PRTPG{PRC{25,E{1,0{{ENTRY POINT{28105
{{BEQ{3,STAGE{18,=STGXT{6,PRP01{JUMP IF EXECUTION TIME{28106
{{BZE{3,LSTLC{6,PRP06{{RETURN IF TOP OF PAGE ALREADY{28107
{{ZER{3,LSTLC{{{CLEAR LINE COUNT{28108
*
*      CHECK TYPE OF LISTING
*
{PRP01{MOV{7,XR{11,-(XS){{PRESERVE XR{28112
{{BNZ{3,PRSTD{6,PRP02{{EJECT IF FLAG SET{28113
{{BNZ{3,PRICH{6,PRP03{{JUMP IF INTERACTIVE LISTING CHANNEL{28114
{{BZE{3,PRECL{6,PRP03{{JUMP IF COMPACT LISTING{28115
*
*      PERFORM AN EJECT
*
{PRP02{JSR{6,SYSEP{{{EJECT{28119
{{BRN{6,PRP04{{{MERGE{28120
*
*      COMPACT OR INTERACTIVE CHANNEL LISTING. CANT PRINT
*      BLANKS UNTIL CHECK MADE FOR HEADERS PRINTED AND FLAG SET.
*
*
{PRP03{MOV{3,HEADP{7,XR{{REMEMBER HEADP{28126
{{MNZ{3,HEADP{{{SET TO AVOID REPEATED PRTPG CALLS{28127
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28128
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28129
{{JSR{6,PRTNL{{{PRINT BLANK LINE{28130
{{MOV{18,=NUM03{3,LSTLC{{COUNT BLANK LINES{28131
{{MOV{7,XR{3,HEADP{{RESTORE HEADER FLAG{28132
{{EJC{{{{{28133
*
*      PRPTG (CONTINUED)
*
*      PRINT THE HEADING
*
{PRP04{BNZ{3,HEADP{6,PRP05{{JUMP IF HEADER LISTED{28139
{{MNZ{3,HEADP{{{MARK HEADERS PRINTED{28140
{{MOV{7,XL{11,-(XS){{KEEP XL{28141
{{MOV{21,=HEADR{7,XR{{POINT TO LISTING HEADER{28142
{{JSR{6,PRTST{{{PLACE IT{28143
{{JSR{6,SYSID{{{GET SYSTEM IDENTIFICATION{28144
{{JSR{6,PRTST{{{APPEND EXTRA CHARS{28145
{{JSR{6,PRTNL{{{PRINT IT{28146
{{MOV{7,XL{7,XR{{EXTRA HEADER LINE{28147
{{JSR{6,PRTST{{{PLACE IT{28148
{{JSR{6,PRTNL{{{PRINT IT{28149
{{JSR{6,PRTNL{{{PRINT A BLANK{28150
{{JSR{6,PRTNL{{{AND ANOTHER{28151
{{ADD{18,=NUM04{3,LSTLC{{FOUR HEADER LINES PRINTED{28152
{{MOV{10,(XS)+{7,XL{{RESTORE XL{28153
*
*      MERGE IF HEADER NOT PRINTED
*
{PRP05{MOV{10,(XS)+{7,XR{{RESTORE XR{28157
*
*      RETURN
*
{PRP06{EXI{{{{RETURN{28161
{{ENP{{{{END PROCEDURE PRTPG{28162
{{EJC{{{{{28163
*
*      PRTPS - PRINT PAGE WITH TEST FOR STANDARD LISTING OPTION
*
*      IF THE STANDARD LISTING OPTION IS SELECTED, INSIST THAT
*      AN EJECT BE DONE
*
*      JSR  PRTPS            CALL FOR EJECT
*
{PRTPS{PRC{25,E{1,0{{ENTRY POINT{28172
{{MOV{3,PRSTO{3,PRSTD{{COPY OPTION FLAG{28173
{{JSR{6,PRTPG{{{PRINT PAGE{28174
{{ZER{3,PRSTD{{{CLEAR FLAG{28175
{{EXI{{{{RETURN{28176
{{ENP{{{{END PROCEDURE PRTPS{28177
{{EJC{{{{{28178
*
*      PRTSN -- PRINT STATEMENT NUMBER
*
*      PRTSN IS USED TO INITIATE A PRINT TRACE LINE BY PRINTING
*      ASTERISKS AND THE CURRENT STATEMENT NUMBER. THE ACTUAL
*      FORMAT OF THE OUTPUT GENERATED IS.
*
*      ***NNNNN**** III.....IIII
*
*      NNNNN IS THE STATEMENT NUMBER WITH LEADING ZEROS REPLACED
*      BY ASTERISKS (E.G. *******9****)
*
*      III...III REPRESENTS A VARIABLE LENGTH OUTPUT CONSISTING
*      OF A NUMBER OF LETTER I CHARACTERS EQUAL TO FNCLEVEL.
*
*      JSR  PRTSN            CALL TO PRINT STATEMENT NUMBER
*      (WC)                  DESTROYED
*
{PRTSN{PRC{25,E{1,0{{ENTRY POINT{28197
{{MOV{7,XR{11,-(XS){{SAVE ENTRY XR{28198
{{MOV{8,WA{3,PRSNA{{SAVE ENTRY WA{28199
{{MOV{21,=TMASB{7,XR{{POINT TO ASTERISKS{28200
{{JSR{6,PRTST{{{PRINT ASTERISKS{28201
{{MOV{18,=NUM04{3,PROFS{{POINT INTO MIDDLE OF ASTERISKS{28202
{{MTI{3,KVSTN{{{LOAD STATEMENT NUMBER AS INTEGER{28203
{{JSR{6,PRTIN{{{PRINT INTEGER STATEMENT NUMBER{28204
{{MOV{18,=PRSNF{3,PROFS{{POINT PAST ASTERISKS PLUS BLANK{28205
{{MOV{3,KVFNC{7,XR{{GET FNCLEVEL{28206
{{MOV{18,=CH$LI{8,WA{{SET LETTER I{28207
*
*      LOOP TO GENERATE LETTER I FNCLEVEL TIMES
*
{PRSN1{BZE{7,XR{6,PRSN2{{JUMP IF ALL SET{28211
{{JSR{6,PRTCH{{{ELSE PRINT AN I{28212
{{DCV{7,XR{{{DECREMENT COUNTER{28213
{{BRN{6,PRSN1{{{LOOP BACK{28214
*
*      MERGE WITH ALL LETTER I CHARACTERS GENERATED
*
{PRSN2{MOV{18,=CH$BL{8,WA{{GET BLANK{28218
{{JSR{6,PRTCH{{{PRINT BLANK{28219
{{MOV{3,PRSNA{8,WA{{RESTORE ENTRY WA{28220
{{MOV{10,(XS)+{7,XR{{RESTORE ENTRY XR{28221
{{EXI{{{{RETURN TO PRTSN CALLER{28222
{{ENP{{{{END PROCEDURE PRTSN{28223
{{EJC{{{{{28224
*
*      PRTST -- PRINT STRING
*
*      PRTST PLACES A STRING OF CHARACTERS IN THE PRINT BUFFER
*
*      SEE PRTNL FOR GLOBAL LOCATIONS USED
*
*      NOTE THAT THE FIRST WORD OF THE BLOCK (NORMALLY B$SCL)
*      IS NOT USED AND NEED NOT BE SET CORRECTLY (SEE PRTVN)
*
*      (XR)                  STRING TO BE PRINTED
*      JSR  PRTST            CALL TO PRINT STRING
*      (PROFS)               UPDATED PAST CHARS PLACED
*
{PRTST{PRC{25,R{1,0{{ENTRY POINT{28239
{{BNZ{3,HEADP{6,PRST0{{WERE HEADERS PRINTED{28240
{{JSR{6,PRTPS{{{NO - PRINT THEM{28241
*
*      CALL SYSPR
*
{PRST0{MOV{8,WA{3,PRSVA{{SAVE WA{28245
{{MOV{8,WB{3,PRSVB{{SAVE WB{28246
{{ZER{8,WB{{{SET CHARS PRINTED COUNT TO ZERO{28247
*
*      LOOP TO PRINT SUCCESSIVE LINES FOR LONG STRING
*
{PRST1{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{28251
{{SUB{8,WB{8,WA{{SUBTRACT COUNT OF CHARS ALREADY OUT{28252
{{BZE{8,WA{6,PRST4{{JUMP TO EXIT IF NONE LEFT{28253
{{MOV{7,XL{11,-(XS){{ELSE STACK ENTRY XL{28254
{{MOV{7,XR{11,-(XS){{SAVE ARGUMENT{28255
{{MOV{7,XR{7,XL{{COPY FOR EVENTUAL MOVE{28256
{{MOV{3,PRLEN{7,XR{{LOAD PRINT BUFFER LENGTH{28257
{{SUB{3,PROFS{7,XR{{GET CHARS LEFT IN PRINT BUFFER{28258
{{BNZ{7,XR{6,PRST2{{SKIP IF ROOM LEFT ON THIS LINE{28259
{{JSR{6,PRTNL{{{ELSE PRINT THIS LINE{28260
{{MOV{3,PRLEN{7,XR{{AND SET FULL WIDTH AVAILABLE{28261
{{EJC{{{{{28262
*
*      PRTST (CONTINUED)
*
*      HERE WITH CHARS TO PRINT AND SOME ROOM IN BUFFER
*
{PRST2{BLO{8,WA{7,XR{6,PRST3{JUMP IF ROOM FOR REST OF STRING{28268
{{MOV{7,XR{8,WA{{ELSE SET TO FILL LINE{28269
*
*      MERGE HERE WITH CHARACTER COUNT IN WA
*
{PRST3{MOV{3,PRBUF{7,XR{{POINT TO PRINT BUFFER{28273
{{PLC{7,XL{8,WB{{POINT TO LOCATION IN STRING{28274
{{PSC{7,XR{3,PROFS{{POINT TO LOCATION IN BUFFER{28275
{{ADD{8,WA{8,WB{{BUMP STRING CHARS COUNT{28276
{{ADD{8,WA{3,PROFS{{BUMP BUFFER POINTER{28277
{{MOV{8,WB{3,PRSVC{{PRESERVE CHAR COUNTER{28278
{{MVC{{{{MOVE CHARACTERS TO BUFFER{28279
{{MOV{3,PRSVC{8,WB{{RECOVER CHAR COUNTER{28280
{{MOV{10,(XS)+{7,XR{{RESTORE ARGUMENT POINTER{28281
{{MOV{10,(XS)+{7,XL{{RESTORE ENTRY XL{28282
{{BRN{6,PRST1{{{LOOP BACK TO TEST FOR MORE{28283
*
*      HERE TO EXIT AFTER PRINTING STRING
*
{PRST4{MOV{3,PRSVB{8,WB{{RESTORE ENTRY WB{28287
{{MOV{3,PRSVA{8,WA{{RESTORE ENTRY WA{28288
{{EXI{{{{RETURN TO PRTST CALLER{28289
{{ENP{{{{END PROCEDURE PRTST{28290
{{EJC{{{{{28291
*
*      PRTTR -- PRINT TO TERMINAL
*
*      CALLED TO PRINT CONTENTS OF STANDARD PRINT BUFFER TO
*      ONLINE TERMINAL. CLEARS BUFFER DOWN AND RESETS PROFS.
*
*      JSR  PRTTR            CALL FOR PRINT
*      (WA,WB)               DESTROYED
*
{PRTTR{PRC{25,E{1,0{{ENTRY POINT{28301
{{MOV{7,XR{11,-(XS){{SAVE XR{28302
{{JSR{6,PRTIC{{{PRINT BUFFER CONTENTS{28303
{{MOV{3,PRBUF{7,XR{{POINT TO PRINT BFR TO CLEAR IT{28304
{{LCT{8,WA{3,PRLNW{{GET BUFFER LENGTH{28305
{{ADD{19,*SCHAR{7,XR{{POINT PAST SCBLK HEADER{28306
{{MOV{4,NULLW{8,WB{{GET BLANKS{28307
*
*      LOOP TO CLEAR BUFFER
*
{PRTT1{MOV{8,WB{10,(XR)+{{CLEAR A WORD{28311
{{BCT{8,WA{6,PRTT1{{LOOP{28312
{{ZER{3,PROFS{{{RESET PROFS{28313
{{MOV{10,(XS)+{7,XR{{RESTORE XR{28314
{{EXI{{{{RETURN{28315
{{ENP{{{{END PROCEDURE PRTTR{28316
{{EJC{{{{{28317
*
*      PRTVL -- PRINT A VALUE
*
*      PRTVL PLACES AN APPROPRIATE CHARACTER REPRESENTATION OF
*      A DATA VALUE IN THE PRINT BUFFER FOR DUMP/TRACE USE.
*
*      (XR)                  VALUE TO BE PRINTED
*      JSR  PRTVL            CALL TO PRINT VALUE
*      (WA,WB,WC,RA)         DESTROYED
*
{PRTVL{PRC{25,R{1,0{{ENTRY POINT, RECURSIVE{28328
{{MOV{7,XL{11,-(XS){{SAVE ENTRY XL{28329
{{MOV{7,XR{11,-(XS){{SAVE ARGUMENT{28330
{{CHK{{{{CHECK FOR STACK OVERFLOW{28331
*
*      LOOP BACK HERE AFTER FINDING A TRAP BLOCK (TRBLK)
*
{PRV01{MOV{13,IDVAL(XR){3,PRVSI{{COPY IDVAL (IF ANY){28335
{{MOV{9,(XR){7,XL{{LOAD FIRST WORD OF BLOCK{28336
{{LEI{7,XL{{{LOAD ENTRY POINT ID{28337
{{BSW{7,XL{2,BL$$T{6,PRV02{SWITCH ON BLOCK TYPE{28338
{{IFF{2,BL$AR{6,PRV05{{ARBLK{28356
{{IFF{1,1{6,PRV02{{{28356
{{IFF{1,2{6,PRV02{{{28356
{{IFF{2,BL$IC{6,PRV08{{ICBLK{28356
{{IFF{2,BL$NM{6,PRV09{{NMBLK{28356
{{IFF{1,5{6,PRV02{{{28356
{{IFF{1,6{6,PRV02{{{28356
{{IFF{1,7{6,PRV02{{{28356
{{IFF{2,BL$RC{6,PRV08{{RCBLK{28356
{{IFF{2,BL$SC{6,PRV11{{SCBLK{28356
{{IFF{2,BL$SE{6,PRV12{{SEBLK{28356
{{IFF{2,BL$TB{6,PRV13{{TBBLK{28356
{{IFF{2,BL$VC{6,PRV13{{VCBLK{28356
{{IFF{1,13{6,PRV02{{{28356
{{IFF{1,14{6,PRV02{{{28356
{{IFF{1,15{6,PRV02{{{28356
{{IFF{2,BL$PD{6,PRV10{{PDBLK{28356
{{IFF{2,BL$TR{6,PRV04{{TRBLK{28356
{{ESW{{{{END OF SWITCH ON BLOCK TYPE{28356
*
*      HERE FOR BLOCKS FOR WHICH WE JUST PRINT DATATYPE NAME
*
{PRV02{JSR{6,DTYPE{{{GET DATATYPE NAME{28360
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28361
*
*      COMMON EXIT POINT
*
{PRV03{MOV{10,(XS)+{7,XR{{RELOAD ARGUMENT{28365
{{MOV{10,(XS)+{7,XL{{RESTORE XL{28366
{{EXI{{{{RETURN TO PRTVL CALLER{28367
*
*      HERE FOR TRBLK
*
{PRV04{MOV{13,TRVAL(XR){7,XR{{LOAD REAL VALUE{28371
{{BRN{6,PRV01{{{AND LOOP BACK{28372
{{EJC{{{{{28373
*
*      PRTVL (CONTINUED)
*
*      HERE FOR ARRAY (ARBLK)
*
*      PRINT ARRAY ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV05{MOV{7,XR{7,XL{{PRESERVE ARGUMENT{28381
{{MOV{21,=SCARR{7,XR{{POINT TO DATATYPE NAME (ARRAY){28382
{{JSR{6,PRTST{{{PRINT IT{28383
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{28384
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{28385
{{ADD{13,AROFS(XL){7,XL{{POINT TO PROTOTYPE{28386
{{MOV{9,(XL){7,XR{{LOAD PROTOTYPE{28387
{{JSR{6,PRTST{{{PRINT PROTOTYPE{28388
*
*      VCBLK, TBBLK, BCBLK MERGE HERE FOR ) BLANK NUMBER IDVAL
*
{PRV06{MOV{18,=CH$RP{8,WA{{LOAD RIGHT PAREN{28392
{{JSR{6,PRTCH{{{PRINT RIGHT PAREN{28393
*
*      PDBLK MERGES HERE TO PRINT BLANK NUMBER IDVAL
*
{PRV07{MOV{18,=CH$BL{8,WA{{LOAD BLANK{28397
{{JSR{6,PRTCH{{{PRINT IT{28398
{{MOV{18,=CH$NM{8,WA{{LOAD NUMBER SIGN{28399
{{JSR{6,PRTCH{{{PRINT IT{28400
{{MTI{3,PRVSI{{{GET IDVAL{28401
{{JSR{6,PRTIN{{{PRINT ID NUMBER{28402
{{BRN{6,PRV03{{{BACK TO EXIT{28403
*
*      HERE FOR INTEGER (ICBLK), REAL (RCBLK)
*
*      PRINT CHARACTER REPRESENTATION OF VALUE
*
{PRV08{MOV{7,XR{11,-(XS){{STACK ARGUMENT FOR GTSTG{28409
{{JSR{6,GTSTG{{{CONVERT TO STRING{28410
{{PPM{{{{ERROR RETURN IS IMPOSSIBLE{28411
{{JSR{6,PRTST{{{PRINT THE STRING{28412
{{MOV{7,XR{3,DNAMP{{DELETE GARBAGE STRING FROM STORAGE{28413
{{BRN{6,PRV03{{{BACK TO EXIT{28414
{{EJC{{{{{28415
*
*      PRTVL (CONTINUED)
*
*      NAME (NMBLK)
*
*      FOR PSEUDO-VARIABLE, JUST PRINT DATATYPE NAME (NAME)
*      FOR ALL OTHER NAMES, PRINT DOT FOLLOWED BY NAME REP
*
{PRV09{MOV{13,NMBAS(XR){7,XL{{LOAD NAME BASE{28424
{{MOV{9,(XL){8,WA{{LOAD FIRST WORD OF BLOCK{28425
{{BEQ{8,WA{22,=B$KVT{6,PRV02{JUST PRINT NAME IF KEYWORD{28426
{{BEQ{8,WA{22,=B$EVT{6,PRV02{JUST PRINT NAME IF EXPRESSION VAR{28427
{{MOV{18,=CH$DT{8,WA{{ELSE GET DOT{28428
{{JSR{6,PRTCH{{{AND PRINT IT{28429
{{MOV{13,NMOFS(XR){8,WA{{LOAD NAME OFFSET{28430
{{JSR{6,PRTNM{{{PRINT NAME{28431
{{BRN{6,PRV03{{{BACK TO EXIT{28432
*
*      PROGRAM DATATYPE (PDBLK)
*
*      PRINT DATATYPE NAME CH$BL CH$NM IDVAL
*
{PRV10{JSR{6,DTYPE{{{GET DATATYPE NAME{28438
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28439
{{BRN{6,PRV07{{{MERGE BACK TO PRINT ID{28440
*
*      HERE FOR STRING (SCBLK)
*
*      PRINT QUOTE STRING-CHARACTERS QUOTE
*
{PRV11{MOV{18,=CH$SQ{8,WA{{LOAD SINGLE QUOTE{28446
{{JSR{6,PRTCH{{{PRINT QUOTE{28447
{{JSR{6,PRTST{{{PRINT STRING VALUE{28448
{{JSR{6,PRTCH{{{PRINT ANOTHER QUOTE{28449
{{BRN{6,PRV03{{{BACK TO EXIT{28450
{{EJC{{{{{28451
*
*      PRTVL (CONTINUED)
*
*      HERE FOR SIMPLE EXPRESSION (SEBLK)
*
*      PRINT ASTERISK VARIABLE-NAME
*
{PRV12{MOV{18,=CH$AS{8,WA{{LOAD ASTERISK{28459
{{JSR{6,PRTCH{{{PRINT ASTERISK{28460
{{MOV{13,SEVAR(XR){7,XR{{LOAD VARIABLE POINTER{28461
{{JSR{6,PRTVN{{{PRINT VARIABLE NAME{28462
{{BRN{6,PRV03{{{JUMP BACK TO EXIT{28463
*
*      HERE FOR TABLE (TBBLK) AND ARRAY (VCBLK)
*
*      PRINT DATATYPE ( PROTOTYPE ) BLANK NUMBER IDVAL
*
{PRV13{MOV{7,XR{7,XL{{PRESERVE ARGUMENT{28469
{{JSR{6,DTYPE{{{GET DATATYPE NAME{28470
{{JSR{6,PRTST{{{PRINT DATATYPE NAME{28471
{{MOV{18,=CH$PP{8,WA{{LOAD LEFT PAREN{28472
{{JSR{6,PRTCH{{{PRINT LEFT PAREN{28473
{{MOV{13,TBLEN(XL){8,WA{{LOAD LENGTH OF BLOCK (=VCLEN){28474
{{BTW{8,WA{{{CONVERT TO WORD COUNT{28475
{{SUB{18,=TBSI${8,WA{{ALLOW FOR STANDARD FIELDS{28476
{{BEQ{9,(XL){22,=B$TBT{6,PRV14{JUMP IF TABLE{28477
{{ADD{18,=VCTBD{8,WA{{FOR VCBLK, ADJUST SIZE{28478
*
*      PRINT PROTOTYPE
*
{PRV14{MTI{8,WA{{{MOVE AS INTEGER{28482
{{JSR{6,PRTIN{{{PRINT INTEGER PROTOTYPE{28483
{{BRN{6,PRV06{{{MERGE BACK FOR REST{28484
{{ENP{{{{END PROCEDURE PRTVL{28507
{{EJC{{{{{28508
*
*      PRTVN -- PRINT NATURAL VARIABLE NAME
*
*      PRTVN PRINTS THE NAME OF A NATURAL VARIABLE
*
*      (XR)                  POINTER TO VRBLK
*      JSR  PRTVN            CALL TO PRINT VARIABLE NAME
*
{PRTVN{PRC{25,E{1,0{{ENTRY POINT{28517
{{MOV{7,XR{11,-(XS){{STACK VRBLK POINTER{28518
{{ADD{19,*VRSOF{7,XR{{POINT TO POSSIBLE STRING NAME{28519
{{BNZ{13,SCLEN(XR){6,PRVN1{{JUMP IF NOT SYSTEM VARIABLE{28520
{{MOV{13,VRSVO(XR){7,XR{{POINT TO SVBLK WITH NAME{28521
*
*      MERGE HERE WITH DUMMY SCBLK POINTER IN XR
*
{PRVN1{JSR{6,PRTST{{{PRINT STRING NAME OF VARIABLE{28525
{{MOV{10,(XS)+{7,XR{{RESTORE VRBLK POINTER{28526
{{EXI{{{{RETURN TO PRTVN CALLER{28527
{{ENP{{{{END PROCEDURE PRTVN{28528
{{EJC{{{{{28531
*
*      RCBLD -- BUILD A REAL BLOCK
*
*      (RA)                  REAL VALUE FOR RCBLK
*      JSR  RCBLD            CALL TO BUILD REAL BLOCK
*      (XR)                  POINTER TO RESULT RCBLK
*      (WA)                  DESTROYED
*
{RCBLD{PRC{25,E{1,0{{ENTRY POINT{28540
{{MOV{3,DNAMP{7,XR{{LOAD POINTER TO NEXT AVAILABLE LOC{28541
{{ADD{19,*RCSI${7,XR{{POINT PAST NEW RCBLK{28542
{{BLO{7,XR{3,DNAME{6,RCBL1{JUMP IF THERE IS ROOM{28543
{{MOV{19,*RCSI${8,WA{{ELSE LOAD RCBLK LENGTH{28544
{{JSR{6,ALLOC{{{USE STANDARD ALLOCATOR TO GET BLOCK{28545
{{ADD{8,WA{7,XR{{POINT PAST BLOCK TO MERGE{28546
*
*      MERGE HERE WITH XR POINTING PAST THE BLOCK OBTAINED
*
{RCBL1{MOV{7,XR{3,DNAMP{{SET NEW POINTER{28550
{{SUB{19,*RCSI${7,XR{{POINT BACK TO START OF BLOCK{28551
{{MOV{22,=B$RCL{9,(XR){{STORE TYPE WORD{28552
{{STR{13,RCVAL(XR){{{STORE REAL VALUE IN RCBLK{28553
{{EXI{{{{RETURN TO RCBLD CALLER{28554
{{ENP{{{{END PROCEDURE RCBLD{28555
{{EJC{{{{{28557
*
*      READR -- READ NEXT SOURCE IMAGE AT COMPILE TIME
*
*      READR IS USED TO READ THE NEXT SOURCE IMAGE. TO PROCESS
*      CONTINUATION CARDS PROPERLY, THE COMPILER MUST READ ONE
*      LINE AHEAD. THUS READR DOES NOT DESTROY THE CURRENT IMAGE
*      SEE ALSO THE NEXTS ROUTINE WHICH ACTUALLY GETS THE IMAGE.
*
*      JSR  READR            CALL TO READ NEXT IMAGE
*      (XR)                  PTR TO NEXT IMAGE (0 IF NONE)
*      (R$CNI)               COPY OF POINTER
*      (WA,WB,WC,XL)         DESTROYED
*
{READR{PRC{25,E{1,0{{ENTRY POINT{28571
{{MOV{3,R$CNI{7,XR{{GET PTR TO NEXT IMAGE{28572
{{BNZ{7,XR{6,READ3{{EXIT IF ALREADY READ{28573
{{BNZ{3,CNIND{6,READA{{IF WITHIN INCLUDE FILE{28575
{{BNE{3,STAGE{18,=STGIC{6,READ3{EXIT IF NOT INITIAL COMPILE{28577
{READA{MOV{3,CSWIN{8,WA{{MAX READ LENGTH{28578
{{ZER{7,XL{{{CLEAR ANY DUD VALUE IN XL{28579
{{JSR{6,ALOCS{{{ALLOCATE BUFFER{28580
{{JSR{6,SYSRD{{{READ INPUT IMAGE{28581
{{PPM{6,READ4{{{JUMP IF EOF OR NEW FILE NAME{28582
{{ICV{3,RDNLN{{{INCREMENT NEXT LINE NUMBER{28583
{{DCV{3,POLCT{{{TEST IF TIME TO POLL INTERFACE{28585
{{BNZ{3,POLCT{6,READ0{{NOT YET{28586
{{ZER{8,WA{{{=0 FOR POLL{28587
{{MOV{3,RDNLN{8,WB{{LINE NUMBER{28588
{{JSR{6,SYSPL{{{ALLOW INTERACTIVE ACCESS{28589
{{ERR{1,320{26,User interrupt{{{28590
{{PPM{{{{SINGLE STEP{28591
{{PPM{{{{EXPRESSION EVALUATION{28592
{{MOV{8,WA{3,POLCS{{NEW COUNTDOWN START VALUE{28593
{{MOV{8,WA{3,POLCT{{NEW COUNTER VALUE{28594
{READ0{BLE{13,SCLEN(XR){3,CSWIN{6,READ1{USE SMALLER OF STRING LNTH ...{28596
{{MOV{3,CSWIN{13,SCLEN(XR){{... AND XXX OF -INXXX{28597
*
*      PERFORM THE TRIM
*
{READ1{MNZ{8,WB{{{SET TRIMR TO PERFORM TRIM{28601
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS{28602
*
*      MERGE HERE AFTER READ
*
{READ2{MOV{7,XR{3,R$CNI{{STORE COPY OF POINTER{28606
*
*      MERGE HERE IF NO READ ATTEMPTED
*
{READ3{EXI{{{{RETURN TO READR CALLER{28610
*
*      HERE ON END OF FILE OR NEW SOURCE FILE NAME.
*      IF THIS IS A NEW SOURCE FILE NAME, THE R$SFN TABLE WILL
*      BE AUGMENTED WITH A NEW TABLE ENTRY CONSISTING OF THE
*      CURRENT COMPILER STATEMENT NUMBER AS SUBSCRIPT, AND THE
*      FILE NAME AS VALUE.
*
{READ4{BZE{13,SCLEN(XR){6,READ5{{JUMP IF TRUE END OF FILE{28619
{{ZER{8,WB{{{NEW SOURCE FILE NAME{28620
{{MOV{8,WB{3,RDNLN{{RESTART LINE COUNTER FOR NEW FILE{28621
{{JSR{6,TRIMR{{{REMOVE UNUSED SPACE IN BLOCK{28622
{{JSR{6,NEWFN{{{RECORD NEW FILE NAME{28623
{{BRN{6,READA{{{NOW REISSUE READ FOR RECORD DATA{28624
*
*      HERE ON END OF FILE
*
{READ5{MOV{7,XR{3,DNAMP{{POP UNUSED SCBLK{28628
{{BZE{3,CNIND{6,READ6{{JUMP IF NOT WITHIN AN INCLUDE FILE{28630
{{ZER{7,XL{{{EOF WITHIN INCLUDE FILE{28631
{{JSR{6,SYSIF{{{SWITCH STREAM BACK TO PREVIOUS FILE{28632
{{PPM{{{{{28633
{{MOV{3,CNIND{8,WA{{RESTORE PREV LINE NUMBER, FILE NAME{28634
{{ADD{18,=VCVLB{8,WA{{VECTOR OFFSET IN WORDS{28635
{{WTB{8,WA{{{CONVERT TO BYTES{28636
{{MOV{3,R$IFA{7,XR{{FILE NAME ARRAY{28637
{{ADD{8,WA{7,XR{{PTR TO ELEMENT{28638
{{MOV{9,(XR){3,R$SFC{{CHANGE SOURCE FILE NAME{28639
{{MOV{21,=NULLS{9,(XR){{RELEASE SCBLK{28640
{{MOV{3,R$IFL{7,XR{{LINE NUMBER ARRAY{28641
{{ADD{8,WA{7,XR{{PTR TO ELEMENT{28642
{{MOV{9,(XR){7,XL{{ICBLK CONTAINING SAVED LINE NUMBER{28643
{{LDI{13,ICVAL(XL){{{LINE NUMBER INTEGER{28644
{{MFI{3,RDNLN{{{CHANGE SOURCE LINE NUMBER{28645
{{MOV{21,=INTON{9,(XR){{RELEASE ICBLK{28646
{{DCV{3,CNIND{{{DECREMENT NESTING LEVEL{28647
{{MOV{3,CMPSN{8,WB{{CURRENT STATEMENT NUMBER{28648
{{ICV{8,WB{{{ANTICIPATE END OF PREVIOUS STMT{28649
{{MTI{8,WB{{{CONVERT TO INTEGER{28650
{{JSR{6,ICBLD{{{BUILD ICBLK FOR STMT NUMBER{28651
{{MOV{3,R$SFN{7,XL{{FILE NAME TABLE{28652
{{MNZ{8,WB{{{LOOKUP STATEMENT NUMBER BY NAME{28653
{{JSR{6,TFIND{{{ALLOCATE NEW TEBLK{28654
{{PPM{{{{ALWAYS POSSIBLE TO ALLOCATE BLOCK{28655
{{MOV{3,R$SFC{13,TEVAL(XL){{RECORD FILE NAME AS ENTRY VALUE{28656
{{BEQ{3,STAGE{18,=STGIC{6,READA{IF INITIAL COMPILE, REISSUE READ{28657
{{BNZ{3,CNIND{6,READA{{STILL READING FROM INCLUDE FILE{28658
*
*      OUTER NESTING OF EXECUTE-TIME COMPILE OF -INCLUDE
*      RESUME WITH ANY STRING REMAINING PRIOR TO -INCLUDE.
*
{{MOV{3,R$ICI{7,XL{{RESTORE CODE ARGUMENT STRING{28663
{{ZER{3,R$ICI{{{RELEASE ORIGINAL STRING{28664
{{MOV{3,CNSIL{8,WA{{GET LENGTH OF STRING{28665
{{MOV{3,CNSPT{8,WB{{OFFSET OF CHARACTERS LEFT{28666
{{SUB{8,WB{8,WA{{NUMBER OF CHARACTERS LEFT{28667
{{MOV{8,WA{3,SCNIL{{SET NEW SCAN LENGTH{28668
{{ZER{3,SCNPT{{{SCAN FROM START OF SUBSTRING{28669
{{JSR{6,SBSTR{{{CREATE SUBSTRING OF REMAINDER{28670
{{MOV{7,XR{3,R$CIM{{SET SCAN IMAGE{28671
{{BRN{6,READ2{{{RETURN{28672
{READ6{ZER{7,XR{{{ZERO PTR AS RESULT{28688
{{BRN{6,READ2{{{MERGE{28689
{{ENP{{{{END PROCEDURE READR{28690
{{EJC{{{{{28691
*
*      SBSTR -- BUILD A SUBSTRING
*
*      (XL)                  PTR TO SCBLK/BFBLK WITH CHARS
*      (WA)                  NUMBER OF CHARS IN SUBSTRING
*      (WB)                  OFFSET TO FIRST CHAR IN SCBLK
*      JSR  SBSTR            CALL TO BUILD SUBSTRING
*      (XR)                  PTR TO NEW SCBLK WITH SUBSTRING
*      (XL)                  ZERO
*      (WA,WB,WC,XL,IA)      DESTROYED
*
*      NOTE THAT SBSTR IS CALLED WITH A DUMMY STRING POINTER
*      (POINTING INTO A VRBLK OR SVBLK) TO COPY THE NAME OF A
*      VARIABLE AS A STANDARD STRING VALUE.
*
{SBSTR{PRC{25,E{1,0{{ENTRY POINT{28786
{{BZE{8,WA{6,SBST2{{JUMP IF NULL SUBSTRING{28787
{{JSR{6,ALOCS{{{ELSE ALLOCATE SCBLK{28788
{{MOV{8,WC{8,WA{{MOVE NUMBER OF CHARACTERS{28789
{{MOV{7,XR{8,WC{{SAVE PTR TO NEW SCBLK{28790
{{PLC{7,XL{8,WB{{PREPARE TO LOAD CHARS FROM OLD BLK{28791
{{PSC{7,XR{{{PREPARE TO STORE CHARS IN NEW BLK{28792
{{MVC{{{{MOVE CHARACTERS TO NEW STRING{28793
{{MOV{8,WC{7,XR{{THEN RESTORE SCBLK POINTER{28794
*
*      RETURN POINT
*
{SBST1{ZER{7,XL{{{CLEAR GARBAGE POINTER IN XL{28798
{{EXI{{{{RETURN TO SBSTR CALLER{28799
*
*      HERE FOR NULL SUBSTRING
*
{SBST2{MOV{21,=NULLS{7,XR{{SET NULL STRING AS RESULT{28803
{{BRN{6,SBST1{{{RETURN{28804
{{ENP{{{{END PROCEDURE SBSTR{28805
{{EJC{{{{{28806
*
*      STGCC -- COMPUTE COUNTERS FOR STMT STARTUP TESTING
*
*      JSR  STGCC            CALL TO RECOMPUTE COUNTERS
*      (WA,WB)               DESTROYED
*
*      ON EXIT, STMCS AND STMCT CONTAIN THE COUNTER VALUE TO
*      TESTED IN STMGO.
*
*
{STGCC{PRC{25,E{1,0{{{28817
{{MOV{3,POLCS{8,WA{{ASSUME NO PROFILING OR STCOUNT TRACING{28819
{{MOV{18,=NUM01{8,WB{{POLL EACH TIME POLCS EXPIRES{28820
{{LDI{3,KVSTL{{{GET STMT LIMIT{28824
{{BNZ{3,KVPFL{6,STGC1{{JUMP IF PROFILING ENABLED{28825
{{ILT{6,STGC3{{{NO STCOUNT TRACING IF NEGATIVE{28826
{{BZE{3,R$STC{6,STGC2{{JUMP IF NOT STCOUNT TRACING{28827
*
*      HERE IF PROFILING OR IF STCOUNT TRACING ENABLED
*
{STGC1{MOV{8,WA{8,WB{{COUNT POLCS TIMES WITHIN STMG{28832
{{MOV{18,=NUM01{8,WA{{BREAK OUT OF STMGO ON EACH STMT{28833
{{BRN{6,STGC3{{{{28837
*
*      CHECK THAT STMCS DOES NOT EXCEED KVSTL
*
{STGC2{MTI{8,WA{{{BREAKOUT COUNT START VALUE{28841
{{SBI{3,KVSTL{{{PROPOSED STMCS MINUS STMT LIMIT{28842
{{ILE{6,STGC3{{{JUMP IF STMT COUNT DOES NOT LIMIT{28843
{{LDI{3,KVSTL{{{STLIMIT LIMITS BREAKCOUNT COUNT{28844
{{MFI{8,WA{{{USE IT INSTEAD{28845
*
*      RE-INITIALIZE COUNTER
*
{STGC3{MOV{8,WA{3,STMCS{{UPDATE BREAKOUT COUNT START VALUE{28849
{{MOV{8,WA{3,STMCT{{RESET BREAKOUT COUNTER{28850
{{MOV{8,WB{3,POLCT{{{28852
{{EXI{{{{{28854
{{EJC{{{{{28855
*
*      TFIND -- LOCATE TABLE ELEMENT
*
*      (XR)                  SUBSCRIPT VALUE FOR ELEMENT
*      (XL)                  POINTER TO TABLE
*      (WB)                  ZERO BY VALUE, NON-ZERO BY NAME
*      JSR  TFIND            CALL TO LOCATE ELEMENT
*      PPM  LOC              TRANSFER LOCATION IF ACCESS FAILS
*      (XR)                  ELEMENT VALUE (IF BY VALUE)
*      (XR)                  DESTROYED (IF BY NAME)
*      (XL,WA)               TEBLK NAME (IF BY NAME)
*      (XL,WA)               DESTROYED (IF BY VALUE)
*      (WC,RA)               DESTROYED
*
*      NOTE THAT IF A CALL BY VALUE SPECIFIES A NON-EXISTENT
*      SUBSCRIPT, THE DEFAULT VALUE IS RETURNED WITHOUT BUILDING
*      A NEW TEBLK.
*
{TFIND{PRC{25,E{1,1{{ENTRY POINT{28874
{{MOV{8,WB{11,-(XS){{SAVE NAME/VALUE INDICATOR{28875
{{MOV{7,XR{11,-(XS){{SAVE SUBSCRIPT VALUE{28876
{{MOV{7,XL{11,-(XS){{SAVE TABLE POINTER{28877
{{MOV{13,TBLEN(XL){8,WA{{LOAD LENGTH OF TBBLK{28878
{{BTW{8,WA{{{CONVERT TO WORD COUNT{28879
{{SUB{18,=TBBUK{8,WA{{GET NUMBER OF BUCKETS{28880
{{MTI{8,WA{{{CONVERT TO INTEGER VALUE{28881
{{STI{3,TFNSI{{{SAVE FOR LATER{28882
{{MOV{9,(XR){7,XL{{LOAD FIRST WORD OF SUBSCRIPT{28883
{{LEI{7,XL{{{LOAD BLOCK ENTRY ID (BL$XX){28884
{{BSW{7,XL{2,BL$$D{6,TFN00{SWITCH ON BLOCK TYPE{28885
{{IFF{1,0{6,TFN00{{{28896
{{IFF{1,1{6,TFN00{{{28896
{{IFF{1,2{6,TFN00{{{28896
{{IFF{2,BL$IC{6,TFN02{{JUMP IF INTEGER{28896
{{IFF{2,BL$NM{6,TFN04{{JUMP IF NAME{28896
{{IFF{2,BL$P0{6,TFN03{{JUMP IF PATTERN{28896
{{IFF{2,BL$P1{6,TFN03{{JUMP IF PATTERN{28896
{{IFF{2,BL$P2{6,TFN03{{JUMP IF PATTERN{28896
{{IFF{2,BL$RC{6,TFN02{{REAL{28896
{{IFF{2,BL$SC{6,TFN05{{JUMP IF STRING{28896
{{IFF{1,10{6,TFN00{{{28896
{{IFF{1,11{6,TFN00{{{28896
{{IFF{1,12{6,TFN00{{{28896
{{IFF{1,13{6,TFN00{{{28896
{{IFF{1,14{6,TFN00{{{28896
{{IFF{1,15{6,TFN00{{{28896
{{IFF{1,16{6,TFN00{{{28896
{{ESW{{{{END SWITCH ON BLOCK TYPE{28896
*
*      HERE FOR BLOCKS FOR WHICH WE USE THE SECOND WORD OF THE
*      BLOCK AS THE HASH SOURCE (SEE BLOCK FORMATS FOR DETAILS).
*
{TFN00{MOV{12,1(XR){8,WA{{LOAD SECOND WORD{28901
*
*      MERGE HERE WITH ONE WORD HASH SOURCE IN WA
*
{TFN01{MTI{8,WA{{{CONVERT TO INTEGER{28905
{{BRN{6,TFN06{{{JUMP TO MERGE{28906
{{EJC{{{{{28907
*
*      TFIND (CONTINUED)
*
*      HERE FOR INTEGER OR REAL
*      POSSIBILITY OF OVERFLOW EXIST ON TWOS COMPLEMENT
*      MACHINE IF HASH SOURCE IS MOST NEGATIVE INTEGER OR IS
*      A REAL HAVING THE SAME BIT PATTERN.
*
*
{TFN02{LDI{12,1(XR){{{LOAD VALUE AS HASH SOURCE{28917
{{IGE{6,TFN06{{{OK IF POSITIVE OR ZERO{28918
{{NGI{{{{MAKE POSITIVE{28919
{{IOV{6,TFN06{{{CLEAR POSSIBLE OVERFLOW{28920
{{BRN{6,TFN06{{{MERGE{28921
*
*      FOR PATTERN, USE FIRST WORD (PCODE) AS SOURCE
*
{TFN03{MOV{9,(XR){8,WA{{LOAD FIRST WORD AS HASH SOURCE{28925
{{BRN{6,TFN01{{{MERGE BACK{28926
*
*      FOR NAME, USE OFFSET AS HASH SOURCE
*
{TFN04{MOV{13,NMOFS(XR){8,WA{{LOAD OFFSET AS HASH SOURCE{28930
{{BRN{6,TFN01{{{MERGE BACK{28931
*
*      HERE FOR STRING
*
{TFN05{JSR{6,HASHS{{{CALL ROUTINE TO COMPUTE HASH{28935
*
*      MERGE HERE WITH HASH SOURCE IN (IA)
*
{TFN06{RMI{3,TFNSI{{{COMPUTE HASH INDEX BY REMAINDERING{28939
{{MFI{8,WC{{{GET AS ONE WORD INTEGER{28940
{{WTB{8,WC{{{CONVERT TO BYTE OFFSET{28941
{{MOV{9,(XS){7,XL{{GET TABLE PTR AGAIN{28942
{{ADD{8,WC{7,XL{{POINT TO PROPER BUCKET{28943
{{MOV{13,TBBUK(XL){7,XR{{LOAD FIRST TEBLK POINTER{28944
{{BEQ{7,XR{9,(XS){6,TFN10{JUMP IF NO TEBLKS ON CHAIN{28945
*
*      LOOP THROUGH TEBLKS ON HASH CHAIN
*
{TFN07{MOV{7,XR{8,WB{{SAVE TEBLK POINTER{28949
{{MOV{13,TESUB(XR){7,XR{{LOAD SUBSCRIPT VALUE{28950
{{MOV{12,1(XS){7,XL{{LOAD INPUT ARGUMENT SUBSCRIPT VAL{28951
{{JSR{6,IDENT{{{COMPARE THEM{28952
{{PPM{6,TFN08{{{JUMP IF EQUAL (IDENT){28953
*
*      HERE IF NO MATCH WITH THAT TEBLK
*
{{MOV{8,WB{7,XL{{RESTORE TEBLK POINTER{28957
{{MOV{13,TENXT(XL){7,XR{{POINT TO NEXT TEBLK ON CHAIN{28958
{{BNE{7,XR{9,(XS){6,TFN07{JUMP IF THERE IS ONE{28959
*
*      HERE IF NO MATCH WITH ANY TEBLK ON CHAIN
*
{{MOV{19,*TENXT{8,WC{{SET OFFSET TO LINK FIELD (XL BASE){28963
{{BRN{6,TFN11{{{JUMP TO MERGE{28964
{{EJC{{{{{28965
*
*      TFIND (CONTINUED)
*
*      HERE WE HAVE FOUND A MATCHING ELEMENT
*
{TFN08{MOV{8,WB{7,XL{{RESTORE TEBLK POINTER{28971
{{MOV{19,*TEVAL{8,WA{{SET TEBLK NAME OFFSET{28972
{{MOV{12,2(XS){8,WB{{RESTORE NAME/VALUE INDICATOR{28973
{{BNZ{8,WB{6,TFN09{{JUMP IF CALLED BY NAME{28974
{{JSR{6,ACESS{{{ELSE GET VALUE{28975
{{PPM{6,TFN12{{{JUMP IF REFERENCE FAILS{28976
{{ZER{8,WB{{{RESTORE NAME/VALUE INDICATOR{28977
*
*      COMMON EXIT FOR ENTRY FOUND
*
{TFN09{ADD{19,*NUM03{7,XS{{POP STACK ENTRIES{28981
{{EXI{{{{RETURN TO TFIND CALLER{28982
*
*      HERE IF NO TEBLKS ON THE HASH CHAIN
*
{TFN10{ADD{19,*TBBUK{8,WC{{GET OFFSET TO BUCKET PTR{28986
{{MOV{9,(XS){7,XL{{SET TBBLK PTR AS BASE{28987
*
*      MERGE HERE WITH (XL,WC) BASE,OFFSET OF FINAL LINK
*
{TFN11{MOV{9,(XS){7,XR{{TBBLK POINTER{28991
{{MOV{13,TBINV(XR){7,XR{{LOAD DEFAULT VALUE IN CASE{28992
{{MOV{12,2(XS){8,WB{{LOAD NAME/VALUE INDICATOR{28993
{{BZE{8,WB{6,TFN09{{EXIT WITH DEFAULT IF VALUE CALL{28994
{{MOV{7,XR{8,WB{{COPY DEFAULT VALUE{28995
*
*      HERE WE MUST BUILD A NEW TEBLK
*
{{MOV{19,*TESI${8,WA{{SET SIZE OF TEBLK{28999
{{JSR{6,ALLOC{{{ALLOCATE TEBLK{29000
{{ADD{8,WC{7,XL{{POINT TO HASH LINK{29001
{{MOV{7,XR{9,(XL){{LINK NEW TEBLK AT END OF CHAIN{29002
{{MOV{22,=B$TET{9,(XR){{STORE TYPE WORD{29003
{{MOV{8,WB{13,TEVAL(XR){{SET DEFAULT AS INITIAL VALUE{29004
{{MOV{10,(XS)+{13,TENXT(XR){{SET TBBLK PTR TO MARK END OF CHAIN{29005
{{MOV{10,(XS)+{13,TESUB(XR){{STORE SUBSCRIPT VALUE{29006
{{MOV{10,(XS)+{8,WB{{RESTORE NAME/VALUE INDICATOR{29007
{{MOV{7,XR{7,XL{{COPY TEBLK POINTER (NAME BASE){29008
{{MOV{19,*TEVAL{8,WA{{SET OFFSET{29009
{{EXI{{{{RETURN TO CALLER WITH NEW TEBLK{29010
*
*      ACESS FAIL RETURN
*
{TFN12{EXI{1,1{{{ALTERNATIVE RETURN{29014
{{ENP{{{{END PROCEDURE TFIND{29015
{{EJC{{{{{29016
*
*      TMAKE -- MAKE NEW TABLE
*
*      (XL)                  INITIAL LOOKUP VALUE
*      (WC)                  NUMBER OF BUCKETS DESIRED
*      JSR  TMAKE            CALL TO MAKE NEW TABLE
*      (XR)                  NEW TABLE
*      (WA,WB)               DESTROYED
*
{TMAKE{PRC{25,E{1,0{{{29026
{{MOV{8,WC{8,WA{{COPY NUMBER OF HEADERS{29027
{{ADD{18,=TBSI${8,WA{{ADJUST FOR STANDARD FIELDS{29028
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{29029
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR TBBLK{29030
{{MOV{7,XR{8,WB{{COPY POINTER TO TBBLK{29031
{{MOV{22,=B$TBT{10,(XR)+{{STORE TYPE WORD{29032
{{ZER{10,(XR)+{{{ZERO ID FOR THE MOMENT{29033
{{MOV{8,WA{10,(XR)+{{STORE LENGTH (TBLEN){29034
{{MOV{7,XL{10,(XR)+{{STORE INITIAL LOOKUP VALUE{29035
{{LCT{8,WC{8,WC{{SET LOOP COUNTER (NUM HEADERS){29036
*
*      LOOP TO INITIALIZE ALL BUCKET POINTERS
*
{TMA01{MOV{8,WB{10,(XR)+{{STORE TBBLK PTR IN BUCKET HEADER{29040
{{BCT{8,WC{6,TMA01{{LOOP TILL ALL STORED{29041
{{MOV{8,WB{7,XR{{RECALL POINTER TO TBBLK{29042
{{EXI{{{{{29043
{{ENP{{{{{29044
{{EJC{{{{{29045
*
*      VMAKE -- CREATE A VECTOR
*
*      (WA)                  NUMBER OF ELEMENTS IN VECTOR
*      (XL)                  DEFAULT VALUE FOR VECTOR ELEMENTS
*      JSR  VMAKE            CALL TO CREATE VECTOR
*      PPM  LOC              IF VECTOR TOO LARGE
*
*      (XR)                  POINTER TO VCBLK
*      (WA,WB,WC,XL)         DESTROYED
*
{VMAKE{PRC{25,E{1,1{{ENTRY POINT{29057
{{LCT{8,WB{8,WA{{COPY ELEMENTS FOR LOOP LATER ON{29058
{{ADD{18,=VCSI${8,WA{{ADD SPACE FOR STANDARD FIELDS{29059
{{WTB{8,WA{{{CONVERT LENGTH TO BYTES{29060
{{BGT{8,WA{3,MXLEN{6,VMAK2{FAIL IF TOO LARGE{29061
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR VCBLK{29062
{{MOV{22,=B$VCT{9,(XR){{STORE TYPE WORD{29063
{{ZER{13,IDVAL(XR){{{INITIALIZE IDVAL{29064
{{MOV{8,WA{13,VCLEN(XR){{SET LENGTH{29065
{{MOV{7,XL{8,WC{{COPY DEFAULT VALUE{29066
{{MOV{7,XR{7,XL{{COPY VCBLK POINTER{29067
{{ADD{19,*VCVLS{7,XL{{POINT TO FIRST ELEMENT VALUE{29068
*
*      LOOP TO SET VECTOR ELEMENTS TO DEFAULT VALUE
*
{VMAK1{MOV{8,WC{10,(XL)+{{STORE ONE VALUE{29072
{{BCT{8,WB{6,VMAK1{{LOOP TILL ALL STORED{29073
{{EXI{{{{SUCCESS RETURN{29074
*
*      HERE IF DESIRED VECTOR SIZE TOO LARGE
*
{VMAK2{EXI{1,1{{{FAIL RETURN{29078
{{ENP{{{{{29079
{{EJC{{{{{29080
*
*      SCANE -- SCAN AN ELEMENT
*
*      SCANE IS CALLED AT COMPILE TIME (BY EXPAN ,CMPIL,CNCRD)
*      TO SCAN ONE ELEMENT FROM THE INPUT IMAGE.
*
*      (SCNCC)               NON-ZERO IF CALLED FROM CNCRD
*      JSR  SCANE            CALL TO SCAN ELEMENT
*      (XR)                  RESULT POINTER (SEE BELOW)
*      (XL)                  SYNTAX TYPE CODE (T$XXX)
*
*      THE FOLLOWING GLOBAL LOCATIONS ARE USED.
*
*      R$CIM                 POINTER TO STRING BLOCK (SCBLK)
*                            FOR CURRENT INPUT IMAGE.
*
*      R$CNI                 POINTER TO NEXT INPUT IMAGE STRING
*                            POINTER (ZERO IF NONE).
*
*      R$SCP                 SAVE POINTER (EXIT XR) FROM LAST
*                            CALL IN CASE RESCAN IS SET.
*
*      SCNBL                 THIS LOCATION IS SET NON-ZERO ON
*                            EXIT IF SCANE SCANNED PAST BLANKS
*                            BEFORE LOCATING THE CURRENT ELEMENT
*                            THE END OF A LINE COUNTS AS BLANKS.
*
*      SCNCC                 CNCRD SETS THIS NON-ZERO TO SCAN
*                            CONTROL CARD NAMES AND CLEARS IT
*                            ON RETURN
*
*      SCNIL                 LENGTH OF CURRENT INPUT IMAGE
*
*      SCNGO                 IF SET NON-ZERO ON ENTRY, F AND S
*                            ARE RETURNED AS SEPARATE SYNTAX
*                            TYPES (NOT LETTERS) (GOTO PRO-
*                            CESSING). SCNGO IS RESET ON EXIT.
*
*      SCNPT                 OFFSET TO CURRENT LOC IN R$CIM
*
*      SCNRS                 IF SET NON-ZERO ON ENTRY, SCANE
*                            RETURNS THE SAME RESULT AS ON THE
*                            LAST CALL (RESCAN). SCNRS IS RESET
*                            ON EXIT FROM ANY CALL TO SCANE.
*
*      SCNTP                 SAVE SYNTAX TYPE FROM LAST
*                            CALL (IN CASE RESCAN IS SET).
{{EJC{{{{{29128
*
*      SCANE (CONTINUED)
*
*
*
*      ELEMENT SCANNED       XL        XR
*      ---------------       --        --
*
*      CONTROL CARD NAME     0         POINTER TO SCBLK FOR NAME
*
*      UNARY OPERATOR        T$UOP     PTR TO OPERATOR DVBLK
*
*      LEFT PAREN            T$LPR     T$LPR
*
*      LEFT BRACKET          T$LBR     T$LBR
*
*      COMMA                 T$CMA     T$CMA
*
*      FUNCTION CALL         T$FNC     PTR TO FUNCTION VRBLK
*
*      VARIABLE              T$VAR     PTR TO VRBLK
*
*      STRING CONSTANT       T$CON     PTR TO SCBLK
*
*      INTEGER CONSTANT      T$CON     PTR TO ICBLK
*
*      REAL CONSTANT         T$CON     PTR TO RCBLK
*
*      BINARY OPERATOR       T$BOP     PTR TO OPERATOR DVBLK
*
*      RIGHT PAREN           T$RPR     T$RPR
*
*      RIGHT BRACKET         T$RBR     T$RBR
*
*      COLON                 T$COL     T$COL
*
*      SEMI-COLON            T$SMC     T$SMC
*
*      F (SCNGO NE 0)        T$FGO     T$FGO
*
*      S (SCNGO NE 0)        T$SGO     T$SGO
{{EJC{{{{{29173
*
*      SCANE (CONTINUED)
*
*      ENTRY POINT
*
{SCANE{PRC{25,E{1,0{{ENTRY POINT{29179
{{ZER{3,SCNBL{{{RESET BLANKS FLAG{29180
{{MOV{8,WA{3,SCNSA{{SAVE WA{29181
{{MOV{8,WB{3,SCNSB{{SAVE WB{29182
{{MOV{8,WC{3,SCNSC{{SAVE WC{29183
{{BZE{3,SCNRS{6,SCN03{{JUMP IF NO RESCAN{29184
*
*      HERE FOR RESCAN REQUEST
*
{{MOV{3,SCNTP{7,XL{{SET PREVIOUS RETURNED SCAN TYPE{29188
{{MOV{3,R$SCP{7,XR{{SET PREVIOUS RETURNED POINTER{29189
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH{29190
{{BRN{6,SCN13{{{JUMP TO EXIT{29191
*
*      COME HERE TO READ NEW IMAGE TO TEST FOR CONTINUATION
*
{SCN01{JSR{6,READR{{{READ NEXT IMAGE{29195
{{MOV{19,*DVUBS{8,WB{{SET WB FOR NOT READING NAME{29196
{{BZE{7,XR{6,SCN30{{TREAT AS SEMI-COLON IF NONE{29197
{{PLC{7,XR{{{ELSE POINT TO FIRST CHARACTER{29198
{{LCH{8,WC{9,(XR){{LOAD FIRST CHARACTER{29199
{{BEQ{8,WC{18,=CH$DT{6,SCN02{JUMP IF DOT FOR CONTINUATION{29200
{{BNE{8,WC{18,=CH$PL{6,SCN30{ELSE TREAT AS SEMICOLON UNLESS PLUS{29201
*
*      HERE FOR CONTINUATION LINE
*
{SCN02{JSR{6,NEXTS{{{ACQUIRE NEXT SOURCE IMAGE{29205
{{MOV{18,=NUM01{3,SCNPT{{SET SCAN POINTER PAST CONTINUATION{29206
{{MNZ{3,SCNBL{{{SET BLANKS FLAG{29207
{{EJC{{{{{29208
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO SCAN NEXT ELEMENT ON CURRENT LINE
*
{SCN03{MOV{3,SCNPT{8,WA{{LOAD CURRENT OFFSET{29214
{{BEQ{8,WA{3,SCNIL{6,SCN01{CHECK CONTINUATION IF END{29215
{{MOV{3,R$CIM{7,XL{{POINT TO CURRENT LINE{29216
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHARACTER{29217
{{MOV{8,WA{3,SCNSE{{SET START OF ELEMENT LOCATION{29218
{{MOV{21,=OPDVS{8,WC{{POINT TO OPERATOR DV LIST{29219
{{MOV{19,*DVUBS{8,WB{{SET CONSTANT FOR OPERATOR CIRCUIT{29220
{{BRN{6,SCN06{{{START SCANNING{29221
*
*      LOOP HERE TO IGNORE LEADING BLANKS AND TABS
*
{SCN05{BZE{8,WB{6,SCN10{{JUMP IF TRAILING{29225
{{ICV{3,SCNSE{{{INCREMENT START OF ELEMENT{29226
{{BEQ{8,WA{3,SCNIL{6,SCN01{JUMP IF END OF IMAGE{29227
{{MNZ{3,SCNBL{{{NOTE BLANKS SEEN{29228
*
*      THE FOLLOWING JUMP IS USED REPEATEDLY FOR SCANNING OUT
*      THE CHARACTERS OF A NUMERIC CONSTANT OR VARIABLE NAME.
*      THE REGISTERS ARE USED AS FOLLOWS.
*
*      (XR)                  SCRATCH
*      (XL)                  PTR TO NEXT CHARACTER
*      (WA)                  CURRENT SCAN OFFSET
*      (WB)                  *DVUBS (0 IF SCANNING NAME,CONST)
*      (WC)                  =OPDVS (0 IF SCANNING CONSTANT)
*
{SCN06{LCH{7,XR{10,(XL)+{{GET NEXT CHARACTER{29240
{{ICV{8,WA{{{BUMP SCAN OFFSET{29241
{{MOV{8,WA{3,SCNPT{{STORE OFFSET PAST CHAR SCANNED{29242
{{BSW{7,XR{2,CFP$U{6,SCN07{SWITCH ON SCANNED CHARACTER{29244
*
*      SWITCH TABLE FOR SWITCH ON CHARACTER
*
{{EJC{{{{{29271
*
*      SCANE (CONTINUED)
*
{{EJC{{{{{29327
*
*      SCANE (CONTINUED)
*
{{IFF{1,0{6,SCN07{{{29360
{{IFF{1,1{6,SCN07{{{29360
{{IFF{1,2{6,SCN07{{{29360
{{IFF{1,3{6,SCN07{{{29360
{{IFF{1,4{6,SCN07{{{29360
{{IFF{1,5{6,SCN07{{{29360
{{IFF{1,6{6,SCN07{{{29360
{{IFF{1,7{6,SCN07{{{29360
{{IFF{1,8{6,SCN07{{{29360
{{IFF{2,CH$HT{6,SCN05{{HORIZONTAL TAB{29360
{{IFF{1,10{6,SCN07{{{29360
{{IFF{1,11{6,SCN07{{{29360
{{IFF{1,12{6,SCN07{{{29360
{{IFF{1,13{6,SCN07{{{29360
{{IFF{1,14{6,SCN07{{{29360
{{IFF{1,15{6,SCN07{{{29360
{{IFF{1,16{6,SCN07{{{29360
{{IFF{1,17{6,SCN07{{{29360
{{IFF{1,18{6,SCN07{{{29360
{{IFF{1,19{6,SCN07{{{29360
{{IFF{1,20{6,SCN07{{{29360
{{IFF{1,21{6,SCN07{{{29360
{{IFF{1,22{6,SCN07{{{29360
{{IFF{1,23{6,SCN07{{{29360
{{IFF{1,24{6,SCN07{{{29360
{{IFF{1,25{6,SCN07{{{29360
{{IFF{1,26{6,SCN07{{{29360
{{IFF{1,27{6,SCN07{{{29360
{{IFF{1,28{6,SCN07{{{29360
{{IFF{1,29{6,SCN07{{{29360
{{IFF{1,30{6,SCN07{{{29360
{{IFF{1,31{6,SCN07{{{29360
{{IFF{2,CH$BL{6,SCN05{{BLANK{29360
{{IFF{2,CH$EX{6,SCN37{{EXCLAMATION MARK{29360
{{IFF{2,CH$DQ{6,SCN17{{DOUBLE QUOTE{29360
{{IFF{2,CH$NM{6,SCN41{{NUMBER SIGN{29360
{{IFF{2,CH$DL{6,SCN36{{DOLLAR{29360
{{IFF{2,CH$PC{6,SCN38{{PERCENT{29360
{{IFF{2,CH$AM{6,SCN44{{AMPERSAND{29360
{{IFF{2,CH$SQ{6,SCN16{{SINGLE QUOTE{29360
{{IFF{2,CH$PP{6,SCN25{{LEFT PAREN{29360
{{IFF{2,CH$RP{6,SCN26{{RIGHT PAREN{29360
{{IFF{2,CH$AS{6,SCN49{{ASTERISK{29360
{{IFF{2,CH$PL{6,SCN33{{PLUS{29360
{{IFF{2,CH$CM{6,SCN31{{COMMA{29360
{{IFF{2,CH$MN{6,SCN34{{MINUS{29360
{{IFF{2,CH$DT{6,SCN32{{DOT{29360
{{IFF{2,CH$SL{6,SCN40{{SLASH{29360
{{IFF{2,CH$D0{6,SCN08{{DIGIT 0{29360
{{IFF{2,CH$D1{6,SCN08{{DIGIT 1{29360
{{IFF{2,CH$D2{6,SCN08{{DIGIT 2{29360
{{IFF{2,CH$D3{6,SCN08{{DIGIT 3{29360
{{IFF{2,CH$D4{6,SCN08{{DIGIT 4{29360
{{IFF{2,CH$D5{6,SCN08{{DIGIT 5{29360
{{IFF{2,CH$D6{6,SCN08{{DIGIT 6{29360
{{IFF{2,CH$D7{6,SCN08{{DIGIT 7{29360
{{IFF{2,CH$D8{6,SCN08{{DIGIT 8{29360
{{IFF{2,CH$D9{6,SCN08{{DIGIT 9{29360
{{IFF{2,CH$CL{6,SCN29{{COLON{29360
{{IFF{2,CH$SM{6,SCN30{{SEMI-COLON{29360
{{IFF{2,CH$BB{6,SCN28{{LEFT BRACKET{29360
{{IFF{2,CH$EQ{6,SCN46{{EQUAL{29360
{{IFF{2,CH$RB{6,SCN27{{RIGHT BRACKET{29360
{{IFF{2,CH$QU{6,SCN45{{QUESTION MARK{29360
{{IFF{2,CH$AT{6,SCN42{{AT{29360
{{IFF{2,CH$LA{6,SCN09{{LETTER A{29360
{{IFF{2,CH$LB{6,SCN09{{LETTER B{29360
{{IFF{2,CH$LC{6,SCN09{{LETTER C{29360
{{IFF{2,CH$LD{6,SCN09{{LETTER D{29360
{{IFF{2,CH$LE{6,SCN09{{LETTER E{29360
{{IFF{2,CH$LF{6,SCN20{{LETTER F{29360
{{IFF{2,CH$LG{6,SCN09{{LETTER G{29360
{{IFF{2,CH$LH{6,SCN09{{LETTER H{29360
{{IFF{2,CH$LI{6,SCN09{{LETTER I{29360
{{IFF{2,CH$LJ{6,SCN09{{LETTER J{29360
{{IFF{2,CH$LK{6,SCN09{{LETTER K{29360
{{IFF{2,CH$LL{6,SCN09{{LETTER L{29360
{{IFF{2,CH$LM{6,SCN09{{LETTER M{29360
{{IFF{2,CH$LN{6,SCN09{{LETTER N{29360
{{IFF{2,CH$LO{6,SCN09{{LETTER O{29360
{{IFF{2,CH$LP{6,SCN09{{LETTER P{29360
{{IFF{2,CH$LQ{6,SCN09{{LETTER Q{29360
{{IFF{2,CH$LR{6,SCN09{{LETTER R{29360
{{IFF{2,CH$LS{6,SCN21{{LETTER S{29360
{{IFF{2,CH$LT{6,SCN09{{LETTER T{29360
{{IFF{2,CH$LU{6,SCN09{{LETTER U{29360
{{IFF{2,CH$LV{6,SCN09{{LETTER V{29360
{{IFF{2,CH$LW{6,SCN09{{LETTER W{29360
{{IFF{2,CH$LX{6,SCN09{{LETTER X{29360
{{IFF{2,CH$LY{6,SCN09{{LETTER Y{29360
{{IFF{2,CH$L${6,SCN09{{LETTER Z{29360
{{IFF{2,CH$OB{6,SCN28{{LEFT BRACKET{29360
{{IFF{1,92{6,SCN07{{{29360
{{IFF{2,CH$CB{6,SCN27{{RIGHT BRACKET{29360
{{IFF{2,CH$EY{6,SCN37{{UP ARROW{29360
{{IFF{2,CH$UN{6,SCN24{{UNDERLINE{29360
{{IFF{1,96{6,SCN07{{{29360
{{IFF{2,CH$$A{6,SCN09{{SHIFTED A{29360
{{IFF{2,CH$$B{6,SCN09{{SHIFTED B{29360
{{IFF{2,CH$$C{6,SCN09{{SHIFTED C{29360
{{IFF{2,CH$$D{6,SCN09{{SHIFTED D{29360
{{IFF{2,CH$$E{6,SCN09{{SHIFTED E{29360
{{IFF{2,CH$$F{6,SCN20{{SHIFTED F{29360
{{IFF{2,CH$$G{6,SCN09{{SHIFTED G{29360
{{IFF{2,CH$$H{6,SCN09{{SHIFTED H{29360
{{IFF{2,CH$$I{6,SCN09{{SHIFTED I{29360
{{IFF{2,CH$$J{6,SCN09{{SHIFTED J{29360
{{IFF{2,CH$$K{6,SCN09{{SHIFTED K{29360
{{IFF{2,CH$$L{6,SCN09{{SHIFTED L{29360
{{IFF{2,CH$$M{6,SCN09{{SHIFTED M{29360
{{IFF{2,CH$$N{6,SCN09{{SHIFTED N{29360
{{IFF{2,CH$$O{6,SCN09{{SHIFTED O{29360
{{IFF{2,CH$$P{6,SCN09{{SHIFTED P{29360
{{IFF{2,CH$$Q{6,SCN09{{SHIFTED Q{29360
{{IFF{2,CH$$R{6,SCN09{{SHIFTED R{29360
{{IFF{2,CH$$S{6,SCN21{{SHIFTED S{29360
{{IFF{2,CH$$T{6,SCN09{{SHIFTED T{29360
{{IFF{2,CH$$U{6,SCN09{{SHIFTED U{29360
{{IFF{2,CH$$V{6,SCN09{{SHIFTED V{29360
{{IFF{2,CH$$W{6,SCN09{{SHIFTED W{29360
{{IFF{2,CH$$X{6,SCN09{{SHIFTED X{29360
{{IFF{2,CH$$Y{6,SCN09{{SHIFTED Y{29360
{{IFF{2,CH$$${6,SCN09{{SHIFTED Z{29360
{{IFF{1,123{6,SCN07{{{29360
{{IFF{2,CH$BR{6,SCN43{{VERTICAL BAR{29360
{{IFF{1,125{6,SCN07{{{29360
{{IFF{2,CH$NT{6,SCN35{{NOT{29360
{{IFF{1,127{6,SCN07{{{29360
{{ESW{{{{END SWITCH ON CHARACTER{29360
*
*      HERE FOR ILLEGAL CHARACTER (UNDERLINE MERGES)
*
{SCN07{BZE{8,WB{6,SCN10{{JUMP IF SCANNING NAME OR CONSTANT{29364
{{ERB{1,230{26,Syntax error: Illegal character{{{29365
{{EJC{{{{{29366
*
*      SCANE (CONTINUED)
*
*      HERE FOR DIGITS 0-9
*
{SCN08{BZE{8,WB{6,SCN09{{KEEP SCANNING IF NAME/CONSTANT{29372
{{ZER{8,WC{{{ELSE SET FLAG FOR SCANNING CONSTANT{29373
*
*      HERE FOR LETTER. LOOP HERE WHEN SCANNING NAME/CONSTANT
*
{SCN09{BEQ{8,WA{3,SCNIL{6,SCN11{JUMP IF END OF IMAGE{29377
{{ZER{8,WB{{{SET FLAG FOR SCANNING NAME/CONST{29378
{{BRN{6,SCN06{{{MERGE BACK TO CONTINUE SCAN{29379
*
*      COME HERE FOR DELIMITER ENDING NAME OR CONSTANT
*
{SCN10{DCV{8,WA{{{RESET OFFSET TO POINT TO DELIMITER{29383
*
*      COME HERE AFTER FINISHING SCAN OF NAME OR CONSTANT
*
{SCN11{MOV{8,WA{3,SCNPT{{STORE UPDATED SCAN OFFSET{29387
{{MOV{3,SCNSE{8,WB{{POINT TO START OF ELEMENT{29388
{{SUB{8,WB{8,WA{{GET NUMBER OF CHARACTERS{29389
{{MOV{3,R$CIM{7,XL{{POINT TO LINE IMAGE{29390
{{BNZ{8,WC{6,SCN15{{JUMP IF NAME{29391
*
*      HERE AFTER SCANNING OUT NUMERIC CONSTANT
*
{{JSR{6,SBSTR{{{GET STRING FOR CONSTANT{29395
{{MOV{7,XR{3,DNAMP{{DELETE FROM STORAGE (NOT NEEDED){29396
{{JSR{6,GTNUM{{{CONVERT TO NUMERIC{29397
{{PPM{6,SCN14{{{JUMP IF CONVERSION FAILURE{29398
*
*      MERGE HERE TO EXIT WITH CONSTANT
*
{SCN12{MOV{18,=T$CON{7,XL{{SET RESULT TYPE OF CONSTANT{29402
{{EJC{{{{{29403
*
*      SCANE (CONTINUED)
*
*      COMMON EXIT POINT (XR,XL) SET
*
{SCN13{MOV{3,SCNSA{8,WA{{RESTORE WA{29409
{{MOV{3,SCNSB{8,WB{{RESTORE WB{29410
{{MOV{3,SCNSC{8,WC{{RESTORE WC{29411
{{MOV{7,XR{3,R$SCP{{SAVE XR IN CASE RESCAN{29412
{{MOV{7,XL{3,SCNTP{{SAVE XL IN CASE RESCAN{29413
{{ZER{3,SCNGO{{{RESET POSSIBLE GOTO FLAG{29414
{{EXI{{{{RETURN TO SCANE CALLER{29415
*
*      HERE IF CONVERSION ERROR ON NUMERIC ITEM
*
{SCN14{ERB{1,231{26,Syntax error: Invalid numeric item{{{29419
*
*      HERE AFTER SCANNING OUT VARIABLE NAME
*
{SCN15{JSR{6,SBSTR{{{BUILD STRING NAME OF VARIABLE{29423
{{BNZ{3,SCNCC{6,SCN13{{RETURN IF CNCRD CALL{29424
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{29425
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{29426
{{MOV{18,=T$VAR{7,XL{{SET TYPE AS VARIABLE{29427
{{BRN{6,SCN13{{{BACK TO EXIT{29428
*
*      HERE FOR SINGLE QUOTE (START OF STRING CONSTANT)
*
{SCN16{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{29432
{{MOV{18,=CH$SQ{8,WB{{SET TERMINATOR AS SINGLE QUOTE{29433
{{BRN{6,SCN18{{{MERGE{29434
*
*      HERE FOR DOUBLE QUOTE (START OF STRING CONSTANT)
*
{SCN17{BZE{8,WB{6,SCN10{{TERMINATOR IF SCANNING NAME OR CNST{29438
{{MOV{18,=CH$DQ{8,WB{{SET DOUBLE QUOTE TERMINATOR, MERGE{29439
*
*      LOOP TO SCAN OUT STRING CONSTANT
*
{SCN18{BEQ{8,WA{3,SCNIL{6,SCN19{ERROR IF END OF IMAGE{29443
{{LCH{8,WC{10,(XL)+{{ELSE LOAD NEXT CHARACTER{29444
{{ICV{8,WA{{{BUMP OFFSET{29445
{{BNE{8,WC{8,WB{6,SCN18{LOOP BACK IF NOT TERMINATOR{29446
{{EJC{{{{{29447
*
*      SCANE (CONTINUED)
*
*      HERE AFTER SCANNING OUT STRING CONSTANT
*
{{MOV{3,SCNPT{8,WB{{POINT TO FIRST CHARACTER{29453
{{MOV{8,WA{3,SCNPT{{SAVE OFFSET PAST FINAL QUOTE{29454
{{DCV{8,WA{{{POINT BACK PAST LAST CHARACTER{29455
{{SUB{8,WB{8,WA{{GET NUMBER OF CHARACTERS{29456
{{MOV{3,R$CIM{7,XL{{POINT TO INPUT IMAGE{29457
{{JSR{6,SBSTR{{{BUILD SUBSTRING VALUE{29458
{{BRN{6,SCN12{{{BACK TO EXIT WITH CONSTANT RESULT{29459
*
*      HERE IF NO MATCHING QUOTE FOUND
*
{SCN19{MOV{8,WA{3,SCNPT{{SET UPDATED SCAN POINTER{29463
{{ERB{1,232{26,Syntax error: Unmatched string quote{{{29464
*
*      HERE FOR F (POSSIBLE FAILURE GOTO)
*
{SCN20{MOV{18,=T$FGO{7,XR{{SET RETURN CODE FOR FAIL GOTO{29468
{{BRN{6,SCN22{{{JUMP TO MERGE{29469
*
*      HERE FOR S (POSSIBLE SUCCESS GOTO)
*
{SCN21{MOV{18,=T$SGO{7,XR{{SET SUCCESS GOTO AS RETURN CODE{29473
*
*      SPECIAL GOTO CASES MERGE HERE
*
{SCN22{BZE{3,SCNGO{6,SCN09{{TREAT AS NORMAL LETTER IF NOT GOTO{29477
*
*      MERGE HERE FOR SPECIAL CHARACTER EXIT
*
{SCN23{BZE{8,WB{6,SCN10{{JUMP IF END OF NAME/CONSTANT{29481
{{MOV{7,XR{7,XL{{ELSE COPY CODE{29482
{{BRN{6,SCN13{{{AND JUMP TO EXIT{29483
*
*      HERE FOR UNDERLINE
*
{SCN24{BZE{8,WB{6,SCN09{{PART OF NAME IF SCANNING NAME{29487
{{BRN{6,SCN07{{{ELSE ILLEGAL{29488
{{EJC{{{{{29489
*
*      SCANE (CONTINUED)
*
*      HERE FOR LEFT PAREN
*
{SCN25{MOV{18,=T$LPR{7,XR{{SET LEFT PAREN RETURN CODE{29495
{{BNZ{8,WB{6,SCN23{{RETURN LEFT PAREN UNLESS NAME{29496
{{BZE{8,WC{6,SCN10{{DELIMITER IF SCANNING CONSTANT{29497
*
*      HERE FOR LEFT PAREN AFTER NAME (FUNCTION CALL)
*
{{MOV{3,SCNSE{8,WB{{POINT TO START OF NAME{29501
{{MOV{8,WA{3,SCNPT{{SET POINTER PAST LEFT PAREN{29502
{{DCV{8,WA{{{POINT BACK PAST LAST CHAR OF NAME{29503
{{SUB{8,WB{8,WA{{GET NAME LENGTH{29504
{{MOV{3,R$CIM{7,XL{{POINT TO INPUT IMAGE{29505
{{JSR{6,SBSTR{{{GET STRING NAME FOR FUNCTION{29506
{{JSR{6,GTNVR{{{LOCATE/BUILD VRBLK{29507
{{PPM{{{{DUMMY (UNUSED) ERROR RETURN{29508
{{MOV{18,=T$FNC{7,XL{{SET CODE FOR FUNCTION CALL{29509
{{BRN{6,SCN13{{{BACK TO EXIT{29510
*
*      PROCESSING FOR SPECIAL CHARACTERS
*
{SCN26{MOV{18,=T$RPR{7,XR{{RIGHT PAREN, SET CODE{29514
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29515
*
{SCN27{MOV{18,=T$RBR{7,XR{{RIGHT BRACKET, SET CODE{29517
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29518
*
{SCN28{MOV{18,=T$LBR{7,XR{{LEFT BRACKET, SET CODE{29520
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29521
*
{SCN29{MOV{18,=T$COL{7,XR{{COLON, SET CODE{29523
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29524
*
{SCN30{MOV{18,=T$SMC{7,XR{{SEMI-COLON, SET CODE{29526
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29527
*
{SCN31{MOV{18,=T$CMA{7,XR{{COMMA, SET CODE{29529
{{BRN{6,SCN23{{{TAKE SPECIAL CHARACTER EXIT{29530
{{EJC{{{{{29531
*
*      SCANE (CONTINUED)
*
*      HERE FOR OPERATORS. ON ENTRY, WC POINTS TO THE TABLE OF
*      OPERATOR DOPE VECTORS AND WB IS THE INCREMENT TO STEP
*      TO THE NEXT PAIR (BINARY/UNARY) OF DOPE VECTORS IN THE
*      LIST. ON REACHING SCN46, THE POINTER HAS BEEN ADJUSTED TO
*      POINT TO THE APPROPRIATE PAIR OF DOPE VECTORS.
*      THE FIRST THREE ENTRIES ARE SPECIAL SINCE THEY CAN OCCUR
*      AS PART OF A VARIABLE NAME (.) OR CONSTANT (.+-).
*
{SCN32{BZE{8,WB{6,SCN09{{DOT CAN BE PART OF NAME OR CONSTANT{29543
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29544
*
{SCN33{BZE{8,WC{6,SCN09{{PLUS CAN BE PART OF CONSTANT{29546
{{BZE{8,WB{6,SCN48{{PLUS CANNOT BE PART OF NAME{29547
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29548
*
{SCN34{BZE{8,WC{6,SCN09{{MINUS CAN BE PART OF CONSTANT{29550
{{BZE{8,WB{6,SCN48{{MINUS CANNOT BE PART OF NAME{29551
{{ADD{8,WB{8,WC{{ELSE BUMP POINTER{29552
*
{SCN35{ADD{8,WB{8,WC{{NOT{29554
{SCN36{ADD{8,WB{8,WC{{DOLLAR{29555
{SCN37{ADD{8,WB{8,WC{{EXCLAMATION{29556
{SCN38{ADD{8,WB{8,WC{{PERCENT{29557
{SCN39{ADD{8,WB{8,WC{{ASTERISK{29558
{SCN40{ADD{8,WB{8,WC{{SLASH{29559
{SCN41{ADD{8,WB{8,WC{{NUMBER SIGN{29560
{SCN42{ADD{8,WB{8,WC{{AT SIGN{29561
{SCN43{ADD{8,WB{8,WC{{VERTICAL BAR{29562
{SCN44{ADD{8,WB{8,WC{{AMPERSAND{29563
{SCN45{ADD{8,WB{8,WC{{QUESTION MARK{29564
*
*      ALL OPERATORS COME HERE (EQUAL MERGES DIRECTLY)
*      (WC) POINTS TO THE BINARY/UNARY PAIR OF OPERATOR DVBLKS.
*
{SCN46{BZE{8,WB{6,SCN10{{OPERATOR TERMINATES NAME/CONSTANT{29569
{{MOV{8,WC{7,XR{{ELSE COPY DV POINTER{29570
{{LCH{8,WC{9,(XL){{LOAD NEXT CHARACTER{29571
{{MOV{18,=T$BOP{7,XL{{SET BINARY OP IN CASE{29572
{{BEQ{8,WA{3,SCNIL{6,SCN47{SHOULD BE BINARY IF IMAGE END{29573
{{BEQ{8,WC{18,=CH$BL{6,SCN47{SHOULD BE BINARY IF FOLLOWED BY BLK{29574
{{BEQ{8,WC{18,=CH$HT{6,SCN47{JUMP IF HORIZONTAL TAB{29576
{{BEQ{8,WC{18,=CH$SM{6,SCN47{SEMICOLON CAN IMMEDIATELY FOLLOW ={29581
{{BEQ{8,WC{18,=CH$CL{6,SCN47{COLON CAN IMMEDIATELY FOLLOW ={29582
{{BEQ{8,WC{18,=CH$RP{6,SCN47{RIGHT PAREN CAN IMMEDIATELY FOLLOW ={29583
{{BEQ{8,WC{18,=CH$RB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={29584
{{BEQ{8,WC{18,=CH$CB{6,SCN47{RIGHT BRACKET CAN IMMEDIATELY FOLLOW ={29585
*
*      HERE FOR UNARY OPERATOR
*
{{ADD{19,*DVBS${7,XR{{POINT TO DV FOR UNARY OP{29589
{{MOV{18,=T$UOP{7,XL{{SET TYPE FOR UNARY OPERATOR{29590
{{BLE{3,SCNTP{18,=T$UOK{6,SCN13{OK UNARY IF OK PRECEDING ELEMENT{29591
{{EJC{{{{{29592
*
*      SCANE (CONTINUED)
*
*      MERGE HERE TO REQUIRE PRECEDING BLANKS
*
{SCN47{BNZ{3,SCNBL{6,SCN13{{ALL OK IF PRECEDING BLANKS, EXIT{29598
*
*      FAIL OPERATOR IN THIS POSITION
*
{SCN48{ERB{1,233{26,Syntax error: Invalid use of operator{{{29602
*
*      HERE FOR ASTERISK, COULD BE ** SUBSTITUTE FOR EXCLAMATION
*
{SCN49{BZE{8,WB{6,SCN10{{END OF NAME IF SCANNING NAME{29606
{{BEQ{8,WA{3,SCNIL{6,SCN39{NOT ** IF * AT IMAGE END{29607
{{MOV{8,WA{7,XR{{ELSE SAVE OFFSET PAST FIRST *{29608
{{MOV{8,WA{3,SCNOF{{SAVE ANOTHER COPY{29609
{{LCH{8,WA{10,(XL)+{{LOAD NEXT CHARACTER{29610
{{BNE{8,WA{18,=CH$AS{6,SCN50{NOT ** IF NEXT CHAR NOT *{29611
{{ICV{7,XR{{{ELSE STEP OFFSET PAST SECOND *{29612
{{BEQ{7,XR{3,SCNIL{6,SCN51{OK EXCLAM IF END OF IMAGE{29613
{{LCH{8,WA{9,(XL){{ELSE LOAD NEXT CHARACTER{29614
{{BEQ{8,WA{18,=CH$BL{6,SCN51{EXCLAMATION IF BLANK{29615
{{BEQ{8,WA{18,=CH$HT{6,SCN51{EXCLAMATION IF HORIZONTAL TAB{29617
*
*      UNARY *
*
{SCN50{MOV{3,SCNOF{8,WA{{RECOVER STORED OFFSET{29625
{{MOV{3,R$CIM{7,XL{{POINT TO LINE AGAIN{29626
{{PLC{7,XL{8,WA{{POINT TO CURRENT CHAR{29627
{{BRN{6,SCN39{{{MERGE WITH UNARY *{29628
*
*      HERE FOR ** AS SUBSTITUTE FOR EXCLAMATION
*
{SCN51{MOV{7,XR{3,SCNPT{{SAVE SCAN POINTER PAST 2ND *{29632
{{MOV{7,XR{8,WA{{COPY SCAN POINTER{29633
{{BRN{6,SCN37{{{MERGE WITH EXCLAMATION{29634
{{ENP{{{{END PROCEDURE SCANE{29635
{{EJC{{{{{29636
*
*      SCNGF -- SCAN GOTO FIELD
*
*      SCNGF IS CALLED FROM CMPIL TO SCAN AND ANALYZE A GOTO
*      FIELD INCLUDING THE SURROUNDING BRACKETS OR PARENTHESES.
*      FOR A NORMAL GOTO, THE RESULT RETURNED IS EITHER A VRBLK
*      POINTER FOR A SIMPLE LABEL OPERAND, OR A POINTER TO AN
*      EXPRESSION TREE WITH A SPECIAL OUTER UNARY OPERATOR
*      (O$GOC). FOR A DIRECT GOTO, THE RESULT RETURNED IS A
*      POINTER TO AN EXPRESSION TREE WITH THE SPECIAL OUTER
*      UNARY OPERATOR O$GOD.
*
*      JSR  SCNGF            CALL TO SCAN GOTO FIELD
*      (XR)                  RESULT (SEE ABOVE)
*      (XL,WA,WB,WC)         DESTROYED
*
{SCNGF{PRC{25,E{1,0{{ENTRY POINT{29653
{{JSR{6,SCANE{{{SCAN INITIAL ELEMENT{29654
{{BEQ{7,XL{18,=T$LPR{6,SCNG1{SKIP IF LEFT PAREN (NORMAL GOTO){29655
{{BEQ{7,XL{18,=T$LBR{6,SCNG2{SKIP IF LEFT BRACKET (DIRECT GOTO){29656
{{ERB{1,234{26,Syntax error: Goto field incorrect{{{29657
*
*      HERE FOR LEFT PAREN (NORMAL GOTO)
*
{SCNG1{MOV{18,=NUM01{8,WB{{SET EXPAN FLAG FOR NORMAL GOTO{29661
{{JSR{6,EXPAN{{{ANALYZE GOTO FIELD{29662
{{MOV{21,=OPDVN{8,WA{{POINT TO OPDV FOR COMPLEX GOTO{29663
{{BLE{7,XR{3,STATB{6,SCNG3{JUMP IF NOT IN STATIC (SGD15){29664
{{BLO{7,XR{3,STATE{6,SCNG4{JUMP TO EXIT IF SIMPLE LABEL NAME{29665
{{BRN{6,SCNG3{{{COMPLEX GOTO - MERGE{29666
*
*      HERE FOR LEFT BRACKET (DIRECT GOTO)
*
{SCNG2{MOV{18,=NUM02{8,WB{{SET EXPAN FLAG FOR DIRECT GOTO{29670
{{JSR{6,EXPAN{{{SCAN GOTO FIELD{29671
{{MOV{21,=OPDVD{8,WA{{SET OPDV POINTER FOR DIRECT GOTO{29672
{{EJC{{{{{29673
*
*      SCNGF (CONTINUED)
*
*      MERGE HERE TO BUILD OUTER UNARY OPERATOR BLOCK
*
{SCNG3{MOV{8,WA{11,-(XS){{STACK OPERATOR DV POINTER{29679
{{MOV{7,XR{11,-(XS){{STACK POINTER TO EXPRESSION TREE{29680
{{JSR{6,EXPOP{{{POP OPERATOR OFF{29681
{{MOV{10,(XS)+{7,XR{{RELOAD NEW EXPRESSION TREE POINTER{29682
*
*      COMMON EXIT POINT
*
{SCNG4{EXI{{{{RETURN TO CALLER{29686
{{ENP{{{{END PROCEDURE SCNGF{29687
{{EJC{{{{{29688
*
*      SETVR -- SET VRGET,VRSTO FIELDS OF VRBLK
*
*      SETVR SETS THE PROPER VALUES IN THE VRGET AND VRSTO
*      FIELDS OF A VRBLK. IT IS CALLED WHENEVER TRBLKS ARE
*      ADDED OR SUBTRACTED (TRACE,STOPTR,INPUT,OUTPUT,DETACH)
*
*      (XR)                  POINTER TO VRBLK
*      JSR  SETVR            CALL TO SET FIELDS
*      (XL,WA)               DESTROYED
*
*      NOTE THAT SETVR IGNORES THE CALL IF XR DOES NOT POINT
*      INTO THE STATIC REGION (I.E. IS SOME OTHER NAME BASE)
*
{SETVR{PRC{25,E{1,0{{ENTRY POINT{29703
{{BHI{7,XR{3,STATE{6,SETV1{EXIT IF NOT NATURAL VARIABLE{29704
*
*      HERE IF WE HAVE A VRBLK
*
{{MOV{7,XR{7,XL{{COPY VRBLK POINTER{29708
{{MOV{22,=B$VRL{13,VRGET(XR){{STORE NORMAL GET VALUE{29709
{{BEQ{13,VRSTO(XR){22,=B$VRE{6,SETV1{SKIP IF PROTECTED VARIABLE{29710
{{MOV{22,=B$VRS{13,VRSTO(XR){{STORE NORMAL STORE VALUE{29711
{{MOV{13,VRVAL(XL){7,XL{{POINT TO NEXT ENTRY ON CHAIN{29712
{{BNE{9,(XL){22,=B$TRT{6,SETV1{JUMP IF END OF TRBLK CHAIN{29713
{{MOV{22,=B$VRA{13,VRGET(XR){{STORE TRAPPED ROUTINE ADDRESS{29714
{{MOV{22,=B$VRV{13,VRSTO(XR){{SET TRAPPED ROUTINE ADDRESS{29715
*
*      MERGE HERE TO EXIT TO CALLER
*
{SETV1{EXI{{{{RETURN TO SETVR CALLER{29719
{{ENP{{{{END PROCEDURE SETVR{29720
{{EJC{{{{{29723
*
*      SORTA -- SORT ARRAY
*
*      ROUTINE TO SORT AN ARRAY OR TABLE ON SAME BASIS AS IN
*      SITBOL. A TABLE IS CONVERTED TO AN ARRAY, LEAVING TWO
*      DIMENSIONAL ARRAYS AND VECTORS AS CASES TO BE CONSIDERED.
*      WHOLE ROWS OF ARRAYS ARE PERMUTED ACCORDING TO THE
*      ORDERING OF THE KEYS THEY CONTAIN, AND THE STRIDE
*      REFERRED TO, IS THE THE LENGTH OF A ROW. IT IS ONE
*      FOR A VECTOR.
*      THE SORT USED IS HEAPSORT, FUNDAMENTALS OF DATA STRUCTURE
*      HOROWITZ AND SAHNI, PITMAN 1977, PAGE 347.
*      IT IS AN ORDER N*LOG(N) ALGORITHM. IN ORDER
*      TO MAKE IT STABLE, COMPARANDS MAY NOT COMPARE EQUAL. THIS
*      IS ACHIEVED BY SORTING A COPY ARRAY (REFERRED TO AS THE
*      SORT ARRAY) CONTAINING AT ITS HIGH ADDRESS END, BYTE
*      OFFSETS TO THE ROWS TO BE SORTED HELD IN THE ORIGINAL
*      ARRAY (REFERRED TO AS THE KEY ARRAY). SORTC, THE
*      COMPARISON ROUTINE, ACCESSES THE KEYS THROUGH THESE
*      OFFSETS AND IN THE CASE OF EQUALITY, RESOLVES IT BY
*      COMPARING THE OFFSETS THEMSELVES. THE SORT PERMUTES THE
*      OFFSETS WHICH ARE THEN USED IN A FINAL OPERATION TO COPY
*      THE ACTUAL ITEMS INTO THE NEW ARRAY IN SORTED ORDER.
*      REFERENCES TO ZEROTH ITEM ARE TO NOTIONAL ITEM
*      PRECEDING FIRST ACTUAL ITEM.
*      REVERSE SORTING FOR RSORT IS DONE BY HAVING THE LESS THAN
*      TEST FOR KEYS EFFECTIVELY BE REPLACED BY A
*      GREATER THAN TEST.
*
*      1(XS)                 FIRST ARG - ARRAY OR TABLE
*      0(XS)                 2ND ARG - INDEX OR PDTYPE NAME
*      (WA)                  0 , NON-ZERO FOR SORT , RSORT
*      JSR  SORTA            CALL TO SORT ARRAY
*      PPM  LOC              TRANSFER LOC IF TABLE IS EMPTY
*      (XR)                  SORTED ARRAY
*      (XL,WA,WB,WC)         DESTROYED
{{EJC{{{{{29760
*
*      SORTA (CONTINUED)
*
{SORTA{PRC{25,N{1,1{{ENTRY POINT{29764
{{MOV{8,WA{3,SRTSR{{SORT/RSORT INDICATOR{29765
{{MOV{19,*NUM01{3,SRTST{{DEFAULT STRIDE OF 1{29766
{{ZER{3,SRTOF{{{DEFAULT ZERO OFFSET TO SORT KEY{29767
{{MOV{21,=NULLS{3,SRTDF{{CLEAR DATATYPE FIELD NAME{29768
{{MOV{10,(XS)+{3,R$SXR{{UNSTACK ARGUMENT 2{29769
{{MOV{10,(XS)+{7,XR{{GET FIRST ARGUMENT{29770
{{MNZ{8,WA{{{USE KEY/VALUES OF TABLE ENTRIES{29771
{{JSR{6,GTARR{{{CONVERT TO ARRAY{29772
{{PPM{6,SRT18{{{SIGNAL THAT TABLE IS EMPTY{29773
{{PPM{6,SRT16{{{ERROR IF NON-CONVERTABLE{29774
{{MOV{7,XR{11,-(XS){{STACK PTR TO RESULTING KEY ARRAY{29775
{{MOV{7,XR{11,-(XS){{ANOTHER COPY FOR COPYB{29776
{{JSR{6,COPYB{{{GET COPY ARRAY FOR SORTING INTO{29777
{{PPM{{{{CANT FAIL{29778
{{MOV{7,XR{11,-(XS){{STACK POINTER TO SORT ARRAY{29779
{{MOV{3,R$SXR{7,XR{{GET SECOND ARG{29780
{{MOV{12,1(XS){7,XL{{GET PTR TO KEY ARRAY{29781
{{BNE{9,(XL){22,=B$VCT{6,SRT02{JUMP IF ARBLK{29782
{{BEQ{7,XR{21,=NULLS{6,SRT01{JUMP IF NULL SECOND ARG{29783
{{JSR{6,GTNVR{{{GET VRBLK PTR FOR IT{29784
{{ERR{1,257{26,Erroneous 2nd arg in SORT/RSORT of vector{{{29785
{{MOV{7,XR{3,SRTDF{{STORE DATATYPE FIELD NAME VRBLK{29786
*
*      COMPUTE N AND OFFSET TO ITEM A(0) IN VECTOR CASE
*
{SRT01{MOV{19,*VCLEN{8,WC{{OFFSET TO A(0){29790
{{MOV{19,*VCVLS{8,WB{{OFFSET TO FIRST ITEM{29791
{{MOV{13,VCLEN(XL){8,WA{{GET BLOCK LENGTH{29792
{{SUB{19,*VCSI${8,WA{{GET NO. OF ENTRIES, N (IN BYTES){29793
{{BRN{6,SRT04{{{MERGE{29794
*
*      HERE FOR ARRAY
*
{SRT02{LDI{13,ARDIM(XL){{{GET POSSIBLE DIMENSION{29798
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{29799
{{WTB{8,WA{{{FURTHER CONVERT TO BAUS{29800
{{MOV{19,*ARVLS{8,WB{{OFFSET TO FIRST VALUE IF ONE{29801
{{MOV{19,*ARPRO{8,WC{{OFFSET BEFORE VALUES IF ONE DIM.{29802
{{BEQ{13,ARNDM(XL){18,=NUM01{6,SRT04{JUMP IN FACT IF ONE DIM.{29803
{{BNE{13,ARNDM(XL){18,=NUM02{6,SRT16{FAIL UNLESS TWO DIMENS{29804
{{LDI{13,ARLB2(XL){{{GET LOWER BOUND 2 AS DEFAULT{29805
{{BEQ{7,XR{21,=NULLS{6,SRT03{JUMP IF DEFAULT SECOND ARG{29806
{{JSR{6,GTINT{{{CONVERT TO INTEGER{29807
{{PPM{6,SRT17{{{FAIL{29808
{{LDI{13,ICVAL(XR){{{GET ACTUAL INTEGER VALUE{29809
{{EJC{{{{{29810
*
*      SORTA (CONTINUED)
*
*      HERE WITH SORT COLUMN INDEX IN IA IN ARRAY CASE
*
{SRT03{SBI{13,ARLB2(XL){{{SUBTRACT LOW BOUND{29816
{{IOV{6,SRT17{{{FAIL IF OVERFLOW{29817
{{ILT{6,SRT17{{{FAIL IF BELOW LOW BOUND{29818
{{SBI{13,ARDM2(XL){{{CHECK AGAINST DIMENSION{29819
{{IGE{6,SRT17{{{FAIL IF TOO LARGE{29820
{{ADI{13,ARDM2(XL){{{RESTORE VALUE{29821
{{MFI{8,WA{{{GET AS SMALL INTEGER{29822
{{WTB{8,WA{{{OFFSET WITHIN ROW TO KEY{29823
{{MOV{8,WA{3,SRTOF{{KEEP OFFSET{29824
{{LDI{13,ARDM2(XL){{{SECOND DIMENSION IS ROW LENGTH{29825
{{MFI{8,WA{{{CONVERT TO SHORT INTEGER{29826
{{MOV{8,WA{7,XR{{COPY ROW LENGTH{29827
{{WTB{8,WA{{{CONVERT TO BYTES{29828
{{MOV{8,WA{3,SRTST{{STORE AS STRIDE{29829
{{LDI{13,ARDIM(XL){{{GET NUMBER OF ROWS{29830
{{MFI{8,WA{{{AS A SHORT INTEGER{29831
{{WTB{8,WA{{{CONVERT N TO BAUS{29832
{{MOV{13,ARLEN(XL){8,WC{{OFFSET PAST ARRAY END{29833
{{SUB{8,WA{8,WC{{ADJUST, GIVING SPACE FOR N OFFSETS{29834
{{DCA{8,WC{{{POINT TO A(0){29835
{{MOV{13,AROFS(XL){8,WB{{OFFSET TO WORD BEFORE FIRST ITEM{29836
{{ICA{8,WB{{{OFFSET TO FIRST ITEM{29837
*
*      SEPARATE PRE-PROCESSING FOR ARRAYS AND VECTORS DONE.
*      TO SIMPLIFY LATER KEY COMPARISONS, REMOVAL OF ANY TRBLK
*      TRAP BLOCKS FROM ENTRIES IN KEY ARRAY IS EFFECTED.
*
*      (XL) = 1(XS) = POINTER TO KEY ARRAY
*      (XS) = POINTER TO SORT ARRAY
*      WA = NUMBER OF ITEMS, N (CONVERTED TO BYTES).
*      WB = OFFSET TO FIRST ITEM OF ARRAYS.
*      WC = OFFSET TO A(0)
*
{SRT04{BLE{8,WA{19,*NUM01{6,SRT15{RETURN IF ONLY A SINGLE ITEM{29849
{{MOV{8,WA{3,SRTSN{{STORE NUMBER OF ITEMS (IN BAUS){29850
{{MOV{8,WC{3,SRTSO{{STORE OFFSET TO A(0){29851
{{MOV{13,ARLEN(XL){8,WC{{LENGTH OF ARRAY OR VEC (=VCLEN){29852
{{ADD{7,XL{8,WC{{POINT PAST END OF ARRAY OR VECTOR{29853
{{MOV{8,WB{3,SRTSF{{STORE OFFSET TO FIRST ROW{29854
{{ADD{8,WB{7,XL{{POINT TO FIRST ITEM IN KEY ARRAY{29855
*
*      LOOP THROUGH ARRAY
*
{SRT05{MOV{9,(XL){7,XR{{GET AN ENTRY{29859
*
*      HUNT ALONG TRBLK CHAIN
*
{SRT06{BNE{9,(XR){22,=B$TRT{6,SRT07{JUMP OUT IF NOT TRBLK{29863
{{MOV{13,TRVAL(XR){7,XR{{GET VALUE FIELD{29864
{{BRN{6,SRT06{{{LOOP{29865
{{EJC{{{{{29866
*
*      SORTA (CONTINUED)
*
*      XR IS VALUE FROM END OF CHAIN
*
{SRT07{MOV{7,XR{10,(XL)+{{STORE AS ARRAY ENTRY{29872
{{BLT{7,XL{8,WC{6,SRT05{LOOP IF NOT DONE{29873
{{MOV{9,(XS){7,XL{{GET ADRS OF SORT ARRAY{29874
{{MOV{3,SRTSF{7,XR{{INITIAL OFFSET TO FIRST KEY{29875
{{MOV{3,SRTST{8,WB{{GET STRIDE{29876
{{ADD{3,SRTSO{7,XL{{OFFSET TO A(0){29877
{{ICA{7,XL{{{POINT TO A(1){29878
{{MOV{3,SRTSN{8,WC{{GET N{29879
{{BTW{8,WC{{{CONVERT FROM BYTES{29880
{{MOV{8,WC{3,SRTNR{{STORE AS ROW COUNT{29881
{{LCT{8,WC{8,WC{{LOOP COUNTER{29882
*
*      STORE KEY OFFSETS AT TOP OF SORT ARRAY
*
{SRT08{MOV{7,XR{10,(XL)+{{STORE AN OFFSET{29886
{{ADD{8,WB{7,XR{{BUMP OFFSET BY STRIDE{29887
{{BCT{8,WC{6,SRT08{{LOOP THROUGH ROWS{29888
*
*      PERFORM THE SORT ON OFFSETS IN SORT ARRAY.
*
*      (SRTSN)               NUMBER OF ITEMS TO SORT, N (BYTES)
*      (SRTSO)               OFFSET TO A(0)
*
{SRT09{MOV{3,SRTSN{8,WA{{GET N{29895
{{MOV{3,SRTNR{8,WC{{GET NUMBER OF ROWS{29896
{{RSH{8,WC{1,1{{I = N / 2 (WC=I, INDEX INTO ARRAY){29897
{{WTB{8,WC{{{CONVERT BACK TO BYTES{29898
*
*      LOOP TO FORM INITIAL HEAP
*
{SRT10{JSR{6,SORTH{{{SORTH(I,N){29902
{{DCA{8,WC{{{I = I - 1{29903
{{BNZ{8,WC{6,SRT10{{LOOP IF I GT 0{29904
{{MOV{8,WA{8,WC{{I = N{29905
*
*      SORTING LOOP. AT THIS POINT, A(1) IS THE LARGEST
*      ITEM, SINCE ALGORITHM INITIALISES IT AS, AND THEN MAINTAI
*      IT AS, ROOT OF TREE.
*
{SRT11{DCA{8,WC{{{I = I - 1 (N - 1 INITIALLY){29911
{{BZE{8,WC{6,SRT12{{JUMP IF DONE{29912
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADDRESS{29913
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){29914
{{MOV{7,XR{7,XL{{A(0) ADDRESS{29915
{{ADD{8,WC{7,XL{{A(I) ADDRESS{29916
{{MOV{12,1(XL){8,WB{{COPY A(I+1){29917
{{MOV{12,1(XR){12,1(XL){{MOVE A(1) TO A(I+1){29918
{{MOV{8,WB{12,1(XR){{COMPLETE EXCHANGE OF A(1), A(I+1){29919
{{MOV{8,WC{8,WA{{N = I FOR SORTH{29920
{{MOV{19,*NUM01{8,WC{{I = 1 FOR SORTH{29921
{{JSR{6,SORTH{{{SORTH(1,N){29922
{{MOV{8,WA{8,WC{{RESTORE WC{29923
{{BRN{6,SRT11{{{LOOP{29924
{{EJC{{{{{29925
*
*      SORTA (CONTINUED)
*
*      OFFSETS HAVE BEEN PERMUTED INTO REQUIRED ORDER BY SORT.
*      COPY ARRAY ELEMENTS OVER THEM.
*
{SRT12{MOV{9,(XS){7,XR{{BASE ADRS OF KEY ARRAY{29932
{{MOV{7,XR{8,WC{{COPY IT{29933
{{ADD{3,SRTSO{8,WC{{OFFSET OF A(0){29934
{{ADD{3,SRTSF{7,XR{{ADRS OF FIRST ROW OF SORT ARRAY{29935
{{MOV{3,SRTST{8,WB{{GET STRIDE{29936
*
*      COPYING LOOP FOR SUCCESSIVE ITEMS. SORTED OFFSETS ARE
*      HELD AT END OF SORT ARRAY.
*
{SRT13{ICA{8,WC{{{ADRS OF NEXT OF SORTED OFFSETS{29941
{{MOV{8,WC{7,XL{{COPY IT FOR ACCESS{29942
{{MOV{9,(XL){7,XL{{GET OFFSET{29943
{{ADD{12,1(XS){7,XL{{ADD KEY ARRAY BASE ADRS{29944
{{MOV{8,WB{8,WA{{GET COUNT OF CHARACTERS IN ROW{29945
{{MVW{{{{COPY A COMPLETE ROW{29946
{{DCV{3,SRTNR{{{DECREMENT ROW COUNT{29947
{{BNZ{3,SRTNR{6,SRT13{{REPEAT TILL ALL ROWS DONE{29948
*
*      RETURN POINT
*
{SRT15{MOV{10,(XS)+{7,XR{{POP RESULT ARRAY PTR{29952
{{ICA{7,XS{{{POP KEY ARRAY PTR{29953
{{ZER{3,R$SXL{{{CLEAR JUNK{29954
{{ZER{3,R$SXR{{{CLEAR JUNK{29955
{{EXI{{{{RETURN{29956
*
*      ERROR POINT
*
{SRT16{ERB{1,256{26,SORT/RSORT 1st arg not suitable ARRAY or TABLE{{{29960
{SRT17{ERB{1,258{26,SORT/RSORT 2nd arg out of range or non-integer{{{29961
*
*      RETURN POINT IF INPUT TABLE IS EMPTY
*
{SRT18{EXI{1,1{{{RETURN INDICATION OF NULL TABLE{29965
{{ENP{{{{END PROCUDURE SORTA{29966
{{EJC{{{{{29967
*
*      SORTC --  COMPARE SORT KEYS
*
*      COMPARE TWO SORT KEYS GIVEN THEIR OFFSETS. IF
*      EQUAL, COMPARE KEY OFFSETS TO GIVE STABLE SORT.
*      NOTE THAT IF SRTSR IS NON-ZERO (REQUEST FOR REVERSE
*      SORT), THE QUOTED RETURNS ARE INVERTED.
*      FOR OBJECTS OF DIFFERING DATATYPES, THE ENTRY POINT
*      IDENTIFICATIONS ARE COMPARED.
*
*      (XL)                  BASE ADRS FOR KEYS
*      (WA)                  OFFSET TO KEY 1 ITEM
*      (WB)                  OFFSET TO KEY 2 ITEM
*      (SRTSR)               ZERO/NON-ZERO FOR SORT/RSORT
*      (SRTOF)               OFFSET WITHIN ROW TO COMPARANDS
*      JSR  SORTC            CALL TO COMPARE KEYS
*      PPM  LOC              KEY1 LESS THAN KEY2
*                            NORMAL RETURN, KEY1 GT THAN KEY2
*      (XL,XR,WA,WB)         DESTROYED
*
{SORTC{PRC{25,E{1,1{{ENTRY POINT{29988
{{MOV{8,WA{3,SRTS1{{SAVE OFFSET 1{29989
{{MOV{8,WB{3,SRTS2{{SAVE OFFSET 2{29990
{{MOV{8,WC{3,SRTSC{{SAVE WC{29991
{{ADD{3,SRTOF{7,XL{{ADD OFFSET TO COMPARAND FIELD{29992
{{MOV{7,XL{7,XR{{COPY BASE + OFFSET{29993
{{ADD{8,WA{7,XL{{ADD KEY1 OFFSET{29994
{{ADD{8,WB{7,XR{{ADD KEY2 OFFSET{29995
{{MOV{9,(XL){7,XL{{GET KEY1{29996
{{MOV{9,(XR){7,XR{{GET KEY2{29997
{{BNE{3,SRTDF{21,=NULLS{6,SRC12{JUMP IF DATATYPE FIELD NAME USED{29998
{{EJC{{{{{29999
*
*      SORTC (CONTINUED)
*
*      MERGE AFTER DEALING WITH FIELD NAME. TRY FOR STRINGS.
*
{SRC01{MOV{9,(XL){8,WC{{GET TYPE CODE{30005
{{BNE{8,WC{9,(XR){6,SRC02{SKIP IF NOT SAME DATATYPE{30006
{{BEQ{8,WC{22,=B$SCL{6,SRC09{JUMP IF BOTH STRINGS{30007
{{BEQ{8,WC{22,=B$ICL{6,SRC14{JUMP IF BOTH INTEGERS{30008
*
*      DATATYPES DIFFERENT.  NOW TRY FOR NUMERIC
*
{SRC02{MOV{7,XL{3,R$SXL{{KEEP ARG1{30016
{{MOV{7,XR{3,R$SXR{{KEEP ARG2{30017
{{BEQ{8,WC{22,=B$SCL{6,SRC11{DO NOT ALLOW CONVERSION TO NUMBER{30020
{{BEQ{9,(XR){22,=B$SCL{6,SRC11{IF EITHER ARG IS A STRING{30021
{SRC14{MOV{7,XL{11,-(XS){{STACK{30064
{{MOV{7,XR{11,-(XS){{ARGS{30065
{{JSR{6,ACOMP{{{COMPARE OBJECTS{30066
{{PPM{6,SRC10{{{NOT NUMERIC{30067
{{PPM{6,SRC10{{{NOT NUMERIC{30068
{{PPM{6,SRC03{{{KEY1 LESS{30069
{{PPM{6,SRC08{{{KEYS EQUAL{30070
{{PPM{6,SRC05{{{KEY1 GREATER{30071
*
*      RETURN IF KEY1 SMALLER (SORT), GREATER (RSORT)
*
{SRC03{BNZ{3,SRTSR{6,SRC06{{JUMP IF RSORT{30075
*
{SRC04{MOV{3,SRTSC{8,WC{{RESTORE WC{30077
{{EXI{1,1{{{RETURN{30078
*
*      RETURN IF KEY1 GREATER (SORT), SMALLER (RSORT)
*
{SRC05{BNZ{3,SRTSR{6,SRC04{{JUMP IF RSORT{30082
*
{SRC06{MOV{3,SRTSC{8,WC{{RESTORE WC{30084
{{EXI{{{{RETURN{30085
*
*      KEYS ARE OF SAME DATATYPE
*
{SRC07{BLT{7,XL{7,XR{6,SRC03{ITEM FIRST CREATED IS LESS{30089
{{BGT{7,XL{7,XR{6,SRC05{ADDRESSES RISE IN ORDER OF CREATION{30090
*
*      DROP THROUGH OR MERGE FOR IDENTICAL OR EQUAL OBJECTS
*
{SRC08{BLT{3,SRTS1{3,SRTS2{6,SRC04{TEST OFFSETS OR KEY ADDRSS INSTEAD{30094
{{BRN{6,SRC06{{{OFFSET 1 GREATER{30095
{{EJC{{{{{30096
*
*      SORTC (CONTINUED)
*
*      STRINGS
*
{SRC09{MOV{7,XL{11,-(XS){{STACK{30106
{{MOV{7,XR{11,-(XS){{ARGS{30107
{{JSR{6,LCOMP{{{COMPARE OBJECTS{30108
{{PPM{{{{CANT{30109
{{PPM{{{{FAIL{30110
{{PPM{6,SRC03{{{KEY1 LESS{30111
{{PPM{6,SRC08{{{KEYS EQUAL{30112
{{PPM{6,SRC05{{{KEY1 GREATER{30113
*
*      ARITHMETIC COMPARISON FAILED - RECOVER ARGS
*
{SRC10{MOV{3,R$SXL{7,XL{{GET ARG1{30117
{{MOV{3,R$SXR{7,XR{{GET ARG2{30118
{{MOV{9,(XL){8,WC{{GET TYPE OF KEY1{30119
{{BEQ{8,WC{9,(XR){6,SRC07{JUMP IF KEYS OF SAME TYPE{30120
*
*      HERE TO COMPARE DATATYPE IDS
*
{SRC11{MOV{8,WC{7,XL{{GET BLOCK TYPE WORD{30124
{{MOV{9,(XR){7,XR{{GET BLOCK TYPE WORD{30125
{{LEI{7,XL{{{ENTRY POINT ID FOR KEY1{30126
{{LEI{7,XR{{{ENTRY POINT ID FOR KEY2{30127
{{BGT{7,XL{7,XR{6,SRC05{JUMP IF KEY1 GT KEY2{30128
{{BRN{6,SRC03{{{KEY1 LT KEY2{30129
*
*      DATATYPE FIELD NAME USED
*
{SRC12{JSR{6,SORTF{{{CALL ROUTINE TO FIND FIELD 1{30133
{{MOV{7,XL{11,-(XS){{STACK ITEM POINTER{30134
{{MOV{7,XR{7,XL{{GET KEY2{30135
{{JSR{6,SORTF{{{FIND FIELD 2{30136
{{MOV{7,XL{7,XR{{PLACE AS KEY2{30137
{{MOV{10,(XS)+{7,XL{{RECOVER KEY1{30138
{{BRN{6,SRC01{{{MERGE{30139
{{ENP{{{{PROCEDURE SORTC{30140
{{EJC{{{{{30141
*
*      SORTF -- FIND FIELD FOR SORTC
*
*      ROUTINE USED BY SORTC TO OBTAIN ITEM CORRESPONDING
*      TO A GIVEN FIELD NAME, IF THIS EXISTS, IN A PROGRAMMER
*      DEFINED OBJECT PASSED AS ARGUMENT.
*      IF SUCH A MATCH OCCURS, RECORD IS KEPT OF DATATYPE
*      NAME, FIELD NAME AND OFFSET TO FIELD IN ORDER TO
*      SHORT-CIRCUIT LATER SEARCHES ON SAME TYPE. NOTE THAT
*      DFBLKS ARE STORED IN STATIC AND HENCE CANNOT BE MOVED.
*
*      (SRTDF)               VRBLK POINTER OF FIELD NAME
*      (XL)                  POSSIBLE PDBLK POINTER
*      JSR  SORTF            CALL TO SEARCH FOR FIELD NAME
*      (XL)                  ITEM FOUND OR ORIGINAL PDBLK PTR
*      (WC)                  DESTROYED
*
{SORTF{PRC{25,E{1,0{{ENTRY POINT{30159
{{BNE{9,(XL){22,=B$PDT{6,SRTF3{RETURN IF NOT PDBLK{30160
{{MOV{7,XR{11,-(XS){{KEEP XR{30161
{{MOV{3,SRTFD{7,XR{{GET POSSIBLE FORMER DFBLK PTR{30162
{{BZE{7,XR{6,SRTF4{{JUMP IF NOT{30163
{{BNE{7,XR{13,PDDFP(XL){6,SRTF4{JUMP IF NOT RIGHT DATATYPE{30164
{{BNE{3,SRTDF{3,SRTFF{6,SRTF4{JUMP IF NOT RIGHT FIELD NAME{30165
{{ADD{3,SRTFO{7,XL{{ADD OFFSET TO REQUIRED FIELD{30166
*
*      HERE WITH XL POINTING TO FOUND FIELD
*
{SRTF1{MOV{9,(XL){7,XL{{GET ITEM FROM FIELD{30170
*
*      RETURN POINT
*
{SRTF2{MOV{10,(XS)+{7,XR{{RESTORE XR{30174
*
{SRTF3{EXI{{{{RETURN{30176
{{EJC{{{{{30177
*
*      SORTF (CONTINUED)
*
*      CONDUCT A SEARCH
*
{SRTF4{MOV{7,XL{7,XR{{COPY ORIGINAL POINTER{30183
{{MOV{13,PDDFP(XR){7,XR{{POINT TO DFBLK{30184
{{MOV{7,XR{3,SRTFD{{KEEP A COPY{30185
{{MOV{13,FARGS(XR){8,WC{{GET NUMBER OF FIELDS{30186
{{WTB{8,WC{{{CONVERT TO BYTES{30187
{{ADD{13,DFLEN(XR){7,XR{{POINT PAST LAST FIELD{30188
*
*      LOOP TO FIND NAME IN PDFBLK
*
{SRTF5{DCA{8,WC{{{COUNT DOWN{30192
{{DCA{7,XR{{{POINT IN FRONT{30193
{{BEQ{9,(XR){3,SRTDF{6,SRTF6{SKIP OUT IF FOUND{30194
{{BNZ{8,WC{6,SRTF5{{LOOP{30195
{{BRN{6,SRTF2{{{RETURN - NOT FOUND{30196
*
*      FOUND
*
{SRTF6{MOV{9,(XR){3,SRTFF{{KEEP FIELD NAME PTR{30200
{{ADD{19,*PDFLD{8,WC{{ADD OFFSET TO FIRST FIELD{30201
{{MOV{8,WC{3,SRTFO{{STORE AS FIELD OFFSET{30202
{{ADD{8,WC{7,XL{{POINT TO FIELD{30203
{{BRN{6,SRTF1{{{RETURN{30204
{{ENP{{{{PROCEDURE SORTF{30205
{{EJC{{{{{30206
*
*      SORTH -- HEAP ROUTINE FOR SORTA
*
*      THIS ROUTINE CONSTRUCTS A HEAP FROM ELEMENTS OF ARRAY, A.
*      IN THIS APPLICATION, THE ELEMENTS ARE OFFSETS TO KEYS IN
*      A KEY ARRAY.
*
*      (XS)                  POINTER TO SORT ARRAY BASE
*      1(XS)                 POINTER TO KEY ARRAY BASE
*      (WA)                  MAX ARRAY INDEX, N (IN BYTES)
*      (WC)                  OFFSET J IN A TO ROOT (IN *1 TO *N)
*      JSR  SORTH            CALL SORTH(J,N) TO MAKE HEAP
*      (XL,XR,WB)            DESTROYED
*
{SORTH{PRC{25,N{1,0{{ENTRY POINT{30221
{{MOV{8,WA{3,SRTSN{{SAVE N{30222
{{MOV{8,WC{3,SRTWC{{KEEP WC{30223
{{MOV{9,(XS){7,XL{{SORT ARRAY BASE ADRS{30224
{{ADD{3,SRTSO{7,XL{{ADD OFFSET TO A(0){30225
{{ADD{8,WC{7,XL{{POINT TO A(J){30226
{{MOV{9,(XL){3,SRTRT{{GET OFFSET TO ROOT{30227
{{ADD{8,WC{8,WC{{DOUBLE J - CANT EXCEED N{30228
*
*      LOOP TO MOVE DOWN TREE USING DOUBLED INDEX J
*
{SRH01{BGT{8,WC{3,SRTSN{6,SRH03{DONE IF J GT N{30232
{{BEQ{8,WC{3,SRTSN{6,SRH02{SKIP IF J EQUALS N{30233
{{MOV{9,(XS){7,XR{{SORT ARRAY BASE ADRS{30234
{{MOV{12,1(XS){7,XL{{KEY ARRAY BASE ADRS{30235
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){30236
{{ADD{8,WC{7,XR{{ADRS OF A(J){30237
{{MOV{12,1(XR){8,WA{{GET A(J+1){30238
{{MOV{9,(XR){8,WB{{GET A(J){30239
*
*      COMPARE SONS. (WA) RIGHT SON, (WB) LEFT SON
*
{{JSR{6,SORTC{{{COMPARE KEYS - LT(A(J+1),A(J)){30243
{{PPM{6,SRH02{{{A(J+1) LT A(J){30244
{{ICA{8,WC{{{POINT TO GREATER SON, A(J+1){30245
{{EJC{{{{{30246
*
*      SORTH (CONTINUED)
*
*      COMPARE ROOT WITH GREATER SON
*
{SRH02{MOV{12,1(XS){7,XL{{KEY ARRAY BASE ADRS{30252
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADDRESS{30253
{{ADD{3,SRTSO{7,XR{{ADRS OF A(0){30254
{{MOV{7,XR{8,WB{{COPY THIS ADRS{30255
{{ADD{8,WC{7,XR{{ADRS OF GREATER SON, A(J){30256
{{MOV{9,(XR){8,WA{{GET A(J){30257
{{MOV{8,WB{7,XR{{POINT BACK TO A(0){30258
{{MOV{3,SRTRT{8,WB{{GET ROOT{30259
{{JSR{6,SORTC{{{COMPARE THEM - LT(A(J),ROOT){30260
{{PPM{6,SRH03{{{FATHER EXCEEDS SONS - DONE{30261
{{MOV{9,(XS){7,XR{{GET SORT ARRAY ADRS{30262
{{ADD{3,SRTSO{7,XR{{POINT TO A(0){30263
{{MOV{7,XR{7,XL{{COPY IT{30264
{{MOV{8,WC{8,WA{{COPY J{30265
{{BTW{8,WC{{{CONVERT TO WORDS{30266
{{RSH{8,WC{1,1{{GET J/2{30267
{{WTB{8,WC{{{CONVERT BACK TO BYTES{30268
{{ADD{8,WA{7,XL{{POINT TO A(J){30269
{{ADD{8,WC{7,XR{{ADRS OF A(J/2){30270
{{MOV{9,(XL){9,(XR){{A(J/2) = A(J){30271
{{MOV{8,WA{8,WC{{RECOVER J{30272
{{AOV{8,WC{8,WC{6,SRH03{J = J*2. DONE IF TOO BIG{30273
{{BRN{6,SRH01{{{LOOP{30274
*
*      FINISH BY COPYING ROOT OFFSET BACK INTO ARRAY
*
{SRH03{BTW{8,WC{{{CONVERT TO WORDS{30278
{{RSH{8,WC{1,1{{J = J/2{30279
{{WTB{8,WC{{{CONVERT BACK TO BYTES{30280
{{MOV{9,(XS){7,XR{{SORT ARRAY ADRS{30281
{{ADD{3,SRTSO{7,XR{{ADRS OF A(0){30282
{{ADD{8,WC{7,XR{{ADRS OF A(J/2){30283
{{MOV{3,SRTRT{9,(XR){{A(J/2) = ROOT{30284
{{MOV{3,SRTSN{8,WA{{RESTORE WA{30285
{{MOV{3,SRTWC{8,WC{{RESTORE WC{30286
{{EXI{{{{RETURN{30287
{{ENP{{{{END PROCEDURE SORTH{30288
{{EJC{{{{{30290
*
*      TRACE -- SET/RESET A TRACE ASSOCIATION
*
*      THIS PROCEDURE IS SHARED BY TRACE AND STOPTR TO
*      EITHER INITIATE OR STOP A TRACE RESPECTIVELY.
*
*      (XL)                  TRBLK PTR (TRACE) OR ZERO (STOPTR)
*      1(XS)                 FIRST ARGUMENT (NAME)
*      0(XS)                 SECOND ARGUMENT (TRACE TYPE)
*      JSR  TRACE            CALL TO SET/RESET TRACE
*      PPM  LOC              TRANSFER LOC IF 1ST ARG IS BAD NAME
*      PPM  LOC              TRANSFER LOC IF 2ND ARG IS BAD TYPE
*      (XS)                  POPPED
*      (XL,XR,WA,WB,WC,IA)   DESTROYED
*
{TRACE{PRC{25,N{1,2{{ENTRY POINT{30306
{{JSR{6,GTSTG{{{GET TRACE TYPE STRING{30307
{{PPM{6,TRC15{{{JUMP IF NOT STRING{30308
{{PLC{7,XR{{{ELSE POINT TO STRING{30309
{{LCH{8,WA{9,(XR){{LOAD FIRST CHARACTER{30310
{{FLC{8,WA{{{FOLD TO UPPER CASE{30312
{{MOV{9,(XS){7,XR{{LOAD NAME ARGUMENT{30314
{{MOV{7,XL{9,(XS){{STACK TRBLK PTR OR ZERO{30315
{{MOV{18,=TRTAC{8,WC{{SET TRTYP FOR ACCESS TRACE{30316
{{BEQ{8,WA{18,=CH$LA{6,TRC10{JUMP IF A (ACCESS){30317
{{MOV{18,=TRTVL{8,WC{{SET TRTYP FOR VALUE TRACE{30318
{{BEQ{8,WA{18,=CH$LV{6,TRC10{JUMP IF V (VALUE){30319
{{BEQ{8,WA{18,=CH$BL{6,TRC10{JUMP IF BLANK (VALUE){30320
*
*      HERE FOR L,K,F,C,R
*
{{BEQ{8,WA{18,=CH$LF{6,TRC01{JUMP IF F (FUNCTION){30324
{{BEQ{8,WA{18,=CH$LR{6,TRC01{JUMP IF R (RETURN){30325
{{BEQ{8,WA{18,=CH$LL{6,TRC03{JUMP IF L (LABEL){30326
{{BEQ{8,WA{18,=CH$LK{6,TRC06{JUMP IF K (KEYWORD){30327
{{BNE{8,WA{18,=CH$LC{6,TRC15{ELSE ERROR IF NOT C (CALL){30328
*
*      HERE FOR F,C,R
*
{TRC01{JSR{6,GTNVR{{{POINT TO VRBLK FOR NAME{30332
{{PPM{6,TRC16{{{JUMP IF BAD NAME{30333
{{ICA{7,XS{{{POP STACK{30334
{{MOV{13,VRFNC(XR){7,XR{{POINT TO FUNCTION BLOCK{30335
{{BNE{9,(XR){22,=B$PFC{6,TRC17{ERROR IF NOT PROGRAM FUNCTION{30336
{{BEQ{8,WA{18,=CH$LR{6,TRC02{JUMP IF R (RETURN){30337
{{EJC{{{{{30338
*
*      TRACE (CONTINUED)
*
*      HERE FOR F,C TO SET/RESET CALL TRACE
*
{{MOV{7,XL{13,PFCTR(XR){{SET/RESET CALL TRACE{30344
{{BEQ{8,WA{18,=CH$LC{6,EXNUL{EXIT WITH NULL IF C (CALL){30345
*
*      HERE FOR F,R TO SET/RESET RETURN TRACE
*
{TRC02{MOV{7,XL{13,PFRTR(XR){{SET/RESET RETURN TRACE{30349
{{EXI{{{{RETURN{30350
*
*      HERE FOR L TO SET/RESET LABEL TRACE
*
{TRC03{JSR{6,GTNVR{{{POINT TO VRBLK{30354
{{PPM{6,TRC16{{{JUMP IF BAD NAME{30355
{{MOV{13,VRLBL(XR){7,XL{{LOAD LABEL POINTER{30356
{{BNE{9,(XL){22,=B$TRT{6,TRC04{JUMP IF NO OLD TRACE{30357
{{MOV{13,TRLBL(XL){7,XL{{ELSE DELETE OLD TRACE ASSOCIATION{30358
*
*      HERE WITH OLD LABEL TRACE ASSOCIATION DELETED
*
{TRC04{BEQ{7,XL{21,=STNDL{6,TRC16{ERROR IF UNDEFINED LABEL{30362
{{MOV{10,(XS)+{8,WB{{GET TRBLK PTR AGAIN{30363
{{BZE{8,WB{6,TRC05{{JUMP IF STOPTR CASE{30364
{{MOV{8,WB{13,VRLBL(XR){{ELSE SET NEW TRBLK POINTER{30365
{{MOV{22,=B$VRT{13,VRTRA(XR){{SET LABEL TRACE ROUTINE ADDRESS{30366
{{MOV{8,WB{7,XR{{COPY TRBLK POINTER{30367
{{MOV{7,XL{13,TRLBL(XR){{STORE REAL LABEL IN TRBLK{30368
{{EXI{{{{RETURN{30369
*
*      HERE FOR STOPTR CASE FOR LABEL
*
{TRC05{MOV{7,XL{13,VRLBL(XR){{STORE LABEL PTR BACK IN VRBLK{30373
{{MOV{22,=B$VRG{13,VRTRA(XR){{STORE NORMAL TRANSFER ADDRESS{30374
{{EXI{{{{RETURN{30375
{{EJC{{{{{30376
*
*      TRACE (CONTINUED)
*
*      HERE FOR K (KEYWORD)
*
{TRC06{JSR{6,GTNVR{{{POINT TO VRBLK{30382
{{PPM{6,TRC16{{{ERROR IF NOT NATURAL VAR{30383
{{BNZ{13,VRLEN(XR){6,TRC16{{ERROR IF NOT SYSTEM VAR{30384
{{ICA{7,XS{{{POP STACK{30385
{{BZE{7,XL{6,TRC07{{JUMP IF STOPTR CASE{30386
{{MOV{7,XR{13,TRKVR(XL){{STORE VRBLK PTR IN TRBLK FOR KTREX{30387
*
*      MERGE HERE WITH TRBLK SET UP IN WB (OR ZERO)
*
{TRC07{MOV{13,VRSVP(XR){7,XR{{POINT TO SVBLK{30391
{{BEQ{7,XR{21,=V$ERT{6,TRC08{JUMP IF ERRTYPE{30392
{{BEQ{7,XR{21,=V$STC{6,TRC09{JUMP IF STCOUNT{30393
{{BNE{7,XR{21,=V$FNC{6,TRC17{ELSE ERROR IF NOT FNCLEVEL{30394
*
*      FNCLEVEL
*
{{MOV{7,XL{3,R$FNC{{SET/RESET FNCLEVEL TRACE{30398
{{EXI{{{{RETURN{30399
*
*      ERRTYPE
*
{TRC08{MOV{7,XL{3,R$ERT{{SET/RESET ERRTYPE TRACE{30403
{{EXI{{{{RETURN{30404
*
*      STCOUNT
*
{TRC09{MOV{7,XL{3,R$STC{{SET/RESET STCOUNT TRACE{30408
{{JSR{6,STGCC{{{UPDATE COUNTDOWN COUNTERS{30409
{{EXI{{{{RETURN{30410
{{EJC{{{{{30411
*
*      TRACE (CONTINUED)
*
*      A,V MERGE HERE WITH TRTYP VALUE IN WC
*
{TRC10{JSR{6,GTVAR{{{LOCATE VARIABLE{30417
{{PPM{6,TRC16{{{ERROR IF NOT APPROPRIATE NAME{30418
{{MOV{10,(XS)+{8,WB{{GET NEW TRBLK PTR AGAIN{30419
{{ADD{7,XL{8,WA{{POINT TO VARIABLE LOCATION{30420
{{MOV{8,WA{7,XR{{COPY VARIABLE POINTER{30421
*
*      LOOP TO SEARCH TRBLK CHAIN
*
{TRC11{MOV{9,(XR){7,XL{{POINT TO NEXT ENTRY{30425
{{BNE{9,(XL){22,=B$TRT{6,TRC13{JUMP IF NOT TRBLK{30426
{{BLT{8,WC{13,TRTYP(XL){6,TRC13{JUMP IF TOO FAR OUT ON CHAIN{30427
{{BEQ{8,WC{13,TRTYP(XL){6,TRC12{JUMP IF THIS MATCHES OUR TYPE{30428
{{ADD{19,*TRNXT{7,XL{{ELSE POINT TO LINK FIELD{30429
{{MOV{7,XL{7,XR{{COPY POINTER{30430
{{BRN{6,TRC11{{{AND LOOP BACK{30431
*
*      HERE TO DELETE AN OLD TRBLK OF THE TYPE WE WERE GIVEN
*
{TRC12{MOV{13,TRNXT(XL){7,XL{{GET PTR TO NEXT BLOCK OR VALUE{30435
{{MOV{7,XL{9,(XR){{STORE TO DELETE THIS TRBLK{30436
*
*      HERE AFTER DELETING ANY OLD ASSOCIATION OF THIS TYPE
*
{TRC13{BZE{8,WB{6,TRC14{{JUMP IF STOPTR CASE{30440
{{MOV{8,WB{9,(XR){{ELSE LINK NEW TRBLK IN{30441
{{MOV{8,WB{7,XR{{COPY TRBLK POINTER{30442
{{MOV{7,XL{13,TRNXT(XR){{STORE FORWARD POINTER{30443
{{MOV{8,WC{13,TRTYP(XR){{STORE APPROPRIATE TRAP TYPE CODE{30444
*
*      HERE TO MAKE SURE VRGET,VRSTO ARE SET PROPERLY
*
{TRC14{MOV{8,WA{7,XR{{RECALL POSSIBLE VRBLK POINTER{30448
{{SUB{19,*VRVAL{7,XR{{POINT BACK TO VRBLK{30449
{{JSR{6,SETVR{{{SET FIELDS IF VRBLK{30450
{{EXI{{{{RETURN{30451
*
*      HERE FOR BAD TRACE TYPE
*
{TRC15{EXI{1,2{{{TAKE BAD TRACE TYPE ERROR EXIT{30455
*
*      POP STACK BEFORE FAILING
*
{TRC16{ICA{7,XS{{{POP STACK{30459
*
*      HERE FOR BAD NAME ARGUMENT
*
{TRC17{EXI{1,1{{{TAKE BAD NAME ERROR EXIT{30463
{{ENP{{{{END PROCEDURE TRACE{30464
{{EJC{{{{{30465
*
*      TRBLD -- BUILD TRBLK
*
*      TRBLK IS USED BY THE INPUT, OUTPUT AND TRACE FUNCTIONS
*      TO CONSTRUCT A TRBLK (TRAP BLOCK)
*
*      (XR)                  TRTAG OR TRTER
*      (XL)                  TRFNC OR TRFPT
*      (WB)                  TRTYP
*      JSR  TRBLD            CALL TO BUILD TRBLK
*      (XR)                  POINTER TO TRBLK
*      (WA)                  DESTROYED
*
{TRBLD{PRC{25,E{1,0{{ENTRY POINT{30479
{{MOV{7,XR{11,-(XS){{STACK TRTAG (OR TRFNM){30480
{{MOV{19,*TRSI${8,WA{{SET SIZE OF TRBLK{30481
{{JSR{6,ALLOC{{{ALLOCATE TRBLK{30482
{{MOV{22,=B$TRT{9,(XR){{STORE FIRST WORD{30483
{{MOV{7,XL{13,TRFNC(XR){{STORE TRFNC (OR TRFPT){30484
{{MOV{10,(XS)+{13,TRTAG(XR){{STORE TRTAG (OR TRFNM){30485
{{MOV{8,WB{13,TRTYP(XR){{STORE TYPE{30486
{{MOV{21,=NULLS{13,TRVAL(XR){{FOR NOW, A NULL VALUE{30487
{{EXI{{{{RETURN TO CALLER{30488
{{ENP{{{{END PROCEDURE TRBLD{30489
{{EJC{{{{{30490
*
*      TRIMR -- TRIM TRAILING BLANKS
*
*      TRIMR IS PASSED A POINTER TO AN SCBLK WHICH MUST BE THE
*      LAST BLOCK IN DYNAMIC STORAGE. TRAILING BLANKS ARE
*      TRIMMED OFF AND THE DYNAMIC STORAGE POINTER RESET TO
*      THE END OF THE (POSSIBLY) SHORTENED BLOCK.
*
*      (WB)                  NON-ZERO TO TRIM TRAILING BLANKS
*      (XR)                  POINTER TO STRING TO TRIM
*      JSR  TRIMR            CALL TO TRIM STRING
*      (XR)                  POINTER TO TRIMMED STRING
*      (XL,WA,WB,WC)         DESTROYED
*
*      THE CALL WITH WB ZERO STILL PERFORMS THE END ZERO PAD
*      AND DNAMP READJUSTMENT. IT IS USED FROM ACESS IF KVTRM=0.
*
{TRIMR{PRC{25,E{1,0{{ENTRY POINT{30508
{{MOV{7,XR{7,XL{{COPY STRING POINTER{30509
{{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{30510
{{BZE{8,WA{6,TRIM2{{JUMP IF NULL INPUT{30511
{{PLC{7,XL{8,WA{{ELSE POINT PAST LAST CHARACTER{30512
{{BZE{8,WB{6,TRIM3{{JUMP IF NO TRIM{30513
{{MOV{18,=CH$BL{8,WC{{LOAD BLANK CHARACTER{30514
*
*      LOOP THROUGH CHARACTERS FROM RIGHT TO LEFT
*
{TRIM0{LCH{8,WB{11,-(XL){{LOAD NEXT CHARACTER{30518
{{BEQ{8,WB{18,=CH$HT{6,TRIM1{JUMP IF HORIZONTAL TAB{30520
{{BNE{8,WB{8,WC{6,TRIM3{JUMP IF NON-BLANK FOUND{30522
{TRIM1{DCV{8,WA{{{ELSE DECREMENT CHARACTER COUNT{30523
{{BNZ{8,WA{6,TRIM0{{LOOP BACK IF MORE TO CHECK{30524
*
*      HERE IF RESULT IS NULL (NULL OR ALL-BLANK INPUT)
*
{TRIM2{MOV{7,XR{3,DNAMP{{WIPE OUT INPUT STRING BLOCK{30528
{{MOV{21,=NULLS{7,XR{{LOAD NULL RESULT{30529
{{BRN{6,TRIM5{{{MERGE TO EXIT{30530
{{EJC{{{{{30531
*
*      TRIMR (CONTINUED)
*
*      HERE WITH NON-BLANK FOUND (MERGE FOR NO TRIM)
*
{TRIM3{MOV{8,WA{13,SCLEN(XR){{SET NEW LENGTH{30537
{{MOV{7,XR{7,XL{{COPY STRING POINTER{30538
{{PSC{7,XL{8,WA{{READY FOR STORING BLANKS{30539
{{CTB{8,WA{2,SCHAR{{GET LENGTH OF BLOCK IN BYTES{30540
{{ADD{7,XR{8,WA{{POINT PAST NEW BLOCK{30541
{{MOV{8,WA{3,DNAMP{{SET NEW TOP OF STORAGE POINTER{30542
{{LCT{8,WA{18,=CFP$C{{GET COUNT OF CHARS IN WORD{30543
{{ZER{8,WC{{{SET ZERO CHAR{30544
*
*      LOOP TO ZERO PAD LAST WORD OF CHARACTERS
*
{TRIM4{SCH{8,WC{10,(XL)+{{STORE ZERO CHARACTER{30548
{{BCT{8,WA{6,TRIM4{{LOOP BACK TILL ALL STORED{30549
{{CSC{7,XL{{{COMPLETE STORE CHARACTERS{30550
*
*      COMMON EXIT POINT
*
{TRIM5{ZER{7,XL{{{CLEAR GARBAGE XL POINTER{30554
{{EXI{{{{RETURN TO CALLER{30555
{{ENP{{{{END PROCEDURE TRIMR{30556
{{EJC{{{{{30557
*
*      TRXEQ -- EXECUTE FUNCTION TYPE TRACE
*
*      TRXEQ IS USED TO EXECUTE A TRACE WHEN A FOURTH ARGUMENT
*      HAS BEEN SUPPLIED. TRACE HAS ALREADY BEEN DECREMENTED.
*
*      (XR)                  POINTER TO TRBLK
*      (XL,WA)               NAME BASE,OFFSET FOR VARIABLE
*      JSR  TRXEQ            CALL TO EXECUTE TRACE
*      (WB,WC,RA)            DESTROYED
*
*      THE FOLLOWING STACK ENTRIES ARE MADE BEFORE PASSING
*      CONTROL TO THE TRACE FUNCTION USING THE CFUNC ROUTINE.
*
*                            TRXEQ RETURN POINT WORD(S)
*                            SAVED VALUE OF TRACE KEYWORD
*                            TRBLK POINTER
*                            NAME BASE
*                            NAME OFFSET
*                            SAVED VALUE OF R$COD
*                            SAVED CODE PTR (-R$COD)
*                            SAVED VALUE OF FLPTR
*      FLPTR --------------- ZERO (DUMMY FAIL OFFSET)
*                            NMBLK FOR VARIABLE NAME
*      XS ------------------ TRACE TAG
*
*      R$COD AND THE CODE PTR ARE SET TO DUMMY VALUES WHICH
*      CAUSE CONTROL TO RETURN TO THE TRXEQ PROCEDURE ON SUCCESS
*      OR FAILURE (TRXEQ IGNORES A FAILURE CONDITION).
*
{TRXEQ{PRC{25,R{1,0{{ENTRY POINT (RECURSIVE){30588
{{MOV{3,R$COD{8,WC{{LOAD CODE BLOCK POINTER{30589
{{SCP{8,WB{{{GET CURRENT CODE POINTER{30590
{{SUB{8,WC{8,WB{{MAKE CODE POINTER INTO OFFSET{30591
{{MOV{3,KVTRA{11,-(XS){{STACK TRACE KEYWORD VALUE{30592
{{MOV{7,XR{11,-(XS){{STACK TRBLK POINTER{30593
{{MOV{7,XL{11,-(XS){{STACK NAME BASE{30594
{{MOV{8,WA{11,-(XS){{STACK NAME OFFSET{30595
{{MOV{8,WC{11,-(XS){{STACK CODE BLOCK POINTER{30596
{{MOV{8,WB{11,-(XS){{STACK CODE POINTER OFFSET{30597
{{MOV{3,FLPTR{11,-(XS){{STACK OLD FAILURE POINTER{30598
{{ZER{11,-(XS){{{SET DUMMY FAIL OFFSET{30599
{{MOV{7,XS{3,FLPTR{{SET NEW FAILURE POINTER{30600
{{ZER{3,KVTRA{{{RESET TRACE KEYWORD TO ZERO{30601
{{MOV{21,=TRXDC{8,WC{{LOAD NEW (DUMMY) CODE BLK POINTER{30602
{{MOV{8,WC{3,R$COD{{SET AS CODE BLOCK POINTER{30603
{{LCP{8,WC{{{AND NEW CODE POINTER{30604
{{EJC{{{{{30605
*
*      TRXEQ (CONTINUED)
*
*      NOW PREPARE ARGUMENTS FOR FUNCTION
*
{{MOV{8,WA{8,WB{{SAVE NAME OFFSET{30611
{{MOV{19,*NMSI${8,WA{{LOAD NMBLK SIZE{30612
{{JSR{6,ALLOC{{{ALLOCATE SPACE FOR NMBLK{30613
{{MOV{22,=B$NML{9,(XR){{SET TYPE WORD{30614
{{MOV{7,XL{13,NMBAS(XR){{STORE NAME BASE{30615
{{MOV{8,WB{13,NMOFS(XR){{STORE NAME OFFSET{30616
{{MOV{12,6(XS){7,XL{{RELOAD POINTER TO TRBLK{30617
{{MOV{7,XR{11,-(XS){{STACK NMBLK POINTER (1ST ARGUMENT){30618
{{MOV{13,TRTAG(XL){11,-(XS){{STACK TRACE TAG (2ND ARGUMENT){30619
{{MOV{13,TRFNC(XL){7,XL{{LOAD TRACE VRBLK POINTER{30620
{{MOV{13,VRFNC(XL){7,XL{{LOAD TRACE FUNCTION POINTER{30621
{{BEQ{7,XL{21,=STNDF{6,TRXQ2{JUMP IF NOT A DEFINED FUNCTION{30622
{{MOV{18,=NUM02{8,WA{{SET NUMBER OF ARGUMENTS TO TWO{30623
{{BRN{6,CFUNC{{{JUMP TO CALL FUNCTION{30624
*
*      SEE O$TXR FOR DETAILS OF RETURN TO THIS POINT
*
{TRXQ1{MOV{3,FLPTR{7,XS{{POINT BACK TO OUR STACK ENTRIES{30628
{{ICA{7,XS{{{POP OFF GARBAGE FAIL OFFSET{30629
{{MOV{10,(XS)+{3,FLPTR{{RESTORE OLD FAILURE POINTER{30630
{{MOV{10,(XS)+{8,WB{{RELOAD CODE OFFSET{30631
{{MOV{10,(XS)+{8,WC{{LOAD OLD CODE BASE POINTER{30632
{{MOV{8,WC{7,XR{{COPY CDBLK POINTER{30633
{{MOV{13,CDSTM(XR){3,KVSTN{{RESTORE STMNT NO{30634
{{MOV{10,(XS)+{8,WA{{RELOAD NAME OFFSET{30635
{{MOV{10,(XS)+{7,XL{{RELOAD NAME BASE{30636
{{MOV{10,(XS)+{7,XR{{RELOAD TRBLK POINTER{30637
{{MOV{10,(XS)+{3,KVTRA{{RESTORE TRACE KEYWORD VALUE{30638
{{ADD{8,WC{8,WB{{RECOMPUTE ABSOLUTE CODE POINTER{30639
{{LCP{8,WB{{{RESTORE CODE POINTER{30640
{{MOV{8,WC{3,R$COD{{AND CODE BLOCK POINTER{30641
{{EXI{{{{RETURN TO TRXEQ CALLER{30642
*
*      HERE IF THE TARGET FUNCTION IS NOT DEFINED
*
{TRXQ2{ERB{1,197{26,TRACE fourth arg is not function name or null{{{30646
*
{{ENP{{{{END PROCEDURE TRXEQ{30648
{{EJC{{{{{30649
*
*      XSCAN -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCAN SCANS OUT ONE TOKEN IN A PROTOTYPE ARGUMENT IN
*      ARRAY,CLEAR,DATA,DEFINE,LOAD FUNCTION CALLS. XSCAN
*      CALLS MUST BE PRECEDED BY A CALL TO THE INITIALIZATION
*      PROCEDURE XSCNI. THE FOLLOWING VARIABLES ARE USED.
*
*      R$XSC                 POINTER TO SCBLK FOR FUNCTION ARG
*      XSOFS                 OFFSET (NUM CHARS SCANNED SO FAR)
*
*      (WA)                  NON-ZERO TO SKIP AND TRIM BLANKS
*      (WC)                  DELIMITER ONE (CH$XX)
*      (XL)                  DELIMITER TWO (CH$XX)
*      JSR  XSCAN            CALL TO SCAN NEXT ITEM
*      (XR)                  POINTER TO SCBLK FOR TOKEN SCANNED
*      (WA)                  COMPLETION CODE (SEE BELOW)
*      (WC,XL)               DESTROYED
*
*      THE SCAN STARTS FROM THE CURRENT POSITION AND CONTINUES
*      UNTIL ONE OF THE FOLLOWING THREE CONDITIONS OCCURS.
*
*      1)   DELIMITER ONE IS ENCOUNTERED  (WA SET TO 1)
*
*      2)   DELIMITER TWO ENCOUNTERED  (WA SET TO 2)
*
*      3)   END OF STRING ENCOUNTERED  (WA SET TO 0)
*
*      THE RESULT IS A STRING CONTAINING ALL CHARACTERS SCANNED
*      UP TO BUT NOT INCLUDING ANY DELIMITER CHARACTER.
*      THE POINTER IS LEFT POINTING PAST THE DELIMITER.
*
*      IF ONLY ONE DELIMITER IS TO BE DETECTED, DELIMITER ONE
*      AND DELIMITER TWO SHOULD BE SET TO THE SAME VALUE.
*
*      IN THE CASE WHERE THE END OF STRING IS ENCOUNTERED, THE
*      STRING INCLUDES ALL THE CHARACTERS TO THE END OF THE
*      STRING. NO FURTHER CALLS CAN BE MADE TO XSCAN UNTIL
*      XSCNI IS CALLED TO INITIALIZE A NEW ARGUMENT SCAN
{{EJC{{{{{30689
*
*      XSCAN (CONTINUED)
*
{XSCAN{PRC{25,E{1,0{{ENTRY POINT{30693
{{MOV{8,WB{3,XSCWB{{PRESERVE WB{30694
{{MOV{8,WA{11,-(XS){{RECORD BLANK SKIP FLAG{30695
{{MOV{8,WA{11,-(XS){{AND SECOND COPY{30696
{{MOV{3,R$XSC{7,XR{{POINT TO ARGUMENT STRING{30697
{{MOV{13,SCLEN(XR){8,WA{{LOAD STRING LENGTH{30698
{{MOV{3,XSOFS{8,WB{{LOAD CURRENT OFFSET{30699
{{SUB{8,WB{8,WA{{GET NUMBER OF REMAINING CHARACTERS{30700
{{BZE{8,WA{6,XSCN3{{JUMP IF NO CHARACTERS LEFT{30701
{{PLC{7,XR{8,WB{{POINT TO CURRENT CHARACTER{30702
*
*      LOOP TO SEARCH FOR DELIMITER
*
{XSCN1{LCH{8,WB{10,(XR)+{{LOAD NEXT CHARACTER{30706
{{BEQ{8,WB{8,WC{6,XSCN4{JUMP IF DELIMITER ONE FOUND{30707
{{BEQ{8,WB{7,XL{6,XSCN5{JUMP IF DELIMITER TWO FOUND{30708
{{BZE{9,(XS){6,XSCN2{{JUMP IF NOT SKIPPING BLANKS{30709
{{ICV{3,XSOFS{{{ASSUME BLANK AND DELETE IT{30710
{{BEQ{8,WB{18,=CH$HT{6,XSCN2{JUMP IF HORIZONTAL TAB{30712
{{BEQ{8,WB{18,=CH$BL{6,XSCN2{JUMP IF BLANK{30717
{{DCV{3,XSOFS{{{UNDELETE NON-BLANK CHARACTER{30718
{{ZER{9,(XS){{{AND DISCONTINUE BLANK CHECKING{30719
*
*      HERE AFTER PERFORMING ANY LEADING BLANK TRIMMING.
*
{XSCN2{DCV{8,WA{{{DECREMENT COUNT OF CHARS LEFT{30723
{{BNZ{8,WA{6,XSCN1{{LOOP BACK IF MORE CHARS TO GO{30724
*
*      HERE FOR RUNOUT
*
{XSCN3{MOV{3,R$XSC{7,XL{{POINT TO STRING BLOCK{30728
{{MOV{13,SCLEN(XL){8,WA{{GET STRING LENGTH{30729
{{MOV{3,XSOFS{8,WB{{LOAD OFFSET{30730
{{SUB{8,WB{8,WA{{GET SUBSTRING LENGTH{30731
{{ZER{3,R$XSC{{{CLEAR STRING PTR FOR COLLECTOR{30732
{{ZER{3,XSCRT{{{SET ZERO (RUNOUT) RETURN CODE{30733
{{BRN{6,XSCN7{{{JUMP TO EXIT{30734
{{EJC{{{{{30735
*
*      XSCAN (CONTINUED)
*
*      HERE IF DELIMITER ONE FOUND
*
{XSCN4{MOV{18,=NUM01{3,XSCRT{{SET RETURN CODE{30741
{{BRN{6,XSCN6{{{JUMP TO MERGE{30742
*
*      HERE IF DELIMITER TWO FOUND
*
{XSCN5{MOV{18,=NUM02{3,XSCRT{{SET RETURN CODE{30746
*
*      MERGE HERE AFTER DETECTING A DELIMITER
*
{XSCN6{MOV{3,R$XSC{7,XL{{RELOAD POINTER TO STRING{30750
{{MOV{13,SCLEN(XL){8,WC{{GET ORIGINAL LENGTH OF STRING{30751
{{SUB{8,WA{8,WC{{MINUS CHARS LEFT = CHARS SCANNED{30752
{{MOV{8,WC{8,WA{{MOVE TO REG FOR SBSTR{30753
{{MOV{3,XSOFS{8,WB{{SET OFFSET{30754
{{SUB{8,WB{8,WA{{COMPUTE LENGTH FOR SBSTR{30755
{{ICV{8,WC{{{ADJUST NEW CURSOR PAST DELIMITER{30756
{{MOV{8,WC{3,XSOFS{{STORE NEW OFFSET{30757
*
*      COMMON EXIT POINT
*
{XSCN7{ZER{7,XR{{{CLEAR GARBAGE CHARACTER PTR IN XR{30761
{{JSR{6,SBSTR{{{BUILD SUB-STRING{30762
{{ICA{7,XS{{{REMOVE COPY OF BLANK FLAG{30763
{{MOV{10,(XS)+{8,WB{{ORIGINAL BLANK SKIP/TRIM FLAG{30764
{{BZE{13,SCLEN(XR){6,XSCN8{{CANNOT TRIM THE NULL STRING{30765
{{JSR{6,TRIMR{{{TRIM TRAILING BLANKS IF REQUESTED{30766
*
*      FINAL EXIT POINT
*
{XSCN8{MOV{3,XSCRT{8,WA{{LOAD RETURN CODE{30770
{{MOV{3,XSCWB{8,WB{{RESTORE WB{30771
{{EXI{{{{RETURN TO XSCAN CALLER{30772
{{ENP{{{{END PROCEDURE XSCAN{30773
{{EJC{{{{{30774
*
*      XSCNI -- EXECUTION FUNCTION ARGUMENT SCAN
*
*      XSCNI INITIALIZES THE SCAN USED FOR PROTOTYPE ARGUMENTS
*      IN THE CLEAR, DEFINE, LOAD, DATA, ARRAY FUNCTIONS. SEE
*      XSCAN FOR THE PROCEDURE WHICH IS USED AFTER THIS CALL.
*
*      -(XS)                 ARGUMENT TO BE SCANNED (ON STACK)
*      JSR  XSCNI            CALL TO SCAN ARGUMENT
*      PPM  LOC              TRANSFER LOC IF ARG IS NOT STRING
*      PPM  LOC              TRANSFER LOC IF ARGUMENT IS NULL
*      (XS)                  POPPED
*      (XR,R$XSC)            ARGUMENT (SCBLK PTR)
*      (WA)                  ARGUMENT LENGTH
*      (IA,RA)               DESTROYED
*
{XSCNI{PRC{25,N{1,2{{ENTRY POINT{30791
{{JSR{6,GTSTG{{{FETCH ARGUMENT AS STRING{30792
{{PPM{6,XSCI1{{{JUMP IF NOT CONVERTIBLE{30793
{{MOV{7,XR{3,R$XSC{{ELSE STORE SCBLK PTR FOR XSCAN{30794
{{ZER{3,XSOFS{{{SET OFFSET TO ZERO{30795
{{BZE{8,WA{6,XSCI2{{JUMP IF NULL STRING{30796
{{EXI{{{{RETURN TO XSCNI CALLER{30797
*
*      HERE IF ARGUMENT IS NOT A STRING
*
{XSCI1{EXI{1,1{{{TAKE NOT-STRING ERROR EXIT{30801
*
*      HERE FOR NULL STRING
*
{XSCI2{EXI{1,2{{{TAKE NULL-STRING ERROR EXIT{30805
{{ENP{{{{END PROCEDURE XSCNI{30806
{{TTL{27,S P I T B O L -- STACK OVERFLOW SECTION{{{{30807
*
*      CONTROL COMES HERE IF THE MAIN STACK OVERFLOWS
*
{{SEC{{{{START OF STACK OVERFLOW SECTION{30811
*
{{ADD{18,=NUM04{3,ERRFT{{FORCE CONCLUSIVE FATAL ERROR{30813
{{MOV{3,FLPTR{7,XS{{POP STACK TO AVOID MORE FAILS{30814
{{BNZ{3,GBCFL{6,STAK1{{JUMP IF GARBAGE COLLECTING{30815
{{ERB{1,246{26,Stack overflow{{{30816
*
*      NO CHANCE OF RECOVERY IN MID GARBAGE COLLECTION
*
{STAK1{MOV{21,=ENDSO{7,XR{{POINT TO MESSAGE{30820
{{ZER{3,KVDMP{{{MEMORY IS UNDUMPABLE{30821
{{BRN{6,STOPR{{{GIVE UP{30822
{{TTL{27,S P I T B O L -- ERROR SECTION{{{{30823
*
*      THIS SECTION OF CODE IS ENTERED WHENEVER A PROCEDURE
*      RETURN VIA AN ERR PARAMETER OR AN ERB OPCODE IS OBEYED.
*
*      (WA)                  IS THE ERROR CODE
*
*      THE GLOBAL VARIABLE STAGE INDICATES THE POINT AT WHICH
*      THE ERROR OCCURED AS FOLLOWS.
*
*      STAGE=STGIC           ERROR DURING INITIAL COMPILE
*
*      STAGE=STGXC           ERROR DURING COMPILE AT EXECUTE
*                            TIME (CODE, CONVERT FUNCTION CALLS)
*
*      STAGE=STGEV           ERROR DURING COMPILATION OF
*                            EXPRESSION AT EXECUTION TIME
*                            (EVAL, CONVERT FUNCTION CALL).
*
*      STAGE=STGXT           ERROR AT EXECUTE TIME. COMPILER
*                            NOT ACTIVE.
*
*      STAGE=STGCE           ERROR DURING INITIAL COMPILE AFTER
*                            SCANNING OUT THE END LINE.
*
*      STAGE=STGXE           ERROR DURING COMPILE AT EXECUTE
*                            TIME AFTER SCANNING END LINE.
*
*      STAGE=STGEE           ERROR DURING EXPRESSION EVALUATION
*
{{SEC{{{{START OF ERROR SECTION{30853
*
{ERROR{BEQ{3,R$CIM{20,=CMLAB{6,CMPLE{JUMP IF ERROR IN SCANNING LABEL{30855
{{MOV{8,WA{3,KVERT{{SAVE ERROR CODE{30856
{{ZER{3,SCNRS{{{RESET RESCAN SWITCH FOR SCANE{30857
{{ZER{3,SCNGO{{{RESET GOTO SWITCH FOR SCANE{30858
{{MOV{18,=NUM01{3,POLCS{{RESET POLL COUNT{30860
{{MOV{18,=NUM01{3,POLCT{{RESET POLL COUNT{30861
{{MOV{3,STAGE{7,XR{{LOAD CURRENT STAGE{30863
{{BSW{7,XR{2,STGNO{{JUMP TO APPROPRIATE ERROR CIRCUIT{30864
{{IFF{2,STGIC{6,ERR01{{INITIAL COMPILE{30872
{{IFF{2,STGXC{6,ERR04{{EXECUTE TIME COMPILE{30872
{{IFF{2,STGEV{6,ERR04{{EVAL COMPILING EXPR.{30872
{{IFF{2,STGXT{6,ERR05{{EXECUTE TIME{30872
{{IFF{2,STGCE{6,ERR01{{COMPILE - AFTER END{30872
{{IFF{2,STGXE{6,ERR04{{XEQ COMPILE-PAST END{30872
{{IFF{2,STGEE{6,ERR04{{EVAL EVALUATING EXPR{30872
{{ESW{{{{END SWITCH ON ERROR TYPE{30872
{{EJC{{{{{30873
*
*      ERROR DURING INITIAL COMPILE
*
*      THE ERROR MESSAGE IS PRINTED AS PART OF THE COMPILER
*      OUTPUT. THIS PRINTOUT INCLUDES THE OFFENDING LINE (IF NOT
*      PRINTED ALREADY) AND AN ERROR FLAG UNDER THE APPROPRIATE
*      COLUMN AS INDICATED BY SCNSE UNLESS SCNSE IS SET TO ZERO.
*
*      AFTER PRINTING THE MESSAGE, THE GENERATED CODE IS
*      MODIFIED TO AN ERROR CALL AND CONTROL IS RETURNED TO
*      THE CMPIL PROCEDURE AFTER RESETTING THE STACK POINTER.
*
*      IF THE ERROR OCCURS AFTER THE END LINE, CONTROL RETURNS
*      IN A SLIGHTLY DIFFERENT MANNER TO ENSURE PROPER CLEANUP.
*
{ERR01{MOV{3,CMPXS{7,XS{{RESET STACK POINTER{30889
{{SSL{3,CMPSS{{{RESTORE S-R STACK PTR FOR CMPIL{30890
{{BNZ{3,ERRSP{6,ERR03{{JUMP IF ERROR SUPPRESS FLAG SET{30891
{{MOV{3,CMPSN{8,WC{{CURRENT STATEMENT{30894
{{JSR{6,FILNM{{{OBTAIN FILE NAME FOR THIS STATEMENT{30895
{{MOV{3,SCNSE{8,WB{{COLUMN NUMBER{30897
{{MOV{3,RDCLN{8,WC{{LINE NUMBER{30898
{{MOV{3,STAGE{7,XR{{{30899
{{JSR{6,SYSEA{{{ADVISE SYSTEM OF ERROR{30900
{{PPM{6,ERRA3{{{IF SYSTEM DOES NOT WANT PRINT{30901
{{MOV{7,XR{11,-(XS){{SAVE ANY PROVIDED PRINT MESSAGE{30902
{{MOV{3,ERICH{3,ERLST{{SET FLAG FOR LISTR{30904
{{JSR{6,LISTR{{{LIST LINE{30905
{{JSR{6,PRTIS{{{TERMINATE LISTING{30906
{{ZER{3,ERLST{{{CLEAR LISTR FLAG{30907
{{MOV{3,SCNSE{8,WA{{LOAD SCAN ELEMENT OFFSET{30908
{{BZE{8,WA{6,ERR02{{SKIP IF NOT SET{30909
{{LCT{8,WB{8,WA{{LOOP COUNTER{30911
{{ICV{8,WA{{{INCREASE FOR CH$EX{30912
{{MOV{3,R$CIM{7,XL{{POINT TO BAD STATEMENT{30913
{{JSR{6,ALOCS{{{STRING BLOCK FOR ERROR FLAG{30914
{{MOV{7,XR{8,WA{{REMEMBER STRING PTR{30915
{{PSC{7,XR{{{READY FOR CHARACTER STORING{30916
{{PLC{7,XL{{{READY TO GET CHARS{30917
*
*      LOOP TO REPLACE ALL CHARS BUT TABS BY BLANKS
*
{ERRA1{LCH{8,WC{10,(XL)+{{GET NEXT CHAR{30921
{{BEQ{8,WC{18,=CH$HT{6,ERRA2{SKIP IF TAB{30922
{{MOV{18,=CH$BL{8,WC{{GET A BLANK{30923
{{EJC{{{{{30924
*
*      MERGE TO STORE BLANK OR TAB IN ERROR LINE
*
{ERRA2{SCH{8,WC{10,(XR)+{{STORE CHAR{30928
{{BCT{8,WB{6,ERRA1{{LOOP{30929
{{MOV{18,=CH$EX{7,XL{{EXCLAMATION MARK{30930
{{SCH{7,XL{9,(XR){{STORE AT END OF ERROR LINE{30931
{{CSC{7,XR{{{END OF SCH LOOP{30932
{{MOV{18,=STNPD{3,PROFS{{ALLOW FOR STATEMENT NUMBER{30933
{{MOV{8,WA{7,XR{{POINT TO ERROR LINE{30934
{{JSR{6,PRTST{{{PRINT ERROR LINE{30935
*
*      HERE AFTER PLACING ERROR FLAG AS REQUIRED
*
{ERR02{JSR{6,PRTIS{{{PRINT BLANK LINE{30949
{{MOV{10,(XS)+{7,XR{{RESTORE ANY SYSEA MESSAGE{30951
{{BZE{7,XR{6,ERRA0{{DID SYSEA PROVIDE MESSAGE TO PRINT{30952
{{JSR{6,PRTST{{{PRINT SYSEA MESSAGE{30953
{ERRA0{JSR{6,ERMSG{{{GENERATE FLAG AND ERROR MESSAGE{30955
{{ADD{18,=NUM03{3,LSTLC{{BUMP PAGE CTR FOR BLANK, ERROR, BLK{30956
{ERRA3{ZER{7,XR{{{IN CASE OF FATAL ERROR{30957
{{BHI{3,ERRFT{18,=NUM03{6,STOPR{PACK UP IF SEVERAL FATALS{30958
*
*      COUNT ERROR, INHIBIT EXECUTION IF REQUIRED
*
{{ICV{3,CMERC{{{BUMP ERROR COUNT{30962
{{ADD{3,CSWER{3,NOXEQ{{INHIBIT XEQ IF -NOERRORS{30963
{{BNE{3,STAGE{18,=STGIC{6,CMP10{SPECIAL RETURN IF AFTER END LINE{30964
{{EJC{{{{{30965
*
*      LOOP TO SCAN TO END OF STATEMENT
*
{ERR03{MOV{3,R$CIM{7,XR{{POINT TO START OF IMAGE{30969
{{PLC{7,XR{{{POINT TO FIRST CHAR{30970
{{LCH{7,XR{9,(XR){{GET FIRST CHAR{30971
{{BEQ{7,XR{18,=CH$MN{6,CMPCE{JUMP IF ERROR IN CONTROL CARD{30972
{{ZER{3,SCNRS{{{CLEAR RESCAN FLAG{30973
{{MNZ{3,ERRSP{{{SET ERROR SUPPRESS FLAG{30974
{{JSR{6,SCANE{{{SCAN NEXT ELEMENT{30975
{{BNE{7,XL{18,=T$SMC{6,ERR03{LOOP BACK IF NOT STATEMENT END{30976
{{ZER{3,ERRSP{{{CLEAR ERROR SUPPRESS FLAG{30977
*
*      GENERATE ERROR CALL IN CODE AND RETURN TO CMPIL
*
{{MOV{19,*CDCOD{3,CWCOF{{RESET OFFSET IN CCBLK{30981
{{MOV{21,=OCER${8,WA{{LOAD COMPILE ERROR CALL{30982
{{JSR{6,CDWRD{{{GENERATE IT{30983
{{MOV{3,CWCOF{13,CMSOC(XS){{SET SUCCESS FILL IN OFFSET{30984
{{MNZ{13,CMFFC(XS){{{SET FAILURE FILL IN FLAG{30985
{{JSR{6,CDWRD{{{GENERATE SUCC. FILL IN WORD{30986
{{BRN{6,CMPSE{{{MERGE TO GENERATE ERROR AS CDFAL{30987
*
*      ERROR DURING EXECUTE TIME COMPILE OR EXPRESSION EVALUATIO
*
*      EXECUTE TIME COMPILATION IS INITIATED THROUGH GTCOD OR
*      GTEXP WHICH ARE CALLED BY COMPILE, CODE OR EVAL.
*      BEFORE CAUSING STATEMENT FAILURE THROUGH EXFAL IT IS
*      HELPFUL TO SET KEYWORD ERRTEXT AND FOR GENERALITY
*      THESE ERRORS MAY BE HANDLED BY THE SETEXIT MECHANISM.
*
{ERR04{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{30997
{{BEQ{3,KVERT{18,=NM320{6,ERR06{TREAT USER INTERRUPT SPECIALLY{30999
{{ZER{3,R$CCB{{{FORGET GARBAGE CODE BLOCK{31001
{{MOV{19,*CCCOD{3,CWCOF{{SET INITIAL OFFSET (MBE CATSPAW){31002
{{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{31003
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{31004
{{DCA{7,XS{{{ENSURE STACK OK ON LOOP START{31005
*
*      POP STACK UNTIL FIND FLPTR FOR MOST DEEPLY NESTED PROG.
*      DEFINED FUNCTION CALL OR CALL OF EVAL / CODE.
*
{ERRA4{ICA{7,XS{{{POP STACK{31010
{{BEQ{7,XS{3,FLPRT{6,ERRC4{JUMP IF PROG DEFINED FN CALL FOUND{31011
{{BNE{7,XS{3,GTCEF{6,ERRA4{LOOP IF NOT EVAL OR CODE CALL YET{31012
{{MOV{18,=STGXT{3,STAGE{{RE-SET STAGE FOR EXECUTE{31013
{{MOV{3,R$GTC{3,R$COD{{RECOVER CODE PTR{31014
{{MOV{7,XS{3,FLPTR{{RESTORE FAIL POINTER{31015
{{ZER{3,R$CIM{{{FORGET POSSIBLE IMAGE{31016
{{ZER{3,CNIND{{{FORGET POSSIBLE INCLUDE{31018
*
*      TEST ERRLIMIT
*
{ERRB4{BNZ{3,KVERL{6,ERR07{{JUMP IF ERRLIMIT NON-ZERO{31023
{{BRN{6,EXFAL{{{FAIL{31024
*
*      RETURN FROM PROG. DEFINED FUNCTION IS OUTSTANDING
*
{ERRC4{MOV{3,FLPTR{7,XS{{RESTORE STACK FROM FLPTR{31028
{{BRN{6,ERRB4{{{MERGE{31029
{{EJC{{{{{31030
*
*      ERROR AT EXECUTE TIME.
*
*      THE ACTION TAKEN ON AN ERROR IS AS FOLLOWS.
*
*      IF ERRLIMIT KEYWORD IS ZERO, AN ABORT IS SIGNALLED,
*      SEE CODING FOR SYSTEM LABEL ABORT AT L$ABO.
*
*      OTHERWISE, ERRLIMIT IS DECREMENTED AND AN ERRTYPE TRACE
*      GENERATED IF REQUIRED. CONTROL RETURNS EITHER VIA A JUMP
*      TO CONTINUE (TO TAKE THE FAILURE EXIT) OR A SPECIFIED
*      SETEXIT TRAP IS EXECUTED AND CONTROL PASSES TO THE TRAP.
*      IF 3 OR MORE FATAL ERRORS OCCUR AN ABORT IS SIGNALLED
*      REGARDLESS OF ERRLIMIT AND SETEXIT - LOOPING IS ALL TOO
*      PROBABLE OTHERWISE. FATAL ERRORS INCLUDE STACK OVERFLOW
*      AND EXCEEDING STLIMIT.
*
{ERR05{SSL{3,INISS{{{RESTORE MAIN PROG S-R STACK PTR{31048
{{BNZ{3,DMVCH{6,ERR08{{JUMP IF IN MID-DUMP{31049
*
*      MERGE HERE FROM ERR08 AND ERR04 (ERROR 320)
*
{ERR06{BZE{3,KVERL{6,LABO1{{ABORT IF ERRLIMIT IS ZERO{31053
{{JSR{6,ERTEX{{{GET FAIL MESSAGE TEXT{31054
*
*      MERGE FROM ERR04
*
{ERR07{BGE{3,ERRFT{18,=NUM03{6,LABO1{ABORT IF TOO MANY FATAL ERRORS{31058
{{DCV{3,KVERL{{{DECREMENT ERRLIMIT{31059
{{MOV{3,R$ERT{7,XL{{LOAD ERRTYPE TRACE POINTER{31060
{{JSR{6,KTREX{{{GENERATE ERRTYPE TRACE IF REQUIRED{31061
{{MOV{3,R$COD{8,WA{{GET CURRENT CODE BLOCK{31062
{{MOV{8,WA{3,R$CNT{{SET CDBLK PTR FOR CONTINUATION{31063
{{SCP{8,WB{{{CURRENT CODE POINTER{31064
{{SUB{8,WA{8,WB{{OFFSET WITHIN CODE BLOCK{31065
{{MOV{8,WB{3,STXOC{{SAVE CODE PTR OFFSET FOR SCONTINUE{31066
{{MOV{3,FLPTR{7,XR{{SET PTR TO FAILURE OFFSET{31067
{{MOV{9,(XR){3,STXOF{{SAVE FAILURE OFFSET FOR CONTINUE{31068
{{MOV{3,R$SXC{7,XR{{LOAD SETEXIT CDBLK POINTER{31069
{{BZE{7,XR{6,LCNT1{{CONTINUE IF NO SETEXIT TRAP{31070
{{ZER{3,R$SXC{{{ELSE RESET TRAP{31071
{{MOV{21,=NULLS{3,STXVR{{RESET SETEXIT ARG TO NULL{31072
{{MOV{9,(XR){7,XL{{LOAD PTR TO CODE BLOCK ROUTINE{31073
{{BRI{7,XL{{{EXECUTE FIRST TRAP STATEMENT{31074
*
*      INTERRUPTED PARTLY THROUGH A DUMP WHILST STORE IS IN A
*      MESS SO DO A TIDY UP OPERATION. SEE DUMPR FOR DETAILS.
*
{ERR08{MOV{3,DMVCH{7,XR{{CHAIN HEAD FOR AFFECTED VRBLKS{31079
{{BZE{7,XR{6,ERR06{{DONE IF ZERO{31080
{{MOV{9,(XR){3,DMVCH{{SET NEXT LINK AS CHAIN HEAD{31081
{{JSR{6,SETVR{{{RESTORE VRGET FIELD{31082
*
*      LABEL TO MARK END OF CODE
*
{S$YYY{BRN{6,ERR08{{{LOOP THROUGH CHAIN{31086
{{TTL{27,S P I T B O L -- HERE ENDETH THE CODE{{{{31087
*
*      END OF ASSEMBLY
*
{{END{{{{END MACRO-SPITBOL ASSEMBLY{31091
